{
  "resolvedId": "/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/segments.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "const Mode = require('./mode')\nconst NumericData = require('./numeric-data')\nconst AlphanumericData = require('./alphanumeric-data')\nconst ByteData = require('./byte-data')\nconst KanjiData = require('./kanji-data')\nconst Regex = require('./regex')\nconst Utils = require('./utils')\nconst dijkstra = require('dijkstrajs')\n\n/**\n * Returns UTF8 byte length\n *\n * @param  {String} str Input string\n * @return {Number}     Number of byte\n */\nfunction getStringByteLength (str) {\n  return unescape(encodeURIComponent(str)).length\n}\n\n/**\n * Get a list of segments of the specified mode\n * from a string\n *\n * @param  {Mode}   mode Segment mode\n * @param  {String} str  String to process\n * @return {Array}       Array of object with segments data\n */\nfunction getSegments (regex, mode, str) {\n  const segments = []\n  let result\n\n  while ((result = regex.exec(str)) !== null) {\n    segments.push({\n      data: result[0],\n      index: result.index,\n      mode: mode,\n      length: result[0].length\n    })\n  }\n\n  return segments\n}\n\n/**\n * Extracts a series of segments with the appropriate\n * modes from a string\n *\n * @param  {String} dataStr Input string\n * @return {Array}          Array of object with segments data\n */\nfunction getSegmentsFromString (dataStr) {\n  const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr)\n  const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr)\n  let byteSegs\n  let kanjiSegs\n\n  if (Utils.isKanjiModeEnabled()) {\n    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr)\n    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr)\n  } else {\n    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr)\n    kanjiSegs = []\n  }\n\n  const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs)\n\n  return segs\n    .sort(function (s1, s2) {\n      return s1.index - s2.index\n    })\n    .map(function (obj) {\n      return {\n        data: obj.data,\n        mode: obj.mode,\n        length: obj.length\n      }\n    })\n}\n\n/**\n * Returns how many bits are needed to encode a string of\n * specified length with the specified mode\n *\n * @param  {Number} length String length\n * @param  {Mode} mode     Segment mode\n * @return {Number}        Bit length\n */\nfunction getSegmentBitsLength (length, mode) {\n  switch (mode) {\n    case Mode.NUMERIC:\n      return NumericData.getBitsLength(length)\n    case Mode.ALPHANUMERIC:\n      return AlphanumericData.getBitsLength(length)\n    case Mode.KANJI:\n      return KanjiData.getBitsLength(length)\n    case Mode.BYTE:\n      return ByteData.getBitsLength(length)\n  }\n}\n\n/**\n * Merges adjacent segments which have the same mode\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction mergeSegments (segs) {\n  return segs.reduce(function (acc, curr) {\n    const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null\n    if (prevSeg && prevSeg.mode === curr.mode) {\n      acc[acc.length - 1].data += curr.data\n      return acc\n    }\n\n    acc.push(curr)\n    return acc\n  }, [])\n}\n\n/**\n * Generates a list of all possible nodes combination which\n * will be used to build a segments graph.\n *\n * Nodes are divided by groups. Each group will contain a list of all the modes\n * in which is possible to encode the given text.\n *\n * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\n * The group for '12345' will contain then 3 objects, one for each\n * possible encoding mode.\n *\n * Each node represents a possible segment.\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction buildNodes (segs) {\n  const nodes = []\n  for (let i = 0; i < segs.length; i++) {\n    const seg = segs[i]\n\n    switch (seg.mode) {\n      case Mode.NUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.ALPHANUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.KANJI:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n        break\n      case Mode.BYTE:\n        nodes.push([\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n    }\n  }\n\n  return nodes\n}\n\n/**\n * Builds a graph from a list of nodes.\n * All segments in each node group will be connected with all the segments of\n * the next group and so on.\n *\n * At each connection will be assigned a weight depending on the\n * segment's byte length.\n *\n * @param  {Array} nodes    Array of object with segments data\n * @param  {Number} version QR Code version\n * @return {Object}         Graph of all possible segments\n */\nfunction buildGraph (nodes, version) {\n  const table = {}\n  const graph = { start: {} }\n  let prevNodeIds = ['start']\n\n  for (let i = 0; i < nodes.length; i++) {\n    const nodeGroup = nodes[i]\n    const currentNodeIds = []\n\n    for (let j = 0; j < nodeGroup.length; j++) {\n      const node = nodeGroup[j]\n      const key = '' + i + j\n\n      currentNodeIds.push(key)\n      table[key] = { node: node, lastCount: 0 }\n      graph[key] = {}\n\n      for (let n = 0; n < prevNodeIds.length; n++) {\n        const prevNodeId = prevNodeIds[n]\n\n        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n          graph[prevNodeId][key] =\n            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -\n            getSegmentBitsLength(table[prevNodeId].lastCount, node.mode)\n\n          table[prevNodeId].lastCount += node.length\n        } else {\n          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length\n\n          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +\n            4 + Mode.getCharCountIndicator(node.mode, version) // switch cost\n        }\n      }\n    }\n\n    prevNodeIds = currentNodeIds\n  }\n\n  for (let n = 0; n < prevNodeIds.length; n++) {\n    graph[prevNodeIds[n]].end = 0\n  }\n\n  return { map: graph, table: table }\n}\n\n/**\n * Builds a segment from a specified data and mode.\n * If a mode is not specified, the more suitable will be used.\n *\n * @param  {String} data             Input data\n * @param  {Mode | String} modesHint Data mode\n * @return {Segment}                 Segment\n */\nfunction buildSingleSegment (data, modesHint) {\n  let mode\n  const bestMode = Mode.getBestModeForData(data)\n\n  mode = Mode.from(modesHint, bestMode)\n\n  // Make sure data can be encoded\n  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {\n    throw new Error('\"' + data + '\"' +\n      ' cannot be encoded with mode ' + Mode.toString(mode) +\n      '.\\n Suggested mode is: ' + Mode.toString(bestMode))\n  }\n\n  // Use Mode.BYTE if Kanji support is disabled\n  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {\n    mode = Mode.BYTE\n  }\n\n  switch (mode) {\n    case Mode.NUMERIC:\n      return new NumericData(data)\n\n    case Mode.ALPHANUMERIC:\n      return new AlphanumericData(data)\n\n    case Mode.KANJI:\n      return new KanjiData(data)\n\n    case Mode.BYTE:\n      return new ByteData(data)\n  }\n}\n\n/**\n * Builds a list of segments from an array.\n * Array can contain Strings or Objects with segment's info.\n *\n * For each item which is a string, will be generated a segment with the given\n * string and the more appropriate encoding mode.\n *\n * For each item which is an object, will be generated a segment with the given\n * data and mode.\n * Objects must contain at least the property \"data\".\n * If property \"mode\" is not present, the more suitable mode will be used.\n *\n * @param  {Array} array Array of objects with segments data\n * @return {Array}       Array of Segments\n */\nexports.fromArray = function fromArray (array) {\n  return array.reduce(function (acc, seg) {\n    if (typeof seg === 'string') {\n      acc.push(buildSingleSegment(seg, null))\n    } else if (seg.data) {\n      acc.push(buildSingleSegment(seg.data, seg.mode))\n    }\n\n    return acc\n  }, [])\n}\n\n/**\n * Builds an optimized sequence of segments from a string,\n * which will produce the shortest possible bitstream.\n *\n * @param  {String} data    Input string\n * @param  {Number} version QR Code version\n * @return {Array}          Array of segments\n */\nexports.fromString = function fromString (data, version) {\n  const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n\n  const nodes = buildNodes(segs)\n  const graph = buildGraph(nodes, version)\n  const path = dijkstra.find_path(graph.map, 'start', 'end')\n\n  const optimizedSegs = []\n  for (let i = 1; i < path.length - 1; i++) {\n    optimizedSegs.push(graph.table[path[i]].node)\n  }\n\n  return exports.fromArray(mergeSegments(optimizedSegs))\n}\n\n/**\n * Splits a string in various segments with the modes which\n * best represent their content.\n * The produced segments are far from being optimized.\n * The output of this function is only used to estimate a QR Code version\n * which may contain the data.\n *\n * @param  {string} data Input string\n * @return {Array}       Array of segments\n */\nexports.rawSplit = function rawSplit (data) {\n  return exports.fromArray(\n    getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n  )\n}\n",
      "start": 1714699771036,
      "end": 1714699771065,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1714699771065,
      "end": 1714699771065,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1714699771065,
      "end": 1714699771065,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1714699771065,
      "end": 1714699771065,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1714699771065,
      "end": 1714699771065,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1714699771065,
      "end": 1714699771065,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1714699771065,
      "end": 1714699771065,
      "order": "normal"
    },
    {
      "name": "vite-plugin-vconsole",
      "result": "const Mode = require('./mode')\nconst NumericData = require('./numeric-data')\nconst AlphanumericData = require('./alphanumeric-data')\nconst ByteData = require('./byte-data')\nconst KanjiData = require('./kanji-data')\nconst Regex = require('./regex')\nconst Utils = require('./utils')\nconst dijkstra = require('dijkstrajs')\n\n/**\n * Returns UTF8 byte length\n *\n * @param  {String} str Input string\n * @return {Number}     Number of byte\n */\nfunction getStringByteLength (str) {\n  return unescape(encodeURIComponent(str)).length\n}\n\n/**\n * Get a list of segments of the specified mode\n * from a string\n *\n * @param  {Mode}   mode Segment mode\n * @param  {String} str  String to process\n * @return {Array}       Array of object with segments data\n */\nfunction getSegments (regex, mode, str) {\n  const segments = []\n  let result\n\n  while ((result = regex.exec(str)) !== null) {\n    segments.push({\n      data: result[0],\n      index: result.index,\n      mode: mode,\n      length: result[0].length\n    })\n  }\n\n  return segments\n}\n\n/**\n * Extracts a series of segments with the appropriate\n * modes from a string\n *\n * @param  {String} dataStr Input string\n * @return {Array}          Array of object with segments data\n */\nfunction getSegmentsFromString (dataStr) {\n  const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr)\n  const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr)\n  let byteSegs\n  let kanjiSegs\n\n  if (Utils.isKanjiModeEnabled()) {\n    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr)\n    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr)\n  } else {\n    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr)\n    kanjiSegs = []\n  }\n\n  const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs)\n\n  return segs\n    .sort(function (s1, s2) {\n      return s1.index - s2.index\n    })\n    .map(function (obj) {\n      return {\n        data: obj.data,\n        mode: obj.mode,\n        length: obj.length\n      }\n    })\n}\n\n/**\n * Returns how many bits are needed to encode a string of\n * specified length with the specified mode\n *\n * @param  {Number} length String length\n * @param  {Mode} mode     Segment mode\n * @return {Number}        Bit length\n */\nfunction getSegmentBitsLength (length, mode) {\n  switch (mode) {\n    case Mode.NUMERIC:\n      return NumericData.getBitsLength(length)\n    case Mode.ALPHANUMERIC:\n      return AlphanumericData.getBitsLength(length)\n    case Mode.KANJI:\n      return KanjiData.getBitsLength(length)\n    case Mode.BYTE:\n      return ByteData.getBitsLength(length)\n  }\n}\n\n/**\n * Merges adjacent segments which have the same mode\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction mergeSegments (segs) {\n  return segs.reduce(function (acc, curr) {\n    const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null\n    if (prevSeg && prevSeg.mode === curr.mode) {\n      acc[acc.length - 1].data += curr.data\n      return acc\n    }\n\n    acc.push(curr)\n    return acc\n  }, [])\n}\n\n/**\n * Generates a list of all possible nodes combination which\n * will be used to build a segments graph.\n *\n * Nodes are divided by groups. Each group will contain a list of all the modes\n * in which is possible to encode the given text.\n *\n * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\n * The group for '12345' will contain then 3 objects, one for each\n * possible encoding mode.\n *\n * Each node represents a possible segment.\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction buildNodes (segs) {\n  const nodes = []\n  for (let i = 0; i < segs.length; i++) {\n    const seg = segs[i]\n\n    switch (seg.mode) {\n      case Mode.NUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.ALPHANUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.KANJI:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n        break\n      case Mode.BYTE:\n        nodes.push([\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n    }\n  }\n\n  return nodes\n}\n\n/**\n * Builds a graph from a list of nodes.\n * All segments in each node group will be connected with all the segments of\n * the next group and so on.\n *\n * At each connection will be assigned a weight depending on the\n * segment's byte length.\n *\n * @param  {Array} nodes    Array of object with segments data\n * @param  {Number} version QR Code version\n * @return {Object}         Graph of all possible segments\n */\nfunction buildGraph (nodes, version) {\n  const table = {}\n  const graph = { start: {} }\n  let prevNodeIds = ['start']\n\n  for (let i = 0; i < nodes.length; i++) {\n    const nodeGroup = nodes[i]\n    const currentNodeIds = []\n\n    for (let j = 0; j < nodeGroup.length; j++) {\n      const node = nodeGroup[j]\n      const key = '' + i + j\n\n      currentNodeIds.push(key)\n      table[key] = { node: node, lastCount: 0 }\n      graph[key] = {}\n\n      for (let n = 0; n < prevNodeIds.length; n++) {\n        const prevNodeId = prevNodeIds[n]\n\n        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n          graph[prevNodeId][key] =\n            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -\n            getSegmentBitsLength(table[prevNodeId].lastCount, node.mode)\n\n          table[prevNodeId].lastCount += node.length\n        } else {\n          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length\n\n          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +\n            4 + Mode.getCharCountIndicator(node.mode, version) // switch cost\n        }\n      }\n    }\n\n    prevNodeIds = currentNodeIds\n  }\n\n  for (let n = 0; n < prevNodeIds.length; n++) {\n    graph[prevNodeIds[n]].end = 0\n  }\n\n  return { map: graph, table: table }\n}\n\n/**\n * Builds a segment from a specified data and mode.\n * If a mode is not specified, the more suitable will be used.\n *\n * @param  {String} data             Input data\n * @param  {Mode | String} modesHint Data mode\n * @return {Segment}                 Segment\n */\nfunction buildSingleSegment (data, modesHint) {\n  let mode\n  const bestMode = Mode.getBestModeForData(data)\n\n  mode = Mode.from(modesHint, bestMode)\n\n  // Make sure data can be encoded\n  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {\n    throw new Error('\"' + data + '\"' +\n      ' cannot be encoded with mode ' + Mode.toString(mode) +\n      '.\\n Suggested mode is: ' + Mode.toString(bestMode))\n  }\n\n  // Use Mode.BYTE if Kanji support is disabled\n  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {\n    mode = Mode.BYTE\n  }\n\n  switch (mode) {\n    case Mode.NUMERIC:\n      return new NumericData(data)\n\n    case Mode.ALPHANUMERIC:\n      return new AlphanumericData(data)\n\n    case Mode.KANJI:\n      return new KanjiData(data)\n\n    case Mode.BYTE:\n      return new ByteData(data)\n  }\n}\n\n/**\n * Builds a list of segments from an array.\n * Array can contain Strings or Objects with segment's info.\n *\n * For each item which is a string, will be generated a segment with the given\n * string and the more appropriate encoding mode.\n *\n * For each item which is an object, will be generated a segment with the given\n * data and mode.\n * Objects must contain at least the property \"data\".\n * If property \"mode\" is not present, the more suitable mode will be used.\n *\n * @param  {Array} array Array of objects with segments data\n * @return {Array}       Array of Segments\n */\nexports.fromArray = function fromArray (array) {\n  return array.reduce(function (acc, seg) {\n    if (typeof seg === 'string') {\n      acc.push(buildSingleSegment(seg, null))\n    } else if (seg.data) {\n      acc.push(buildSingleSegment(seg.data, seg.mode))\n    }\n\n    return acc\n  }, [])\n}\n\n/**\n * Builds an optimized sequence of segments from a string,\n * which will produce the shortest possible bitstream.\n *\n * @param  {String} data    Input string\n * @param  {Number} version QR Code version\n * @return {Array}          Array of segments\n */\nexports.fromString = function fromString (data, version) {\n  const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n\n  const nodes = buildNodes(segs)\n  const graph = buildGraph(nodes, version)\n  const path = dijkstra.find_path(graph.map, 'start', 'end')\n\n  const optimizedSegs = []\n  for (let i = 1; i < path.length - 1; i++) {\n    optimizedSegs.push(graph.table[path[i]].node)\n  }\n\n  return exports.fromArray(mergeSegments(optimizedSegs))\n}\n\n/**\n * Splits a string in various segments with the modes which\n * best represent their content.\n * The produced segments are far from being optimized.\n * The output of this function is only used to estimate a QR Code version\n * which may contain the data.\n *\n * @param  {string} data Input string\n * @return {Array}       Array of segments\n */\nexports.rawSplit = function rawSplit (data) {\n  return exports.fromArray(\n    getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n  )\n}\n",
      "start": 1714699771065,
      "end": 1714699771065,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "esbuild",
      "start": 1714699771065,
      "end": 1714699771065,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1714699771065,
      "end": 1714699771065,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1714699771065,
      "end": 1714699771065,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1714699771065,
      "end": 1714699771065,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1714699771065,
      "end": 1714699771065,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1714699771065,
      "end": 1714699771065,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "result": "import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as segments } from \"\\u0000/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/segments.js?commonjs-exports\";\nimport require$$0 from \"\\u0000/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/mode.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/numeric-data.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/alphanumeric-data.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/byte-data.js?commonjs-proxy\";\nimport require$$4 from \"\\u0000/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/kanji-data.js?commonjs-proxy\";\nimport require$$5 from \"\\u0000/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/regex.js?commonjs-proxy\";\nimport require$$6 from \"\\u0000/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/utils.js?commonjs-proxy\";\nimport require$$7 from \"\\u0000/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/dijkstrajs@1.0.3/node_modules/dijkstrajs/dijkstra.js?commonjs-proxy\";\n\n(function (exports) {\n\tconst Mode = require$$0\n\tconst NumericData = require$$1\n\tconst AlphanumericData = require$$2\n\tconst ByteData = require$$3\n\tconst KanjiData = require$$4\n\tconst Regex = require$$5\n\tconst Utils = require$$6\n\tconst dijkstra = require$$7\n\n\t/**\n\t * Returns UTF8 byte length\n\t *\n\t * @param  {String} str Input string\n\t * @return {Number}     Number of byte\n\t */\n\tfunction getStringByteLength (str) {\n\t  return unescape(encodeURIComponent(str)).length\n\t}\n\n\t/**\n\t * Get a list of segments of the specified mode\n\t * from a string\n\t *\n\t * @param  {Mode}   mode Segment mode\n\t * @param  {String} str  String to process\n\t * @return {Array}       Array of object with segments data\n\t */\n\tfunction getSegments (regex, mode, str) {\n\t  const segments = []\n\t  let result\n\n\t  while ((result = regex.exec(str)) !== null) {\n\t    segments.push({\n\t      data: result[0],\n\t      index: result.index,\n\t      mode: mode,\n\t      length: result[0].length\n\t    })\n\t  }\n\n\t  return segments\n\t}\n\n\t/**\n\t * Extracts a series of segments with the appropriate\n\t * modes from a string\n\t *\n\t * @param  {String} dataStr Input string\n\t * @return {Array}          Array of object with segments data\n\t */\n\tfunction getSegmentsFromString (dataStr) {\n\t  const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr)\n\t  const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr)\n\t  let byteSegs\n\t  let kanjiSegs\n\n\t  if (Utils.isKanjiModeEnabled()) {\n\t    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr)\n\t    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr)\n\t  } else {\n\t    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr)\n\t    kanjiSegs = []\n\t  }\n\n\t  const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs)\n\n\t  return segs\n\t    .sort(function (s1, s2) {\n\t      return s1.index - s2.index\n\t    })\n\t    .map(function (obj) {\n\t      return {\n\t        data: obj.data,\n\t        mode: obj.mode,\n\t        length: obj.length\n\t      }\n\t    })\n\t}\n\n\t/**\n\t * Returns how many bits are needed to encode a string of\n\t * specified length with the specified mode\n\t *\n\t * @param  {Number} length String length\n\t * @param  {Mode} mode     Segment mode\n\t * @return {Number}        Bit length\n\t */\n\tfunction getSegmentBitsLength (length, mode) {\n\t  switch (mode) {\n\t    case Mode.NUMERIC:\n\t      return NumericData.getBitsLength(length)\n\t    case Mode.ALPHANUMERIC:\n\t      return AlphanumericData.getBitsLength(length)\n\t    case Mode.KANJI:\n\t      return KanjiData.getBitsLength(length)\n\t    case Mode.BYTE:\n\t      return ByteData.getBitsLength(length)\n\t  }\n\t}\n\n\t/**\n\t * Merges adjacent segments which have the same mode\n\t *\n\t * @param  {Array} segs Array of object with segments data\n\t * @return {Array}      Array of object with segments data\n\t */\n\tfunction mergeSegments (segs) {\n\t  return segs.reduce(function (acc, curr) {\n\t    const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null\n\t    if (prevSeg && prevSeg.mode === curr.mode) {\n\t      acc[acc.length - 1].data += curr.data\n\t      return acc\n\t    }\n\n\t    acc.push(curr)\n\t    return acc\n\t  }, [])\n\t}\n\n\t/**\n\t * Generates a list of all possible nodes combination which\n\t * will be used to build a segments graph.\n\t *\n\t * Nodes are divided by groups. Each group will contain a list of all the modes\n\t * in which is possible to encode the given text.\n\t *\n\t * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\n\t * The group for '12345' will contain then 3 objects, one for each\n\t * possible encoding mode.\n\t *\n\t * Each node represents a possible segment.\n\t *\n\t * @param  {Array} segs Array of object with segments data\n\t * @return {Array}      Array of object with segments data\n\t */\n\tfunction buildNodes (segs) {\n\t  const nodes = []\n\t  for (let i = 0; i < segs.length; i++) {\n\t    const seg = segs[i]\n\n\t    switch (seg.mode) {\n\t      case Mode.NUMERIC:\n\t        nodes.push([seg,\n\t          { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },\n\t          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n\t        ])\n\t        break\n\t      case Mode.ALPHANUMERIC:\n\t        nodes.push([seg,\n\t          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n\t        ])\n\t        break\n\t      case Mode.KANJI:\n\t        nodes.push([seg,\n\t          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n\t        ])\n\t        break\n\t      case Mode.BYTE:\n\t        nodes.push([\n\t          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n\t        ])\n\t    }\n\t  }\n\n\t  return nodes\n\t}\n\n\t/**\n\t * Builds a graph from a list of nodes.\n\t * All segments in each node group will be connected with all the segments of\n\t * the next group and so on.\n\t *\n\t * At each connection will be assigned a weight depending on the\n\t * segment's byte length.\n\t *\n\t * @param  {Array} nodes    Array of object with segments data\n\t * @param  {Number} version QR Code version\n\t * @return {Object}         Graph of all possible segments\n\t */\n\tfunction buildGraph (nodes, version) {\n\t  const table = {}\n\t  const graph = { start: {} }\n\t  let prevNodeIds = ['start']\n\n\t  for (let i = 0; i < nodes.length; i++) {\n\t    const nodeGroup = nodes[i]\n\t    const currentNodeIds = []\n\n\t    for (let j = 0; j < nodeGroup.length; j++) {\n\t      const node = nodeGroup[j]\n\t      const key = '' + i + j\n\n\t      currentNodeIds.push(key)\n\t      table[key] = { node: node, lastCount: 0 }\n\t      graph[key] = {}\n\n\t      for (let n = 0; n < prevNodeIds.length; n++) {\n\t        const prevNodeId = prevNodeIds[n]\n\n\t        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n\t          graph[prevNodeId][key] =\n\t            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -\n\t            getSegmentBitsLength(table[prevNodeId].lastCount, node.mode)\n\n\t          table[prevNodeId].lastCount += node.length\n\t        } else {\n\t          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length\n\n\t          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +\n\t            4 + Mode.getCharCountIndicator(node.mode, version) // switch cost\n\t        }\n\t      }\n\t    }\n\n\t    prevNodeIds = currentNodeIds\n\t  }\n\n\t  for (let n = 0; n < prevNodeIds.length; n++) {\n\t    graph[prevNodeIds[n]].end = 0\n\t  }\n\n\t  return { map: graph, table: table }\n\t}\n\n\t/**\n\t * Builds a segment from a specified data and mode.\n\t * If a mode is not specified, the more suitable will be used.\n\t *\n\t * @param  {String} data             Input data\n\t * @param  {Mode | String} modesHint Data mode\n\t * @return {Segment}                 Segment\n\t */\n\tfunction buildSingleSegment (data, modesHint) {\n\t  let mode\n\t  const bestMode = Mode.getBestModeForData(data)\n\n\t  mode = Mode.from(modesHint, bestMode)\n\n\t  // Make sure data can be encoded\n\t  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {\n\t    throw new Error('\"' + data + '\"' +\n\t      ' cannot be encoded with mode ' + Mode.toString(mode) +\n\t      '.\\n Suggested mode is: ' + Mode.toString(bestMode))\n\t  }\n\n\t  // Use Mode.BYTE if Kanji support is disabled\n\t  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {\n\t    mode = Mode.BYTE\n\t  }\n\n\t  switch (mode) {\n\t    case Mode.NUMERIC:\n\t      return new NumericData(data)\n\n\t    case Mode.ALPHANUMERIC:\n\t      return new AlphanumericData(data)\n\n\t    case Mode.KANJI:\n\t      return new KanjiData(data)\n\n\t    case Mode.BYTE:\n\t      return new ByteData(data)\n\t  }\n\t}\n\n\t/**\n\t * Builds a list of segments from an array.\n\t * Array can contain Strings or Objects with segment's info.\n\t *\n\t * For each item which is a string, will be generated a segment with the given\n\t * string and the more appropriate encoding mode.\n\t *\n\t * For each item which is an object, will be generated a segment with the given\n\t * data and mode.\n\t * Objects must contain at least the property \"data\".\n\t * If property \"mode\" is not present, the more suitable mode will be used.\n\t *\n\t * @param  {Array} array Array of objects with segments data\n\t * @return {Array}       Array of Segments\n\t */\n\texports.fromArray = function fromArray (array) {\n\t  return array.reduce(function (acc, seg) {\n\t    if (typeof seg === 'string') {\n\t      acc.push(buildSingleSegment(seg, null))\n\t    } else if (seg.data) {\n\t      acc.push(buildSingleSegment(seg.data, seg.mode))\n\t    }\n\n\t    return acc\n\t  }, [])\n\t}\n\n\t/**\n\t * Builds an optimized sequence of segments from a string,\n\t * which will produce the shortest possible bitstream.\n\t *\n\t * @param  {String} data    Input string\n\t * @param  {Number} version QR Code version\n\t * @return {Array}          Array of segments\n\t */\n\texports.fromString = function fromString (data, version) {\n\t  const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n\n\t  const nodes = buildNodes(segs)\n\t  const graph = buildGraph(nodes, version)\n\t  const path = dijkstra.find_path(graph.map, 'start', 'end')\n\n\t  const optimizedSegs = []\n\t  for (let i = 1; i < path.length - 1; i++) {\n\t    optimizedSegs.push(graph.table[path[i]].node)\n\t  }\n\n\t  return exports.fromArray(mergeSegments(optimizedSegs))\n\t}\n\n\t/**\n\t * Splits a string in various segments with the modes which\n\t * best represent their content.\n\t * The produced segments are far from being optimized.\n\t * The output of this function is only used to estimate a QR Code version\n\t * which may contain the data.\n\t *\n\t * @param  {string} data Input string\n\t * @return {Array}       Array of segments\n\t */\n\texports.rawSplit = function rawSplit (data) {\n\t  return exports.fromArray(\n\t    getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n\t  )\n\t} \n} (segments));\n\nexport default /*@__PURE__*/commonjsHelpers.getDefaultExportFromCjs(segments);\nexport { segments as __moduleExports };",
      "start": 1714699771065,
      "end": 1714699771122,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          ""
        ],
        "names": [],
        "mappings": "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"
      }
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1714699771122,
      "end": 1714699771122,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1714699771122,
      "end": 1714699771122,
      "order": "normal"
    },
    {
      "name": "unplugin-auto-import",
      "start": 1714699771122,
      "end": 1714699771122,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1714699771122,
      "end": 1714699771122,
      "order": "post"
    },
    {
      "name": "vite:style-import",
      "start": 1714699771122,
      "end": 1714699771122,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1714699771122,
      "end": 1714699771122,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1714699771122,
      "end": 1714699771122,
      "order": "normal"
    }
  ]
}
