{
  "resolvedId": "/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/vxe-table@4.5.21_vue@3.4.19_xe-utils@3.5.24/node_modules/vxe-table/es/tooltip/src/tooltip.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { defineComponent, h, ref, nextTick, onBeforeUnmount, onMounted, reactive, watch } from 'vue';\nimport XEUtils from 'xe-utils';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport { useSize } from '../../hooks/size';\nimport { getLastZIndex, nextZIndex, formatText } from '../../tools/utils';\nimport { getAbsolutePos, getDomNode } from '../../tools/dom';\nimport { getSlotVNs } from '../../tools/vn';\nexport default defineComponent({\n    name: 'VxeTooltip',\n    props: {\n        modelValue: Boolean,\n        size: { type: String, default: function () { return GlobalConfig.tooltip.size || GlobalConfig.size; } },\n        trigger: { type: String, default: function () { return GlobalConfig.tooltip.trigger; } },\n        theme: { type: String, default: function () { return GlobalConfig.tooltip.theme; } },\n        content: { type: [String, Number], default: null },\n        useHTML: Boolean,\n        zIndex: [String, Number],\n        popupClassName: [String, Function],\n        isArrow: { type: Boolean, default: true },\n        enterable: Boolean,\n        enterDelay: { type: Number, default: function () { return GlobalConfig.tooltip.enterDelay; } },\n        leaveDelay: { type: Number, default: function () { return GlobalConfig.tooltip.leaveDelay; } }\n    },\n    emits: [\n        'update:modelValue'\n    ],\n    setup: function (props, context) {\n        var slots = context.slots, emit = context.emit;\n        var xID = XEUtils.uniqueId();\n        var computeSize = useSize(props);\n        var reactData = reactive({\n            target: null,\n            isUpdate: false,\n            visible: false,\n            tipContent: '',\n            tipActive: false,\n            tipTarget: null,\n            tipZindex: 0,\n            tipStore: {\n                style: {},\n                placement: '',\n                arrowStyle: {}\n            }\n        });\n        var refElem = ref();\n        var refMaps = {\n            refElem: refElem\n        };\n        var $xetooltip = {\n            xID: xID,\n            props: props,\n            context: context,\n            reactData: reactData,\n            getRefMaps: function () { return refMaps; }\n        };\n        var tooltipMethods = {};\n        var updateTipStyle = function () {\n            var tipTarget = reactData.tipTarget, tipStore = reactData.tipStore;\n            if (tipTarget) {\n                var _a = getDomNode(), scrollTop = _a.scrollTop, scrollLeft = _a.scrollLeft, visibleWidth = _a.visibleWidth;\n                var _b = getAbsolutePos(tipTarget), top_1 = _b.top, left = _b.left;\n                var el = refElem.value;\n                var marginSize = 6;\n                var offsetHeight = el.offsetHeight;\n                var offsetWidth = el.offsetWidth;\n                var tipLeft = left;\n                var tipTop = top_1 - offsetHeight - marginSize;\n                tipLeft = Math.max(marginSize, left + Math.floor((tipTarget.offsetWidth - offsetWidth) / 2));\n                if (tipLeft + offsetWidth + marginSize > scrollLeft + visibleWidth) {\n                    tipLeft = scrollLeft + visibleWidth - offsetWidth - marginSize;\n                }\n                if (top_1 - offsetHeight < scrollTop + marginSize) {\n                    tipStore.placement = 'bottom';\n                    tipTop = top_1 + tipTarget.offsetHeight + marginSize;\n                }\n                tipStore.style.top = \"\".concat(tipTop, \"px\");\n                tipStore.style.left = \"\".concat(tipLeft, \"px\");\n                tipStore.arrowStyle.left = \"\".concat(left - tipLeft + tipTarget.offsetWidth / 2, \"px\");\n            }\n        };\n        var updateValue = function (value) {\n            if (value !== reactData.visible) {\n                reactData.visible = value;\n                reactData.isUpdate = true;\n                emit('update:modelValue', value);\n            }\n        };\n        var updateZindex = function () {\n            if (reactData.tipZindex < getLastZIndex()) {\n                reactData.tipZindex = nextZIndex();\n            }\n        };\n        var clickEvent = function () {\n            if (reactData.visible) {\n                tooltipMethods.close();\n            }\n            else {\n                tooltipMethods.open();\n            }\n        };\n        var targetMouseenterEvent = function () {\n            tooltipMethods.open();\n        };\n        var targetMouseleaveEvent = function () {\n            var trigger = props.trigger, enterable = props.enterable, leaveDelay = props.leaveDelay;\n            reactData.tipActive = false;\n            if (enterable && trigger === 'hover') {\n                setTimeout(function () {\n                    if (!reactData.tipActive) {\n                        tooltipMethods.close();\n                    }\n                }, leaveDelay);\n            }\n            else {\n                tooltipMethods.close();\n            }\n        };\n        var wrapperMouseenterEvent = function () {\n            reactData.tipActive = true;\n        };\n        var wrapperMouseleaveEvent = function () {\n            var trigger = props.trigger, enterable = props.enterable, leaveDelay = props.leaveDelay;\n            reactData.tipActive = false;\n            if (enterable && trigger === 'hover') {\n                setTimeout(function () {\n                    if (!reactData.tipActive) {\n                        tooltipMethods.close();\n                    }\n                }, leaveDelay);\n            }\n        };\n        var showTip = function () {\n            var tipStore = reactData.tipStore;\n            var el = refElem.value;\n            if (el) {\n                var parentNode = el.parentNode;\n                if (!parentNode) {\n                    document.body.appendChild(el);\n                }\n            }\n            updateValue(true);\n            updateZindex();\n            tipStore.placement = 'top';\n            tipStore.style = { width: 'auto', left: 0, top: 0, zIndex: props.zIndex || reactData.tipZindex };\n            tipStore.arrowStyle = { left: '50%' };\n            return tooltipMethods.updatePlacement();\n        };\n        var showDelayTip = XEUtils.debounce(function () {\n            if (reactData.tipActive) {\n                showTip();\n            }\n        }, props.enterDelay, { leading: false, trailing: true });\n        tooltipMethods = {\n            dispatchEvent: function (type, params, evnt) {\n                emit(type, Object.assign({ $tooltip: $xetooltip, $event: evnt }, params));\n            },\n            open: function (target, content) {\n                return tooltipMethods.toVisible(target || reactData.target, content);\n            },\n            close: function () {\n                reactData.tipTarget = null;\n                reactData.tipActive = false;\n                Object.assign(reactData.tipStore, {\n                    style: {},\n                    placement: '',\n                    arrowStyle: null\n                });\n                updateValue(false);\n                return nextTick();\n            },\n            toVisible: function (target, content) {\n                if (target) {\n                    var trigger = props.trigger, enterDelay = props.enterDelay;\n                    reactData.tipActive = true;\n                    reactData.tipTarget = target;\n                    if (content) {\n                        reactData.tipContent = content;\n                    }\n                    if (enterDelay && trigger === 'hover') {\n                        showDelayTip();\n                    }\n                    else {\n                        return showTip();\n                    }\n                }\n                return nextTick();\n            },\n            updatePlacement: function () {\n                return nextTick().then(function () {\n                    var tipTarget = reactData.tipTarget;\n                    var el = refElem.value;\n                    if (tipTarget && el) {\n                        updateTipStyle();\n                        return nextTick().then(updateTipStyle);\n                    }\n                });\n            },\n            isActived: function () {\n                return reactData.tipActive;\n            },\n            setActived: function (actived) {\n                reactData.tipActive = !!actived;\n            }\n        };\n        Object.assign($xetooltip, tooltipMethods);\n        watch(function () { return props.content; }, function () {\n            reactData.tipContent = props.content;\n        });\n        watch(function () { return props.modelValue; }, function () {\n            if (!reactData.isUpdate) {\n                if (props.modelValue) {\n                    tooltipMethods.open();\n                }\n                else {\n                    tooltipMethods.close();\n                }\n            }\n            reactData.isUpdate = false;\n        });\n        onMounted(function () {\n            nextTick(function () {\n                var trigger = props.trigger, content = props.content, modelValue = props.modelValue;\n                var wrapperElem = refElem.value;\n                if (wrapperElem) {\n                    var parentNode_1 = wrapperElem.parentNode;\n                    if (parentNode_1) {\n                        reactData.tipContent = content;\n                        reactData.tipZindex = nextZIndex();\n                        XEUtils.arrayEach(wrapperElem.children, function (elem, index) {\n                            if (index > 1) {\n                                parentNode_1.insertBefore(elem, wrapperElem);\n                                if (!reactData.target) {\n                                    reactData.target = elem;\n                                }\n                            }\n                        });\n                        parentNode_1.removeChild(wrapperElem);\n                        var target = reactData.target;\n                        if (target) {\n                            if (trigger === 'hover') {\n                                target.onmouseenter = targetMouseenterEvent;\n                                target.onmouseleave = targetMouseleaveEvent;\n                            }\n                            else if (trigger === 'click') {\n                                target.onclick = clickEvent;\n                            }\n                        }\n                        if (modelValue) {\n                            tooltipMethods.open();\n                        }\n                    }\n                }\n            });\n        });\n        onBeforeUnmount(function () {\n            var trigger = props.trigger;\n            var target = reactData.target;\n            var wrapperElem = refElem.value;\n            if (wrapperElem) {\n                var parentNode = wrapperElem.parentNode;\n                if (parentNode) {\n                    parentNode.removeChild(wrapperElem);\n                }\n            }\n            if (target) {\n                if (trigger === 'hover') {\n                    target.onmouseenter = null;\n                    target.onmouseleave = null;\n                }\n                else if (trigger === 'click') {\n                    target.onclick = null;\n                }\n            }\n        });\n        var renderContent = function () {\n            var useHTML = props.useHTML;\n            var tipContent = reactData.tipContent;\n            var contentSlot = slots.content;\n            if (contentSlot) {\n                return h('div', {\n                    key: 1,\n                    class: 'vxe-table--tooltip-content'\n                }, getSlotVNs(contentSlot({})));\n            }\n            if (useHTML) {\n                return h('div', {\n                    key: 2,\n                    class: 'vxe-table--tooltip-content',\n                    innerHTML: tipContent\n                });\n            }\n            return h('div', {\n                key: 3,\n                class: 'vxe-table--tooltip-content'\n            }, formatText(tipContent));\n        };\n        var renderVN = function () {\n            var _a;\n            var popupClassName = props.popupClassName, theme = props.theme, isArrow = props.isArrow, enterable = props.enterable;\n            var tipActive = reactData.tipActive, visible = reactData.visible, tipStore = reactData.tipStore;\n            var defaultSlot = slots.default;\n            var vSize = computeSize.value;\n            var ons;\n            if (enterable) {\n                ons = {\n                    onMouseenter: wrapperMouseenterEvent,\n                    onMouseleave: wrapperMouseleaveEvent\n                };\n            }\n            return h('div', __assign({ ref: refElem, class: ['vxe-table--tooltip-wrapper', \"theme--\".concat(theme), popupClassName ? (XEUtils.isFunction(popupClassName) ? popupClassName({ $tooltip: $xetooltip }) : popupClassName) : '', (_a = {},\n                        _a[\"size--\".concat(vSize)] = vSize,\n                        _a[\"placement--\".concat(tipStore.placement)] = tipStore.placement,\n                        _a['is--enterable'] = enterable,\n                        _a['is--visible'] = visible,\n                        _a['is--arrow'] = isArrow,\n                        _a['is--active'] = tipActive,\n                        _a)], style: tipStore.style }, ons), __spreadArray([\n                renderContent(),\n                h('div', {\n                    class: 'vxe-table--tooltip-arrow',\n                    style: tipStore.arrowStyle\n                })\n            ], (defaultSlot ? getSlotVNs(defaultSlot({})) : []), true));\n        };\n        $xetooltip.renderVN = renderVN;\n        return $xetooltip;\n    },\n    render: function () {\n        return this.renderVN();\n    }\n});\n",
      "start": 1714699767752,
      "end": 1714699767799,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1714699767799,
      "end": 1714699767799,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1714699767799,
      "end": 1714699767799,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1714699767799,
      "end": 1714699767799,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1714699767799,
      "end": 1714699767799,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1714699767799,
      "end": 1714699767799,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1714699767799,
      "end": 1714699767799,
      "order": "normal"
    },
    {
      "name": "vite-plugin-vconsole",
      "result": "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { defineComponent, h, ref, nextTick, onBeforeUnmount, onMounted, reactive, watch } from 'vue';\nimport XEUtils from 'xe-utils';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport { useSize } from '../../hooks/size';\nimport { getLastZIndex, nextZIndex, formatText } from '../../tools/utils';\nimport { getAbsolutePos, getDomNode } from '../../tools/dom';\nimport { getSlotVNs } from '../../tools/vn';\nexport default defineComponent({\n    name: 'VxeTooltip',\n    props: {\n        modelValue: Boolean,\n        size: { type: String, default: function () { return GlobalConfig.tooltip.size || GlobalConfig.size; } },\n        trigger: { type: String, default: function () { return GlobalConfig.tooltip.trigger; } },\n        theme: { type: String, default: function () { return GlobalConfig.tooltip.theme; } },\n        content: { type: [String, Number], default: null },\n        useHTML: Boolean,\n        zIndex: [String, Number],\n        popupClassName: [String, Function],\n        isArrow: { type: Boolean, default: true },\n        enterable: Boolean,\n        enterDelay: { type: Number, default: function () { return GlobalConfig.tooltip.enterDelay; } },\n        leaveDelay: { type: Number, default: function () { return GlobalConfig.tooltip.leaveDelay; } }\n    },\n    emits: [\n        'update:modelValue'\n    ],\n    setup: function (props, context) {\n        var slots = context.slots, emit = context.emit;\n        var xID = XEUtils.uniqueId();\n        var computeSize = useSize(props);\n        var reactData = reactive({\n            target: null,\n            isUpdate: false,\n            visible: false,\n            tipContent: '',\n            tipActive: false,\n            tipTarget: null,\n            tipZindex: 0,\n            tipStore: {\n                style: {},\n                placement: '',\n                arrowStyle: {}\n            }\n        });\n        var refElem = ref();\n        var refMaps = {\n            refElem: refElem\n        };\n        var $xetooltip = {\n            xID: xID,\n            props: props,\n            context: context,\n            reactData: reactData,\n            getRefMaps: function () { return refMaps; }\n        };\n        var tooltipMethods = {};\n        var updateTipStyle = function () {\n            var tipTarget = reactData.tipTarget, tipStore = reactData.tipStore;\n            if (tipTarget) {\n                var _a = getDomNode(), scrollTop = _a.scrollTop, scrollLeft = _a.scrollLeft, visibleWidth = _a.visibleWidth;\n                var _b = getAbsolutePos(tipTarget), top_1 = _b.top, left = _b.left;\n                var el = refElem.value;\n                var marginSize = 6;\n                var offsetHeight = el.offsetHeight;\n                var offsetWidth = el.offsetWidth;\n                var tipLeft = left;\n                var tipTop = top_1 - offsetHeight - marginSize;\n                tipLeft = Math.max(marginSize, left + Math.floor((tipTarget.offsetWidth - offsetWidth) / 2));\n                if (tipLeft + offsetWidth + marginSize > scrollLeft + visibleWidth) {\n                    tipLeft = scrollLeft + visibleWidth - offsetWidth - marginSize;\n                }\n                if (top_1 - offsetHeight < scrollTop + marginSize) {\n                    tipStore.placement = 'bottom';\n                    tipTop = top_1 + tipTarget.offsetHeight + marginSize;\n                }\n                tipStore.style.top = \"\".concat(tipTop, \"px\");\n                tipStore.style.left = \"\".concat(tipLeft, \"px\");\n                tipStore.arrowStyle.left = \"\".concat(left - tipLeft + tipTarget.offsetWidth / 2, \"px\");\n            }\n        };\n        var updateValue = function (value) {\n            if (value !== reactData.visible) {\n                reactData.visible = value;\n                reactData.isUpdate = true;\n                emit('update:modelValue', value);\n            }\n        };\n        var updateZindex = function () {\n            if (reactData.tipZindex < getLastZIndex()) {\n                reactData.tipZindex = nextZIndex();\n            }\n        };\n        var clickEvent = function () {\n            if (reactData.visible) {\n                tooltipMethods.close();\n            }\n            else {\n                tooltipMethods.open();\n            }\n        };\n        var targetMouseenterEvent = function () {\n            tooltipMethods.open();\n        };\n        var targetMouseleaveEvent = function () {\n            var trigger = props.trigger, enterable = props.enterable, leaveDelay = props.leaveDelay;\n            reactData.tipActive = false;\n            if (enterable && trigger === 'hover') {\n                setTimeout(function () {\n                    if (!reactData.tipActive) {\n                        tooltipMethods.close();\n                    }\n                }, leaveDelay);\n            }\n            else {\n                tooltipMethods.close();\n            }\n        };\n        var wrapperMouseenterEvent = function () {\n            reactData.tipActive = true;\n        };\n        var wrapperMouseleaveEvent = function () {\n            var trigger = props.trigger, enterable = props.enterable, leaveDelay = props.leaveDelay;\n            reactData.tipActive = false;\n            if (enterable && trigger === 'hover') {\n                setTimeout(function () {\n                    if (!reactData.tipActive) {\n                        tooltipMethods.close();\n                    }\n                }, leaveDelay);\n            }\n        };\n        var showTip = function () {\n            var tipStore = reactData.tipStore;\n            var el = refElem.value;\n            if (el) {\n                var parentNode = el.parentNode;\n                if (!parentNode) {\n                    document.body.appendChild(el);\n                }\n            }\n            updateValue(true);\n            updateZindex();\n            tipStore.placement = 'top';\n            tipStore.style = { width: 'auto', left: 0, top: 0, zIndex: props.zIndex || reactData.tipZindex };\n            tipStore.arrowStyle = { left: '50%' };\n            return tooltipMethods.updatePlacement();\n        };\n        var showDelayTip = XEUtils.debounce(function () {\n            if (reactData.tipActive) {\n                showTip();\n            }\n        }, props.enterDelay, { leading: false, trailing: true });\n        tooltipMethods = {\n            dispatchEvent: function (type, params, evnt) {\n                emit(type, Object.assign({ $tooltip: $xetooltip, $event: evnt }, params));\n            },\n            open: function (target, content) {\n                return tooltipMethods.toVisible(target || reactData.target, content);\n            },\n            close: function () {\n                reactData.tipTarget = null;\n                reactData.tipActive = false;\n                Object.assign(reactData.tipStore, {\n                    style: {},\n                    placement: '',\n                    arrowStyle: null\n                });\n                updateValue(false);\n                return nextTick();\n            },\n            toVisible: function (target, content) {\n                if (target) {\n                    var trigger = props.trigger, enterDelay = props.enterDelay;\n                    reactData.tipActive = true;\n                    reactData.tipTarget = target;\n                    if (content) {\n                        reactData.tipContent = content;\n                    }\n                    if (enterDelay && trigger === 'hover') {\n                        showDelayTip();\n                    }\n                    else {\n                        return showTip();\n                    }\n                }\n                return nextTick();\n            },\n            updatePlacement: function () {\n                return nextTick().then(function () {\n                    var tipTarget = reactData.tipTarget;\n                    var el = refElem.value;\n                    if (tipTarget && el) {\n                        updateTipStyle();\n                        return nextTick().then(updateTipStyle);\n                    }\n                });\n            },\n            isActived: function () {\n                return reactData.tipActive;\n            },\n            setActived: function (actived) {\n                reactData.tipActive = !!actived;\n            }\n        };\n        Object.assign($xetooltip, tooltipMethods);\n        watch(function () { return props.content; }, function () {\n            reactData.tipContent = props.content;\n        });\n        watch(function () { return props.modelValue; }, function () {\n            if (!reactData.isUpdate) {\n                if (props.modelValue) {\n                    tooltipMethods.open();\n                }\n                else {\n                    tooltipMethods.close();\n                }\n            }\n            reactData.isUpdate = false;\n        });\n        onMounted(function () {\n            nextTick(function () {\n                var trigger = props.trigger, content = props.content, modelValue = props.modelValue;\n                var wrapperElem = refElem.value;\n                if (wrapperElem) {\n                    var parentNode_1 = wrapperElem.parentNode;\n                    if (parentNode_1) {\n                        reactData.tipContent = content;\n                        reactData.tipZindex = nextZIndex();\n                        XEUtils.arrayEach(wrapperElem.children, function (elem, index) {\n                            if (index > 1) {\n                                parentNode_1.insertBefore(elem, wrapperElem);\n                                if (!reactData.target) {\n                                    reactData.target = elem;\n                                }\n                            }\n                        });\n                        parentNode_1.removeChild(wrapperElem);\n                        var target = reactData.target;\n                        if (target) {\n                            if (trigger === 'hover') {\n                                target.onmouseenter = targetMouseenterEvent;\n                                target.onmouseleave = targetMouseleaveEvent;\n                            }\n                            else if (trigger === 'click') {\n                                target.onclick = clickEvent;\n                            }\n                        }\n                        if (modelValue) {\n                            tooltipMethods.open();\n                        }\n                    }\n                }\n            });\n        });\n        onBeforeUnmount(function () {\n            var trigger = props.trigger;\n            var target = reactData.target;\n            var wrapperElem = refElem.value;\n            if (wrapperElem) {\n                var parentNode = wrapperElem.parentNode;\n                if (parentNode) {\n                    parentNode.removeChild(wrapperElem);\n                }\n            }\n            if (target) {\n                if (trigger === 'hover') {\n                    target.onmouseenter = null;\n                    target.onmouseleave = null;\n                }\n                else if (trigger === 'click') {\n                    target.onclick = null;\n                }\n            }\n        });\n        var renderContent = function () {\n            var useHTML = props.useHTML;\n            var tipContent = reactData.tipContent;\n            var contentSlot = slots.content;\n            if (contentSlot) {\n                return h('div', {\n                    key: 1,\n                    class: 'vxe-table--tooltip-content'\n                }, getSlotVNs(contentSlot({})));\n            }\n            if (useHTML) {\n                return h('div', {\n                    key: 2,\n                    class: 'vxe-table--tooltip-content',\n                    innerHTML: tipContent\n                });\n            }\n            return h('div', {\n                key: 3,\n                class: 'vxe-table--tooltip-content'\n            }, formatText(tipContent));\n        };\n        var renderVN = function () {\n            var _a;\n            var popupClassName = props.popupClassName, theme = props.theme, isArrow = props.isArrow, enterable = props.enterable;\n            var tipActive = reactData.tipActive, visible = reactData.visible, tipStore = reactData.tipStore;\n            var defaultSlot = slots.default;\n            var vSize = computeSize.value;\n            var ons;\n            if (enterable) {\n                ons = {\n                    onMouseenter: wrapperMouseenterEvent,\n                    onMouseleave: wrapperMouseleaveEvent\n                };\n            }\n            return h('div', __assign({ ref: refElem, class: ['vxe-table--tooltip-wrapper', \"theme--\".concat(theme), popupClassName ? (XEUtils.isFunction(popupClassName) ? popupClassName({ $tooltip: $xetooltip }) : popupClassName) : '', (_a = {},\n                        _a[\"size--\".concat(vSize)] = vSize,\n                        _a[\"placement--\".concat(tipStore.placement)] = tipStore.placement,\n                        _a['is--enterable'] = enterable,\n                        _a['is--visible'] = visible,\n                        _a['is--arrow'] = isArrow,\n                        _a['is--active'] = tipActive,\n                        _a)], style: tipStore.style }, ons), __spreadArray([\n                renderContent(),\n                h('div', {\n                    class: 'vxe-table--tooltip-arrow',\n                    style: tipStore.arrowStyle\n                })\n            ], (defaultSlot ? getSlotVNs(defaultSlot({})) : []), true));\n        };\n        $xetooltip.renderVN = renderVN;\n        return $xetooltip;\n    },\n    render: function () {\n        return this.renderVN();\n    }\n});\n",
      "start": 1714699767799,
      "end": 1714699767799,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "esbuild",
      "start": 1714699767799,
      "end": 1714699767799,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1714699767799,
      "end": 1714699767799,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1714699767799,
      "end": 1714699767799,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1714699767799,
      "end": 1714699767799,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1714699767799,
      "end": 1714699767799,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1714699767799,
      "end": 1714699767799,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1714699767799,
      "end": 1714699767800,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1714699767800,
      "end": 1714699767800,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1714699767800,
      "end": 1714699767800,
      "order": "normal"
    },
    {
      "name": "unplugin-auto-import",
      "start": 1714699767800,
      "end": 1714699767800,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1714699767800,
      "end": 1714699767800,
      "order": "post"
    },
    {
      "name": "vite:style-import",
      "start": 1714699767800,
      "end": 1714699767800,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1714699767800,
      "end": 1714699767800,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1714699767800,
      "end": 1714699767800,
      "order": "normal"
    }
  ]
}
