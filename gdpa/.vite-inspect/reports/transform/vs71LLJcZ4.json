{
  "resolvedId": "/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/vxe-table@4.5.21_vue@3.4.19_xe-utils@3.5.24/node_modules/vxe-table/es/select/src/select.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { defineComponent, h, Teleport, ref, inject, computed, provide, onUnmounted, reactive, nextTick, watch, onMounted, createCommentVNode } from 'vue';\nimport XEUtils from 'xe-utils';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport { useSize } from '../../hooks/size';\nimport { getEventTargetNode, getAbsolutePos } from '../../tools/dom';\nimport { getLastZIndex, nextZIndex, getFuncText, formatText } from '../../tools/utils';\nimport { GlobalEvent, hasEventKey, EVENT_KEYS } from '../../tools/event';\nimport VxeInputComponent from '../../input/src/input';\nimport { getSlotVNs } from '../../tools/vn';\nfunction isOptionVisible(option) {\n    return option.visible !== false;\n}\nfunction getOptUniqueId() {\n    return XEUtils.uniqueId('opt_');\n}\nexport default defineComponent({\n    name: 'VxeSelect',\n    props: {\n        modelValue: null,\n        clearable: Boolean,\n        placeholder: {\n            type: String,\n            default: function () { return XEUtils.eqNull(GlobalConfig.select.placeholder) ? GlobalConfig.i18n('vxe.base.pleaseSelect') : GlobalConfig.select.placeholder; }\n        },\n        loading: Boolean,\n        disabled: Boolean,\n        multiple: Boolean,\n        multiCharOverflow: { type: [Number, String], default: function () { return GlobalConfig.select.multiCharOverflow; } },\n        prefixIcon: String,\n        placement: String,\n        options: Array,\n        optionProps: Object,\n        optionGroups: Array,\n        optionGroupProps: Object,\n        optionConfig: Object,\n        className: [String, Function],\n        popupClassName: [String, Function],\n        max: { type: [String, Number], default: null },\n        size: { type: String, default: function () { return GlobalConfig.select.size || GlobalConfig.size; } },\n        filterable: Boolean,\n        filterMethod: Function,\n        remote: Boolean,\n        remoteMethod: Function,\n        emptyText: String,\n        // 已废弃，被 option-config.keyField 替换\n        optionId: { type: String, default: function () { return GlobalConfig.select.optionId; } },\n        // 已废弃，被 option-config.useKey 替换\n        optionKey: Boolean,\n        transfer: { type: Boolean, default: function () { return GlobalConfig.select.transfer; } }\n    },\n    emits: [\n        'update:modelValue',\n        'change',\n        'clear',\n        'blur',\n        'focus'\n    ],\n    setup: function (props, context) {\n        var slots = context.slots, emit = context.emit;\n        var $xeform = inject('$xeform', null);\n        var $xeformiteminfo = inject('$xeformiteminfo', null);\n        var xID = XEUtils.uniqueId();\n        var computeSize = useSize(props);\n        var reactData = reactive({\n            inited: false,\n            staticOptions: [],\n            fullGroupList: [],\n            fullOptionList: [],\n            visibleGroupList: [],\n            visibleOptionList: [],\n            remoteValueList: [],\n            panelIndex: 0,\n            panelStyle: {},\n            panelPlacement: null,\n            currentOption: null,\n            currentValue: null,\n            visiblePanel: false,\n            animatVisible: false,\n            isActivated: false,\n            searchValue: '',\n            searchLoading: false\n        });\n        var refElem = ref();\n        var refInput = ref();\n        var refInpSearch = ref();\n        var refOptionWrapper = ref();\n        var refOptionPanel = ref();\n        var refMaps = {\n            refElem: refElem\n        };\n        var $xeselect = {\n            xID: xID,\n            props: props,\n            context: context,\n            reactData: reactData,\n            getRefMaps: function () { return refMaps; }\n        };\n        var selectMethods = {};\n        var computePropsOpts = computed(function () {\n            return props.optionProps || {};\n        });\n        var computeGroupPropsOpts = computed(function () {\n            return props.optionGroupProps || {};\n        });\n        var computeLabelField = computed(function () {\n            var propsOpts = computePropsOpts.value;\n            return propsOpts.label || 'label';\n        });\n        var computeValueField = computed(function () {\n            var propsOpts = computePropsOpts.value;\n            return propsOpts.value || 'value';\n        });\n        var computeGroupLabelField = computed(function () {\n            var groupPropsOpts = computeGroupPropsOpts.value;\n            return groupPropsOpts.label || 'label';\n        });\n        var computeGroupOptionsField = computed(function () {\n            var groupPropsOpts = computeGroupPropsOpts.value;\n            return groupPropsOpts.options || 'options';\n        });\n        var computeIsMaximize = computed(function () {\n            var modelValue = props.modelValue, multiple = props.multiple, max = props.max;\n            if (multiple && max) {\n                return (modelValue ? modelValue.length : 0) >= XEUtils.toNumber(max);\n            }\n            return false;\n        });\n        var computeOptionOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.select.optionConfig, props.optionConfig);\n        });\n        var computeIsGroup = computed(function () {\n            return reactData.fullGroupList.some(function (item) { return item.options && item.options.length; });\n        });\n        var computeMultiMaxCharNum = computed(function () {\n            return XEUtils.toNumber(props.multiCharOverflow);\n        });\n        var callSlot = function (slotFunc, params) {\n            if (slotFunc) {\n                if (XEUtils.isString(slotFunc)) {\n                    slotFunc = slots[slotFunc] || null;\n                }\n                if (XEUtils.isFunction(slotFunc)) {\n                    return getSlotVNs(slotFunc(params));\n                }\n            }\n            return [];\n        };\n        var findOption = function (optionValue) {\n            var fullOptionList = reactData.fullOptionList, fullGroupList = reactData.fullGroupList;\n            var isGroup = computeIsGroup.value;\n            var valueField = computeValueField.value;\n            if (isGroup) {\n                for (var gIndex = 0; gIndex < fullGroupList.length; gIndex++) {\n                    var group = fullGroupList[gIndex];\n                    if (group.options) {\n                        for (var index = 0; index < group.options.length; index++) {\n                            var option = group.options[index];\n                            if (optionValue === option[valueField]) {\n                                return option;\n                            }\n                        }\n                    }\n                }\n            }\n            return fullOptionList.find(function (item) { return optionValue === item[valueField]; });\n        };\n        var getRemoteSelectLabel = function (value) {\n            var remoteValueList = reactData.remoteValueList;\n            var labelField = computeLabelField.value;\n            var remoteItem = remoteValueList.find(function (item) { return value === item.key; });\n            var item = remoteItem ? remoteItem.result : null;\n            return XEUtils.toValueString(item ? item[labelField] : value);\n        };\n        var getSelectLabel = function (value) {\n            var labelField = computeLabelField.value;\n            var item = findOption(value);\n            return XEUtils.toValueString(item ? item[labelField] : value);\n        };\n        var computeSelectLabel = computed(function () {\n            var modelValue = props.modelValue, multiple = props.multiple, remote = props.remote;\n            var multiMaxCharNum = computeMultiMaxCharNum.value;\n            if (modelValue && multiple) {\n                var vals = XEUtils.isArray(modelValue) ? modelValue : [modelValue];\n                if (remote) {\n                    return vals.map(function (val) { return getRemoteSelectLabel(val); }).join(', ');\n                }\n                return vals.map(function (val) {\n                    var label = getSelectLabel(val);\n                    if (multiMaxCharNum > 0 && label.length > multiMaxCharNum) {\n                        return \"\".concat(label.substring(0, multiMaxCharNum), \"...\");\n                    }\n                    return label;\n                }).join(', ');\n            }\n            if (remote) {\n                return getRemoteSelectLabel(modelValue);\n            }\n            return getSelectLabel(modelValue);\n        });\n        var getOptkey = function () {\n            var optionOpts = computeOptionOpts.value;\n            return optionOpts.keyField || props.optionId || '_X_OPTION_KEY';\n        };\n        var getOptid = function (option) {\n            var optid = option[getOptkey()];\n            return optid ? encodeURIComponent(optid) : '';\n        };\n        /**\n         * 刷新选项，当选项被动态显示/隐藏时可能会用到\n         */\n        var refreshOption = function () {\n            var filterable = props.filterable, filterMethod = props.filterMethod;\n            var fullOptionList = reactData.fullOptionList, fullGroupList = reactData.fullGroupList, searchValue = reactData.searchValue;\n            var isGroup = computeIsGroup.value;\n            var groupLabelField = computeGroupLabelField.value;\n            var labelField = computeLabelField.value;\n            if (isGroup) {\n                if (filterable && filterMethod) {\n                    reactData.visibleGroupList = fullGroupList.filter(function (group) { return isOptionVisible(group) && filterMethod({ group: group, option: null, searchValue: searchValue }); });\n                }\n                else if (filterable) {\n                    reactData.visibleGroupList = fullGroupList.filter(function (group) { return isOptionVisible(group) && (!searchValue || \"\".concat(group[groupLabelField]).indexOf(searchValue) > -1); });\n                }\n                else {\n                    reactData.visibleGroupList = fullGroupList.filter(isOptionVisible);\n                }\n            }\n            else {\n                if (filterable && filterMethod) {\n                    reactData.visibleOptionList = fullOptionList.filter(function (option) { return isOptionVisible(option) && filterMethod({ group: null, option: option, searchValue: searchValue }); });\n                }\n                else if (filterable) {\n                    reactData.visibleOptionList = fullOptionList.filter(function (option) { return isOptionVisible(option) && (!searchValue || \"\".concat(option[labelField]).indexOf(searchValue) > -1); });\n                }\n                else {\n                    reactData.visibleOptionList = fullOptionList.filter(isOptionVisible);\n                }\n            }\n            return nextTick();\n        };\n        var cacheItemMap = function () {\n            var fullOptionList = reactData.fullOptionList, fullGroupList = reactData.fullGroupList;\n            var groupOptionsField = computeGroupOptionsField.value;\n            var key = getOptkey();\n            var handleOptis = function (item) {\n                if (!getOptid(item)) {\n                    item[key] = getOptUniqueId();\n                }\n            };\n            if (fullGroupList.length) {\n                fullGroupList.forEach(function (group) {\n                    handleOptis(group);\n                    if (group[groupOptionsField]) {\n                        group[groupOptionsField].forEach(handleOptis);\n                    }\n                });\n            }\n            else if (fullOptionList.length) {\n                fullOptionList.forEach(handleOptis);\n            }\n            refreshOption();\n        };\n        var setCurrentOption = function (option) {\n            var valueField = computeValueField.value;\n            if (option) {\n                reactData.currentOption = option;\n                reactData.currentValue = option[valueField];\n            }\n        };\n        var scrollToOption = function (option, isAlignBottom) {\n            return nextTick().then(function () {\n                if (option) {\n                    var optWrapperElem = refOptionWrapper.value;\n                    var panelElem = refOptionPanel.value;\n                    var optElem = panelElem.querySelector(\"[optid='\".concat(getOptid(option), \"']\"));\n                    if (optWrapperElem && optElem) {\n                        var wrapperHeight = optWrapperElem.offsetHeight;\n                        var offsetPadding = 5;\n                        if (isAlignBottom) {\n                            if (optElem.offsetTop + optElem.offsetHeight - optWrapperElem.scrollTop > wrapperHeight) {\n                                optWrapperElem.scrollTop = optElem.offsetTop + optElem.offsetHeight - wrapperHeight;\n                            }\n                        }\n                        else {\n                            if (optElem.offsetTop + offsetPadding < optWrapperElem.scrollTop || optElem.offsetTop + offsetPadding > optWrapperElem.scrollTop + optWrapperElem.clientHeight) {\n                                optWrapperElem.scrollTop = optElem.offsetTop - offsetPadding;\n                            }\n                        }\n                    }\n                }\n            });\n        };\n        var updateZindex = function () {\n            if (reactData.panelIndex < getLastZIndex()) {\n                reactData.panelIndex = nextZIndex();\n            }\n        };\n        var updatePlacement = function () {\n            return nextTick().then(function () {\n                var transfer = props.transfer, placement = props.placement;\n                var panelIndex = reactData.panelIndex;\n                var el = refElem.value;\n                var panelElem = refOptionPanel.value;\n                if (panelElem && el) {\n                    var targetHeight = el.offsetHeight;\n                    var targetWidth = el.offsetWidth;\n                    var panelHeight = panelElem.offsetHeight;\n                    var panelWidth = panelElem.offsetWidth;\n                    var marginSize = 5;\n                    var panelStyle = {\n                        zIndex: panelIndex\n                    };\n                    var _a = getAbsolutePos(el), boundingTop = _a.boundingTop, boundingLeft = _a.boundingLeft, visibleHeight = _a.visibleHeight, visibleWidth = _a.visibleWidth;\n                    var panelPlacement = 'bottom';\n                    if (transfer) {\n                        var left = boundingLeft;\n                        var top_1 = boundingTop + targetHeight;\n                        if (placement === 'top') {\n                            panelPlacement = 'top';\n                            top_1 = boundingTop - panelHeight;\n                        }\n                        else if (!placement) {\n                            // 如果下面不够放，则向上\n                            if (top_1 + panelHeight + marginSize > visibleHeight) {\n                                panelPlacement = 'top';\n                                top_1 = boundingTop - panelHeight;\n                            }\n                            // 如果上面不够放，则向下（优先）\n                            if (top_1 < marginSize) {\n                                panelPlacement = 'bottom';\n                                top_1 = boundingTop + targetHeight;\n                            }\n                        }\n                        // 如果溢出右边\n                        if (left + panelWidth + marginSize > visibleWidth) {\n                            left -= left + panelWidth + marginSize - visibleWidth;\n                        }\n                        // 如果溢出左边\n                        if (left < marginSize) {\n                            left = marginSize;\n                        }\n                        Object.assign(panelStyle, {\n                            left: \"\".concat(left, \"px\"),\n                            top: \"\".concat(top_1, \"px\"),\n                            minWidth: \"\".concat(targetWidth, \"px\")\n                        });\n                    }\n                    else {\n                        if (placement === 'top') {\n                            panelPlacement = 'top';\n                            panelStyle.bottom = \"\".concat(targetHeight, \"px\");\n                        }\n                        else if (!placement) {\n                            // 如果下面不够放，则向上\n                            if (boundingTop + targetHeight + panelHeight > visibleHeight) {\n                                // 如果上面不够放，则向下（优先）\n                                if (boundingTop - targetHeight - panelHeight > marginSize) {\n                                    panelPlacement = 'top';\n                                    panelStyle.bottom = \"\".concat(targetHeight, \"px\");\n                                }\n                            }\n                        }\n                    }\n                    reactData.panelStyle = panelStyle;\n                    reactData.panelPlacement = panelPlacement;\n                    return nextTick();\n                }\n            });\n        };\n        var hidePanelTimeout;\n        var showOptionPanel = function () {\n            var loading = props.loading, disabled = props.disabled, filterable = props.filterable;\n            if (!loading && !disabled) {\n                clearTimeout(hidePanelTimeout);\n                if (!reactData.inited) {\n                    reactData.inited = true;\n                }\n                reactData.isActivated = true;\n                reactData.animatVisible = true;\n                if (filterable) {\n                    refreshOption();\n                }\n                setTimeout(function () {\n                    var modelValue = props.modelValue, multiple = props.multiple;\n                    var currOption = findOption(multiple && modelValue ? modelValue[0] : modelValue);\n                    reactData.visiblePanel = true;\n                    if (currOption) {\n                        setCurrentOption(currOption);\n                        scrollToOption(currOption);\n                    }\n                    handleFocusSearch();\n                }, 10);\n                updateZindex();\n                updatePlacement();\n            }\n        };\n        var hideOptionPanel = function () {\n            reactData.searchValue = '';\n            reactData.searchLoading = false;\n            reactData.visiblePanel = false;\n            hidePanelTimeout = window.setTimeout(function () {\n                reactData.animatVisible = false;\n            }, 350);\n        };\n        var changeEvent = function (evnt, selectValue) {\n            if (selectValue !== props.modelValue) {\n                emit('update:modelValue', selectValue);\n                selectMethods.dispatchEvent('change', { value: selectValue }, evnt);\n                // 自动更新校验状态\n                if ($xeform && $xeformiteminfo) {\n                    $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, selectValue);\n                }\n            }\n        };\n        var clearValueEvent = function (evnt, selectValue) {\n            reactData.remoteValueList = [];\n            changeEvent(evnt, selectValue);\n            selectMethods.dispatchEvent('clear', { value: selectValue }, evnt);\n        };\n        var clearEvent = function (params, evnt) {\n            clearValueEvent(evnt, null);\n            hideOptionPanel();\n        };\n        var changeOptionEvent = function (evnt, selectValue, option) {\n            var modelValue = props.modelValue, multiple = props.multiple;\n            var remoteValueList = reactData.remoteValueList;\n            if (multiple) {\n                var multipleValue = void 0;\n                if (modelValue) {\n                    if (modelValue.indexOf(selectValue) === -1) {\n                        multipleValue = modelValue.concat([selectValue]);\n                    }\n                    else {\n                        multipleValue = modelValue.filter(function (val) { return val !== selectValue; });\n                    }\n                }\n                else {\n                    multipleValue = [selectValue];\n                }\n                var remoteItem = remoteValueList.find(function (item) { return item.key === selectValue; });\n                if (remoteItem) {\n                    remoteItem.result = option;\n                }\n                else {\n                    remoteValueList.push({ key: selectValue, result: option });\n                }\n                changeEvent(evnt, multipleValue);\n            }\n            else {\n                reactData.remoteValueList = [{ key: selectValue, result: option }];\n                changeEvent(evnt, selectValue);\n                hideOptionPanel();\n            }\n        };\n        var handleGlobalMousewheelEvent = function (evnt) {\n            var disabled = props.disabled;\n            var visiblePanel = reactData.visiblePanel;\n            if (!disabled) {\n                if (visiblePanel) {\n                    var panelElem = refOptionPanel.value;\n                    if (getEventTargetNode(evnt, panelElem).flag) {\n                        updatePlacement();\n                    }\n                    else {\n                        hideOptionPanel();\n                    }\n                }\n            }\n        };\n        var handleGlobalMousedownEvent = function (evnt) {\n            var disabled = props.disabled;\n            var visiblePanel = reactData.visiblePanel;\n            if (!disabled) {\n                var el = refElem.value;\n                var panelElem = refOptionPanel.value;\n                reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;\n                if (visiblePanel && !reactData.isActivated) {\n                    hideOptionPanel();\n                }\n            }\n        };\n        var findOffsetOption = function (optionValue, isUpArrow) {\n            var visibleOptionList = reactData.visibleOptionList, visibleGroupList = reactData.visibleGroupList;\n            var isGroup = computeIsGroup.value;\n            var valueField = computeValueField.value;\n            var groupOptionsField = computeGroupOptionsField.value;\n            var firstOption;\n            var prevOption;\n            var nextOption;\n            var currOption;\n            if (isGroup) {\n                for (var gIndex = 0; gIndex < visibleGroupList.length; gIndex++) {\n                    var group = visibleGroupList[gIndex];\n                    var groupOptionList = group[groupOptionsField];\n                    var isGroupDisabled = group.disabled;\n                    if (groupOptionList) {\n                        for (var index = 0; index < groupOptionList.length; index++) {\n                            var option = groupOptionList[index];\n                            var isVisible = isOptionVisible(option);\n                            var isDisabled = isGroupDisabled || option.disabled;\n                            if (!firstOption && !isDisabled) {\n                                firstOption = option;\n                            }\n                            if (currOption) {\n                                if (isVisible && !isDisabled) {\n                                    nextOption = option;\n                                    if (!isUpArrow) {\n                                        return { offsetOption: nextOption };\n                                    }\n                                }\n                            }\n                            if (optionValue === option[valueField]) {\n                                currOption = option;\n                                if (isUpArrow) {\n                                    return { offsetOption: prevOption };\n                                }\n                            }\n                            else {\n                                if (isVisible && !isDisabled) {\n                                    prevOption = option;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                for (var index = 0; index < visibleOptionList.length; index++) {\n                    var option = visibleOptionList[index];\n                    var isDisabled = option.disabled;\n                    if (!firstOption && !isDisabled) {\n                        firstOption = option;\n                    }\n                    if (currOption) {\n                        if (!isDisabled) {\n                            nextOption = option;\n                            if (!isUpArrow) {\n                                return { offsetOption: nextOption };\n                            }\n                        }\n                    }\n                    if (optionValue === option[valueField]) {\n                        currOption = option;\n                        if (isUpArrow) {\n                            return { offsetOption: prevOption };\n                        }\n                    }\n                    else {\n                        if (!isDisabled) {\n                            prevOption = option;\n                        }\n                    }\n                }\n            }\n            return { firstOption: firstOption };\n        };\n        var handleGlobalKeydownEvent = function (evnt) {\n            var clearable = props.clearable, disabled = props.disabled;\n            var visiblePanel = reactData.visiblePanel, currentValue = reactData.currentValue, currentOption = reactData.currentOption;\n            if (!disabled) {\n                var isTab = hasEventKey(evnt, EVENT_KEYS.TAB);\n                var isEnter = hasEventKey(evnt, EVENT_KEYS.ENTER);\n                var isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);\n                var isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);\n                var isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);\n                var isDel = hasEventKey(evnt, EVENT_KEYS.DELETE);\n                var isSpacebar = hasEventKey(evnt, EVENT_KEYS.SPACEBAR);\n                if (isTab) {\n                    reactData.isActivated = false;\n                }\n                if (visiblePanel) {\n                    if (isEsc || isTab) {\n                        hideOptionPanel();\n                    }\n                    else if (isEnter) {\n                        evnt.preventDefault();\n                        evnt.stopPropagation();\n                        changeOptionEvent(evnt, currentValue, currentOption);\n                    }\n                    else if (isUpArrow || isDwArrow) {\n                        evnt.preventDefault();\n                        var _a = findOffsetOption(currentValue, isUpArrow), firstOption = _a.firstOption, offsetOption = _a.offsetOption;\n                        if (!offsetOption && !findOption(currentValue)) {\n                            offsetOption = firstOption;\n                        }\n                        setCurrentOption(offsetOption);\n                        scrollToOption(offsetOption, isDwArrow);\n                    }\n                    else if (isSpacebar) {\n                        evnt.preventDefault();\n                    }\n                }\n                else if ((isUpArrow || isDwArrow || isEnter || isSpacebar) && reactData.isActivated) {\n                    evnt.preventDefault();\n                    showOptionPanel();\n                }\n                if (reactData.isActivated) {\n                    if (isDel && clearable) {\n                        clearValueEvent(evnt, null);\n                    }\n                }\n            }\n        };\n        var handleGlobalBlurEvent = function () {\n            hideOptionPanel();\n        };\n        var handleFocusSearch = function () {\n            if (props.filterable) {\n                nextTick(function () {\n                    var inpSearch = refInpSearch.value;\n                    if (inpSearch) {\n                        inpSearch.focus();\n                    }\n                });\n            }\n        };\n        var focusEvent = function (evnt) {\n            if (!props.disabled) {\n                reactData.isActivated = true;\n            }\n            selectMethods.dispatchEvent('focus', {}, evnt);\n        };\n        var blurEvent = function (evnt) {\n            reactData.isActivated = false;\n            selectMethods.dispatchEvent('blur', {}, evnt);\n        };\n        var modelSearchEvent = function (value) {\n            reactData.searchValue = value;\n        };\n        var focusSearchEvent = function () {\n            reactData.isActivated = true;\n        };\n        var keydownSearchEvent = function (params) {\n            var $event = params.$event;\n            var isEnter = hasEventKey($event, EVENT_KEYS.ENTER);\n            if (isEnter) {\n                $event.preventDefault();\n                $event.stopPropagation();\n            }\n        };\n        var triggerSearchEvent = XEUtils.debounce(function () {\n            var remote = props.remote, remoteMethod = props.remoteMethod;\n            var searchValue = reactData.searchValue;\n            if (remote && remoteMethod) {\n                reactData.searchLoading = true;\n                Promise.resolve(remoteMethod({ searchValue: searchValue })).then(function () { return nextTick(); }).catch(function () { return nextTick(); }).finally(function () {\n                    reactData.searchLoading = false;\n                    refreshOption();\n                });\n            }\n            else {\n                refreshOption();\n            }\n        }, 350, { trailing: true });\n        var togglePanelEvent = function (params) {\n            var $event = params.$event;\n            $event.preventDefault();\n            if (reactData.visiblePanel) {\n                hideOptionPanel();\n            }\n            else {\n                showOptionPanel();\n            }\n        };\n        var checkOptionDisabled = function (isSelected, option, group) {\n            if (option.disabled) {\n                return true;\n            }\n            if (group && group.disabled) {\n                return true;\n            }\n            var isMaximize = computeIsMaximize.value;\n            if (isMaximize && !isSelected) {\n                return true;\n            }\n            return false;\n        };\n        var renderOption = function (list, group) {\n            var optionKey = props.optionKey, modelValue = props.modelValue, multiple = props.multiple;\n            var currentValue = reactData.currentValue;\n            var optionOpts = computeOptionOpts.value;\n            var labelField = computeLabelField.value;\n            var valueField = computeValueField.value;\n            var isGroup = computeIsGroup.value;\n            var useKey = optionOpts.useKey;\n            var optionSlot = slots.option;\n            return list.map(function (option, cIndex) {\n                var slots = option.slots, className = option.className;\n                var optionValue = option[valueField];\n                var isSelected = multiple ? (modelValue && modelValue.indexOf(optionValue) > -1) : modelValue === optionValue;\n                var isVisible = !isGroup || isOptionVisible(option);\n                var isDisabled = checkOptionDisabled(isSelected, option, group);\n                var optid = getOptid(option);\n                var defaultSlot = slots ? slots.default : null;\n                var optParams = { option: option, group: null, $select: $xeselect };\n                return isVisible ? h('div', {\n                    key: useKey || optionKey ? optid : cIndex,\n                    class: ['vxe-select-option', className ? (XEUtils.isFunction(className) ? className(optParams) : className) : '', {\n                            'is--disabled': isDisabled,\n                            'is--selected': isSelected,\n                            'is--hover': currentValue === optionValue\n                        }],\n                    // attrs\n                    optid: optid,\n                    // event\n                    onMousedown: function (evnt) {\n                        var isLeftBtn = evnt.button === 0;\n                        if (isLeftBtn) {\n                            evnt.stopPropagation();\n                        }\n                    },\n                    onClick: function (evnt) {\n                        if (!isDisabled) {\n                            changeOptionEvent(evnt, optionValue, option);\n                        }\n                    },\n                    onMouseenter: function () {\n                        if (!isDisabled) {\n                            setCurrentOption(option);\n                        }\n                    }\n                }, optionSlot ? callSlot(optionSlot, optParams) : (defaultSlot ? callSlot(defaultSlot, optParams) : formatText(getFuncText(option[labelField])))) : null;\n            });\n        };\n        var renderOptgroup = function () {\n            var optionKey = props.optionKey;\n            var visibleGroupList = reactData.visibleGroupList;\n            var optionOpts = computeOptionOpts.value;\n            var groupLabelField = computeGroupLabelField.value;\n            var groupOptionsField = computeGroupOptionsField.value;\n            var useKey = optionOpts.useKey;\n            var optionSlot = slots.option;\n            return visibleGroupList.map(function (group, gIndex) {\n                var slots = group.slots, className = group.className;\n                var optid = getOptid(group);\n                var isGroupDisabled = group.disabled;\n                var defaultSlot = slots ? slots.default : null;\n                var optParams = { option: group, group: group, $select: $xeselect };\n                return h('div', {\n                    key: useKey || optionKey ? optid : gIndex,\n                    class: ['vxe-optgroup', className ? (XEUtils.isFunction(className) ? className(optParams) : className) : '', {\n                            'is--disabled': isGroupDisabled\n                        }],\n                    // attrs\n                    optid: optid\n                }, [\n                    h('div', {\n                        class: 'vxe-optgroup--title'\n                    }, optionSlot ? callSlot(optionSlot, optParams) : (defaultSlot ? callSlot(defaultSlot, optParams) : getFuncText(group[groupLabelField]))),\n                    h('div', {\n                        class: 'vxe-optgroup--wrapper'\n                    }, renderOption(group[groupOptionsField] || [], group))\n                ]);\n            });\n        };\n        var renderOpts = function () {\n            var visibleGroupList = reactData.visibleGroupList, visibleOptionList = reactData.visibleOptionList, searchLoading = reactData.searchLoading;\n            var isGroup = computeIsGroup.value;\n            if (searchLoading) {\n                return [\n                    h('div', {\n                        class: 'vxe-select--search-loading'\n                    }, [\n                        h('i', {\n                            class: ['vxe-select--search-icon', GlobalConfig.icon.SELECT_LOADED]\n                        }),\n                        h('span', {\n                            class: 'vxe-select--search-text'\n                        }, GlobalConfig.i18n('vxe.select.loadingText'))\n                    ])\n                ];\n            }\n            if (isGroup) {\n                if (visibleGroupList.length) {\n                    return renderOptgroup();\n                }\n            }\n            else {\n                if (visibleOptionList.length) {\n                    return renderOption(visibleOptionList);\n                }\n            }\n            return [\n                h('div', {\n                    class: 'vxe-select--empty-placeholder'\n                }, props.emptyText || GlobalConfig.i18n('vxe.select.emptyText'))\n            ];\n        };\n        selectMethods = {\n            dispatchEvent: function (type, params, evnt) {\n                emit(type, Object.assign({ $select: $xeselect, $event: evnt }, params));\n            },\n            isPanelVisible: function () {\n                return reactData.visiblePanel;\n            },\n            togglePanel: function () {\n                if (reactData.visiblePanel) {\n                    hideOptionPanel();\n                }\n                else {\n                    showOptionPanel();\n                }\n                return nextTick();\n            },\n            hidePanel: function () {\n                if (reactData.visiblePanel) {\n                    hideOptionPanel();\n                }\n                return nextTick();\n            },\n            showPanel: function () {\n                if (!reactData.visiblePanel) {\n                    showOptionPanel();\n                }\n                return nextTick();\n            },\n            refreshOption: refreshOption,\n            focus: function () {\n                var $input = refInput.value;\n                reactData.isActivated = true;\n                $input.blur();\n                return nextTick();\n            },\n            blur: function () {\n                var $input = refInput.value;\n                $input.blur();\n                reactData.isActivated = false;\n                return nextTick();\n            }\n        };\n        Object.assign($xeselect, selectMethods);\n        watch(function () { return reactData.staticOptions; }, function (value) {\n            if (value.some(function (item) { return item.options && item.options.length; })) {\n                reactData.fullOptionList = [];\n                reactData.fullGroupList = value;\n            }\n            else {\n                reactData.fullGroupList = [];\n                reactData.fullOptionList = value || [];\n            }\n            cacheItemMap();\n        });\n        watch(function () { return props.options; }, function (value) {\n            reactData.fullGroupList = [];\n            reactData.fullOptionList = value || [];\n            cacheItemMap();\n        });\n        watch(function () { return props.optionGroups; }, function (value) {\n            reactData.fullOptionList = [];\n            reactData.fullGroupList = value || [];\n            cacheItemMap();\n        });\n        onMounted(function () {\n            nextTick(function () {\n                var options = props.options, optionGroups = props.optionGroups;\n                if (optionGroups) {\n                    reactData.fullGroupList = optionGroups;\n                }\n                else if (options) {\n                    reactData.fullOptionList = options;\n                }\n                cacheItemMap();\n            });\n            GlobalEvent.on($xeselect, 'mousewheel', handleGlobalMousewheelEvent);\n            GlobalEvent.on($xeselect, 'mousedown', handleGlobalMousedownEvent);\n            GlobalEvent.on($xeselect, 'keydown', handleGlobalKeydownEvent);\n            GlobalEvent.on($xeselect, 'blur', handleGlobalBlurEvent);\n        });\n        onUnmounted(function () {\n            GlobalEvent.off($xeselect, 'mousewheel');\n            GlobalEvent.off($xeselect, 'mousedown');\n            GlobalEvent.off($xeselect, 'keydown');\n            GlobalEvent.off($xeselect, 'blur');\n        });\n        var renderVN = function () {\n            var _a, _b;\n            var className = props.className, popupClassName = props.popupClassName, transfer = props.transfer, disabled = props.disabled, loading = props.loading, filterable = props.filterable;\n            var inited = reactData.inited, isActivated = reactData.isActivated, visiblePanel = reactData.visiblePanel;\n            var vSize = computeSize.value;\n            var selectLabel = computeSelectLabel.value;\n            var defaultSlot = slots.default;\n            var headerSlot = slots.header;\n            var footerSlot = slots.footer;\n            var prefixSlot = slots.prefix;\n            return h('div', {\n                ref: refElem,\n                class: ['vxe-select', className ? (XEUtils.isFunction(className) ? className({ $select: $xeselect }) : className) : '', (_a = {},\n                        _a[\"size--\".concat(vSize)] = vSize,\n                        _a['is--visivle'] = visiblePanel,\n                        _a['is--disabled'] = disabled,\n                        _a['is--filter'] = filterable,\n                        _a['is--loading'] = loading,\n                        _a['is--active'] = isActivated,\n                        _a)]\n            }, [\n                h('div', {\n                    class: 'vxe-select-slots',\n                    ref: 'hideOption'\n                }, defaultSlot ? defaultSlot({}) : []),\n                h(VxeInputComponent, {\n                    ref: refInput,\n                    clearable: props.clearable,\n                    placeholder: props.placeholder,\n                    readonly: true,\n                    disabled: disabled,\n                    type: 'text',\n                    prefixIcon: props.prefixIcon,\n                    suffixIcon: loading ? GlobalConfig.icon.SELECT_LOADED : (visiblePanel ? GlobalConfig.icon.SELECT_OPEN : GlobalConfig.icon.SELECT_CLOSE),\n                    modelValue: selectLabel,\n                    onClear: clearEvent,\n                    onClick: togglePanelEvent,\n                    onFocus: focusEvent,\n                    onBlur: blurEvent,\n                    onSuffixClick: togglePanelEvent\n                }, prefixSlot ? {\n                    prefix: function () { return prefixSlot({}); }\n                } : {}),\n                h(Teleport, {\n                    to: 'body',\n                    disabled: transfer ? !inited : true\n                }, [\n                    h('div', {\n                        ref: refOptionPanel,\n                        class: ['vxe-table--ignore-clear vxe-select--panel', popupClassName ? (XEUtils.isFunction(popupClassName) ? popupClassName({ $select: $xeselect }) : popupClassName) : '', (_b = {},\n                                _b[\"size--\".concat(vSize)] = vSize,\n                                _b['is--transfer'] = transfer,\n                                _b['animat--leave'] = !loading && reactData.animatVisible,\n                                _b['animat--enter'] = !loading && visiblePanel,\n                                _b)],\n                        placement: reactData.panelPlacement,\n                        style: reactData.panelStyle\n                    }, inited ? [\n                        filterable ? h('div', {\n                            class: 'vxe-select--panel-search'\n                        }, [\n                            h(VxeInputComponent, {\n                                ref: refInpSearch,\n                                class: 'vxe-select-search--input',\n                                modelValue: reactData.searchValue,\n                                clearable: true,\n                                placeholder: GlobalConfig.i18n('vxe.select.search'),\n                                prefixIcon: GlobalConfig.icon.INPUT_SEARCH,\n                                'onUpdate:modelValue': modelSearchEvent,\n                                onFocus: focusSearchEvent,\n                                onKeydown: keydownSearchEvent,\n                                onChange: triggerSearchEvent,\n                                onSearch: triggerSearchEvent\n                            })\n                        ]) : createCommentVNode(),\n                        h('div', {\n                            class: 'vxe-select--panel-wrapper'\n                        }, [\n                            headerSlot ? h('div', {\n                                class: 'vxe-select--panel-header'\n                            }, headerSlot({})) : createCommentVNode(),\n                            h('div', {\n                                class: 'vxe-select--panel-body'\n                            }, [\n                                h('div', {\n                                    ref: refOptionWrapper,\n                                    class: 'vxe-select-option--wrapper'\n                                }, renderOpts())\n                            ]),\n                            footerSlot ? h('div', {\n                                class: 'vxe-select--panel-footer'\n                            }, footerSlot({})) : createCommentVNode()\n                        ])\n                    ] : [])\n                ])\n            ]);\n        };\n        $xeselect.renderVN = renderVN;\n        provide('$xeselect', $xeselect);\n        return $xeselect;\n    },\n    render: function () {\n        return this.renderVN();\n    }\n});\n",
      "start": 1714699767773,
      "end": 1714699767841,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1714699767841,
      "end": 1714699767841,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1714699767841,
      "end": 1714699767841,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1714699767841,
      "end": 1714699767841,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1714699767841,
      "end": 1714699767841,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1714699767841,
      "end": 1714699767841,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1714699767841,
      "end": 1714699767841,
      "order": "normal"
    },
    {
      "name": "vite-plugin-vconsole",
      "result": "import { defineComponent, h, Teleport, ref, inject, computed, provide, onUnmounted, reactive, nextTick, watch, onMounted, createCommentVNode } from 'vue';\nimport XEUtils from 'xe-utils';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport { useSize } from '../../hooks/size';\nimport { getEventTargetNode, getAbsolutePos } from '../../tools/dom';\nimport { getLastZIndex, nextZIndex, getFuncText, formatText } from '../../tools/utils';\nimport { GlobalEvent, hasEventKey, EVENT_KEYS } from '../../tools/event';\nimport VxeInputComponent from '../../input/src/input';\nimport { getSlotVNs } from '../../tools/vn';\nfunction isOptionVisible(option) {\n    return option.visible !== false;\n}\nfunction getOptUniqueId() {\n    return XEUtils.uniqueId('opt_');\n}\nexport default defineComponent({\n    name: 'VxeSelect',\n    props: {\n        modelValue: null,\n        clearable: Boolean,\n        placeholder: {\n            type: String,\n            default: function () { return XEUtils.eqNull(GlobalConfig.select.placeholder) ? GlobalConfig.i18n('vxe.base.pleaseSelect') : GlobalConfig.select.placeholder; }\n        },\n        loading: Boolean,\n        disabled: Boolean,\n        multiple: Boolean,\n        multiCharOverflow: { type: [Number, String], default: function () { return GlobalConfig.select.multiCharOverflow; } },\n        prefixIcon: String,\n        placement: String,\n        options: Array,\n        optionProps: Object,\n        optionGroups: Array,\n        optionGroupProps: Object,\n        optionConfig: Object,\n        className: [String, Function],\n        popupClassName: [String, Function],\n        max: { type: [String, Number], default: null },\n        size: { type: String, default: function () { return GlobalConfig.select.size || GlobalConfig.size; } },\n        filterable: Boolean,\n        filterMethod: Function,\n        remote: Boolean,\n        remoteMethod: Function,\n        emptyText: String,\n        // 已废弃，被 option-config.keyField 替换\n        optionId: { type: String, default: function () { return GlobalConfig.select.optionId; } },\n        // 已废弃，被 option-config.useKey 替换\n        optionKey: Boolean,\n        transfer: { type: Boolean, default: function () { return GlobalConfig.select.transfer; } }\n    },\n    emits: [\n        'update:modelValue',\n        'change',\n        'clear',\n        'blur',\n        'focus'\n    ],\n    setup: function (props, context) {\n        var slots = context.slots, emit = context.emit;\n        var $xeform = inject('$xeform', null);\n        var $xeformiteminfo = inject('$xeformiteminfo', null);\n        var xID = XEUtils.uniqueId();\n        var computeSize = useSize(props);\n        var reactData = reactive({\n            inited: false,\n            staticOptions: [],\n            fullGroupList: [],\n            fullOptionList: [],\n            visibleGroupList: [],\n            visibleOptionList: [],\n            remoteValueList: [],\n            panelIndex: 0,\n            panelStyle: {},\n            panelPlacement: null,\n            currentOption: null,\n            currentValue: null,\n            visiblePanel: false,\n            animatVisible: false,\n            isActivated: false,\n            searchValue: '',\n            searchLoading: false\n        });\n        var refElem = ref();\n        var refInput = ref();\n        var refInpSearch = ref();\n        var refOptionWrapper = ref();\n        var refOptionPanel = ref();\n        var refMaps = {\n            refElem: refElem\n        };\n        var $xeselect = {\n            xID: xID,\n            props: props,\n            context: context,\n            reactData: reactData,\n            getRefMaps: function () { return refMaps; }\n        };\n        var selectMethods = {};\n        var computePropsOpts = computed(function () {\n            return props.optionProps || {};\n        });\n        var computeGroupPropsOpts = computed(function () {\n            return props.optionGroupProps || {};\n        });\n        var computeLabelField = computed(function () {\n            var propsOpts = computePropsOpts.value;\n            return propsOpts.label || 'label';\n        });\n        var computeValueField = computed(function () {\n            var propsOpts = computePropsOpts.value;\n            return propsOpts.value || 'value';\n        });\n        var computeGroupLabelField = computed(function () {\n            var groupPropsOpts = computeGroupPropsOpts.value;\n            return groupPropsOpts.label || 'label';\n        });\n        var computeGroupOptionsField = computed(function () {\n            var groupPropsOpts = computeGroupPropsOpts.value;\n            return groupPropsOpts.options || 'options';\n        });\n        var computeIsMaximize = computed(function () {\n            var modelValue = props.modelValue, multiple = props.multiple, max = props.max;\n            if (multiple && max) {\n                return (modelValue ? modelValue.length : 0) >= XEUtils.toNumber(max);\n            }\n            return false;\n        });\n        var computeOptionOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.select.optionConfig, props.optionConfig);\n        });\n        var computeIsGroup = computed(function () {\n            return reactData.fullGroupList.some(function (item) { return item.options && item.options.length; });\n        });\n        var computeMultiMaxCharNum = computed(function () {\n            return XEUtils.toNumber(props.multiCharOverflow);\n        });\n        var callSlot = function (slotFunc, params) {\n            if (slotFunc) {\n                if (XEUtils.isString(slotFunc)) {\n                    slotFunc = slots[slotFunc] || null;\n                }\n                if (XEUtils.isFunction(slotFunc)) {\n                    return getSlotVNs(slotFunc(params));\n                }\n            }\n            return [];\n        };\n        var findOption = function (optionValue) {\n            var fullOptionList = reactData.fullOptionList, fullGroupList = reactData.fullGroupList;\n            var isGroup = computeIsGroup.value;\n            var valueField = computeValueField.value;\n            if (isGroup) {\n                for (var gIndex = 0; gIndex < fullGroupList.length; gIndex++) {\n                    var group = fullGroupList[gIndex];\n                    if (group.options) {\n                        for (var index = 0; index < group.options.length; index++) {\n                            var option = group.options[index];\n                            if (optionValue === option[valueField]) {\n                                return option;\n                            }\n                        }\n                    }\n                }\n            }\n            return fullOptionList.find(function (item) { return optionValue === item[valueField]; });\n        };\n        var getRemoteSelectLabel = function (value) {\n            var remoteValueList = reactData.remoteValueList;\n            var labelField = computeLabelField.value;\n            var remoteItem = remoteValueList.find(function (item) { return value === item.key; });\n            var item = remoteItem ? remoteItem.result : null;\n            return XEUtils.toValueString(item ? item[labelField] : value);\n        };\n        var getSelectLabel = function (value) {\n            var labelField = computeLabelField.value;\n            var item = findOption(value);\n            return XEUtils.toValueString(item ? item[labelField] : value);\n        };\n        var computeSelectLabel = computed(function () {\n            var modelValue = props.modelValue, multiple = props.multiple, remote = props.remote;\n            var multiMaxCharNum = computeMultiMaxCharNum.value;\n            if (modelValue && multiple) {\n                var vals = XEUtils.isArray(modelValue) ? modelValue : [modelValue];\n                if (remote) {\n                    return vals.map(function (val) { return getRemoteSelectLabel(val); }).join(', ');\n                }\n                return vals.map(function (val) {\n                    var label = getSelectLabel(val);\n                    if (multiMaxCharNum > 0 && label.length > multiMaxCharNum) {\n                        return \"\".concat(label.substring(0, multiMaxCharNum), \"...\");\n                    }\n                    return label;\n                }).join(', ');\n            }\n            if (remote) {\n                return getRemoteSelectLabel(modelValue);\n            }\n            return getSelectLabel(modelValue);\n        });\n        var getOptkey = function () {\n            var optionOpts = computeOptionOpts.value;\n            return optionOpts.keyField || props.optionId || '_X_OPTION_KEY';\n        };\n        var getOptid = function (option) {\n            var optid = option[getOptkey()];\n            return optid ? encodeURIComponent(optid) : '';\n        };\n        /**\n         * 刷新选项，当选项被动态显示/隐藏时可能会用到\n         */\n        var refreshOption = function () {\n            var filterable = props.filterable, filterMethod = props.filterMethod;\n            var fullOptionList = reactData.fullOptionList, fullGroupList = reactData.fullGroupList, searchValue = reactData.searchValue;\n            var isGroup = computeIsGroup.value;\n            var groupLabelField = computeGroupLabelField.value;\n            var labelField = computeLabelField.value;\n            if (isGroup) {\n                if (filterable && filterMethod) {\n                    reactData.visibleGroupList = fullGroupList.filter(function (group) { return isOptionVisible(group) && filterMethod({ group: group, option: null, searchValue: searchValue }); });\n                }\n                else if (filterable) {\n                    reactData.visibleGroupList = fullGroupList.filter(function (group) { return isOptionVisible(group) && (!searchValue || \"\".concat(group[groupLabelField]).indexOf(searchValue) > -1); });\n                }\n                else {\n                    reactData.visibleGroupList = fullGroupList.filter(isOptionVisible);\n                }\n            }\n            else {\n                if (filterable && filterMethod) {\n                    reactData.visibleOptionList = fullOptionList.filter(function (option) { return isOptionVisible(option) && filterMethod({ group: null, option: option, searchValue: searchValue }); });\n                }\n                else if (filterable) {\n                    reactData.visibleOptionList = fullOptionList.filter(function (option) { return isOptionVisible(option) && (!searchValue || \"\".concat(option[labelField]).indexOf(searchValue) > -1); });\n                }\n                else {\n                    reactData.visibleOptionList = fullOptionList.filter(isOptionVisible);\n                }\n            }\n            return nextTick();\n        };\n        var cacheItemMap = function () {\n            var fullOptionList = reactData.fullOptionList, fullGroupList = reactData.fullGroupList;\n            var groupOptionsField = computeGroupOptionsField.value;\n            var key = getOptkey();\n            var handleOptis = function (item) {\n                if (!getOptid(item)) {\n                    item[key] = getOptUniqueId();\n                }\n            };\n            if (fullGroupList.length) {\n                fullGroupList.forEach(function (group) {\n                    handleOptis(group);\n                    if (group[groupOptionsField]) {\n                        group[groupOptionsField].forEach(handleOptis);\n                    }\n                });\n            }\n            else if (fullOptionList.length) {\n                fullOptionList.forEach(handleOptis);\n            }\n            refreshOption();\n        };\n        var setCurrentOption = function (option) {\n            var valueField = computeValueField.value;\n            if (option) {\n                reactData.currentOption = option;\n                reactData.currentValue = option[valueField];\n            }\n        };\n        var scrollToOption = function (option, isAlignBottom) {\n            return nextTick().then(function () {\n                if (option) {\n                    var optWrapperElem = refOptionWrapper.value;\n                    var panelElem = refOptionPanel.value;\n                    var optElem = panelElem.querySelector(\"[optid='\".concat(getOptid(option), \"']\"));\n                    if (optWrapperElem && optElem) {\n                        var wrapperHeight = optWrapperElem.offsetHeight;\n                        var offsetPadding = 5;\n                        if (isAlignBottom) {\n                            if (optElem.offsetTop + optElem.offsetHeight - optWrapperElem.scrollTop > wrapperHeight) {\n                                optWrapperElem.scrollTop = optElem.offsetTop + optElem.offsetHeight - wrapperHeight;\n                            }\n                        }\n                        else {\n                            if (optElem.offsetTop + offsetPadding < optWrapperElem.scrollTop || optElem.offsetTop + offsetPadding > optWrapperElem.scrollTop + optWrapperElem.clientHeight) {\n                                optWrapperElem.scrollTop = optElem.offsetTop - offsetPadding;\n                            }\n                        }\n                    }\n                }\n            });\n        };\n        var updateZindex = function () {\n            if (reactData.panelIndex < getLastZIndex()) {\n                reactData.panelIndex = nextZIndex();\n            }\n        };\n        var updatePlacement = function () {\n            return nextTick().then(function () {\n                var transfer = props.transfer, placement = props.placement;\n                var panelIndex = reactData.panelIndex;\n                var el = refElem.value;\n                var panelElem = refOptionPanel.value;\n                if (panelElem && el) {\n                    var targetHeight = el.offsetHeight;\n                    var targetWidth = el.offsetWidth;\n                    var panelHeight = panelElem.offsetHeight;\n                    var panelWidth = panelElem.offsetWidth;\n                    var marginSize = 5;\n                    var panelStyle = {\n                        zIndex: panelIndex\n                    };\n                    var _a = getAbsolutePos(el), boundingTop = _a.boundingTop, boundingLeft = _a.boundingLeft, visibleHeight = _a.visibleHeight, visibleWidth = _a.visibleWidth;\n                    var panelPlacement = 'bottom';\n                    if (transfer) {\n                        var left = boundingLeft;\n                        var top_1 = boundingTop + targetHeight;\n                        if (placement === 'top') {\n                            panelPlacement = 'top';\n                            top_1 = boundingTop - panelHeight;\n                        }\n                        else if (!placement) {\n                            // 如果下面不够放，则向上\n                            if (top_1 + panelHeight + marginSize > visibleHeight) {\n                                panelPlacement = 'top';\n                                top_1 = boundingTop - panelHeight;\n                            }\n                            // 如果上面不够放，则向下（优先）\n                            if (top_1 < marginSize) {\n                                panelPlacement = 'bottom';\n                                top_1 = boundingTop + targetHeight;\n                            }\n                        }\n                        // 如果溢出右边\n                        if (left + panelWidth + marginSize > visibleWidth) {\n                            left -= left + panelWidth + marginSize - visibleWidth;\n                        }\n                        // 如果溢出左边\n                        if (left < marginSize) {\n                            left = marginSize;\n                        }\n                        Object.assign(panelStyle, {\n                            left: \"\".concat(left, \"px\"),\n                            top: \"\".concat(top_1, \"px\"),\n                            minWidth: \"\".concat(targetWidth, \"px\")\n                        });\n                    }\n                    else {\n                        if (placement === 'top') {\n                            panelPlacement = 'top';\n                            panelStyle.bottom = \"\".concat(targetHeight, \"px\");\n                        }\n                        else if (!placement) {\n                            // 如果下面不够放，则向上\n                            if (boundingTop + targetHeight + panelHeight > visibleHeight) {\n                                // 如果上面不够放，则向下（优先）\n                                if (boundingTop - targetHeight - panelHeight > marginSize) {\n                                    panelPlacement = 'top';\n                                    panelStyle.bottom = \"\".concat(targetHeight, \"px\");\n                                }\n                            }\n                        }\n                    }\n                    reactData.panelStyle = panelStyle;\n                    reactData.panelPlacement = panelPlacement;\n                    return nextTick();\n                }\n            });\n        };\n        var hidePanelTimeout;\n        var showOptionPanel = function () {\n            var loading = props.loading, disabled = props.disabled, filterable = props.filterable;\n            if (!loading && !disabled) {\n                clearTimeout(hidePanelTimeout);\n                if (!reactData.inited) {\n                    reactData.inited = true;\n                }\n                reactData.isActivated = true;\n                reactData.animatVisible = true;\n                if (filterable) {\n                    refreshOption();\n                }\n                setTimeout(function () {\n                    var modelValue = props.modelValue, multiple = props.multiple;\n                    var currOption = findOption(multiple && modelValue ? modelValue[0] : modelValue);\n                    reactData.visiblePanel = true;\n                    if (currOption) {\n                        setCurrentOption(currOption);\n                        scrollToOption(currOption);\n                    }\n                    handleFocusSearch();\n                }, 10);\n                updateZindex();\n                updatePlacement();\n            }\n        };\n        var hideOptionPanel = function () {\n            reactData.searchValue = '';\n            reactData.searchLoading = false;\n            reactData.visiblePanel = false;\n            hidePanelTimeout = window.setTimeout(function () {\n                reactData.animatVisible = false;\n            }, 350);\n        };\n        var changeEvent = function (evnt, selectValue) {\n            if (selectValue !== props.modelValue) {\n                emit('update:modelValue', selectValue);\n                selectMethods.dispatchEvent('change', { value: selectValue }, evnt);\n                // 自动更新校验状态\n                if ($xeform && $xeformiteminfo) {\n                    $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, selectValue);\n                }\n            }\n        };\n        var clearValueEvent = function (evnt, selectValue) {\n            reactData.remoteValueList = [];\n            changeEvent(evnt, selectValue);\n            selectMethods.dispatchEvent('clear', { value: selectValue }, evnt);\n        };\n        var clearEvent = function (params, evnt) {\n            clearValueEvent(evnt, null);\n            hideOptionPanel();\n        };\n        var changeOptionEvent = function (evnt, selectValue, option) {\n            var modelValue = props.modelValue, multiple = props.multiple;\n            var remoteValueList = reactData.remoteValueList;\n            if (multiple) {\n                var multipleValue = void 0;\n                if (modelValue) {\n                    if (modelValue.indexOf(selectValue) === -1) {\n                        multipleValue = modelValue.concat([selectValue]);\n                    }\n                    else {\n                        multipleValue = modelValue.filter(function (val) { return val !== selectValue; });\n                    }\n                }\n                else {\n                    multipleValue = [selectValue];\n                }\n                var remoteItem = remoteValueList.find(function (item) { return item.key === selectValue; });\n                if (remoteItem) {\n                    remoteItem.result = option;\n                }\n                else {\n                    remoteValueList.push({ key: selectValue, result: option });\n                }\n                changeEvent(evnt, multipleValue);\n            }\n            else {\n                reactData.remoteValueList = [{ key: selectValue, result: option }];\n                changeEvent(evnt, selectValue);\n                hideOptionPanel();\n            }\n        };\n        var handleGlobalMousewheelEvent = function (evnt) {\n            var disabled = props.disabled;\n            var visiblePanel = reactData.visiblePanel;\n            if (!disabled) {\n                if (visiblePanel) {\n                    var panelElem = refOptionPanel.value;\n                    if (getEventTargetNode(evnt, panelElem).flag) {\n                        updatePlacement();\n                    }\n                    else {\n                        hideOptionPanel();\n                    }\n                }\n            }\n        };\n        var handleGlobalMousedownEvent = function (evnt) {\n            var disabled = props.disabled;\n            var visiblePanel = reactData.visiblePanel;\n            if (!disabled) {\n                var el = refElem.value;\n                var panelElem = refOptionPanel.value;\n                reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;\n                if (visiblePanel && !reactData.isActivated) {\n                    hideOptionPanel();\n                }\n            }\n        };\n        var findOffsetOption = function (optionValue, isUpArrow) {\n            var visibleOptionList = reactData.visibleOptionList, visibleGroupList = reactData.visibleGroupList;\n            var isGroup = computeIsGroup.value;\n            var valueField = computeValueField.value;\n            var groupOptionsField = computeGroupOptionsField.value;\n            var firstOption;\n            var prevOption;\n            var nextOption;\n            var currOption;\n            if (isGroup) {\n                for (var gIndex = 0; gIndex < visibleGroupList.length; gIndex++) {\n                    var group = visibleGroupList[gIndex];\n                    var groupOptionList = group[groupOptionsField];\n                    var isGroupDisabled = group.disabled;\n                    if (groupOptionList) {\n                        for (var index = 0; index < groupOptionList.length; index++) {\n                            var option = groupOptionList[index];\n                            var isVisible = isOptionVisible(option);\n                            var isDisabled = isGroupDisabled || option.disabled;\n                            if (!firstOption && !isDisabled) {\n                                firstOption = option;\n                            }\n                            if (currOption) {\n                                if (isVisible && !isDisabled) {\n                                    nextOption = option;\n                                    if (!isUpArrow) {\n                                        return { offsetOption: nextOption };\n                                    }\n                                }\n                            }\n                            if (optionValue === option[valueField]) {\n                                currOption = option;\n                                if (isUpArrow) {\n                                    return { offsetOption: prevOption };\n                                }\n                            }\n                            else {\n                                if (isVisible && !isDisabled) {\n                                    prevOption = option;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                for (var index = 0; index < visibleOptionList.length; index++) {\n                    var option = visibleOptionList[index];\n                    var isDisabled = option.disabled;\n                    if (!firstOption && !isDisabled) {\n                        firstOption = option;\n                    }\n                    if (currOption) {\n                        if (!isDisabled) {\n                            nextOption = option;\n                            if (!isUpArrow) {\n                                return { offsetOption: nextOption };\n                            }\n                        }\n                    }\n                    if (optionValue === option[valueField]) {\n                        currOption = option;\n                        if (isUpArrow) {\n                            return { offsetOption: prevOption };\n                        }\n                    }\n                    else {\n                        if (!isDisabled) {\n                            prevOption = option;\n                        }\n                    }\n                }\n            }\n            return { firstOption: firstOption };\n        };\n        var handleGlobalKeydownEvent = function (evnt) {\n            var clearable = props.clearable, disabled = props.disabled;\n            var visiblePanel = reactData.visiblePanel, currentValue = reactData.currentValue, currentOption = reactData.currentOption;\n            if (!disabled) {\n                var isTab = hasEventKey(evnt, EVENT_KEYS.TAB);\n                var isEnter = hasEventKey(evnt, EVENT_KEYS.ENTER);\n                var isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);\n                var isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);\n                var isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);\n                var isDel = hasEventKey(evnt, EVENT_KEYS.DELETE);\n                var isSpacebar = hasEventKey(evnt, EVENT_KEYS.SPACEBAR);\n                if (isTab) {\n                    reactData.isActivated = false;\n                }\n                if (visiblePanel) {\n                    if (isEsc || isTab) {\n                        hideOptionPanel();\n                    }\n                    else if (isEnter) {\n                        evnt.preventDefault();\n                        evnt.stopPropagation();\n                        changeOptionEvent(evnt, currentValue, currentOption);\n                    }\n                    else if (isUpArrow || isDwArrow) {\n                        evnt.preventDefault();\n                        var _a = findOffsetOption(currentValue, isUpArrow), firstOption = _a.firstOption, offsetOption = _a.offsetOption;\n                        if (!offsetOption && !findOption(currentValue)) {\n                            offsetOption = firstOption;\n                        }\n                        setCurrentOption(offsetOption);\n                        scrollToOption(offsetOption, isDwArrow);\n                    }\n                    else if (isSpacebar) {\n                        evnt.preventDefault();\n                    }\n                }\n                else if ((isUpArrow || isDwArrow || isEnter || isSpacebar) && reactData.isActivated) {\n                    evnt.preventDefault();\n                    showOptionPanel();\n                }\n                if (reactData.isActivated) {\n                    if (isDel && clearable) {\n                        clearValueEvent(evnt, null);\n                    }\n                }\n            }\n        };\n        var handleGlobalBlurEvent = function () {\n            hideOptionPanel();\n        };\n        var handleFocusSearch = function () {\n            if (props.filterable) {\n                nextTick(function () {\n                    var inpSearch = refInpSearch.value;\n                    if (inpSearch) {\n                        inpSearch.focus();\n                    }\n                });\n            }\n        };\n        var focusEvent = function (evnt) {\n            if (!props.disabled) {\n                reactData.isActivated = true;\n            }\n            selectMethods.dispatchEvent('focus', {}, evnt);\n        };\n        var blurEvent = function (evnt) {\n            reactData.isActivated = false;\n            selectMethods.dispatchEvent('blur', {}, evnt);\n        };\n        var modelSearchEvent = function (value) {\n            reactData.searchValue = value;\n        };\n        var focusSearchEvent = function () {\n            reactData.isActivated = true;\n        };\n        var keydownSearchEvent = function (params) {\n            var $event = params.$event;\n            var isEnter = hasEventKey($event, EVENT_KEYS.ENTER);\n            if (isEnter) {\n                $event.preventDefault();\n                $event.stopPropagation();\n            }\n        };\n        var triggerSearchEvent = XEUtils.debounce(function () {\n            var remote = props.remote, remoteMethod = props.remoteMethod;\n            var searchValue = reactData.searchValue;\n            if (remote && remoteMethod) {\n                reactData.searchLoading = true;\n                Promise.resolve(remoteMethod({ searchValue: searchValue })).then(function () { return nextTick(); }).catch(function () { return nextTick(); }).finally(function () {\n                    reactData.searchLoading = false;\n                    refreshOption();\n                });\n            }\n            else {\n                refreshOption();\n            }\n        }, 350, { trailing: true });\n        var togglePanelEvent = function (params) {\n            var $event = params.$event;\n            $event.preventDefault();\n            if (reactData.visiblePanel) {\n                hideOptionPanel();\n            }\n            else {\n                showOptionPanel();\n            }\n        };\n        var checkOptionDisabled = function (isSelected, option, group) {\n            if (option.disabled) {\n                return true;\n            }\n            if (group && group.disabled) {\n                return true;\n            }\n            var isMaximize = computeIsMaximize.value;\n            if (isMaximize && !isSelected) {\n                return true;\n            }\n            return false;\n        };\n        var renderOption = function (list, group) {\n            var optionKey = props.optionKey, modelValue = props.modelValue, multiple = props.multiple;\n            var currentValue = reactData.currentValue;\n            var optionOpts = computeOptionOpts.value;\n            var labelField = computeLabelField.value;\n            var valueField = computeValueField.value;\n            var isGroup = computeIsGroup.value;\n            var useKey = optionOpts.useKey;\n            var optionSlot = slots.option;\n            return list.map(function (option, cIndex) {\n                var slots = option.slots, className = option.className;\n                var optionValue = option[valueField];\n                var isSelected = multiple ? (modelValue && modelValue.indexOf(optionValue) > -1) : modelValue === optionValue;\n                var isVisible = !isGroup || isOptionVisible(option);\n                var isDisabled = checkOptionDisabled(isSelected, option, group);\n                var optid = getOptid(option);\n                var defaultSlot = slots ? slots.default : null;\n                var optParams = { option: option, group: null, $select: $xeselect };\n                return isVisible ? h('div', {\n                    key: useKey || optionKey ? optid : cIndex,\n                    class: ['vxe-select-option', className ? (XEUtils.isFunction(className) ? className(optParams) : className) : '', {\n                            'is--disabled': isDisabled,\n                            'is--selected': isSelected,\n                            'is--hover': currentValue === optionValue\n                        }],\n                    // attrs\n                    optid: optid,\n                    // event\n                    onMousedown: function (evnt) {\n                        var isLeftBtn = evnt.button === 0;\n                        if (isLeftBtn) {\n                            evnt.stopPropagation();\n                        }\n                    },\n                    onClick: function (evnt) {\n                        if (!isDisabled) {\n                            changeOptionEvent(evnt, optionValue, option);\n                        }\n                    },\n                    onMouseenter: function () {\n                        if (!isDisabled) {\n                            setCurrentOption(option);\n                        }\n                    }\n                }, optionSlot ? callSlot(optionSlot, optParams) : (defaultSlot ? callSlot(defaultSlot, optParams) : formatText(getFuncText(option[labelField])))) : null;\n            });\n        };\n        var renderOptgroup = function () {\n            var optionKey = props.optionKey;\n            var visibleGroupList = reactData.visibleGroupList;\n            var optionOpts = computeOptionOpts.value;\n            var groupLabelField = computeGroupLabelField.value;\n            var groupOptionsField = computeGroupOptionsField.value;\n            var useKey = optionOpts.useKey;\n            var optionSlot = slots.option;\n            return visibleGroupList.map(function (group, gIndex) {\n                var slots = group.slots, className = group.className;\n                var optid = getOptid(group);\n                var isGroupDisabled = group.disabled;\n                var defaultSlot = slots ? slots.default : null;\n                var optParams = { option: group, group: group, $select: $xeselect };\n                return h('div', {\n                    key: useKey || optionKey ? optid : gIndex,\n                    class: ['vxe-optgroup', className ? (XEUtils.isFunction(className) ? className(optParams) : className) : '', {\n                            'is--disabled': isGroupDisabled\n                        }],\n                    // attrs\n                    optid: optid\n                }, [\n                    h('div', {\n                        class: 'vxe-optgroup--title'\n                    }, optionSlot ? callSlot(optionSlot, optParams) : (defaultSlot ? callSlot(defaultSlot, optParams) : getFuncText(group[groupLabelField]))),\n                    h('div', {\n                        class: 'vxe-optgroup--wrapper'\n                    }, renderOption(group[groupOptionsField] || [], group))\n                ]);\n            });\n        };\n        var renderOpts = function () {\n            var visibleGroupList = reactData.visibleGroupList, visibleOptionList = reactData.visibleOptionList, searchLoading = reactData.searchLoading;\n            var isGroup = computeIsGroup.value;\n            if (searchLoading) {\n                return [\n                    h('div', {\n                        class: 'vxe-select--search-loading'\n                    }, [\n                        h('i', {\n                            class: ['vxe-select--search-icon', GlobalConfig.icon.SELECT_LOADED]\n                        }),\n                        h('span', {\n                            class: 'vxe-select--search-text'\n                        }, GlobalConfig.i18n('vxe.select.loadingText'))\n                    ])\n                ];\n            }\n            if (isGroup) {\n                if (visibleGroupList.length) {\n                    return renderOptgroup();\n                }\n            }\n            else {\n                if (visibleOptionList.length) {\n                    return renderOption(visibleOptionList);\n                }\n            }\n            return [\n                h('div', {\n                    class: 'vxe-select--empty-placeholder'\n                }, props.emptyText || GlobalConfig.i18n('vxe.select.emptyText'))\n            ];\n        };\n        selectMethods = {\n            dispatchEvent: function (type, params, evnt) {\n                emit(type, Object.assign({ $select: $xeselect, $event: evnt }, params));\n            },\n            isPanelVisible: function () {\n                return reactData.visiblePanel;\n            },\n            togglePanel: function () {\n                if (reactData.visiblePanel) {\n                    hideOptionPanel();\n                }\n                else {\n                    showOptionPanel();\n                }\n                return nextTick();\n            },\n            hidePanel: function () {\n                if (reactData.visiblePanel) {\n                    hideOptionPanel();\n                }\n                return nextTick();\n            },\n            showPanel: function () {\n                if (!reactData.visiblePanel) {\n                    showOptionPanel();\n                }\n                return nextTick();\n            },\n            refreshOption: refreshOption,\n            focus: function () {\n                var $input = refInput.value;\n                reactData.isActivated = true;\n                $input.blur();\n                return nextTick();\n            },\n            blur: function () {\n                var $input = refInput.value;\n                $input.blur();\n                reactData.isActivated = false;\n                return nextTick();\n            }\n        };\n        Object.assign($xeselect, selectMethods);\n        watch(function () { return reactData.staticOptions; }, function (value) {\n            if (value.some(function (item) { return item.options && item.options.length; })) {\n                reactData.fullOptionList = [];\n                reactData.fullGroupList = value;\n            }\n            else {\n                reactData.fullGroupList = [];\n                reactData.fullOptionList = value || [];\n            }\n            cacheItemMap();\n        });\n        watch(function () { return props.options; }, function (value) {\n            reactData.fullGroupList = [];\n            reactData.fullOptionList = value || [];\n            cacheItemMap();\n        });\n        watch(function () { return props.optionGroups; }, function (value) {\n            reactData.fullOptionList = [];\n            reactData.fullGroupList = value || [];\n            cacheItemMap();\n        });\n        onMounted(function () {\n            nextTick(function () {\n                var options = props.options, optionGroups = props.optionGroups;\n                if (optionGroups) {\n                    reactData.fullGroupList = optionGroups;\n                }\n                else if (options) {\n                    reactData.fullOptionList = options;\n                }\n                cacheItemMap();\n            });\n            GlobalEvent.on($xeselect, 'mousewheel', handleGlobalMousewheelEvent);\n            GlobalEvent.on($xeselect, 'mousedown', handleGlobalMousedownEvent);\n            GlobalEvent.on($xeselect, 'keydown', handleGlobalKeydownEvent);\n            GlobalEvent.on($xeselect, 'blur', handleGlobalBlurEvent);\n        });\n        onUnmounted(function () {\n            GlobalEvent.off($xeselect, 'mousewheel');\n            GlobalEvent.off($xeselect, 'mousedown');\n            GlobalEvent.off($xeselect, 'keydown');\n            GlobalEvent.off($xeselect, 'blur');\n        });\n        var renderVN = function () {\n            var _a, _b;\n            var className = props.className, popupClassName = props.popupClassName, transfer = props.transfer, disabled = props.disabled, loading = props.loading, filterable = props.filterable;\n            var inited = reactData.inited, isActivated = reactData.isActivated, visiblePanel = reactData.visiblePanel;\n            var vSize = computeSize.value;\n            var selectLabel = computeSelectLabel.value;\n            var defaultSlot = slots.default;\n            var headerSlot = slots.header;\n            var footerSlot = slots.footer;\n            var prefixSlot = slots.prefix;\n            return h('div', {\n                ref: refElem,\n                class: ['vxe-select', className ? (XEUtils.isFunction(className) ? className({ $select: $xeselect }) : className) : '', (_a = {},\n                        _a[\"size--\".concat(vSize)] = vSize,\n                        _a['is--visivle'] = visiblePanel,\n                        _a['is--disabled'] = disabled,\n                        _a['is--filter'] = filterable,\n                        _a['is--loading'] = loading,\n                        _a['is--active'] = isActivated,\n                        _a)]\n            }, [\n                h('div', {\n                    class: 'vxe-select-slots',\n                    ref: 'hideOption'\n                }, defaultSlot ? defaultSlot({}) : []),\n                h(VxeInputComponent, {\n                    ref: refInput,\n                    clearable: props.clearable,\n                    placeholder: props.placeholder,\n                    readonly: true,\n                    disabled: disabled,\n                    type: 'text',\n                    prefixIcon: props.prefixIcon,\n                    suffixIcon: loading ? GlobalConfig.icon.SELECT_LOADED : (visiblePanel ? GlobalConfig.icon.SELECT_OPEN : GlobalConfig.icon.SELECT_CLOSE),\n                    modelValue: selectLabel,\n                    onClear: clearEvent,\n                    onClick: togglePanelEvent,\n                    onFocus: focusEvent,\n                    onBlur: blurEvent,\n                    onSuffixClick: togglePanelEvent\n                }, prefixSlot ? {\n                    prefix: function () { return prefixSlot({}); }\n                } : {}),\n                h(Teleport, {\n                    to: 'body',\n                    disabled: transfer ? !inited : true\n                }, [\n                    h('div', {\n                        ref: refOptionPanel,\n                        class: ['vxe-table--ignore-clear vxe-select--panel', popupClassName ? (XEUtils.isFunction(popupClassName) ? popupClassName({ $select: $xeselect }) : popupClassName) : '', (_b = {},\n                                _b[\"size--\".concat(vSize)] = vSize,\n                                _b['is--transfer'] = transfer,\n                                _b['animat--leave'] = !loading && reactData.animatVisible,\n                                _b['animat--enter'] = !loading && visiblePanel,\n                                _b)],\n                        placement: reactData.panelPlacement,\n                        style: reactData.panelStyle\n                    }, inited ? [\n                        filterable ? h('div', {\n                            class: 'vxe-select--panel-search'\n                        }, [\n                            h(VxeInputComponent, {\n                                ref: refInpSearch,\n                                class: 'vxe-select-search--input',\n                                modelValue: reactData.searchValue,\n                                clearable: true,\n                                placeholder: GlobalConfig.i18n('vxe.select.search'),\n                                prefixIcon: GlobalConfig.icon.INPUT_SEARCH,\n                                'onUpdate:modelValue': modelSearchEvent,\n                                onFocus: focusSearchEvent,\n                                onKeydown: keydownSearchEvent,\n                                onChange: triggerSearchEvent,\n                                onSearch: triggerSearchEvent\n                            })\n                        ]) : createCommentVNode(),\n                        h('div', {\n                            class: 'vxe-select--panel-wrapper'\n                        }, [\n                            headerSlot ? h('div', {\n                                class: 'vxe-select--panel-header'\n                            }, headerSlot({})) : createCommentVNode(),\n                            h('div', {\n                                class: 'vxe-select--panel-body'\n                            }, [\n                                h('div', {\n                                    ref: refOptionWrapper,\n                                    class: 'vxe-select-option--wrapper'\n                                }, renderOpts())\n                            ]),\n                            footerSlot ? h('div', {\n                                class: 'vxe-select--panel-footer'\n                            }, footerSlot({})) : createCommentVNode()\n                        ])\n                    ] : [])\n                ])\n            ]);\n        };\n        $xeselect.renderVN = renderVN;\n        provide('$xeselect', $xeselect);\n        return $xeselect;\n    },\n    render: function () {\n        return this.renderVN();\n    }\n});\n",
      "start": 1714699767841,
      "end": 1714699767841,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "esbuild",
      "start": 1714699767841,
      "end": 1714699767841,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1714699767841,
      "end": 1714699767841,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1714699767841,
      "end": 1714699767841,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1714699767841,
      "end": 1714699767841,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1714699767841,
      "end": 1714699767841,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1714699767841,
      "end": 1714699767841,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1714699767841,
      "end": 1714699767843,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1714699767843,
      "end": 1714699767843,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1714699767843,
      "end": 1714699767843,
      "order": "normal"
    },
    {
      "name": "unplugin-auto-import",
      "start": 1714699767843,
      "end": 1714699767843,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1714699767843,
      "end": 1714699767843,
      "order": "post"
    },
    {
      "name": "vite:style-import",
      "start": 1714699767843,
      "end": 1714699767843,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1714699767843,
      "end": 1714699767843,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1714699767843,
      "end": 1714699767843,
      "order": "normal"
    }
  ]
}
