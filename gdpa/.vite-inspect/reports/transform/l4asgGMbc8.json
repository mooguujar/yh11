{
  "resolvedId": "/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/vxe-table@4.5.21_vue@3.4.19_xe-utils@3.5.24/node_modules/vxe-table/es/edit/src/hook.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { reactive, nextTick } from 'vue';\nimport XEUtils from 'xe-utils';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport { renderer } from '../../v-x-e-table';\nimport { isEnableConf } from '../../tools/utils';\nimport { getCellValue, setCellValue, getRowid } from '../../table/src/util';\nimport { browse, removeClass, addClass } from '../../tools/dom';\nimport { warnLog, errLog, getLog } from '../../tools/log';\nvar tableEditMethodKeys = ['insert', 'insertAt', 'insertNextAt', 'remove', 'removeCheckboxRow', 'removeRadioRow', 'removeCurrentRow', 'getRecordset', 'getInsertRecords', 'getRemoveRecords', 'getUpdateRecords', 'getEditRecord', 'getActiveRecord', 'getSelectedCell', 'clearEdit', 'clearActived', 'clearSelected', 'isEditByRow', 'isActiveByRow', 'setEditRow', 'setActiveRow', 'setEditCell', 'setActiveCell', 'setSelectCell'];\nvar editHook = {\n    setupTable: function ($xetable) {\n        var props = $xetable.props, reactData = $xetable.reactData, internalData = $xetable.internalData;\n        var refElem = $xetable.getRefMaps().refElem;\n        var _a = $xetable.getComputeMaps(), computeMouseOpts = _a.computeMouseOpts, computeEditOpts = _a.computeEditOpts, computeCheckboxOpts = _a.computeCheckboxOpts, computeTreeOpts = _a.computeTreeOpts;\n        var editMethods = {};\n        var editPrivateMethods = {};\n        var getEditColumnModel = function (row, column) {\n            var model = column.model, editRender = column.editRender;\n            if (editRender) {\n                model.value = getCellValue(row, column);\n                model.update = false;\n            }\n        };\n        var setEditColumnModel = function (row, column) {\n            var model = column.model, editRender = column.editRender;\n            if (editRender && model.update) {\n                setCellValue(row, column, model.value);\n                model.update = false;\n                model.value = null;\n            }\n        };\n        var removeCellSelectedClass = function () {\n            var el = refElem.value;\n            if (el) {\n                var cell = el.querySelector('.col--selected');\n                if (cell) {\n                    removeClass(cell, 'col--selected');\n                }\n            }\n        };\n        function syncActivedCell() {\n            var editStore = reactData.editStore, tableColumn = reactData.tableColumn;\n            var editOpts = computeEditOpts.value;\n            var actived = editStore.actived;\n            var row = actived.row, column = actived.column;\n            if (row || column) {\n                if (editOpts.mode === 'row') {\n                    tableColumn.forEach(function (column) { return setEditColumnModel(row, column); });\n                }\n                else {\n                    setEditColumnModel(row, column);\n                }\n            }\n        }\n        function insertTreeRow(newRecords, isAppend) {\n            var tableFullTreeData = internalData.tableFullTreeData, afterFullData = internalData.afterFullData, fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n            var treeOpts = computeTreeOpts.value;\n            var rowField = treeOpts.rowField, parentField = treeOpts.parentField, mapChildrenField = treeOpts.mapChildrenField;\n            var childrenField = treeOpts.children || treeOpts.childrenField;\n            var funcName = isAppend ? 'push' : 'unshift';\n            newRecords.forEach(function (item) {\n                var parentRowId = item[parentField];\n                var rowid = getRowid($xetable, item);\n                var matchObj = parentRowId ? XEUtils.findTree(tableFullTreeData, function (item) { return parentRowId === item[rowField]; }, { children: mapChildrenField }) : null;\n                if (matchObj) {\n                    var parentRow = matchObj.item;\n                    var parentRest = fullAllDataRowIdData[getRowid($xetable, parentRow)];\n                    var parentLevel = parentRest ? parentRest.level : 0;\n                    var parentChilds = parentRow[childrenField];\n                    var mapChilds = parentRow[mapChildrenField];\n                    if (!XEUtils.isArray(parentChilds)) {\n                        parentChilds = parentRow[childrenField] = [];\n                    }\n                    if (!XEUtils.isArray(mapChilds)) {\n                        mapChilds = parentRow[childrenField] = [];\n                    }\n                    parentChilds[funcName](item);\n                    mapChilds[funcName](item);\n                    var rest = { row: item, rowid: rowid, seq: -1, index: -1, _index: -1, $index: -1, items: parentChilds, parent: parentRow, level: parentLevel + 1 };\n                    fullDataRowIdData[rowid] = rest;\n                    fullAllDataRowIdData[rowid] = rest;\n                }\n                else {\n                    if (process.env.NODE_ENV === 'development') {\n                        if (parentRowId) {\n                            warnLog('vxe.error.unableInsert');\n                        }\n                    }\n                    afterFullData[funcName](item);\n                    tableFullTreeData[funcName](item);\n                    var rest = { row: item, rowid: rowid, seq: -1, index: -1, _index: -1, $index: -1, items: tableFullTreeData, parent: null, level: 0 };\n                    fullDataRowIdData[rowid] = rest;\n                    fullAllDataRowIdData[rowid] = rest;\n                }\n            });\n        }\n        var handleInsertRowAt = function (records, row, isInsertNextRow) {\n            var treeConfig = props.treeConfig;\n            var mergeList = reactData.mergeList, editStore = reactData.editStore;\n            var tableFullTreeData = internalData.tableFullTreeData, afterFullData = internalData.afterFullData, tableFullData = internalData.tableFullData, fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n            var treeOpts = computeTreeOpts.value;\n            var transform = treeOpts.transform, rowField = treeOpts.rowField, mapChildrenField = treeOpts.mapChildrenField;\n            var childrenField = treeOpts.children || treeOpts.childrenField;\n            if (!XEUtils.isArray(records)) {\n                records = [records];\n            }\n            var newRecords = reactive($xetable.defineField(records.map(function (record) {\n                var _a;\n                return Object.assign(treeConfig && transform ? (_a = {}, _a[mapChildrenField] = [], _a[childrenField] = [], _a) : {}, record);\n            })));\n            if (XEUtils.eqNull(row)) {\n                // 如果为虚拟树\n                if (treeConfig && transform) {\n                    insertTreeRow(newRecords, false);\n                }\n                else {\n                    afterFullData.unshift.apply(afterFullData, newRecords);\n                    tableFullData.unshift.apply(tableFullData, newRecords);\n                    // 刷新单元格合并\n                    mergeList.forEach(function (mergeItem) {\n                        var mergeRowIndex = mergeItem.row;\n                        if (mergeRowIndex > 0) {\n                            mergeItem.row = mergeRowIndex + newRecords.length;\n                        }\n                    });\n                }\n            }\n            else {\n                if (row === -1) {\n                    // 如果为虚拟树\n                    if (treeConfig && transform) {\n                        insertTreeRow(newRecords, true);\n                    }\n                    else {\n                        afterFullData.push.apply(afterFullData, newRecords);\n                        tableFullData.push.apply(tableFullData, newRecords);\n                        // 刷新单元格合并\n                        mergeList.forEach(function (mergeItem) {\n                            var mergeRowIndex = mergeItem.row, mergeRowspan = mergeItem.rowspan;\n                            if (mergeRowIndex + mergeRowspan > afterFullData.length) {\n                                mergeItem.rowspan = mergeRowspan + newRecords.length;\n                            }\n                        });\n                    }\n                }\n                else {\n                    // 如果为虚拟树\n                    if (treeConfig && transform) {\n                        var matchMapObj_1 = XEUtils.findTree(tableFullTreeData, function (item) { return row[rowField] === item[rowField]; }, { children: mapChildrenField });\n                        if (matchMapObj_1) {\n                            var parentRow_1 = matchMapObj_1.parent;\n                            var parentMapChilds_1 = parentRow_1 ? parentRow_1[mapChildrenField] : tableFullTreeData;\n                            var parentRest = fullAllDataRowIdData[getRowid($xetable, parentRow_1)];\n                            var parentLevel_1 = parentRest ? parentRest.level : 0;\n                            newRecords.forEach(function (item, i) {\n                                var rowid = getRowid($xetable, item);\n                                if (process.env.NODE_ENV === 'development') {\n                                    if (item[treeOpts.parentField]) {\n                                        if (parentRow_1 && item[treeOpts.parentField] !== parentRow_1[rowField]) {\n                                            errLog('vxe.error.errProp', [\"\".concat(treeOpts.parentField, \"=\").concat(item[treeOpts.parentField]), \"\".concat(treeOpts.parentField, \"=\").concat(parentRow_1[rowField])]);\n                                        }\n                                    }\n                                }\n                                if (parentRow_1) {\n                                    item[treeOpts.parentField] = parentRow_1[rowField];\n                                }\n                                var targetIndex = matchMapObj_1.index + i;\n                                if (isInsertNextRow) {\n                                    targetIndex = targetIndex + 1;\n                                }\n                                parentMapChilds_1.splice(targetIndex, 0, item);\n                                var rest = { row: item, rowid: rowid, seq: -1, index: -1, _index: -1, $index: -1, items: parentMapChilds_1, parent: parentRow_1, level: parentLevel_1 + 1 };\n                                fullDataRowIdData[rowid] = rest;\n                                fullAllDataRowIdData[rowid] = rest;\n                            });\n                            // 源\n                            if (parentRow_1) {\n                                var matchObj = XEUtils.findTree(tableFullTreeData, function (item) { return row[rowField] === item[rowField]; }, { children: childrenField });\n                                if (matchObj) {\n                                    var parentChilds = matchObj.items;\n                                    var targetIndex = matchObj.index;\n                                    if (isInsertNextRow) {\n                                        targetIndex = targetIndex + 1;\n                                    }\n                                    parentChilds.splice.apply(parentChilds, __spreadArray([targetIndex, 0], newRecords, false));\n                                }\n                            }\n                        }\n                        else {\n                            if (process.env.NODE_ENV === 'development') {\n                                warnLog('vxe.error.unableInsert');\n                            }\n                            insertTreeRow(newRecords, true);\n                        }\n                    }\n                    else {\n                        if (treeConfig) {\n                            throw new Error(getLog('vxe.error.noTree', ['insert']));\n                        }\n                        var afIndex_1 = -1;\n                        // 如果是可视索引\n                        if (XEUtils.isNumber(row)) {\n                            if (row < afterFullData.length) {\n                                afIndex_1 = row;\n                            }\n                        }\n                        else {\n                            afIndex_1 = $xetable.findRowIndexOf(afterFullData, row);\n                        }\n                        // 如果是插入指定行的下一行\n                        if (isInsertNextRow) {\n                            afIndex_1 = Math.min(afterFullData.length, afIndex_1 + 1);\n                        }\n                        if (afIndex_1 === -1) {\n                            throw new Error(errLog('vxe.error.unableInsert'));\n                        }\n                        afterFullData.splice.apply(afterFullData, __spreadArray([afIndex_1, 0], newRecords, false));\n                        tableFullData.splice.apply(tableFullData, __spreadArray([$xetable.findRowIndexOf(tableFullData, row), 0], newRecords, false));\n                        // 刷新单元格合并\n                        mergeList.forEach(function (mergeItem) {\n                            var mergeRowIndex = mergeItem.row, mergeRowspan = mergeItem.rowspan;\n                            if (mergeRowIndex > afIndex_1) {\n                                mergeItem.row = mergeRowIndex + newRecords.length;\n                            }\n                            else if (mergeRowIndex + mergeRowspan > afIndex_1) {\n                                mergeItem.rowspan = mergeRowspan + newRecords.length;\n                            }\n                        });\n                    }\n                }\n            }\n            var insertMaps = editStore.insertMaps;\n            newRecords.forEach(function (newRow) {\n                var rowid = getRowid($xetable, newRow);\n                insertMaps[rowid] = newRow;\n            });\n            $xetable.cacheRowMap();\n            $xetable.updateScrollYStatus();\n            $xetable.handleTableData(treeConfig && transform);\n            if (!(treeConfig && transform)) {\n                $xetable.updateAfterDataIndex();\n            }\n            $xetable.updateFooter();\n            $xetable.checkSelectionStatus();\n            if (reactData.scrollYLoad) {\n                $xetable.updateScrollYSpace();\n            }\n            return nextTick().then(function () {\n                $xetable.updateCellAreas();\n                return $xetable.recalculate();\n            }).then(function () {\n                return {\n                    row: newRecords.length ? newRecords[newRecords.length - 1] : null,\n                    rows: newRecords\n                };\n            });\n        };\n        editMethods = {\n            /**\n             * 往表格中插入临时数据\n             *\n             * @param {*} records\n             */\n            insert: function (records) {\n                return handleInsertRowAt(records, null);\n            },\n            /**\n             * 往表格指定行中插入临时数据\n             * 如果 row 为空则从插入到顶部，如果为树结构，则插入到目标节点顶部\n             * 如果 row 为 -1 则从插入到底部，如果为树结构，则插入到目标节点底部\n             * 如果 row 为有效行则插入到该行的位置，如果为树结构，则有插入到效的目标节点该行的位置\n             * @param {Object/Array} records 新的数据\n             * @param {Row} row 指定行\n             */\n            insertAt: function (records, row) {\n                return handleInsertRowAt(records, row);\n            },\n            insertNextAt: function (records, row) {\n                return handleInsertRowAt(records, row, true);\n            },\n            /**\n             * 删除指定行数据\n             * 如果传 row 则删除一行\n             * 如果传 rows 则删除多行\n             * 如果为空则删除所有\n             */\n            remove: function (rows) {\n                var treeConfig = props.treeConfig;\n                var mergeList = reactData.mergeList, editStore = reactData.editStore, selectCheckboxMaps = reactData.selectCheckboxMaps;\n                var tableFullTreeData = internalData.tableFullTreeData, afterFullData = internalData.afterFullData, tableFullData = internalData.tableFullData;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var treeOpts = computeTreeOpts.value;\n                var transform = treeOpts.transform, mapChildrenField = treeOpts.mapChildrenField;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var actived = editStore.actived, removeMaps = editStore.removeMaps, insertMaps = editStore.insertMaps;\n                var checkField = checkboxOpts.checkField;\n                var delList = [];\n                if (!rows) {\n                    rows = tableFullData;\n                }\n                else if (!XEUtils.isArray(rows)) {\n                    rows = [rows];\n                }\n                // 如果是新增，则保存记录\n                rows.forEach(function (row) {\n                    if (!$xetable.isInsertByRow(row)) {\n                        var rowid = getRowid($xetable, row);\n                        removeMaps[rowid] = row;\n                    }\n                });\n                // 如果绑定了多选属性，则更新状态\n                if (!checkField) {\n                    var selectRowMaps_1 = __assign({}, selectCheckboxMaps);\n                    rows.forEach(function (row) {\n                        var rowid = getRowid($xetable, row);\n                        if (selectRowMaps_1[rowid]) {\n                            delete selectRowMaps_1[rowid];\n                        }\n                    });\n                    reactData.selectCheckboxMaps = selectRowMaps_1;\n                }\n                // 从数据源中移除\n                if (tableFullData === rows) {\n                    rows = delList = tableFullData.slice(0);\n                    internalData.tableFullData = [];\n                    internalData.afterFullData = [];\n                    $xetable.clearMergeCells();\n                }\n                else {\n                    // 如果为虚拟树\n                    if (treeConfig && transform) {\n                        rows.forEach(function (row) {\n                            var rowid = getRowid($xetable, row);\n                            var matchMapObj = XEUtils.findTree(tableFullTreeData, function (item) { return rowid === getRowid($xetable, item); }, { children: mapChildrenField });\n                            if (matchMapObj) {\n                                var rItems = matchMapObj.items.splice(matchMapObj.index, 1);\n                                delList.push(rItems[0]);\n                            }\n                            var matchObj = XEUtils.findTree(tableFullTreeData, function (item) { return rowid === getRowid($xetable, item); }, { children: childrenField });\n                            if (matchObj) {\n                                matchObj.items.splice(matchObj.index, 1);\n                            }\n                            var afIndex = $xetable.findRowIndexOf(afterFullData, row);\n                            if (afIndex > -1) {\n                                afterFullData.splice(afIndex, 1);\n                            }\n                        });\n                    }\n                    else {\n                        rows.forEach(function (row) {\n                            var tfIndex = $xetable.findRowIndexOf(tableFullData, row);\n                            if (tfIndex > -1) {\n                                var rItems = tableFullData.splice(tfIndex, 1);\n                                delList.push(rItems[0]);\n                            }\n                            var afIndex = $xetable.findRowIndexOf(afterFullData, row);\n                            if (afIndex > -1) {\n                                // 刷新单元格合并\n                                mergeList.forEach(function (mergeItem) {\n                                    var mergeRowIndex = mergeItem.row, mergeRowspan = mergeItem.rowspan;\n                                    if (mergeRowIndex > afIndex) {\n                                        mergeItem.row = mergeRowIndex - 1;\n                                    }\n                                    else if (mergeRowIndex + mergeRowspan > afIndex) {\n                                        mergeItem.rowspan = mergeRowspan - 1;\n                                    }\n                                });\n                                afterFullData.splice(afIndex, 1);\n                            }\n                        });\n                    }\n                }\n                // 如果当前行被激活编辑，则清除激活状态\n                if (actived.row && $xetable.findRowIndexOf(rows, actived.row) > -1) {\n                    editMethods.clearEdit();\n                }\n                // 从新增中移除已删除的数据\n                rows.forEach(function (row) {\n                    var rowid = getRowid($xetable, row);\n                    if (insertMaps[rowid]) {\n                        delete insertMaps[rowid];\n                    }\n                });\n                $xetable.updateFooter();\n                $xetable.cacheRowMap();\n                $xetable.handleTableData(treeConfig && transform);\n                if (!(treeConfig && transform)) {\n                    $xetable.updateAfterDataIndex();\n                }\n                $xetable.checkSelectionStatus();\n                if (reactData.scrollYLoad) {\n                    $xetable.updateScrollYSpace();\n                }\n                return nextTick().then(function () {\n                    $xetable.updateCellAreas();\n                    return $xetable.recalculate();\n                }).then(function () {\n                    return { row: delList.length ? delList[delList.length - 1] : null, rows: delList };\n                });\n            },\n            /**\n             * 删除复选框选中的数据\n             */\n            removeCheckboxRow: function () {\n                return editMethods.remove($xetable.getCheckboxRecords()).then(function (params) {\n                    $xetable.clearCheckboxRow();\n                    return params;\n                });\n            },\n            /**\n             * 删除单选框选中的数据\n             */\n            removeRadioRow: function () {\n                var radioRecord = $xetable.getRadioRecord();\n                return editMethods.remove(radioRecord || []).then(function (params) {\n                    $xetable.clearRadioRow();\n                    return params;\n                });\n            },\n            /**\n             * 删除当前行选中的数据\n             */\n            removeCurrentRow: function () {\n                var currentRecord = $xetable.getCurrentRecord();\n                return editMethods.remove(currentRecord || []).then(function (params) {\n                    $xetable.clearCurrentRow();\n                    return params;\n                });\n            },\n            /**\n             * 获取表格数据集，包含新增、删除、修改、标记\n             */\n            getRecordset: function () {\n                return {\n                    insertRecords: editMethods.getInsertRecords(),\n                    removeRecords: editMethods.getRemoveRecords(),\n                    updateRecords: editMethods.getUpdateRecords(),\n                    pendingRecords: $xetable.getPendingRecords()\n                };\n            },\n            /**\n             * 获取新增的临时数据\n             */\n            getInsertRecords: function () {\n                var editStore = reactData.editStore;\n                var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                var insertMaps = editStore.insertMaps;\n                var insertRecords = [];\n                XEUtils.each(insertMaps, function (row, rowid) {\n                    if (fullAllDataRowIdData[rowid]) {\n                        insertRecords.push(row);\n                    }\n                });\n                return insertRecords;\n            },\n            /**\n             * 获取已删除的数据\n             */\n            getRemoveRecords: function () {\n                var editStore = reactData.editStore;\n                var removeMaps = editStore.removeMaps;\n                var removeRecords = [];\n                XEUtils.each(removeMaps, function (row) {\n                    removeRecords.push(row);\n                });\n                return removeRecords;\n            },\n            /**\n             * 获取更新数据\n             * 只精准匹配 row 的更改\n             * 如果是树表格，子节点更改状态不会影响父节点的更新状态\n             */\n            getUpdateRecords: function () {\n                var keepSource = props.keepSource, treeConfig = props.treeConfig;\n                var tableFullData = internalData.tableFullData;\n                var treeOpts = computeTreeOpts.value;\n                if (keepSource) {\n                    syncActivedCell();\n                    if (treeConfig) {\n                        return XEUtils.filterTree(tableFullData, function (row) { return $xetable.isUpdateByRow(row); }, treeOpts);\n                    }\n                    return tableFullData.filter(function (row) { return $xetable.isUpdateByRow(row); });\n                }\n                return [];\n            },\n            getActiveRecord: function () {\n                return this.getEditRecord();\n            },\n            getEditRecord: function () {\n                var editStore = reactData.editStore;\n                var afterFullData = internalData.afterFullData;\n                var el = refElem.value;\n                var _a = editStore.actived, args = _a.args, row = _a.row;\n                if (args && $xetable.findRowIndexOf(afterFullData, row) > -1 && el.querySelectorAll('.vxe-body--column.col--active').length) {\n                    return Object.assign({}, args);\n                }\n                return null;\n            },\n            /**\n             * 获取选中的单元格\n             */\n            getSelectedCell: function () {\n                var editStore = reactData.editStore;\n                var _a = editStore.selected, args = _a.args, column = _a.column;\n                if (args && column) {\n                    return Object.assign({}, args);\n                }\n                return null;\n            },\n            clearActived: function (evnt) {\n                // if (process.env.NODE_ENV === 'development') {\n                //   warnLog('vxe.error.delFunc', ['clearActived', 'clearEdit'])\n                // }\n                // 即将废弃\n                return this.clearEdit(evnt);\n            },\n            /**\n             * 清除激活的编辑\n             */\n            clearEdit: function (evnt) {\n                var editStore = reactData.editStore;\n                var actived = editStore.actived;\n                var row = actived.row, column = actived.column;\n                if (row || column) {\n                    syncActivedCell();\n                    actived.args = null;\n                    actived.row = null;\n                    actived.column = null;\n                    $xetable.updateFooter();\n                    $xetable.dispatchEvent('edit-closed', {\n                        row: row,\n                        rowIndex: $xetable.getRowIndex(row),\n                        $rowIndex: $xetable.getVMRowIndex(row),\n                        column: column,\n                        columnIndex: $xetable.getColumnIndex(column),\n                        $columnIndex: $xetable.getVMColumnIndex(column)\n                    }, evnt || null);\n                }\n                if (GlobalConfig.cellVaildMode === 'obsolete') {\n                    if ($xetable.clearValidate) {\n                        return $xetable.clearValidate();\n                    }\n                }\n                return nextTick();\n            },\n            /**\n             * 清除所选中源状态\n             */\n            clearSelected: function () {\n                var editStore = reactData.editStore;\n                var selected = editStore.selected;\n                selected.row = null;\n                selected.column = null;\n                removeCellSelectedClass();\n                return nextTick();\n            },\n            isActiveByRow: function (row) {\n                // if (process.env.NODE_ENV === 'development') {\n                //   warnLog('vxe.error.delFunc', ['isActiveByRow', 'isEditByRow'])\n                // }\n                // 即将废弃\n                return this.isEditByRow(row);\n            },\n            /**\n             * 判断行是否为激活编辑状态\n             * @param {Row} row 行对象\n             */\n            isEditByRow: function (row) {\n                var editStore = reactData.editStore;\n                return editStore.actived.row === row;\n            },\n            setActiveRow: function (row) {\n                // if (process.env.NODE_ENV === 'development') {\n                //   warnLog('vxe.error.delFunc', ['setActiveRow', 'setEditRow'])\n                // }\n                // 即将废弃\n                return editMethods.setEditRow(row);\n            },\n            /**\n             * 激活行编辑\n             */\n            setEditRow: function (row, fieldOrColumn) {\n                var visibleColumn = internalData.visibleColumn;\n                var column = XEUtils.find(visibleColumn, function (column) { return isEnableConf(column.editRender); });\n                if (fieldOrColumn) {\n                    column = XEUtils.isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;\n                }\n                return $xetable.setEditCell(row, column);\n            },\n            setActiveCell: function (row, fieldOrColumn) {\n                // if (process.env.NODE_ENV === 'development') {\n                //   warnLog('vxe.error.delFunc', ['setActiveCell', 'setEditCell'])\n                // }\n                // 即将废弃\n                return editMethods.setEditCell(row, fieldOrColumn);\n            },\n            /**\n             * 激活单元格编辑\n             */\n            setEditCell: function (row, fieldOrColumn) {\n                var editConfig = props.editConfig;\n                var column = XEUtils.isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;\n                if (row && column && isEnableConf(editConfig) && isEnableConf(column.editRender)) {\n                    return $xetable.scrollToRow(row, column).then(function () {\n                        var cell = $xetable.getCell(row, column);\n                        if (cell) {\n                            editPrivateMethods.handleActived({\n                                row: row,\n                                rowIndex: $xetable.getRowIndex(row),\n                                column: column,\n                                columnIndex: $xetable.getColumnIndex(column),\n                                cell: cell,\n                                $table: $xetable\n                            });\n                            internalData._lastCallTime = Date.now();\n                        }\n                        return nextTick();\n                    });\n                }\n                return nextTick();\n            },\n            /**\n             * 只对 trigger=dblclick 有效，选中单元格\n             */\n            setSelectCell: function (row, fieldOrColumn) {\n                var tableData = reactData.tableData;\n                var editOpts = computeEditOpts.value;\n                var column = XEUtils.isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;\n                if (row && column && editOpts.trigger !== 'manual') {\n                    var rowIndex = $xetable.findRowIndexOf(tableData, row);\n                    if (rowIndex > -1 && column) {\n                        var cell = $xetable.getCell(row, column);\n                        var params = {\n                            row: row,\n                            rowIndex: rowIndex,\n                            column: column,\n                            columnIndex: $xetable.getColumnIndex(column),\n                            cell: cell\n                        };\n                        $xetable.handleSelected(params, {});\n                    }\n                }\n                return nextTick();\n            }\n        };\n        editPrivateMethods = {\n            /**\n             * 处理激活编辑\n             */\n            handleActived: function (params, evnt) {\n                var editConfig = props.editConfig, mouseConfig = props.mouseConfig;\n                var editStore = reactData.editStore, tableColumn = reactData.tableColumn;\n                var editOpts = computeEditOpts.value;\n                var mode = editOpts.mode;\n                var actived = editStore.actived;\n                var row = params.row, column = params.column;\n                var editRender = column.editRender;\n                var cell = (params.cell || $xetable.getCell(row, column));\n                var beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;\n                params.cell = cell;\n                if (isEnableConf(editConfig) && isEnableConf(editRender) && !$xetable.hasPendingByRow(row) && cell) {\n                    if (actived.row !== row || (mode === 'cell' ? actived.column !== column : false)) {\n                        // 判断是否禁用编辑\n                        var type = 'edit-disabled';\n                        if (!beforeEditMethod || beforeEditMethod(__assign(__assign({}, params), { $table: $xetable, $grid: $xetable.xegrid }))) {\n                            if (mouseConfig) {\n                                editMethods.clearSelected();\n                                if ($xetable.clearCellAreas) {\n                                    $xetable.clearCellAreas();\n                                    $xetable.clearCopyCellArea();\n                                }\n                            }\n                            $xetable.closeTooltip();\n                            if (actived.column) {\n                                editMethods.clearEdit(evnt);\n                            }\n                            type = 'edit-activated';\n                            column.renderHeight = cell.offsetHeight;\n                            actived.args = params;\n                            actived.row = row;\n                            actived.column = column;\n                            if (mode === 'row') {\n                                tableColumn.forEach(function (column) { return getEditColumnModel(row, column); });\n                            }\n                            else {\n                                getEditColumnModel(row, column);\n                            }\n                            nextTick(function () {\n                                editPrivateMethods.handleFocus(params, evnt);\n                            });\n                        }\n                        $xetable.dispatchEvent(type, {\n                            row: row,\n                            rowIndex: $xetable.getRowIndex(row),\n                            $rowIndex: $xetable.getVMRowIndex(row),\n                            column: column,\n                            columnIndex: $xetable.getColumnIndex(column),\n                            $columnIndex: $xetable.getVMColumnIndex(column)\n                        }, evnt);\n                        // v4已废弃\n                        if (type === 'edit-activated') {\n                            $xetable.dispatchEvent('edit-actived', {\n                                row: row,\n                                rowIndex: $xetable.getRowIndex(row),\n                                $rowIndex: $xetable.getVMRowIndex(row),\n                                column: column,\n                                columnIndex: $xetable.getColumnIndex(column),\n                                $columnIndex: $xetable.getVMColumnIndex(column)\n                            }, evnt);\n                        }\n                    }\n                    else {\n                        var oldColumn = actived.column;\n                        if (mouseConfig) {\n                            editMethods.clearSelected();\n                            if ($xetable.clearCellAreas) {\n                                $xetable.clearCellAreas();\n                                $xetable.clearCopyCellArea();\n                            }\n                        }\n                        if (oldColumn !== column) {\n                            var oldModel = oldColumn.model;\n                            if (oldModel.update) {\n                                setCellValue(row, oldColumn, oldModel.value);\n                            }\n                            if ($xetable.clearValidate) {\n                                $xetable.clearValidate(row, column);\n                            }\n                        }\n                        column.renderHeight = cell.offsetHeight;\n                        actived.args = params;\n                        actived.column = column;\n                        setTimeout(function () {\n                            editPrivateMethods.handleFocus(params, evnt);\n                        });\n                    }\n                    $xetable.focus();\n                }\n                return nextTick();\n            },\n            /**\n             * 处理聚焦\n             */\n            handleFocus: function (params) {\n                var row = params.row, column = params.column, cell = params.cell;\n                var editRender = column.editRender;\n                if (isEnableConf(editRender)) {\n                    var compRender = renderer.get(editRender.name);\n                    var autofocus = editRender.autofocus, autoselect = editRender.autoselect;\n                    var inputElem = void 0;\n                    if (!autofocus && compRender) {\n                        autofocus = compRender.autofocus;\n                    }\n                    if (!autoselect && compRender) {\n                        autoselect = compRender.autoselect;\n                    }\n                    // 如果指定了聚焦 class\n                    if (XEUtils.isFunction(autofocus)) {\n                        inputElem = autofocus.call(this, params);\n                    }\n                    else if (autofocus) {\n                        inputElem = cell.querySelector(autofocus);\n                        if (inputElem) {\n                            inputElem.focus();\n                        }\n                    }\n                    if (inputElem) {\n                        if (autoselect) {\n                            inputElem.select();\n                        }\n                        else {\n                            // 保持一致行为，光标移到末端\n                            if (browse.msie) {\n                                var textRange = inputElem.createTextRange();\n                                textRange.collapse(false);\n                                textRange.select();\n                            }\n                        }\n                    }\n                    else {\n                        // 显示到可视区中\n                        $xetable.scrollToRow(row, column);\n                    }\n                }\n            },\n            /**\n             * 处理选中源\n             */\n            handleSelected: function (params, evnt) {\n                var mouseConfig = props.mouseConfig;\n                var editStore = reactData.editStore;\n                var mouseOpts = computeMouseOpts.value;\n                var editOpts = computeEditOpts.value;\n                var actived = editStore.actived, selected = editStore.selected;\n                var row = params.row, column = params.column;\n                var isMouseSelected = mouseConfig && mouseOpts.selected;\n                var selectMethod = function () {\n                    if (isMouseSelected && (selected.row !== row || selected.column !== column)) {\n                        if (actived.row !== row || (editOpts.mode === 'cell' ? actived.column !== column : false)) {\n                            editMethods.clearEdit(evnt);\n                            editMethods.clearSelected();\n                            if ($xetable.clearCellAreas) {\n                                $xetable.clearCellAreas();\n                                $xetable.clearCopyCellArea();\n                            }\n                            selected.args = params;\n                            selected.row = row;\n                            selected.column = column;\n                            if (isMouseSelected) {\n                                editPrivateMethods.addCellSelectedClass();\n                            }\n                            $xetable.focus();\n                            if (evnt) {\n                                $xetable.dispatchEvent('cell-selected', params, evnt);\n                            }\n                        }\n                    }\n                    return nextTick();\n                };\n                return selectMethod();\n            },\n            addCellSelectedClass: function () {\n                var editStore = reactData.editStore;\n                var selected = editStore.selected;\n                var row = selected.row, column = selected.column;\n                removeCellSelectedClass();\n                if (row && column) {\n                    var cell = $xetable.getCell(row, column);\n                    if (cell) {\n                        addClass(cell, 'col--selected');\n                    }\n                }\n            }\n        };\n        return __assign(__assign({}, editMethods), editPrivateMethods);\n    },\n    setupGrid: function ($xegrid) {\n        return $xegrid.extendTableMethods(tableEditMethodKeys);\n    }\n};\nexport default editHook;\n",
      "start": 1714699767734,
      "end": 1714699767752,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1714699767752,
      "end": 1714699767752,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1714699767752,
      "end": 1714699767752,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1714699767752,
      "end": 1714699767752,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1714699767752,
      "end": 1714699767752,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1714699767752,
      "end": 1714699767752,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1714699767752,
      "end": 1714699767752,
      "order": "normal"
    },
    {
      "name": "vite-plugin-vconsole",
      "result": "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { reactive, nextTick } from 'vue';\nimport XEUtils from 'xe-utils';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport { renderer } from '../../v-x-e-table';\nimport { isEnableConf } from '../../tools/utils';\nimport { getCellValue, setCellValue, getRowid } from '../../table/src/util';\nimport { browse, removeClass, addClass } from '../../tools/dom';\nimport { warnLog, errLog, getLog } from '../../tools/log';\nvar tableEditMethodKeys = ['insert', 'insertAt', 'insertNextAt', 'remove', 'removeCheckboxRow', 'removeRadioRow', 'removeCurrentRow', 'getRecordset', 'getInsertRecords', 'getRemoveRecords', 'getUpdateRecords', 'getEditRecord', 'getActiveRecord', 'getSelectedCell', 'clearEdit', 'clearActived', 'clearSelected', 'isEditByRow', 'isActiveByRow', 'setEditRow', 'setActiveRow', 'setEditCell', 'setActiveCell', 'setSelectCell'];\nvar editHook = {\n    setupTable: function ($xetable) {\n        var props = $xetable.props, reactData = $xetable.reactData, internalData = $xetable.internalData;\n        var refElem = $xetable.getRefMaps().refElem;\n        var _a = $xetable.getComputeMaps(), computeMouseOpts = _a.computeMouseOpts, computeEditOpts = _a.computeEditOpts, computeCheckboxOpts = _a.computeCheckboxOpts, computeTreeOpts = _a.computeTreeOpts;\n        var editMethods = {};\n        var editPrivateMethods = {};\n        var getEditColumnModel = function (row, column) {\n            var model = column.model, editRender = column.editRender;\n            if (editRender) {\n                model.value = getCellValue(row, column);\n                model.update = false;\n            }\n        };\n        var setEditColumnModel = function (row, column) {\n            var model = column.model, editRender = column.editRender;\n            if (editRender && model.update) {\n                setCellValue(row, column, model.value);\n                model.update = false;\n                model.value = null;\n            }\n        };\n        var removeCellSelectedClass = function () {\n            var el = refElem.value;\n            if (el) {\n                var cell = el.querySelector('.col--selected');\n                if (cell) {\n                    removeClass(cell, 'col--selected');\n                }\n            }\n        };\n        function syncActivedCell() {\n            var editStore = reactData.editStore, tableColumn = reactData.tableColumn;\n            var editOpts = computeEditOpts.value;\n            var actived = editStore.actived;\n            var row = actived.row, column = actived.column;\n            if (row || column) {\n                if (editOpts.mode === 'row') {\n                    tableColumn.forEach(function (column) { return setEditColumnModel(row, column); });\n                }\n                else {\n                    setEditColumnModel(row, column);\n                }\n            }\n        }\n        function insertTreeRow(newRecords, isAppend) {\n            var tableFullTreeData = internalData.tableFullTreeData, afterFullData = internalData.afterFullData, fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n            var treeOpts = computeTreeOpts.value;\n            var rowField = treeOpts.rowField, parentField = treeOpts.parentField, mapChildrenField = treeOpts.mapChildrenField;\n            var childrenField = treeOpts.children || treeOpts.childrenField;\n            var funcName = isAppend ? 'push' : 'unshift';\n            newRecords.forEach(function (item) {\n                var parentRowId = item[parentField];\n                var rowid = getRowid($xetable, item);\n                var matchObj = parentRowId ? XEUtils.findTree(tableFullTreeData, function (item) { return parentRowId === item[rowField]; }, { children: mapChildrenField }) : null;\n                if (matchObj) {\n                    var parentRow = matchObj.item;\n                    var parentRest = fullAllDataRowIdData[getRowid($xetable, parentRow)];\n                    var parentLevel = parentRest ? parentRest.level : 0;\n                    var parentChilds = parentRow[childrenField];\n                    var mapChilds = parentRow[mapChildrenField];\n                    if (!XEUtils.isArray(parentChilds)) {\n                        parentChilds = parentRow[childrenField] = [];\n                    }\n                    if (!XEUtils.isArray(mapChilds)) {\n                        mapChilds = parentRow[childrenField] = [];\n                    }\n                    parentChilds[funcName](item);\n                    mapChilds[funcName](item);\n                    var rest = { row: item, rowid: rowid, seq: -1, index: -1, _index: -1, $index: -1, items: parentChilds, parent: parentRow, level: parentLevel + 1 };\n                    fullDataRowIdData[rowid] = rest;\n                    fullAllDataRowIdData[rowid] = rest;\n                }\n                else {\n                    if (process.env.NODE_ENV === 'development') {\n                        if (parentRowId) {\n                            warnLog('vxe.error.unableInsert');\n                        }\n                    }\n                    afterFullData[funcName](item);\n                    tableFullTreeData[funcName](item);\n                    var rest = { row: item, rowid: rowid, seq: -1, index: -1, _index: -1, $index: -1, items: tableFullTreeData, parent: null, level: 0 };\n                    fullDataRowIdData[rowid] = rest;\n                    fullAllDataRowIdData[rowid] = rest;\n                }\n            });\n        }\n        var handleInsertRowAt = function (records, row, isInsertNextRow) {\n            var treeConfig = props.treeConfig;\n            var mergeList = reactData.mergeList, editStore = reactData.editStore;\n            var tableFullTreeData = internalData.tableFullTreeData, afterFullData = internalData.afterFullData, tableFullData = internalData.tableFullData, fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n            var treeOpts = computeTreeOpts.value;\n            var transform = treeOpts.transform, rowField = treeOpts.rowField, mapChildrenField = treeOpts.mapChildrenField;\n            var childrenField = treeOpts.children || treeOpts.childrenField;\n            if (!XEUtils.isArray(records)) {\n                records = [records];\n            }\n            var newRecords = reactive($xetable.defineField(records.map(function (record) {\n                var _a;\n                return Object.assign(treeConfig && transform ? (_a = {}, _a[mapChildrenField] = [], _a[childrenField] = [], _a) : {}, record);\n            })));\n            if (XEUtils.eqNull(row)) {\n                // 如果为虚拟树\n                if (treeConfig && transform) {\n                    insertTreeRow(newRecords, false);\n                }\n                else {\n                    afterFullData.unshift.apply(afterFullData, newRecords);\n                    tableFullData.unshift.apply(tableFullData, newRecords);\n                    // 刷新单元格合并\n                    mergeList.forEach(function (mergeItem) {\n                        var mergeRowIndex = mergeItem.row;\n                        if (mergeRowIndex > 0) {\n                            mergeItem.row = mergeRowIndex + newRecords.length;\n                        }\n                    });\n                }\n            }\n            else {\n                if (row === -1) {\n                    // 如果为虚拟树\n                    if (treeConfig && transform) {\n                        insertTreeRow(newRecords, true);\n                    }\n                    else {\n                        afterFullData.push.apply(afterFullData, newRecords);\n                        tableFullData.push.apply(tableFullData, newRecords);\n                        // 刷新单元格合并\n                        mergeList.forEach(function (mergeItem) {\n                            var mergeRowIndex = mergeItem.row, mergeRowspan = mergeItem.rowspan;\n                            if (mergeRowIndex + mergeRowspan > afterFullData.length) {\n                                mergeItem.rowspan = mergeRowspan + newRecords.length;\n                            }\n                        });\n                    }\n                }\n                else {\n                    // 如果为虚拟树\n                    if (treeConfig && transform) {\n                        var matchMapObj_1 = XEUtils.findTree(tableFullTreeData, function (item) { return row[rowField] === item[rowField]; }, { children: mapChildrenField });\n                        if (matchMapObj_1) {\n                            var parentRow_1 = matchMapObj_1.parent;\n                            var parentMapChilds_1 = parentRow_1 ? parentRow_1[mapChildrenField] : tableFullTreeData;\n                            var parentRest = fullAllDataRowIdData[getRowid($xetable, parentRow_1)];\n                            var parentLevel_1 = parentRest ? parentRest.level : 0;\n                            newRecords.forEach(function (item, i) {\n                                var rowid = getRowid($xetable, item);\n                                if (process.env.NODE_ENV === 'development') {\n                                    if (item[treeOpts.parentField]) {\n                                        if (parentRow_1 && item[treeOpts.parentField] !== parentRow_1[rowField]) {\n                                            errLog('vxe.error.errProp', [\"\".concat(treeOpts.parentField, \"=\").concat(item[treeOpts.parentField]), \"\".concat(treeOpts.parentField, \"=\").concat(parentRow_1[rowField])]);\n                                        }\n                                    }\n                                }\n                                if (parentRow_1) {\n                                    item[treeOpts.parentField] = parentRow_1[rowField];\n                                }\n                                var targetIndex = matchMapObj_1.index + i;\n                                if (isInsertNextRow) {\n                                    targetIndex = targetIndex + 1;\n                                }\n                                parentMapChilds_1.splice(targetIndex, 0, item);\n                                var rest = { row: item, rowid: rowid, seq: -1, index: -1, _index: -1, $index: -1, items: parentMapChilds_1, parent: parentRow_1, level: parentLevel_1 + 1 };\n                                fullDataRowIdData[rowid] = rest;\n                                fullAllDataRowIdData[rowid] = rest;\n                            });\n                            // 源\n                            if (parentRow_1) {\n                                var matchObj = XEUtils.findTree(tableFullTreeData, function (item) { return row[rowField] === item[rowField]; }, { children: childrenField });\n                                if (matchObj) {\n                                    var parentChilds = matchObj.items;\n                                    var targetIndex = matchObj.index;\n                                    if (isInsertNextRow) {\n                                        targetIndex = targetIndex + 1;\n                                    }\n                                    parentChilds.splice.apply(parentChilds, __spreadArray([targetIndex, 0], newRecords, false));\n                                }\n                            }\n                        }\n                        else {\n                            if (process.env.NODE_ENV === 'development') {\n                                warnLog('vxe.error.unableInsert');\n                            }\n                            insertTreeRow(newRecords, true);\n                        }\n                    }\n                    else {\n                        if (treeConfig) {\n                            throw new Error(getLog('vxe.error.noTree', ['insert']));\n                        }\n                        var afIndex_1 = -1;\n                        // 如果是可视索引\n                        if (XEUtils.isNumber(row)) {\n                            if (row < afterFullData.length) {\n                                afIndex_1 = row;\n                            }\n                        }\n                        else {\n                            afIndex_1 = $xetable.findRowIndexOf(afterFullData, row);\n                        }\n                        // 如果是插入指定行的下一行\n                        if (isInsertNextRow) {\n                            afIndex_1 = Math.min(afterFullData.length, afIndex_1 + 1);\n                        }\n                        if (afIndex_1 === -1) {\n                            throw new Error(errLog('vxe.error.unableInsert'));\n                        }\n                        afterFullData.splice.apply(afterFullData, __spreadArray([afIndex_1, 0], newRecords, false));\n                        tableFullData.splice.apply(tableFullData, __spreadArray([$xetable.findRowIndexOf(tableFullData, row), 0], newRecords, false));\n                        // 刷新单元格合并\n                        mergeList.forEach(function (mergeItem) {\n                            var mergeRowIndex = mergeItem.row, mergeRowspan = mergeItem.rowspan;\n                            if (mergeRowIndex > afIndex_1) {\n                                mergeItem.row = mergeRowIndex + newRecords.length;\n                            }\n                            else if (mergeRowIndex + mergeRowspan > afIndex_1) {\n                                mergeItem.rowspan = mergeRowspan + newRecords.length;\n                            }\n                        });\n                    }\n                }\n            }\n            var insertMaps = editStore.insertMaps;\n            newRecords.forEach(function (newRow) {\n                var rowid = getRowid($xetable, newRow);\n                insertMaps[rowid] = newRow;\n            });\n            $xetable.cacheRowMap();\n            $xetable.updateScrollYStatus();\n            $xetable.handleTableData(treeConfig && transform);\n            if (!(treeConfig && transform)) {\n                $xetable.updateAfterDataIndex();\n            }\n            $xetable.updateFooter();\n            $xetable.checkSelectionStatus();\n            if (reactData.scrollYLoad) {\n                $xetable.updateScrollYSpace();\n            }\n            return nextTick().then(function () {\n                $xetable.updateCellAreas();\n                return $xetable.recalculate();\n            }).then(function () {\n                return {\n                    row: newRecords.length ? newRecords[newRecords.length - 1] : null,\n                    rows: newRecords\n                };\n            });\n        };\n        editMethods = {\n            /**\n             * 往表格中插入临时数据\n             *\n             * @param {*} records\n             */\n            insert: function (records) {\n                return handleInsertRowAt(records, null);\n            },\n            /**\n             * 往表格指定行中插入临时数据\n             * 如果 row 为空则从插入到顶部，如果为树结构，则插入到目标节点顶部\n             * 如果 row 为 -1 则从插入到底部，如果为树结构，则插入到目标节点底部\n             * 如果 row 为有效行则插入到该行的位置，如果为树结构，则有插入到效的目标节点该行的位置\n             * @param {Object/Array} records 新的数据\n             * @param {Row} row 指定行\n             */\n            insertAt: function (records, row) {\n                return handleInsertRowAt(records, row);\n            },\n            insertNextAt: function (records, row) {\n                return handleInsertRowAt(records, row, true);\n            },\n            /**\n             * 删除指定行数据\n             * 如果传 row 则删除一行\n             * 如果传 rows 则删除多行\n             * 如果为空则删除所有\n             */\n            remove: function (rows) {\n                var treeConfig = props.treeConfig;\n                var mergeList = reactData.mergeList, editStore = reactData.editStore, selectCheckboxMaps = reactData.selectCheckboxMaps;\n                var tableFullTreeData = internalData.tableFullTreeData, afterFullData = internalData.afterFullData, tableFullData = internalData.tableFullData;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var treeOpts = computeTreeOpts.value;\n                var transform = treeOpts.transform, mapChildrenField = treeOpts.mapChildrenField;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var actived = editStore.actived, removeMaps = editStore.removeMaps, insertMaps = editStore.insertMaps;\n                var checkField = checkboxOpts.checkField;\n                var delList = [];\n                if (!rows) {\n                    rows = tableFullData;\n                }\n                else if (!XEUtils.isArray(rows)) {\n                    rows = [rows];\n                }\n                // 如果是新增，则保存记录\n                rows.forEach(function (row) {\n                    if (!$xetable.isInsertByRow(row)) {\n                        var rowid = getRowid($xetable, row);\n                        removeMaps[rowid] = row;\n                    }\n                });\n                // 如果绑定了多选属性，则更新状态\n                if (!checkField) {\n                    var selectRowMaps_1 = __assign({}, selectCheckboxMaps);\n                    rows.forEach(function (row) {\n                        var rowid = getRowid($xetable, row);\n                        if (selectRowMaps_1[rowid]) {\n                            delete selectRowMaps_1[rowid];\n                        }\n                    });\n                    reactData.selectCheckboxMaps = selectRowMaps_1;\n                }\n                // 从数据源中移除\n                if (tableFullData === rows) {\n                    rows = delList = tableFullData.slice(0);\n                    internalData.tableFullData = [];\n                    internalData.afterFullData = [];\n                    $xetable.clearMergeCells();\n                }\n                else {\n                    // 如果为虚拟树\n                    if (treeConfig && transform) {\n                        rows.forEach(function (row) {\n                            var rowid = getRowid($xetable, row);\n                            var matchMapObj = XEUtils.findTree(tableFullTreeData, function (item) { return rowid === getRowid($xetable, item); }, { children: mapChildrenField });\n                            if (matchMapObj) {\n                                var rItems = matchMapObj.items.splice(matchMapObj.index, 1);\n                                delList.push(rItems[0]);\n                            }\n                            var matchObj = XEUtils.findTree(tableFullTreeData, function (item) { return rowid === getRowid($xetable, item); }, { children: childrenField });\n                            if (matchObj) {\n                                matchObj.items.splice(matchObj.index, 1);\n                            }\n                            var afIndex = $xetable.findRowIndexOf(afterFullData, row);\n                            if (afIndex > -1) {\n                                afterFullData.splice(afIndex, 1);\n                            }\n                        });\n                    }\n                    else {\n                        rows.forEach(function (row) {\n                            var tfIndex = $xetable.findRowIndexOf(tableFullData, row);\n                            if (tfIndex > -1) {\n                                var rItems = tableFullData.splice(tfIndex, 1);\n                                delList.push(rItems[0]);\n                            }\n                            var afIndex = $xetable.findRowIndexOf(afterFullData, row);\n                            if (afIndex > -1) {\n                                // 刷新单元格合并\n                                mergeList.forEach(function (mergeItem) {\n                                    var mergeRowIndex = mergeItem.row, mergeRowspan = mergeItem.rowspan;\n                                    if (mergeRowIndex > afIndex) {\n                                        mergeItem.row = mergeRowIndex - 1;\n                                    }\n                                    else if (mergeRowIndex + mergeRowspan > afIndex) {\n                                        mergeItem.rowspan = mergeRowspan - 1;\n                                    }\n                                });\n                                afterFullData.splice(afIndex, 1);\n                            }\n                        });\n                    }\n                }\n                // 如果当前行被激活编辑，则清除激活状态\n                if (actived.row && $xetable.findRowIndexOf(rows, actived.row) > -1) {\n                    editMethods.clearEdit();\n                }\n                // 从新增中移除已删除的数据\n                rows.forEach(function (row) {\n                    var rowid = getRowid($xetable, row);\n                    if (insertMaps[rowid]) {\n                        delete insertMaps[rowid];\n                    }\n                });\n                $xetable.updateFooter();\n                $xetable.cacheRowMap();\n                $xetable.handleTableData(treeConfig && transform);\n                if (!(treeConfig && transform)) {\n                    $xetable.updateAfterDataIndex();\n                }\n                $xetable.checkSelectionStatus();\n                if (reactData.scrollYLoad) {\n                    $xetable.updateScrollYSpace();\n                }\n                return nextTick().then(function () {\n                    $xetable.updateCellAreas();\n                    return $xetable.recalculate();\n                }).then(function () {\n                    return { row: delList.length ? delList[delList.length - 1] : null, rows: delList };\n                });\n            },\n            /**\n             * 删除复选框选中的数据\n             */\n            removeCheckboxRow: function () {\n                return editMethods.remove($xetable.getCheckboxRecords()).then(function (params) {\n                    $xetable.clearCheckboxRow();\n                    return params;\n                });\n            },\n            /**\n             * 删除单选框选中的数据\n             */\n            removeRadioRow: function () {\n                var radioRecord = $xetable.getRadioRecord();\n                return editMethods.remove(radioRecord || []).then(function (params) {\n                    $xetable.clearRadioRow();\n                    return params;\n                });\n            },\n            /**\n             * 删除当前行选中的数据\n             */\n            removeCurrentRow: function () {\n                var currentRecord = $xetable.getCurrentRecord();\n                return editMethods.remove(currentRecord || []).then(function (params) {\n                    $xetable.clearCurrentRow();\n                    return params;\n                });\n            },\n            /**\n             * 获取表格数据集，包含新增、删除、修改、标记\n             */\n            getRecordset: function () {\n                return {\n                    insertRecords: editMethods.getInsertRecords(),\n                    removeRecords: editMethods.getRemoveRecords(),\n                    updateRecords: editMethods.getUpdateRecords(),\n                    pendingRecords: $xetable.getPendingRecords()\n                };\n            },\n            /**\n             * 获取新增的临时数据\n             */\n            getInsertRecords: function () {\n                var editStore = reactData.editStore;\n                var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                var insertMaps = editStore.insertMaps;\n                var insertRecords = [];\n                XEUtils.each(insertMaps, function (row, rowid) {\n                    if (fullAllDataRowIdData[rowid]) {\n                        insertRecords.push(row);\n                    }\n                });\n                return insertRecords;\n            },\n            /**\n             * 获取已删除的数据\n             */\n            getRemoveRecords: function () {\n                var editStore = reactData.editStore;\n                var removeMaps = editStore.removeMaps;\n                var removeRecords = [];\n                XEUtils.each(removeMaps, function (row) {\n                    removeRecords.push(row);\n                });\n                return removeRecords;\n            },\n            /**\n             * 获取更新数据\n             * 只精准匹配 row 的更改\n             * 如果是树表格，子节点更改状态不会影响父节点的更新状态\n             */\n            getUpdateRecords: function () {\n                var keepSource = props.keepSource, treeConfig = props.treeConfig;\n                var tableFullData = internalData.tableFullData;\n                var treeOpts = computeTreeOpts.value;\n                if (keepSource) {\n                    syncActivedCell();\n                    if (treeConfig) {\n                        return XEUtils.filterTree(tableFullData, function (row) { return $xetable.isUpdateByRow(row); }, treeOpts);\n                    }\n                    return tableFullData.filter(function (row) { return $xetable.isUpdateByRow(row); });\n                }\n                return [];\n            },\n            getActiveRecord: function () {\n                return this.getEditRecord();\n            },\n            getEditRecord: function () {\n                var editStore = reactData.editStore;\n                var afterFullData = internalData.afterFullData;\n                var el = refElem.value;\n                var _a = editStore.actived, args = _a.args, row = _a.row;\n                if (args && $xetable.findRowIndexOf(afterFullData, row) > -1 && el.querySelectorAll('.vxe-body--column.col--active').length) {\n                    return Object.assign({}, args);\n                }\n                return null;\n            },\n            /**\n             * 获取选中的单元格\n             */\n            getSelectedCell: function () {\n                var editStore = reactData.editStore;\n                var _a = editStore.selected, args = _a.args, column = _a.column;\n                if (args && column) {\n                    return Object.assign({}, args);\n                }\n                return null;\n            },\n            clearActived: function (evnt) {\n                // if (process.env.NODE_ENV === 'development') {\n                //   warnLog('vxe.error.delFunc', ['clearActived', 'clearEdit'])\n                // }\n                // 即将废弃\n                return this.clearEdit(evnt);\n            },\n            /**\n             * 清除激活的编辑\n             */\n            clearEdit: function (evnt) {\n                var editStore = reactData.editStore;\n                var actived = editStore.actived;\n                var row = actived.row, column = actived.column;\n                if (row || column) {\n                    syncActivedCell();\n                    actived.args = null;\n                    actived.row = null;\n                    actived.column = null;\n                    $xetable.updateFooter();\n                    $xetable.dispatchEvent('edit-closed', {\n                        row: row,\n                        rowIndex: $xetable.getRowIndex(row),\n                        $rowIndex: $xetable.getVMRowIndex(row),\n                        column: column,\n                        columnIndex: $xetable.getColumnIndex(column),\n                        $columnIndex: $xetable.getVMColumnIndex(column)\n                    }, evnt || null);\n                }\n                if (GlobalConfig.cellVaildMode === 'obsolete') {\n                    if ($xetable.clearValidate) {\n                        return $xetable.clearValidate();\n                    }\n                }\n                return nextTick();\n            },\n            /**\n             * 清除所选中源状态\n             */\n            clearSelected: function () {\n                var editStore = reactData.editStore;\n                var selected = editStore.selected;\n                selected.row = null;\n                selected.column = null;\n                removeCellSelectedClass();\n                return nextTick();\n            },\n            isActiveByRow: function (row) {\n                // if (process.env.NODE_ENV === 'development') {\n                //   warnLog('vxe.error.delFunc', ['isActiveByRow', 'isEditByRow'])\n                // }\n                // 即将废弃\n                return this.isEditByRow(row);\n            },\n            /**\n             * 判断行是否为激活编辑状态\n             * @param {Row} row 行对象\n             */\n            isEditByRow: function (row) {\n                var editStore = reactData.editStore;\n                return editStore.actived.row === row;\n            },\n            setActiveRow: function (row) {\n                // if (process.env.NODE_ENV === 'development') {\n                //   warnLog('vxe.error.delFunc', ['setActiveRow', 'setEditRow'])\n                // }\n                // 即将废弃\n                return editMethods.setEditRow(row);\n            },\n            /**\n             * 激活行编辑\n             */\n            setEditRow: function (row, fieldOrColumn) {\n                var visibleColumn = internalData.visibleColumn;\n                var column = XEUtils.find(visibleColumn, function (column) { return isEnableConf(column.editRender); });\n                if (fieldOrColumn) {\n                    column = XEUtils.isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;\n                }\n                return $xetable.setEditCell(row, column);\n            },\n            setActiveCell: function (row, fieldOrColumn) {\n                // if (process.env.NODE_ENV === 'development') {\n                //   warnLog('vxe.error.delFunc', ['setActiveCell', 'setEditCell'])\n                // }\n                // 即将废弃\n                return editMethods.setEditCell(row, fieldOrColumn);\n            },\n            /**\n             * 激活单元格编辑\n             */\n            setEditCell: function (row, fieldOrColumn) {\n                var editConfig = props.editConfig;\n                var column = XEUtils.isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;\n                if (row && column && isEnableConf(editConfig) && isEnableConf(column.editRender)) {\n                    return $xetable.scrollToRow(row, column).then(function () {\n                        var cell = $xetable.getCell(row, column);\n                        if (cell) {\n                            editPrivateMethods.handleActived({\n                                row: row,\n                                rowIndex: $xetable.getRowIndex(row),\n                                column: column,\n                                columnIndex: $xetable.getColumnIndex(column),\n                                cell: cell,\n                                $table: $xetable\n                            });\n                            internalData._lastCallTime = Date.now();\n                        }\n                        return nextTick();\n                    });\n                }\n                return nextTick();\n            },\n            /**\n             * 只对 trigger=dblclick 有效，选中单元格\n             */\n            setSelectCell: function (row, fieldOrColumn) {\n                var tableData = reactData.tableData;\n                var editOpts = computeEditOpts.value;\n                var column = XEUtils.isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;\n                if (row && column && editOpts.trigger !== 'manual') {\n                    var rowIndex = $xetable.findRowIndexOf(tableData, row);\n                    if (rowIndex > -1 && column) {\n                        var cell = $xetable.getCell(row, column);\n                        var params = {\n                            row: row,\n                            rowIndex: rowIndex,\n                            column: column,\n                            columnIndex: $xetable.getColumnIndex(column),\n                            cell: cell\n                        };\n                        $xetable.handleSelected(params, {});\n                    }\n                }\n                return nextTick();\n            }\n        };\n        editPrivateMethods = {\n            /**\n             * 处理激活编辑\n             */\n            handleActived: function (params, evnt) {\n                var editConfig = props.editConfig, mouseConfig = props.mouseConfig;\n                var editStore = reactData.editStore, tableColumn = reactData.tableColumn;\n                var editOpts = computeEditOpts.value;\n                var mode = editOpts.mode;\n                var actived = editStore.actived;\n                var row = params.row, column = params.column;\n                var editRender = column.editRender;\n                var cell = (params.cell || $xetable.getCell(row, column));\n                var beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;\n                params.cell = cell;\n                if (isEnableConf(editConfig) && isEnableConf(editRender) && !$xetable.hasPendingByRow(row) && cell) {\n                    if (actived.row !== row || (mode === 'cell' ? actived.column !== column : false)) {\n                        // 判断是否禁用编辑\n                        var type = 'edit-disabled';\n                        if (!beforeEditMethod || beforeEditMethod(__assign(__assign({}, params), { $table: $xetable, $grid: $xetable.xegrid }))) {\n                            if (mouseConfig) {\n                                editMethods.clearSelected();\n                                if ($xetable.clearCellAreas) {\n                                    $xetable.clearCellAreas();\n                                    $xetable.clearCopyCellArea();\n                                }\n                            }\n                            $xetable.closeTooltip();\n                            if (actived.column) {\n                                editMethods.clearEdit(evnt);\n                            }\n                            type = 'edit-activated';\n                            column.renderHeight = cell.offsetHeight;\n                            actived.args = params;\n                            actived.row = row;\n                            actived.column = column;\n                            if (mode === 'row') {\n                                tableColumn.forEach(function (column) { return getEditColumnModel(row, column); });\n                            }\n                            else {\n                                getEditColumnModel(row, column);\n                            }\n                            nextTick(function () {\n                                editPrivateMethods.handleFocus(params, evnt);\n                            });\n                        }\n                        $xetable.dispatchEvent(type, {\n                            row: row,\n                            rowIndex: $xetable.getRowIndex(row),\n                            $rowIndex: $xetable.getVMRowIndex(row),\n                            column: column,\n                            columnIndex: $xetable.getColumnIndex(column),\n                            $columnIndex: $xetable.getVMColumnIndex(column)\n                        }, evnt);\n                        // v4已废弃\n                        if (type === 'edit-activated') {\n                            $xetable.dispatchEvent('edit-actived', {\n                                row: row,\n                                rowIndex: $xetable.getRowIndex(row),\n                                $rowIndex: $xetable.getVMRowIndex(row),\n                                column: column,\n                                columnIndex: $xetable.getColumnIndex(column),\n                                $columnIndex: $xetable.getVMColumnIndex(column)\n                            }, evnt);\n                        }\n                    }\n                    else {\n                        var oldColumn = actived.column;\n                        if (mouseConfig) {\n                            editMethods.clearSelected();\n                            if ($xetable.clearCellAreas) {\n                                $xetable.clearCellAreas();\n                                $xetable.clearCopyCellArea();\n                            }\n                        }\n                        if (oldColumn !== column) {\n                            var oldModel = oldColumn.model;\n                            if (oldModel.update) {\n                                setCellValue(row, oldColumn, oldModel.value);\n                            }\n                            if ($xetable.clearValidate) {\n                                $xetable.clearValidate(row, column);\n                            }\n                        }\n                        column.renderHeight = cell.offsetHeight;\n                        actived.args = params;\n                        actived.column = column;\n                        setTimeout(function () {\n                            editPrivateMethods.handleFocus(params, evnt);\n                        });\n                    }\n                    $xetable.focus();\n                }\n                return nextTick();\n            },\n            /**\n             * 处理聚焦\n             */\n            handleFocus: function (params) {\n                var row = params.row, column = params.column, cell = params.cell;\n                var editRender = column.editRender;\n                if (isEnableConf(editRender)) {\n                    var compRender = renderer.get(editRender.name);\n                    var autofocus = editRender.autofocus, autoselect = editRender.autoselect;\n                    var inputElem = void 0;\n                    if (!autofocus && compRender) {\n                        autofocus = compRender.autofocus;\n                    }\n                    if (!autoselect && compRender) {\n                        autoselect = compRender.autoselect;\n                    }\n                    // 如果指定了聚焦 class\n                    if (XEUtils.isFunction(autofocus)) {\n                        inputElem = autofocus.call(this, params);\n                    }\n                    else if (autofocus) {\n                        inputElem = cell.querySelector(autofocus);\n                        if (inputElem) {\n                            inputElem.focus();\n                        }\n                    }\n                    if (inputElem) {\n                        if (autoselect) {\n                            inputElem.select();\n                        }\n                        else {\n                            // 保持一致行为，光标移到末端\n                            if (browse.msie) {\n                                var textRange = inputElem.createTextRange();\n                                textRange.collapse(false);\n                                textRange.select();\n                            }\n                        }\n                    }\n                    else {\n                        // 显示到可视区中\n                        $xetable.scrollToRow(row, column);\n                    }\n                }\n            },\n            /**\n             * 处理选中源\n             */\n            handleSelected: function (params, evnt) {\n                var mouseConfig = props.mouseConfig;\n                var editStore = reactData.editStore;\n                var mouseOpts = computeMouseOpts.value;\n                var editOpts = computeEditOpts.value;\n                var actived = editStore.actived, selected = editStore.selected;\n                var row = params.row, column = params.column;\n                var isMouseSelected = mouseConfig && mouseOpts.selected;\n                var selectMethod = function () {\n                    if (isMouseSelected && (selected.row !== row || selected.column !== column)) {\n                        if (actived.row !== row || (editOpts.mode === 'cell' ? actived.column !== column : false)) {\n                            editMethods.clearEdit(evnt);\n                            editMethods.clearSelected();\n                            if ($xetable.clearCellAreas) {\n                                $xetable.clearCellAreas();\n                                $xetable.clearCopyCellArea();\n                            }\n                            selected.args = params;\n                            selected.row = row;\n                            selected.column = column;\n                            if (isMouseSelected) {\n                                editPrivateMethods.addCellSelectedClass();\n                            }\n                            $xetable.focus();\n                            if (evnt) {\n                                $xetable.dispatchEvent('cell-selected', params, evnt);\n                            }\n                        }\n                    }\n                    return nextTick();\n                };\n                return selectMethod();\n            },\n            addCellSelectedClass: function () {\n                var editStore = reactData.editStore;\n                var selected = editStore.selected;\n                var row = selected.row, column = selected.column;\n                removeCellSelectedClass();\n                if (row && column) {\n                    var cell = $xetable.getCell(row, column);\n                    if (cell) {\n                        addClass(cell, 'col--selected');\n                    }\n                }\n            }\n        };\n        return __assign(__assign({}, editMethods), editPrivateMethods);\n    },\n    setupGrid: function ($xegrid) {\n        return $xegrid.extendTableMethods(tableEditMethodKeys);\n    }\n};\nexport default editHook;\n",
      "start": 1714699767752,
      "end": 1714699767752,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "esbuild",
      "start": 1714699767752,
      "end": 1714699767752,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "var __assign = function() {\n  __assign = Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s)\n        if (Object.prototype.hasOwnProperty.call(s, p))\n          t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __spreadArray = function(to, from, pack) {\n  if (pack || arguments.length === 2)\n    for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n        if (!ar)\n          ar = Array.prototype.slice.call(from, 0, i);\n        ar[i] = from[i];\n      }\n    }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { reactive, nextTick } from \"vue\";\nimport XEUtils from \"xe-utils\";\nimport GlobalConfig from \"../../v-x-e-table/src/conf\";\nimport { renderer } from \"../../v-x-e-table\";\nimport { isEnableConf } from \"../../tools/utils\";\nimport { getCellValue, setCellValue, getRowid } from \"../../table/src/util\";\nimport { browse, removeClass, addClass } from \"../../tools/dom\";\nimport { warnLog, errLog, getLog } from \"../../tools/log\";\nvar tableEditMethodKeys = [\"insert\", \"insertAt\", \"insertNextAt\", \"remove\", \"removeCheckboxRow\", \"removeRadioRow\", \"removeCurrentRow\", \"getRecordset\", \"getInsertRecords\", \"getRemoveRecords\", \"getUpdateRecords\", \"getEditRecord\", \"getActiveRecord\", \"getSelectedCell\", \"clearEdit\", \"clearActived\", \"clearSelected\", \"isEditByRow\", \"isActiveByRow\", \"setEditRow\", \"setActiveRow\", \"setEditCell\", \"setActiveCell\", \"setSelectCell\"];\nvar editHook = {\n  setupTable: function($xetable) {\n    var props = $xetable.props, reactData = $xetable.reactData, internalData = $xetable.internalData;\n    var refElem = $xetable.getRefMaps().refElem;\n    var _a = $xetable.getComputeMaps(), computeMouseOpts = _a.computeMouseOpts, computeEditOpts = _a.computeEditOpts, computeCheckboxOpts = _a.computeCheckboxOpts, computeTreeOpts = _a.computeTreeOpts;\n    var editMethods = {};\n    var editPrivateMethods = {};\n    var getEditColumnModel = function(row, column) {\n      var model = column.model, editRender = column.editRender;\n      if (editRender) {\n        model.value = getCellValue(row, column);\n        model.update = false;\n      }\n    };\n    var setEditColumnModel = function(row, column) {\n      var model = column.model, editRender = column.editRender;\n      if (editRender && model.update) {\n        setCellValue(row, column, model.value);\n        model.update = false;\n        model.value = null;\n      }\n    };\n    var removeCellSelectedClass = function() {\n      var el = refElem.value;\n      if (el) {\n        var cell = el.querySelector(\".col--selected\");\n        if (cell) {\n          removeClass(cell, \"col--selected\");\n        }\n      }\n    };\n    function syncActivedCell() {\n      var editStore = reactData.editStore, tableColumn = reactData.tableColumn;\n      var editOpts = computeEditOpts.value;\n      var actived = editStore.actived;\n      var row = actived.row, column = actived.column;\n      if (row || column) {\n        if (editOpts.mode === \"row\") {\n          tableColumn.forEach(function(column2) {\n            return setEditColumnModel(row, column2);\n          });\n        } else {\n          setEditColumnModel(row, column);\n        }\n      }\n    }\n    function insertTreeRow(newRecords, isAppend) {\n      var tableFullTreeData = internalData.tableFullTreeData, afterFullData = internalData.afterFullData, fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n      var treeOpts = computeTreeOpts.value;\n      var rowField = treeOpts.rowField, parentField = treeOpts.parentField, mapChildrenField = treeOpts.mapChildrenField;\n      var childrenField = treeOpts.children || treeOpts.childrenField;\n      var funcName = isAppend ? \"push\" : \"unshift\";\n      newRecords.forEach(function(item) {\n        var parentRowId = item[parentField];\n        var rowid = getRowid($xetable, item);\n        var matchObj = parentRowId ? XEUtils.findTree(tableFullTreeData, function(item2) {\n          return parentRowId === item2[rowField];\n        }, { children: mapChildrenField }) : null;\n        if (matchObj) {\n          var parentRow = matchObj.item;\n          var parentRest = fullAllDataRowIdData[getRowid($xetable, parentRow)];\n          var parentLevel = parentRest ? parentRest.level : 0;\n          var parentChilds = parentRow[childrenField];\n          var mapChilds = parentRow[mapChildrenField];\n          if (!XEUtils.isArray(parentChilds)) {\n            parentChilds = parentRow[childrenField] = [];\n          }\n          if (!XEUtils.isArray(mapChilds)) {\n            mapChilds = parentRow[childrenField] = [];\n          }\n          parentChilds[funcName](item);\n          mapChilds[funcName](item);\n          var rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, items: parentChilds, parent: parentRow, level: parentLevel + 1 };\n          fullDataRowIdData[rowid] = rest;\n          fullAllDataRowIdData[rowid] = rest;\n        } else {\n          if (false) {\n            if (parentRowId) {\n              warnLog(\"vxe.error.unableInsert\");\n            }\n          }\n          afterFullData[funcName](item);\n          tableFullTreeData[funcName](item);\n          var rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, items: tableFullTreeData, parent: null, level: 0 };\n          fullDataRowIdData[rowid] = rest;\n          fullAllDataRowIdData[rowid] = rest;\n        }\n      });\n    }\n    var handleInsertRowAt = function(records, row, isInsertNextRow) {\n      var treeConfig = props.treeConfig;\n      var mergeList = reactData.mergeList, editStore = reactData.editStore;\n      var tableFullTreeData = internalData.tableFullTreeData, afterFullData = internalData.afterFullData, tableFullData = internalData.tableFullData, fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n      var treeOpts = computeTreeOpts.value;\n      var transform = treeOpts.transform, rowField = treeOpts.rowField, mapChildrenField = treeOpts.mapChildrenField;\n      var childrenField = treeOpts.children || treeOpts.childrenField;\n      if (!XEUtils.isArray(records)) {\n        records = [records];\n      }\n      var newRecords = reactive($xetable.defineField(records.map(function(record) {\n        var _a2;\n        return Object.assign(treeConfig && transform ? (_a2 = {}, _a2[mapChildrenField] = [], _a2[childrenField] = [], _a2) : {}, record);\n      })));\n      if (XEUtils.eqNull(row)) {\n        if (treeConfig && transform) {\n          insertTreeRow(newRecords, false);\n        } else {\n          afterFullData.unshift.apply(afterFullData, newRecords);\n          tableFullData.unshift.apply(tableFullData, newRecords);\n          mergeList.forEach(function(mergeItem) {\n            var mergeRowIndex = mergeItem.row;\n            if (mergeRowIndex > 0) {\n              mergeItem.row = mergeRowIndex + newRecords.length;\n            }\n          });\n        }\n      } else {\n        if (row === -1) {\n          if (treeConfig && transform) {\n            insertTreeRow(newRecords, true);\n          } else {\n            afterFullData.push.apply(afterFullData, newRecords);\n            tableFullData.push.apply(tableFullData, newRecords);\n            mergeList.forEach(function(mergeItem) {\n              var mergeRowIndex = mergeItem.row, mergeRowspan = mergeItem.rowspan;\n              if (mergeRowIndex + mergeRowspan > afterFullData.length) {\n                mergeItem.rowspan = mergeRowspan + newRecords.length;\n              }\n            });\n          }\n        } else {\n          if (treeConfig && transform) {\n            var matchMapObj_1 = XEUtils.findTree(tableFullTreeData, function(item) {\n              return row[rowField] === item[rowField];\n            }, { children: mapChildrenField });\n            if (matchMapObj_1) {\n              var parentRow_1 = matchMapObj_1.parent;\n              var parentMapChilds_1 = parentRow_1 ? parentRow_1[mapChildrenField] : tableFullTreeData;\n              var parentRest = fullAllDataRowIdData[getRowid($xetable, parentRow_1)];\n              var parentLevel_1 = parentRest ? parentRest.level : 0;\n              newRecords.forEach(function(item, i) {\n                var rowid = getRowid($xetable, item);\n                if (false) {\n                  if (item[treeOpts.parentField]) {\n                    if (parentRow_1 && item[treeOpts.parentField] !== parentRow_1[rowField]) {\n                      errLog(\"vxe.error.errProp\", [\"\".concat(treeOpts.parentField, \"=\").concat(item[treeOpts.parentField]), \"\".concat(treeOpts.parentField, \"=\").concat(parentRow_1[rowField])]);\n                    }\n                  }\n                }\n                if (parentRow_1) {\n                  item[treeOpts.parentField] = parentRow_1[rowField];\n                }\n                var targetIndex2 = matchMapObj_1.index + i;\n                if (isInsertNextRow) {\n                  targetIndex2 = targetIndex2 + 1;\n                }\n                parentMapChilds_1.splice(targetIndex2, 0, item);\n                var rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, items: parentMapChilds_1, parent: parentRow_1, level: parentLevel_1 + 1 };\n                fullDataRowIdData[rowid] = rest;\n                fullAllDataRowIdData[rowid] = rest;\n              });\n              if (parentRow_1) {\n                var matchObj = XEUtils.findTree(tableFullTreeData, function(item) {\n                  return row[rowField] === item[rowField];\n                }, { children: childrenField });\n                if (matchObj) {\n                  var parentChilds = matchObj.items;\n                  var targetIndex = matchObj.index;\n                  if (isInsertNextRow) {\n                    targetIndex = targetIndex + 1;\n                  }\n                  parentChilds.splice.apply(parentChilds, __spreadArray([targetIndex, 0], newRecords, false));\n                }\n              }\n            } else {\n              if (false) {\n                warnLog(\"vxe.error.unableInsert\");\n              }\n              insertTreeRow(newRecords, true);\n            }\n          } else {\n            if (treeConfig) {\n              throw new Error(getLog(\"vxe.error.noTree\", [\"insert\"]));\n            }\n            var afIndex_1 = -1;\n            if (XEUtils.isNumber(row)) {\n              if (row < afterFullData.length) {\n                afIndex_1 = row;\n              }\n            } else {\n              afIndex_1 = $xetable.findRowIndexOf(afterFullData, row);\n            }\n            if (isInsertNextRow) {\n              afIndex_1 = Math.min(afterFullData.length, afIndex_1 + 1);\n            }\n            if (afIndex_1 === -1) {\n              throw new Error(errLog(\"vxe.error.unableInsert\"));\n            }\n            afterFullData.splice.apply(afterFullData, __spreadArray([afIndex_1, 0], newRecords, false));\n            tableFullData.splice.apply(tableFullData, __spreadArray([$xetable.findRowIndexOf(tableFullData, row), 0], newRecords, false));\n            mergeList.forEach(function(mergeItem) {\n              var mergeRowIndex = mergeItem.row, mergeRowspan = mergeItem.rowspan;\n              if (mergeRowIndex > afIndex_1) {\n                mergeItem.row = mergeRowIndex + newRecords.length;\n              } else if (mergeRowIndex + mergeRowspan > afIndex_1) {\n                mergeItem.rowspan = mergeRowspan + newRecords.length;\n              }\n            });\n          }\n        }\n      }\n      var insertMaps = editStore.insertMaps;\n      newRecords.forEach(function(newRow) {\n        var rowid = getRowid($xetable, newRow);\n        insertMaps[rowid] = newRow;\n      });\n      $xetable.cacheRowMap();\n      $xetable.updateScrollYStatus();\n      $xetable.handleTableData(treeConfig && transform);\n      if (!(treeConfig && transform)) {\n        $xetable.updateAfterDataIndex();\n      }\n      $xetable.updateFooter();\n      $xetable.checkSelectionStatus();\n      if (reactData.scrollYLoad) {\n        $xetable.updateScrollYSpace();\n      }\n      return nextTick().then(function() {\n        $xetable.updateCellAreas();\n        return $xetable.recalculate();\n      }).then(function() {\n        return {\n          row: newRecords.length ? newRecords[newRecords.length - 1] : null,\n          rows: newRecords\n        };\n      });\n    };\n    editMethods = {\n      /**\n       * 往表格中插入临时数据\n       *\n       * @param {*} records\n       */\n      insert: function(records) {\n        return handleInsertRowAt(records, null);\n      },\n      /**\n       * 往表格指定行中插入临时数据\n       * 如果 row 为空则从插入到顶部，如果为树结构，则插入到目标节点顶部\n       * 如果 row 为 -1 则从插入到底部，如果为树结构，则插入到目标节点底部\n       * 如果 row 为有效行则插入到该行的位置，如果为树结构，则有插入到效的目标节点该行的位置\n       * @param {Object/Array} records 新的数据\n       * @param {Row} row 指定行\n       */\n      insertAt: function(records, row) {\n        return handleInsertRowAt(records, row);\n      },\n      insertNextAt: function(records, row) {\n        return handleInsertRowAt(records, row, true);\n      },\n      /**\n       * 删除指定行数据\n       * 如果传 row 则删除一行\n       * 如果传 rows 则删除多行\n       * 如果为空则删除所有\n       */\n      remove: function(rows) {\n        var treeConfig = props.treeConfig;\n        var mergeList = reactData.mergeList, editStore = reactData.editStore, selectCheckboxMaps = reactData.selectCheckboxMaps;\n        var tableFullTreeData = internalData.tableFullTreeData, afterFullData = internalData.afterFullData, tableFullData = internalData.tableFullData;\n        var checkboxOpts = computeCheckboxOpts.value;\n        var treeOpts = computeTreeOpts.value;\n        var transform = treeOpts.transform, mapChildrenField = treeOpts.mapChildrenField;\n        var childrenField = treeOpts.children || treeOpts.childrenField;\n        var actived = editStore.actived, removeMaps = editStore.removeMaps, insertMaps = editStore.insertMaps;\n        var checkField = checkboxOpts.checkField;\n        var delList = [];\n        if (!rows) {\n          rows = tableFullData;\n        } else if (!XEUtils.isArray(rows)) {\n          rows = [rows];\n        }\n        rows.forEach(function(row) {\n          if (!$xetable.isInsertByRow(row)) {\n            var rowid = getRowid($xetable, row);\n            removeMaps[rowid] = row;\n          }\n        });\n        if (!checkField) {\n          var selectRowMaps_1 = __assign({}, selectCheckboxMaps);\n          rows.forEach(function(row) {\n            var rowid = getRowid($xetable, row);\n            if (selectRowMaps_1[rowid]) {\n              delete selectRowMaps_1[rowid];\n            }\n          });\n          reactData.selectCheckboxMaps = selectRowMaps_1;\n        }\n        if (tableFullData === rows) {\n          rows = delList = tableFullData.slice(0);\n          internalData.tableFullData = [];\n          internalData.afterFullData = [];\n          $xetable.clearMergeCells();\n        } else {\n          if (treeConfig && transform) {\n            rows.forEach(function(row) {\n              var rowid = getRowid($xetable, row);\n              var matchMapObj = XEUtils.findTree(tableFullTreeData, function(item) {\n                return rowid === getRowid($xetable, item);\n              }, { children: mapChildrenField });\n              if (matchMapObj) {\n                var rItems = matchMapObj.items.splice(matchMapObj.index, 1);\n                delList.push(rItems[0]);\n              }\n              var matchObj = XEUtils.findTree(tableFullTreeData, function(item) {\n                return rowid === getRowid($xetable, item);\n              }, { children: childrenField });\n              if (matchObj) {\n                matchObj.items.splice(matchObj.index, 1);\n              }\n              var afIndex = $xetable.findRowIndexOf(afterFullData, row);\n              if (afIndex > -1) {\n                afterFullData.splice(afIndex, 1);\n              }\n            });\n          } else {\n            rows.forEach(function(row) {\n              var tfIndex = $xetable.findRowIndexOf(tableFullData, row);\n              if (tfIndex > -1) {\n                var rItems = tableFullData.splice(tfIndex, 1);\n                delList.push(rItems[0]);\n              }\n              var afIndex = $xetable.findRowIndexOf(afterFullData, row);\n              if (afIndex > -1) {\n                mergeList.forEach(function(mergeItem) {\n                  var mergeRowIndex = mergeItem.row, mergeRowspan = mergeItem.rowspan;\n                  if (mergeRowIndex > afIndex) {\n                    mergeItem.row = mergeRowIndex - 1;\n                  } else if (mergeRowIndex + mergeRowspan > afIndex) {\n                    mergeItem.rowspan = mergeRowspan - 1;\n                  }\n                });\n                afterFullData.splice(afIndex, 1);\n              }\n            });\n          }\n        }\n        if (actived.row && $xetable.findRowIndexOf(rows, actived.row) > -1) {\n          editMethods.clearEdit();\n        }\n        rows.forEach(function(row) {\n          var rowid = getRowid($xetable, row);\n          if (insertMaps[rowid]) {\n            delete insertMaps[rowid];\n          }\n        });\n        $xetable.updateFooter();\n        $xetable.cacheRowMap();\n        $xetable.handleTableData(treeConfig && transform);\n        if (!(treeConfig && transform)) {\n          $xetable.updateAfterDataIndex();\n        }\n        $xetable.checkSelectionStatus();\n        if (reactData.scrollYLoad) {\n          $xetable.updateScrollYSpace();\n        }\n        return nextTick().then(function() {\n          $xetable.updateCellAreas();\n          return $xetable.recalculate();\n        }).then(function() {\n          return { row: delList.length ? delList[delList.length - 1] : null, rows: delList };\n        });\n      },\n      /**\n       * 删除复选框选中的数据\n       */\n      removeCheckboxRow: function() {\n        return editMethods.remove($xetable.getCheckboxRecords()).then(function(params) {\n          $xetable.clearCheckboxRow();\n          return params;\n        });\n      },\n      /**\n       * 删除单选框选中的数据\n       */\n      removeRadioRow: function() {\n        var radioRecord = $xetable.getRadioRecord();\n        return editMethods.remove(radioRecord || []).then(function(params) {\n          $xetable.clearRadioRow();\n          return params;\n        });\n      },\n      /**\n       * 删除当前行选中的数据\n       */\n      removeCurrentRow: function() {\n        var currentRecord = $xetable.getCurrentRecord();\n        return editMethods.remove(currentRecord || []).then(function(params) {\n          $xetable.clearCurrentRow();\n          return params;\n        });\n      },\n      /**\n       * 获取表格数据集，包含新增、删除、修改、标记\n       */\n      getRecordset: function() {\n        return {\n          insertRecords: editMethods.getInsertRecords(),\n          removeRecords: editMethods.getRemoveRecords(),\n          updateRecords: editMethods.getUpdateRecords(),\n          pendingRecords: $xetable.getPendingRecords()\n        };\n      },\n      /**\n       * 获取新增的临时数据\n       */\n      getInsertRecords: function() {\n        var editStore = reactData.editStore;\n        var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n        var insertMaps = editStore.insertMaps;\n        var insertRecords = [];\n        XEUtils.each(insertMaps, function(row, rowid) {\n          if (fullAllDataRowIdData[rowid]) {\n            insertRecords.push(row);\n          }\n        });\n        return insertRecords;\n      },\n      /**\n       * 获取已删除的数据\n       */\n      getRemoveRecords: function() {\n        var editStore = reactData.editStore;\n        var removeMaps = editStore.removeMaps;\n        var removeRecords = [];\n        XEUtils.each(removeMaps, function(row) {\n          removeRecords.push(row);\n        });\n        return removeRecords;\n      },\n      /**\n       * 获取更新数据\n       * 只精准匹配 row 的更改\n       * 如果是树表格，子节点更改状态不会影响父节点的更新状态\n       */\n      getUpdateRecords: function() {\n        var keepSource = props.keepSource, treeConfig = props.treeConfig;\n        var tableFullData = internalData.tableFullData;\n        var treeOpts = computeTreeOpts.value;\n        if (keepSource) {\n          syncActivedCell();\n          if (treeConfig) {\n            return XEUtils.filterTree(tableFullData, function(row) {\n              return $xetable.isUpdateByRow(row);\n            }, treeOpts);\n          }\n          return tableFullData.filter(function(row) {\n            return $xetable.isUpdateByRow(row);\n          });\n        }\n        return [];\n      },\n      getActiveRecord: function() {\n        return this.getEditRecord();\n      },\n      getEditRecord: function() {\n        var editStore = reactData.editStore;\n        var afterFullData = internalData.afterFullData;\n        var el = refElem.value;\n        var _a2 = editStore.actived, args = _a2.args, row = _a2.row;\n        if (args && $xetable.findRowIndexOf(afterFullData, row) > -1 && el.querySelectorAll(\".vxe-body--column.col--active\").length) {\n          return Object.assign({}, args);\n        }\n        return null;\n      },\n      /**\n       * 获取选中的单元格\n       */\n      getSelectedCell: function() {\n        var editStore = reactData.editStore;\n        var _a2 = editStore.selected, args = _a2.args, column = _a2.column;\n        if (args && column) {\n          return Object.assign({}, args);\n        }\n        return null;\n      },\n      clearActived: function(evnt) {\n        return this.clearEdit(evnt);\n      },\n      /**\n       * 清除激活的编辑\n       */\n      clearEdit: function(evnt) {\n        var editStore = reactData.editStore;\n        var actived = editStore.actived;\n        var row = actived.row, column = actived.column;\n        if (row || column) {\n          syncActivedCell();\n          actived.args = null;\n          actived.row = null;\n          actived.column = null;\n          $xetable.updateFooter();\n          $xetable.dispatchEvent(\"edit-closed\", {\n            row,\n            rowIndex: $xetable.getRowIndex(row),\n            $rowIndex: $xetable.getVMRowIndex(row),\n            column,\n            columnIndex: $xetable.getColumnIndex(column),\n            $columnIndex: $xetable.getVMColumnIndex(column)\n          }, evnt || null);\n        }\n        if (GlobalConfig.cellVaildMode === \"obsolete\") {\n          if ($xetable.clearValidate) {\n            return $xetable.clearValidate();\n          }\n        }\n        return nextTick();\n      },\n      /**\n       * 清除所选中源状态\n       */\n      clearSelected: function() {\n        var editStore = reactData.editStore;\n        var selected = editStore.selected;\n        selected.row = null;\n        selected.column = null;\n        removeCellSelectedClass();\n        return nextTick();\n      },\n      isActiveByRow: function(row) {\n        return this.isEditByRow(row);\n      },\n      /**\n       * 判断行是否为激活编辑状态\n       * @param {Row} row 行对象\n       */\n      isEditByRow: function(row) {\n        var editStore = reactData.editStore;\n        return editStore.actived.row === row;\n      },\n      setActiveRow: function(row) {\n        return editMethods.setEditRow(row);\n      },\n      /**\n       * 激活行编辑\n       */\n      setEditRow: function(row, fieldOrColumn) {\n        var visibleColumn = internalData.visibleColumn;\n        var column = XEUtils.find(visibleColumn, function(column2) {\n          return isEnableConf(column2.editRender);\n        });\n        if (fieldOrColumn) {\n          column = XEUtils.isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;\n        }\n        return $xetable.setEditCell(row, column);\n      },\n      setActiveCell: function(row, fieldOrColumn) {\n        return editMethods.setEditCell(row, fieldOrColumn);\n      },\n      /**\n       * 激活单元格编辑\n       */\n      setEditCell: function(row, fieldOrColumn) {\n        var editConfig = props.editConfig;\n        var column = XEUtils.isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;\n        if (row && column && isEnableConf(editConfig) && isEnableConf(column.editRender)) {\n          return $xetable.scrollToRow(row, column).then(function() {\n            var cell = $xetable.getCell(row, column);\n            if (cell) {\n              editPrivateMethods.handleActived({\n                row,\n                rowIndex: $xetable.getRowIndex(row),\n                column,\n                columnIndex: $xetable.getColumnIndex(column),\n                cell,\n                $table: $xetable\n              });\n              internalData._lastCallTime = Date.now();\n            }\n            return nextTick();\n          });\n        }\n        return nextTick();\n      },\n      /**\n       * 只对 trigger=dblclick 有效，选中单元格\n       */\n      setSelectCell: function(row, fieldOrColumn) {\n        var tableData = reactData.tableData;\n        var editOpts = computeEditOpts.value;\n        var column = XEUtils.isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;\n        if (row && column && editOpts.trigger !== \"manual\") {\n          var rowIndex = $xetable.findRowIndexOf(tableData, row);\n          if (rowIndex > -1 && column) {\n            var cell = $xetable.getCell(row, column);\n            var params = {\n              row,\n              rowIndex,\n              column,\n              columnIndex: $xetable.getColumnIndex(column),\n              cell\n            };\n            $xetable.handleSelected(params, {});\n          }\n        }\n        return nextTick();\n      }\n    };\n    editPrivateMethods = {\n      /**\n       * 处理激活编辑\n       */\n      handleActived: function(params, evnt) {\n        var editConfig = props.editConfig, mouseConfig = props.mouseConfig;\n        var editStore = reactData.editStore, tableColumn = reactData.tableColumn;\n        var editOpts = computeEditOpts.value;\n        var mode = editOpts.mode;\n        var actived = editStore.actived;\n        var row = params.row, column = params.column;\n        var editRender = column.editRender;\n        var cell = params.cell || $xetable.getCell(row, column);\n        var beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;\n        params.cell = cell;\n        if (isEnableConf(editConfig) && isEnableConf(editRender) && !$xetable.hasPendingByRow(row) && cell) {\n          if (actived.row !== row || (mode === \"cell\" ? actived.column !== column : false)) {\n            var type = \"edit-disabled\";\n            if (!beforeEditMethod || beforeEditMethod(__assign(__assign({}, params), { $table: $xetable, $grid: $xetable.xegrid }))) {\n              if (mouseConfig) {\n                editMethods.clearSelected();\n                if ($xetable.clearCellAreas) {\n                  $xetable.clearCellAreas();\n                  $xetable.clearCopyCellArea();\n                }\n              }\n              $xetable.closeTooltip();\n              if (actived.column) {\n                editMethods.clearEdit(evnt);\n              }\n              type = \"edit-activated\";\n              column.renderHeight = cell.offsetHeight;\n              actived.args = params;\n              actived.row = row;\n              actived.column = column;\n              if (mode === \"row\") {\n                tableColumn.forEach(function(column2) {\n                  return getEditColumnModel(row, column2);\n                });\n              } else {\n                getEditColumnModel(row, column);\n              }\n              nextTick(function() {\n                editPrivateMethods.handleFocus(params, evnt);\n              });\n            }\n            $xetable.dispatchEvent(type, {\n              row,\n              rowIndex: $xetable.getRowIndex(row),\n              $rowIndex: $xetable.getVMRowIndex(row),\n              column,\n              columnIndex: $xetable.getColumnIndex(column),\n              $columnIndex: $xetable.getVMColumnIndex(column)\n            }, evnt);\n            if (type === \"edit-activated\") {\n              $xetable.dispatchEvent(\"edit-actived\", {\n                row,\n                rowIndex: $xetable.getRowIndex(row),\n                $rowIndex: $xetable.getVMRowIndex(row),\n                column,\n                columnIndex: $xetable.getColumnIndex(column),\n                $columnIndex: $xetable.getVMColumnIndex(column)\n              }, evnt);\n            }\n          } else {\n            var oldColumn = actived.column;\n            if (mouseConfig) {\n              editMethods.clearSelected();\n              if ($xetable.clearCellAreas) {\n                $xetable.clearCellAreas();\n                $xetable.clearCopyCellArea();\n              }\n            }\n            if (oldColumn !== column) {\n              var oldModel = oldColumn.model;\n              if (oldModel.update) {\n                setCellValue(row, oldColumn, oldModel.value);\n              }\n              if ($xetable.clearValidate) {\n                $xetable.clearValidate(row, column);\n              }\n            }\n            column.renderHeight = cell.offsetHeight;\n            actived.args = params;\n            actived.column = column;\n            setTimeout(function() {\n              editPrivateMethods.handleFocus(params, evnt);\n            });\n          }\n          $xetable.focus();\n        }\n        return nextTick();\n      },\n      /**\n       * 处理聚焦\n       */\n      handleFocus: function(params) {\n        var row = params.row, column = params.column, cell = params.cell;\n        var editRender = column.editRender;\n        if (isEnableConf(editRender)) {\n          var compRender = renderer.get(editRender.name);\n          var autofocus = editRender.autofocus, autoselect = editRender.autoselect;\n          var inputElem = void 0;\n          if (!autofocus && compRender) {\n            autofocus = compRender.autofocus;\n          }\n          if (!autoselect && compRender) {\n            autoselect = compRender.autoselect;\n          }\n          if (XEUtils.isFunction(autofocus)) {\n            inputElem = autofocus.call(this, params);\n          } else if (autofocus) {\n            inputElem = cell.querySelector(autofocus);\n            if (inputElem) {\n              inputElem.focus();\n            }\n          }\n          if (inputElem) {\n            if (autoselect) {\n              inputElem.select();\n            } else {\n              if (browse.msie) {\n                var textRange = inputElem.createTextRange();\n                textRange.collapse(false);\n                textRange.select();\n              }\n            }\n          } else {\n            $xetable.scrollToRow(row, column);\n          }\n        }\n      },\n      /**\n       * 处理选中源\n       */\n      handleSelected: function(params, evnt) {\n        var mouseConfig = props.mouseConfig;\n        var editStore = reactData.editStore;\n        var mouseOpts = computeMouseOpts.value;\n        var editOpts = computeEditOpts.value;\n        var actived = editStore.actived, selected = editStore.selected;\n        var row = params.row, column = params.column;\n        var isMouseSelected = mouseConfig && mouseOpts.selected;\n        var selectMethod = function() {\n          if (isMouseSelected && (selected.row !== row || selected.column !== column)) {\n            if (actived.row !== row || (editOpts.mode === \"cell\" ? actived.column !== column : false)) {\n              editMethods.clearEdit(evnt);\n              editMethods.clearSelected();\n              if ($xetable.clearCellAreas) {\n                $xetable.clearCellAreas();\n                $xetable.clearCopyCellArea();\n              }\n              selected.args = params;\n              selected.row = row;\n              selected.column = column;\n              if (isMouseSelected) {\n                editPrivateMethods.addCellSelectedClass();\n              }\n              $xetable.focus();\n              if (evnt) {\n                $xetable.dispatchEvent(\"cell-selected\", params, evnt);\n              }\n            }\n          }\n          return nextTick();\n        };\n        return selectMethod();\n      },\n      addCellSelectedClass: function() {\n        var editStore = reactData.editStore;\n        var selected = editStore.selected;\n        var row = selected.row, column = selected.column;\n        removeCellSelectedClass();\n        if (row && column) {\n          var cell = $xetable.getCell(row, column);\n          if (cell) {\n            addClass(cell, \"col--selected\");\n          }\n        }\n      }\n    };\n    return __assign(__assign({}, editMethods), editPrivateMethods);\n  },\n  setupGrid: function($xegrid) {\n    return $xegrid.extendTableMethods(tableEditMethodKeys);\n  }\n};\nexport default editHook;\n",
      "start": 1714699767752,
      "end": 1714699768294,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-post",
      "start": 1714699768294,
      "end": 1714699768295,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1714699768295,
      "end": 1714699768295,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1714699768295,
      "end": 1714699768295,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1714699768295,
      "end": 1714699768295,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1714699768295,
      "end": 1714699768297,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1714699768297,
      "end": 1714699768297,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1714699768297,
      "end": 1714699768297,
      "order": "normal"
    },
    {
      "name": "unplugin-auto-import",
      "start": 1714699768297,
      "end": 1714699768297,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1714699768297,
      "end": 1714699768297,
      "order": "post"
    },
    {
      "name": "vite:style-import",
      "start": 1714699768297,
      "end": 1714699768297,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1714699768297,
      "end": 1714699768297,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1714699768297,
      "end": 1714699768297,
      "order": "normal"
    }
  ]
}
