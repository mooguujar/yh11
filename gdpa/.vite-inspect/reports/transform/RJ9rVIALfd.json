{
  "resolvedId": "/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/vant@4.8.4_vue@3.4.19/node_modules/vant/es/uploader/Uploader.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { withDirectives as _withDirectives, vShow as _vShow, createVNode as _createVNode, mergeProps as _mergeProps } from \"vue\";\nimport { ref, reactive, defineComponent, onBeforeUnmount, nextTick } from \"vue\";\nimport { pick, extend, toArray, isPromise, truthProp, getSizeStyle, makeArrayProp, makeStringProp, makeNumericProp } from \"../utils/index.mjs\";\nimport { bem, name, isOversize, filterFiles, isImageFile, readFileContent } from \"./utils.mjs\";\nimport { useCustomFieldValue } from \"@vant/use\";\nimport { useExpose } from \"../composables/use-expose.mjs\";\nimport { Icon } from \"../icon/index.mjs\";\nimport { showImagePreview } from \"../image-preview/index.mjs\";\nimport UploaderPreviewItem from \"./UploaderPreviewItem.mjs\";\nconst uploaderProps = {\n  name: makeNumericProp(\"\"),\n  accept: makeStringProp(\"image/*\"),\n  capture: String,\n  multiple: Boolean,\n  disabled: Boolean,\n  readonly: Boolean,\n  lazyLoad: Boolean,\n  maxCount: makeNumericProp(Infinity),\n  imageFit: makeStringProp(\"cover\"),\n  resultType: makeStringProp(\"dataUrl\"),\n  uploadIcon: makeStringProp(\"photograph\"),\n  uploadText: String,\n  deletable: truthProp,\n  reupload: Boolean,\n  afterRead: Function,\n  showUpload: truthProp,\n  modelValue: makeArrayProp(),\n  beforeRead: Function,\n  beforeDelete: Function,\n  previewSize: [Number, String, Array],\n  previewImage: truthProp,\n  previewOptions: Object,\n  previewFullImage: truthProp,\n  maxSize: {\n    type: [Number, String, Function],\n    default: Infinity\n  }\n};\nvar stdin_default = defineComponent({\n  name,\n  props: uploaderProps,\n  emits: [\"delete\", \"oversize\", \"clickUpload\", \"closePreview\", \"clickPreview\", \"clickReupload\", \"update:modelValue\"],\n  setup(props, {\n    emit,\n    slots\n  }) {\n    const inputRef = ref();\n    const urls = [];\n    const reuploadIndex = ref(-1);\n    const isReuploading = ref(false);\n    const getDetail = (index = props.modelValue.length) => ({\n      name: props.name,\n      index\n    });\n    const resetInput = () => {\n      if (inputRef.value) {\n        inputRef.value.value = \"\";\n      }\n    };\n    const onAfterRead = (items) => {\n      resetInput();\n      if (isOversize(items, props.maxSize)) {\n        if (Array.isArray(items)) {\n          const result = filterFiles(items, props.maxSize);\n          items = result.valid;\n          emit(\"oversize\", result.invalid, getDetail());\n          if (!items.length) {\n            return;\n          }\n        } else {\n          emit(\"oversize\", items, getDetail());\n          return;\n        }\n      }\n      items = reactive(items);\n      if (reuploadIndex.value > -1) {\n        const arr = [...props.modelValue];\n        arr.splice(reuploadIndex.value, 1, items);\n        emit(\"update:modelValue\", arr);\n        reuploadIndex.value = -1;\n      } else {\n        emit(\"update:modelValue\", [...props.modelValue, ...toArray(items)]);\n      }\n      if (props.afterRead) {\n        props.afterRead(items, getDetail());\n      }\n    };\n    const readFile = (files) => {\n      const {\n        maxCount,\n        modelValue,\n        resultType\n      } = props;\n      if (Array.isArray(files)) {\n        const remainCount = +maxCount - modelValue.length;\n        if (files.length > remainCount) {\n          files = files.slice(0, remainCount);\n        }\n        Promise.all(files.map((file) => readFileContent(file, resultType))).then((contents) => {\n          const fileList = files.map((file, index) => {\n            const result = {\n              file,\n              status: \"\",\n              message: \"\",\n              objectUrl: URL.createObjectURL(file)\n            };\n            if (contents[index]) {\n              result.content = contents[index];\n            }\n            return result;\n          });\n          onAfterRead(fileList);\n        });\n      } else {\n        readFileContent(files, resultType).then((content) => {\n          const result = {\n            file: files,\n            status: \"\",\n            message: \"\",\n            objectUrl: URL.createObjectURL(files)\n          };\n          if (content) {\n            result.content = content;\n          }\n          onAfterRead(result);\n        });\n      }\n    };\n    const onChange = (event) => {\n      const {\n        files\n      } = event.target;\n      if (props.disabled || !files || !files.length) {\n        return;\n      }\n      const file = files.length === 1 ? files[0] : [].slice.call(files);\n      if (props.beforeRead) {\n        const response = props.beforeRead(file, getDetail());\n        if (!response) {\n          resetInput();\n          return;\n        }\n        if (isPromise(response)) {\n          response.then((data) => {\n            if (data) {\n              readFile(data);\n            } else {\n              readFile(file);\n            }\n          }).catch(resetInput);\n          return;\n        }\n      }\n      readFile(file);\n    };\n    let imagePreview;\n    const onClosePreview = () => emit(\"closePreview\");\n    const previewImage = (item) => {\n      if (props.previewFullImage) {\n        const imageFiles = props.modelValue.filter(isImageFile);\n        const images = imageFiles.map((item2) => {\n          if (item2.objectUrl && !item2.url && item2.status !== \"failed\") {\n            item2.url = item2.objectUrl;\n            urls.push(item2.url);\n          }\n          return item2.url;\n        }).filter(Boolean);\n        imagePreview = showImagePreview(extend({\n          images,\n          startPosition: imageFiles.indexOf(item),\n          onClose: onClosePreview\n        }, props.previewOptions));\n      }\n    };\n    const closeImagePreview = () => {\n      if (imagePreview) {\n        imagePreview.close();\n      }\n    };\n    const deleteFile = (item, index) => {\n      const fileList = props.modelValue.slice(0);\n      fileList.splice(index, 1);\n      emit(\"update:modelValue\", fileList);\n      emit(\"delete\", item, getDetail(index));\n    };\n    const reuploadImage = (index) => {\n      isReuploading.value = true;\n      reuploadIndex.value = index;\n      nextTick(() => chooseFile());\n    };\n    const onInputClick = () => {\n      if (!isReuploading.value) {\n        reuploadIndex.value = -1;\n      }\n      isReuploading.value = false;\n    };\n    const renderPreviewItem = (item, index) => {\n      const needPickData = [\"imageFit\", \"deletable\", \"reupload\", \"previewSize\", \"beforeDelete\"];\n      const previewData = extend(pick(props, needPickData), pick(item, needPickData, true));\n      return _createVNode(UploaderPreviewItem, _mergeProps({\n        \"item\": item,\n        \"index\": index,\n        \"onClick\": () => emit(props.reupload ? \"clickReupload\" : \"clickPreview\", item, getDetail(index)),\n        \"onDelete\": () => deleteFile(item, index),\n        \"onPreview\": () => previewImage(item),\n        \"onReupload\": () => reuploadImage(index)\n      }, pick(props, [\"name\", \"lazyLoad\"]), previewData), pick(slots, [\"preview-cover\", \"preview-delete\"]));\n    };\n    const renderPreviewList = () => {\n      if (props.previewImage) {\n        return props.modelValue.map(renderPreviewItem);\n      }\n    };\n    const onClickUpload = (event) => emit(\"clickUpload\", event);\n    const renderUpload = () => {\n      if (props.modelValue.length >= +props.maxCount && !props.reupload) {\n        return;\n      }\n      const hideUploader = props.modelValue.length >= +props.maxCount && props.reupload;\n      const Input = props.readonly ? null : _createVNode(\"input\", {\n        \"ref\": inputRef,\n        \"type\": \"file\",\n        \"class\": bem(\"input\"),\n        \"accept\": props.accept,\n        \"capture\": props.capture,\n        \"multiple\": props.multiple && reuploadIndex.value === -1,\n        \"disabled\": props.disabled,\n        \"onChange\": onChange,\n        \"onClick\": onInputClick\n      }, null);\n      if (slots.default) {\n        return _withDirectives(_createVNode(\"div\", {\n          \"class\": bem(\"input-wrapper\"),\n          \"onClick\": onClickUpload\n        }, [slots.default(), Input]), [[_vShow, !hideUploader]]);\n      }\n      return _withDirectives(_createVNode(\"div\", {\n        \"class\": bem(\"upload\", {\n          readonly: props.readonly\n        }),\n        \"style\": getSizeStyle(props.previewSize),\n        \"onClick\": onClickUpload\n      }, [_createVNode(Icon, {\n        \"name\": props.uploadIcon,\n        \"class\": bem(\"upload-icon\")\n      }, null), props.uploadText && _createVNode(\"span\", {\n        \"class\": bem(\"upload-text\")\n      }, [props.uploadText]), Input]), [[_vShow, props.showUpload && !hideUploader]]);\n    };\n    const chooseFile = () => {\n      if (inputRef.value && !props.disabled) {\n        inputRef.value.click();\n      }\n    };\n    onBeforeUnmount(() => {\n      urls.forEach((url) => URL.revokeObjectURL(url));\n    });\n    useExpose({\n      chooseFile,\n      closeImagePreview\n    });\n    useCustomFieldValue(() => props.modelValue);\n    return () => _createVNode(\"div\", {\n      \"class\": bem()\n    }, [_createVNode(\"div\", {\n      \"class\": bem(\"wrapper\", {\n        disabled: props.disabled\n      })\n    }, [renderPreviewList(), renderUpload()])]);\n  }\n});\nexport {\n  stdin_default as default,\n  uploaderProps\n};\n",
      "start": 1714699767721,
      "end": 1714699767733,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "normal"
    },
    {
      "name": "vite-plugin-vconsole",
      "result": "import { withDirectives as _withDirectives, vShow as _vShow, createVNode as _createVNode, mergeProps as _mergeProps } from \"vue\";\nimport { ref, reactive, defineComponent, onBeforeUnmount, nextTick } from \"vue\";\nimport { pick, extend, toArray, isPromise, truthProp, getSizeStyle, makeArrayProp, makeStringProp, makeNumericProp } from \"../utils/index.mjs\";\nimport { bem, name, isOversize, filterFiles, isImageFile, readFileContent } from \"./utils.mjs\";\nimport { useCustomFieldValue } from \"@vant/use\";\nimport { useExpose } from \"../composables/use-expose.mjs\";\nimport { Icon } from \"../icon/index.mjs\";\nimport { showImagePreview } from \"../image-preview/index.mjs\";\nimport UploaderPreviewItem from \"./UploaderPreviewItem.mjs\";\nconst uploaderProps = {\n  name: makeNumericProp(\"\"),\n  accept: makeStringProp(\"image/*\"),\n  capture: String,\n  multiple: Boolean,\n  disabled: Boolean,\n  readonly: Boolean,\n  lazyLoad: Boolean,\n  maxCount: makeNumericProp(Infinity),\n  imageFit: makeStringProp(\"cover\"),\n  resultType: makeStringProp(\"dataUrl\"),\n  uploadIcon: makeStringProp(\"photograph\"),\n  uploadText: String,\n  deletable: truthProp,\n  reupload: Boolean,\n  afterRead: Function,\n  showUpload: truthProp,\n  modelValue: makeArrayProp(),\n  beforeRead: Function,\n  beforeDelete: Function,\n  previewSize: [Number, String, Array],\n  previewImage: truthProp,\n  previewOptions: Object,\n  previewFullImage: truthProp,\n  maxSize: {\n    type: [Number, String, Function],\n    default: Infinity\n  }\n};\nvar stdin_default = defineComponent({\n  name,\n  props: uploaderProps,\n  emits: [\"delete\", \"oversize\", \"clickUpload\", \"closePreview\", \"clickPreview\", \"clickReupload\", \"update:modelValue\"],\n  setup(props, {\n    emit,\n    slots\n  }) {\n    const inputRef = ref();\n    const urls = [];\n    const reuploadIndex = ref(-1);\n    const isReuploading = ref(false);\n    const getDetail = (index = props.modelValue.length) => ({\n      name: props.name,\n      index\n    });\n    const resetInput = () => {\n      if (inputRef.value) {\n        inputRef.value.value = \"\";\n      }\n    };\n    const onAfterRead = (items) => {\n      resetInput();\n      if (isOversize(items, props.maxSize)) {\n        if (Array.isArray(items)) {\n          const result = filterFiles(items, props.maxSize);\n          items = result.valid;\n          emit(\"oversize\", result.invalid, getDetail());\n          if (!items.length) {\n            return;\n          }\n        } else {\n          emit(\"oversize\", items, getDetail());\n          return;\n        }\n      }\n      items = reactive(items);\n      if (reuploadIndex.value > -1) {\n        const arr = [...props.modelValue];\n        arr.splice(reuploadIndex.value, 1, items);\n        emit(\"update:modelValue\", arr);\n        reuploadIndex.value = -1;\n      } else {\n        emit(\"update:modelValue\", [...props.modelValue, ...toArray(items)]);\n      }\n      if (props.afterRead) {\n        props.afterRead(items, getDetail());\n      }\n    };\n    const readFile = (files) => {\n      const {\n        maxCount,\n        modelValue,\n        resultType\n      } = props;\n      if (Array.isArray(files)) {\n        const remainCount = +maxCount - modelValue.length;\n        if (files.length > remainCount) {\n          files = files.slice(0, remainCount);\n        }\n        Promise.all(files.map((file) => readFileContent(file, resultType))).then((contents) => {\n          const fileList = files.map((file, index) => {\n            const result = {\n              file,\n              status: \"\",\n              message: \"\",\n              objectUrl: URL.createObjectURL(file)\n            };\n            if (contents[index]) {\n              result.content = contents[index];\n            }\n            return result;\n          });\n          onAfterRead(fileList);\n        });\n      } else {\n        readFileContent(files, resultType).then((content) => {\n          const result = {\n            file: files,\n            status: \"\",\n            message: \"\",\n            objectUrl: URL.createObjectURL(files)\n          };\n          if (content) {\n            result.content = content;\n          }\n          onAfterRead(result);\n        });\n      }\n    };\n    const onChange = (event) => {\n      const {\n        files\n      } = event.target;\n      if (props.disabled || !files || !files.length) {\n        return;\n      }\n      const file = files.length === 1 ? files[0] : [].slice.call(files);\n      if (props.beforeRead) {\n        const response = props.beforeRead(file, getDetail());\n        if (!response) {\n          resetInput();\n          return;\n        }\n        if (isPromise(response)) {\n          response.then((data) => {\n            if (data) {\n              readFile(data);\n            } else {\n              readFile(file);\n            }\n          }).catch(resetInput);\n          return;\n        }\n      }\n      readFile(file);\n    };\n    let imagePreview;\n    const onClosePreview = () => emit(\"closePreview\");\n    const previewImage = (item) => {\n      if (props.previewFullImage) {\n        const imageFiles = props.modelValue.filter(isImageFile);\n        const images = imageFiles.map((item2) => {\n          if (item2.objectUrl && !item2.url && item2.status !== \"failed\") {\n            item2.url = item2.objectUrl;\n            urls.push(item2.url);\n          }\n          return item2.url;\n        }).filter(Boolean);\n        imagePreview = showImagePreview(extend({\n          images,\n          startPosition: imageFiles.indexOf(item),\n          onClose: onClosePreview\n        }, props.previewOptions));\n      }\n    };\n    const closeImagePreview = () => {\n      if (imagePreview) {\n        imagePreview.close();\n      }\n    };\n    const deleteFile = (item, index) => {\n      const fileList = props.modelValue.slice(0);\n      fileList.splice(index, 1);\n      emit(\"update:modelValue\", fileList);\n      emit(\"delete\", item, getDetail(index));\n    };\n    const reuploadImage = (index) => {\n      isReuploading.value = true;\n      reuploadIndex.value = index;\n      nextTick(() => chooseFile());\n    };\n    const onInputClick = () => {\n      if (!isReuploading.value) {\n        reuploadIndex.value = -1;\n      }\n      isReuploading.value = false;\n    };\n    const renderPreviewItem = (item, index) => {\n      const needPickData = [\"imageFit\", \"deletable\", \"reupload\", \"previewSize\", \"beforeDelete\"];\n      const previewData = extend(pick(props, needPickData), pick(item, needPickData, true));\n      return _createVNode(UploaderPreviewItem, _mergeProps({\n        \"item\": item,\n        \"index\": index,\n        \"onClick\": () => emit(props.reupload ? \"clickReupload\" : \"clickPreview\", item, getDetail(index)),\n        \"onDelete\": () => deleteFile(item, index),\n        \"onPreview\": () => previewImage(item),\n        \"onReupload\": () => reuploadImage(index)\n      }, pick(props, [\"name\", \"lazyLoad\"]), previewData), pick(slots, [\"preview-cover\", \"preview-delete\"]));\n    };\n    const renderPreviewList = () => {\n      if (props.previewImage) {\n        return props.modelValue.map(renderPreviewItem);\n      }\n    };\n    const onClickUpload = (event) => emit(\"clickUpload\", event);\n    const renderUpload = () => {\n      if (props.modelValue.length >= +props.maxCount && !props.reupload) {\n        return;\n      }\n      const hideUploader = props.modelValue.length >= +props.maxCount && props.reupload;\n      const Input = props.readonly ? null : _createVNode(\"input\", {\n        \"ref\": inputRef,\n        \"type\": \"file\",\n        \"class\": bem(\"input\"),\n        \"accept\": props.accept,\n        \"capture\": props.capture,\n        \"multiple\": props.multiple && reuploadIndex.value === -1,\n        \"disabled\": props.disabled,\n        \"onChange\": onChange,\n        \"onClick\": onInputClick\n      }, null);\n      if (slots.default) {\n        return _withDirectives(_createVNode(\"div\", {\n          \"class\": bem(\"input-wrapper\"),\n          \"onClick\": onClickUpload\n        }, [slots.default(), Input]), [[_vShow, !hideUploader]]);\n      }\n      return _withDirectives(_createVNode(\"div\", {\n        \"class\": bem(\"upload\", {\n          readonly: props.readonly\n        }),\n        \"style\": getSizeStyle(props.previewSize),\n        \"onClick\": onClickUpload\n      }, [_createVNode(Icon, {\n        \"name\": props.uploadIcon,\n        \"class\": bem(\"upload-icon\")\n      }, null), props.uploadText && _createVNode(\"span\", {\n        \"class\": bem(\"upload-text\")\n      }, [props.uploadText]), Input]), [[_vShow, props.showUpload && !hideUploader]]);\n    };\n    const chooseFile = () => {\n      if (inputRef.value && !props.disabled) {\n        inputRef.value.click();\n      }\n    };\n    onBeforeUnmount(() => {\n      urls.forEach((url) => URL.revokeObjectURL(url));\n    });\n    useExpose({\n      chooseFile,\n      closeImagePreview\n    });\n    useCustomFieldValue(() => props.modelValue);\n    return () => _createVNode(\"div\", {\n      \"class\": bem()\n    }, [_createVNode(\"div\", {\n      \"class\": bem(\"wrapper\", {\n        disabled: props.disabled\n      })\n    }, [renderPreviewList(), renderUpload()])]);\n  }\n});\nexport {\n  stdin_default as default,\n  uploaderProps\n};\n",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "esbuild",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "normal"
    },
    {
      "name": "unplugin-auto-import",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "post"
    },
    {
      "name": "vite:style-import",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1714699767733,
      "end": 1714699767733,
      "order": "normal"
    }
  ]
}
