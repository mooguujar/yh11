{
  "resolvedId": "/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/vxe-table@4.5.21_vue@3.4.19_xe-utils@3.5.24/node_modules/vxe-table/es/export/src/hook.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { inject, nextTick } from 'vue';\nimport XEUtils from 'xe-utils';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport { VXETable } from '../../v-x-e-table';\nimport { isColumnInfo, mergeBodyMethod, getCellValue } from '../../table/src/util';\nimport { parseFile, formatText } from '../../tools/utils';\nimport { warnLog, errLog } from '../../tools/log';\nimport { readLocalFile, handlePrint, saveLocalFile, createHtmlPage, getExportBlobByContent } from './util';\nvar htmlCellElem;\nvar csvBOM = '\\ufeff';\nvar enterSymbol = '\\r\\n';\nfunction defaultFilterExportColumn(column) {\n    return column.property || ['seq', 'checkbox', 'radio'].indexOf(column.type) > -1;\n}\nvar getConvertColumns = function (columns) {\n    var result = [];\n    columns.forEach(function (column) {\n        if (column.childNodes && column.childNodes.length) {\n            result.push(column);\n            result.push.apply(result, getConvertColumns(column.childNodes));\n        }\n        else {\n            result.push(column);\n        }\n    });\n    return result;\n};\nvar convertToRows = function (originColumns) {\n    var maxLevel = 1;\n    var traverse = function (column, parent) {\n        if (parent) {\n            column._level = parent._level + 1;\n            if (maxLevel < column._level) {\n                maxLevel = column._level;\n            }\n        }\n        if (column.childNodes && column.childNodes.length) {\n            var colSpan_1 = 0;\n            column.childNodes.forEach(function (subColumn) {\n                traverse(subColumn, column);\n                colSpan_1 += subColumn._colSpan;\n            });\n            column._colSpan = colSpan_1;\n        }\n        else {\n            column._colSpan = 1;\n        }\n    };\n    originColumns.forEach(function (column) {\n        column._level = 1;\n        traverse(column);\n    });\n    var rows = [];\n    for (var i = 0; i < maxLevel; i++) {\n        rows.push([]);\n    }\n    var allColumns = getConvertColumns(originColumns);\n    allColumns.forEach(function (column) {\n        if (column.childNodes && column.childNodes.length) {\n            column._rowSpan = 1;\n        }\n        else {\n            column._rowSpan = maxLevel - column._level + 1;\n        }\n        rows[column._level - 1].push(column);\n    });\n    return rows;\n};\nfunction toTableBorder(border) {\n    if (border === true) {\n        return 'full';\n    }\n    if (border) {\n        return border;\n    }\n    return 'default';\n}\nfunction getBooleanValue(cellValue) {\n    return cellValue === 'TRUE' || cellValue === 'true' || cellValue === true;\n}\nfunction getFooterData(opts, footerTableData) {\n    var footerFilterMethod = opts.footerFilterMethod;\n    return footerFilterMethod ? footerTableData.filter(function (items, index) { return footerFilterMethod({ items: items, $rowIndex: index }); }) : footerTableData;\n}\nfunction getCsvCellTypeLabel(column, cellValue) {\n    if (cellValue) {\n        if (column.type === 'seq') {\n            return \"\\t\".concat(cellValue);\n        }\n        switch (column.cellType) {\n            case 'string':\n                if (!isNaN(cellValue)) {\n                    return \"\\t\".concat(cellValue);\n                }\n                break;\n            case 'number':\n                break;\n            default:\n                if (cellValue.length >= 12 && !isNaN(cellValue)) {\n                    return \"\\t\".concat(cellValue);\n                }\n                break;\n        }\n    }\n    return cellValue;\n}\nfunction toTxtCellLabel(val) {\n    if (/[\",\\s\\n]/.test(val)) {\n        return \"\\\"\".concat(val.replace(/\"/g, '\"\"'), \"\\\"\");\n    }\n    return val;\n}\nfunction getElementsByTagName(elem, qualifiedName) {\n    return elem.getElementsByTagName(qualifiedName);\n}\nfunction getTxtCellKey(now) {\n    return \"#\".concat(now, \"@\").concat(XEUtils.uniqueId());\n}\nfunction replaceTxtCell(cell, vMaps) {\n    return cell.replace(/#\\d+@\\d+/g, function (key) { return XEUtils.hasOwnProp(vMaps, key) ? vMaps[key] : key; });\n}\nfunction getTxtCellValue(val, vMaps) {\n    var rest = replaceTxtCell(val, vMaps);\n    return rest.replace(/^\"+$/g, function (qVal) { return '\"'.repeat(Math.ceil(qVal.length / 2)); });\n}\nfunction parseCsvAndTxt(columns, content, cellSeparator) {\n    var list = content.split(enterSymbol);\n    var rows = [];\n    var fields = [];\n    if (list.length) {\n        var vMaps_1 = {};\n        var now_1 = Date.now();\n        list.forEach(function (rVal) {\n            if (rVal) {\n                var item_1 = {};\n                rVal = rVal.replace(/(\"\")|(\\n)/g, function (text, dVal) {\n                    var key = getTxtCellKey(now_1);\n                    vMaps_1[key] = dVal ? '\"' : '\\n';\n                    return key;\n                }).replace(/\"(.*?)\"/g, function (text, cVal) {\n                    var key = getTxtCellKey(now_1);\n                    vMaps_1[key] = replaceTxtCell(cVal, vMaps_1);\n                    return key;\n                });\n                var cells = rVal.split(cellSeparator);\n                if (!fields.length) {\n                    fields = cells.map(function (val) { return getTxtCellValue(val.trim(), vMaps_1); });\n                }\n                else {\n                    cells.forEach(function (val, colIndex) {\n                        if (colIndex < fields.length) {\n                            item_1[fields[colIndex]] = getTxtCellValue(val.trim(), vMaps_1);\n                        }\n                    });\n                    rows.push(item_1);\n                }\n            }\n        });\n    }\n    return { fields: fields, rows: rows };\n}\nfunction parseCsv(columns, content) {\n    return parseCsvAndTxt(columns, content, ',');\n}\nfunction parseTxt(columns, content) {\n    return parseCsvAndTxt(columns, content, '\\t');\n}\nfunction parseHTML(columns, content) {\n    var domParser = new DOMParser();\n    var xmlDoc = domParser.parseFromString(content, 'text/html');\n    var bodyNodes = getElementsByTagName(xmlDoc, 'body');\n    var rows = [];\n    var fields = [];\n    if (bodyNodes.length) {\n        var tableNodes = getElementsByTagName(bodyNodes[0], 'table');\n        if (tableNodes.length) {\n            var theadNodes = getElementsByTagName(tableNodes[0], 'thead');\n            if (theadNodes.length) {\n                XEUtils.arrayEach(getElementsByTagName(theadNodes[0], 'tr'), function (rowNode) {\n                    XEUtils.arrayEach(getElementsByTagName(rowNode, 'th'), function (cellNode) {\n                        fields.push(cellNode.textContent);\n                    });\n                });\n                var tbodyNodes = getElementsByTagName(tableNodes[0], 'tbody');\n                if (tbodyNodes.length) {\n                    XEUtils.arrayEach(getElementsByTagName(tbodyNodes[0], 'tr'), function (rowNode) {\n                        var item = {};\n                        XEUtils.arrayEach(getElementsByTagName(rowNode, 'td'), function (cellNode, colIndex) {\n                            if (fields[colIndex]) {\n                                item[fields[colIndex]] = cellNode.textContent || '';\n                            }\n                        });\n                        rows.push(item);\n                    });\n                }\n            }\n        }\n    }\n    return { fields: fields, rows: rows };\n}\nfunction parseXML(columns, content) {\n    var domParser = new DOMParser();\n    var xmlDoc = domParser.parseFromString(content, 'application/xml');\n    var sheetNodes = getElementsByTagName(xmlDoc, 'Worksheet');\n    var rows = [];\n    var fields = [];\n    if (sheetNodes.length) {\n        var tableNodes = getElementsByTagName(sheetNodes[0], 'Table');\n        if (tableNodes.length) {\n            var rowNodes = getElementsByTagName(tableNodes[0], 'Row');\n            if (rowNodes.length) {\n                XEUtils.arrayEach(getElementsByTagName(rowNodes[0], 'Cell'), function (cellNode) {\n                    fields.push(cellNode.textContent);\n                });\n                XEUtils.arrayEach(rowNodes, function (rowNode, index) {\n                    if (index) {\n                        var item_2 = {};\n                        var cellNodes = getElementsByTagName(rowNode, 'Cell');\n                        XEUtils.arrayEach(cellNodes, function (cellNode, colIndex) {\n                            if (fields[colIndex]) {\n                                item_2[fields[colIndex]] = cellNode.textContent;\n                            }\n                        });\n                        rows.push(item_2);\n                    }\n                });\n            }\n        }\n    }\n    return { fields: fields, rows: rows };\n}\nfunction clearColumnConvert(columns) {\n    XEUtils.eachTree(columns, function (column) {\n        delete column._level;\n        delete column._colSpan;\n        delete column._rowSpan;\n        delete column._children;\n        delete column.childNodes;\n    }, { children: 'children' });\n}\n/**\n * 检查导入的列是否完整\n * @param {Array} fields 字段名列表\n * @param {Array} rows 数据列表\n */\nfunction checkImportData(columns, fields) {\n    var tableFields = [];\n    columns.forEach(function (column) {\n        var field = column.property;\n        if (field) {\n            tableFields.push(field);\n        }\n    });\n    return fields.some(function (field) { return tableFields.indexOf(field) > -1; });\n}\nvar tableExportMethodKeys = ['exportData', 'importByFile', 'importData', 'saveFile', 'readFile', 'print', 'openImport', 'openExport', 'openPrint'];\nvar tableExportHook = {\n    setupTable: function ($xetable) {\n        var props = $xetable.props, reactData = $xetable.reactData, internalData = $xetable.internalData;\n        var _a = $xetable.getComputeMaps(), computeTreeOpts = _a.computeTreeOpts, computePrintOpts = _a.computePrintOpts, computeExportOpts = _a.computeExportOpts, computeImportOpts = _a.computeImportOpts, computeCustomOpts = _a.computeCustomOpts, computeSeqOpts = _a.computeSeqOpts, computeRadioOpts = _a.computeRadioOpts, computeCheckboxOpts = _a.computeCheckboxOpts, computeColumnOpts = _a.computeColumnOpts;\n        var $xegrid = inject('$xegrid', null);\n        var hasTreeChildren = function (row) {\n            var treeOpts = computeTreeOpts.value;\n            var childrenField = treeOpts.children || treeOpts.childrenField;\n            return row[childrenField] && row[childrenField].length;\n        };\n        var getSeq = function (row, $rowIndex, column, $columnIndex) {\n            var seqOpts = computeSeqOpts.value;\n            var seqMethod = seqOpts.seqMethod || column.seqMethod;\n            if (seqMethod) {\n                return seqMethod({\n                    row: row,\n                    rowIndex: $xetable.getRowIndex(row),\n                    $rowIndex: $rowIndex,\n                    column: column,\n                    columnIndex: $xetable.getColumnIndex(column),\n                    $columnIndex: $columnIndex\n                });\n            }\n            return $xetable.getRowSeq(row);\n        };\n        function getHeaderTitle(opts, column) {\n            var columnOpts = computeColumnOpts.value;\n            var headExportMethod = column.headerExportMethod || columnOpts.headerExportMethod;\n            return headExportMethod ? headExportMethod({ column: column, options: opts, $table: $xetable }) : ((opts.original ? column.property : column.getTitle()) || '');\n        }\n        var toBooleanValue = function (cellValue) {\n            return XEUtils.isBoolean(cellValue) ? (cellValue ? 'TRUE' : 'FALSE') : cellValue;\n        };\n        var getLabelData = function (opts, columns, datas) {\n            var isAllExpand = opts.isAllExpand, mode = opts.mode;\n            var treeConfig = props.treeConfig;\n            var radioOpts = computeRadioOpts.value;\n            var checkboxOpts = computeCheckboxOpts.value;\n            var treeOpts = computeTreeOpts.value;\n            var columnOpts = computeColumnOpts.value;\n            if (!htmlCellElem) {\n                htmlCellElem = document.createElement('div');\n            }\n            if (treeConfig) {\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                // 如果是树表格只允许导出数据源\n                var rest_1 = [];\n                var expandMaps_1 = new Map();\n                XEUtils.eachTree(datas, function (item, $rowIndex, items, path, parent, nodes) {\n                    var row = item._row || item;\n                    var parentRow = parent && parent._row ? parent._row : parent;\n                    if ((isAllExpand || !parentRow || (expandMaps_1.has(parentRow) && $xetable.isTreeExpandByRow(parentRow)))) {\n                        var hasRowChild = hasTreeChildren(row);\n                        var item_3 = {\n                            _row: row,\n                            _level: nodes.length - 1,\n                            _hasChild: hasRowChild,\n                            _expand: hasRowChild && $xetable.isTreeExpandByRow(row)\n                        };\n                        columns.forEach(function (column, $columnIndex) {\n                            var cellValue = '';\n                            var renderOpts = column.editRender || column.cellRender;\n                            var bodyExportMethod = column.exportMethod;\n                            if (!bodyExportMethod && renderOpts && renderOpts.name) {\n                                var compConf = VXETable.renderer.get(renderOpts.name);\n                                if (compConf) {\n                                    bodyExportMethod = compConf.exportMethod;\n                                }\n                            }\n                            if (!bodyExportMethod) {\n                                bodyExportMethod = columnOpts.exportMethod;\n                            }\n                            if (bodyExportMethod) {\n                                cellValue = bodyExportMethod({ $table: $xetable, row: row, column: column, options: opts });\n                            }\n                            else {\n                                switch (column.type) {\n                                    case 'seq':\n                                        cellValue = mode === 'all' ? path.map(function (num, i) { return i % 2 === 0 ? (Number(num) + 1) : '.'; }).join('') : getSeq(row, $rowIndex, column, $columnIndex);\n                                        break;\n                                    case 'checkbox':\n                                        cellValue = toBooleanValue($xetable.isCheckedByCheckboxRow(row));\n                                        item_3._checkboxLabel = checkboxOpts.labelField ? XEUtils.get(row, checkboxOpts.labelField) : '';\n                                        item_3._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({ row: row });\n                                        break;\n                                    case 'radio':\n                                        cellValue = toBooleanValue($xetable.isCheckedByRadioRow(row));\n                                        item_3._radioLabel = radioOpts.labelField ? XEUtils.get(row, radioOpts.labelField) : '';\n                                        item_3._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({ row: row });\n                                        break;\n                                    default:\n                                        if (opts.original) {\n                                            cellValue = getCellValue(row, column);\n                                        }\n                                        else {\n                                            cellValue = $xetable.getCellLabel(row, column);\n                                            if (column.type === 'html') {\n                                                htmlCellElem.innerHTML = cellValue;\n                                                cellValue = htmlCellElem.innerText.trim();\n                                            }\n                                            else {\n                                                var cell = $xetable.getCell(row, column);\n                                                if (cell) {\n                                                    cellValue = cell.innerText.trim();\n                                                }\n                                            }\n                                        }\n                                }\n                            }\n                            item_3[column.id] = XEUtils.toValueString(cellValue);\n                        });\n                        expandMaps_1.set(row, 1);\n                        rest_1.push(Object.assign(item_3, row));\n                    }\n                }, { children: childrenField });\n                return rest_1;\n            }\n            return datas.map(function (row, $rowIndex) {\n                var item = {\n                    _row: row\n                };\n                columns.forEach(function (column, $columnIndex) {\n                    var cellValue = '';\n                    var renderOpts = column.editRender || column.cellRender;\n                    var exportLabelMethod = column.exportMethod;\n                    if (!exportLabelMethod && renderOpts && renderOpts.name) {\n                        var compConf = VXETable.renderer.get(renderOpts.name);\n                        if (compConf) {\n                            exportLabelMethod = compConf.exportMethod;\n                        }\n                    }\n                    if (exportLabelMethod) {\n                        cellValue = exportLabelMethod({ $table: $xetable, row: row, column: column, options: opts });\n                    }\n                    else {\n                        switch (column.type) {\n                            case 'seq':\n                                cellValue = mode === 'all' ? $rowIndex + 1 : getSeq(row, $rowIndex, column, $columnIndex);\n                                break;\n                            case 'checkbox':\n                                cellValue = toBooleanValue($xetable.isCheckedByCheckboxRow(row));\n                                item._checkboxLabel = checkboxOpts.labelField ? XEUtils.get(row, checkboxOpts.labelField) : '';\n                                item._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({ row: row });\n                                break;\n                            case 'radio':\n                                cellValue = toBooleanValue($xetable.isCheckedByRadioRow(row));\n                                item._radioLabel = radioOpts.labelField ? XEUtils.get(row, radioOpts.labelField) : '';\n                                item._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({ row: row });\n                                break;\n                            default:\n                                if (opts.original) {\n                                    cellValue = getCellValue(row, column);\n                                }\n                                else {\n                                    cellValue = $xetable.getCellLabel(row, column);\n                                    if (column.type === 'html') {\n                                        htmlCellElem.innerHTML = cellValue;\n                                        cellValue = htmlCellElem.innerText.trim();\n                                    }\n                                    else {\n                                        var cell = $xetable.getCell(row, column);\n                                        if (cell) {\n                                            cellValue = cell.innerText.trim();\n                                        }\n                                    }\n                                }\n                        }\n                    }\n                    item[column.id] = XEUtils.toValueString(cellValue);\n                });\n                return item;\n            });\n        };\n        var getExportData = function (opts) {\n            var columns = opts.columns, dataFilterMethod = opts.dataFilterMethod;\n            var datas = opts.data;\n            if (dataFilterMethod) {\n                datas = datas.filter(function (row, index) { return dataFilterMethod({ row: row, $rowIndex: index }); });\n            }\n            return getLabelData(opts, columns, datas);\n        };\n        var getFooterCellValue = function (opts, items, column) {\n            var columnOpts = computeColumnOpts.value;\n            var renderOpts = column.editRender || column.cellRender;\n            var footLabelMethod = column.footerExportMethod;\n            if (!footLabelMethod && renderOpts && renderOpts.name) {\n                var compConf = VXETable.renderer.get(renderOpts.name);\n                if (compConf) {\n                    footLabelMethod = compConf.footerExportMethod;\n                }\n            }\n            if (!footLabelMethod) {\n                footLabelMethod = columnOpts.footerExportMethod;\n            }\n            var _columnIndex = $xetable.getVTColumnIndex(column);\n            var cellValue = footLabelMethod ? footLabelMethod({ $table: $xetable, items: items, itemIndex: _columnIndex, _columnIndex: _columnIndex, column: column, options: opts }) : XEUtils.toValueString(items[_columnIndex]);\n            return cellValue;\n        };\n        var toCsv = function (opts, columns, datas) {\n            var content = csvBOM;\n            if (opts.isHeader) {\n                content += columns.map(function (column) { return toTxtCellLabel(getHeaderTitle(opts, column)); }).join(',') + enterSymbol;\n            }\n            datas.forEach(function (row) {\n                content += columns.map(function (column) { return toTxtCellLabel(getCsvCellTypeLabel(column, row[column.id])); }).join(',') + enterSymbol;\n            });\n            if (opts.isFooter) {\n                var footerTableData = reactData.footerTableData;\n                var footers = getFooterData(opts, footerTableData);\n                footers.forEach(function (rows) {\n                    content += columns.map(function (column) { return toTxtCellLabel(getFooterCellValue(opts, rows, column)); }).join(',') + enterSymbol;\n                });\n            }\n            return content;\n        };\n        var toTxt = function (opts, columns, datas) {\n            var content = '';\n            if (opts.isHeader) {\n                content += columns.map(function (column) { return toTxtCellLabel(getHeaderTitle(opts, column)); }).join('\\t') + enterSymbol;\n            }\n            datas.forEach(function (row) {\n                content += columns.map(function (column) { return toTxtCellLabel(row[column.id]); }).join('\\t') + enterSymbol;\n            });\n            if (opts.isFooter) {\n                var footerTableData = reactData.footerTableData;\n                var footers = getFooterData(opts, footerTableData);\n                footers.forEach(function (rows) {\n                    content += columns.map(function (column) { return toTxtCellLabel(getFooterCellValue(opts, rows, column)); }).join(',') + enterSymbol;\n                });\n            }\n            return content;\n        };\n        var hasEllipsis = function (column, property, allColumnOverflow) {\n            var columnOverflow = column[property];\n            var headOverflow = XEUtils.isUndefined(columnOverflow) || XEUtils.isNull(columnOverflow) ? allColumnOverflow : columnOverflow;\n            var showEllipsis = headOverflow === 'ellipsis';\n            var showTitle = headOverflow === 'title';\n            var showTooltip = headOverflow === true || headOverflow === 'tooltip';\n            var isEllipsis = showTitle || showTooltip || showEllipsis;\n            // 虚拟滚动不支持动态高度\n            var scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad;\n            if ((scrollXLoad || scrollYLoad) && !isEllipsis) {\n                isEllipsis = true;\n            }\n            return isEllipsis;\n        };\n        var toHtml = function (opts, columns, datas) {\n            var id = props.id, border = props.border, treeConfig = props.treeConfig, allHeaderAlign = props.headerAlign, allAlign = props.align, allFooterAlign = props.footerAlign, allColumnOverflow = props.showOverflow, allColumnHeaderOverflow = props.showHeaderOverflow;\n            var isAllSelected = reactData.isAllSelected, isIndeterminate = reactData.isIndeterminate, mergeList = reactData.mergeList;\n            var treeOpts = computeTreeOpts.value;\n            var isPrint = opts.print, isHeader = opts.isHeader, isFooter = opts.isFooter, isColgroup = opts.isColgroup, isMerge = opts.isMerge, colgroups = opts.colgroups, original = opts.original;\n            var allCls = 'check-all';\n            var clss = [\n                'vxe-table',\n                \"border--\".concat(toTableBorder(border)),\n                isPrint ? 'is--print' : '',\n                isHeader ? 'is--header' : ''\n            ].filter(function (cls) { return cls; });\n            var tables = [\n                \"<table class=\\\"\".concat(clss.join(' '), \"\\\" border=\\\"0\\\" cellspacing=\\\"0\\\" cellpadding=\\\"0\\\">\"),\n                \"<colgroup>\".concat(columns.map(function (column) { return \"<col style=\\\"width:\".concat(column.renderWidth, \"px\\\">\"); }).join(''), \"</colgroup>\")\n            ];\n            if (isHeader) {\n                tables.push('<thead>');\n                if (isColgroup && !original) {\n                    colgroups.forEach(function (cols) {\n                        tables.push(\"<tr>\".concat(cols.map(function (column) {\n                            var headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;\n                            var classNames = hasEllipsis(column, 'showHeaderOverflow', allColumnHeaderOverflow) ? ['col--ellipsis'] : [];\n                            var cellTitle = getHeaderTitle(opts, column);\n                            var childWidth = 0;\n                            var countChild = 0;\n                            XEUtils.eachTree([column], function (item) {\n                                if (!item.childNodes || !column.childNodes.length) {\n                                    countChild++;\n                                }\n                                childWidth += item.renderWidth;\n                            }, { children: 'childNodes' });\n                            var cellWidth = childWidth - countChild;\n                            if (headAlign) {\n                                classNames.push(\"col--\".concat(headAlign));\n                            }\n                            if (column.type === 'checkbox') {\n                                return \"<th class=\\\"\".concat(classNames.join(' '), \"\\\" colspan=\\\"\").concat(column._colSpan, \"\\\" rowspan=\\\"\").concat(column._rowSpan, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(cellWidth, \"px\\\"\"), \"><input type=\\\"checkbox\\\" class=\\\"\").concat(allCls, \"\\\" \").concat(isAllSelected ? 'checked' : '', \"><span>\").concat(cellTitle, \"</span></div></th>\");\n                            }\n                            return \"<th class=\\\"\".concat(classNames.join(' '), \"\\\" colspan=\\\"\").concat(column._colSpan, \"\\\" rowspan=\\\"\").concat(column._rowSpan, \"\\\" title=\\\"\").concat(cellTitle, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(cellWidth, \"px\\\"\"), \"><span>\").concat(formatText(cellTitle, true), \"</span></div></th>\");\n                        }).join(''), \"</tr>\"));\n                    });\n                }\n                else {\n                    tables.push(\"<tr>\".concat(columns.map(function (column) {\n                        var headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;\n                        var classNames = hasEllipsis(column, 'showHeaderOverflow', allColumnHeaderOverflow) ? ['col--ellipsis'] : [];\n                        var cellTitle = getHeaderTitle(opts, column);\n                        if (headAlign) {\n                            classNames.push(\"col--\".concat(headAlign));\n                        }\n                        if (column.type === 'checkbox') {\n                            return \"<th class=\\\"\".concat(classNames.join(' '), \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \"><input type=\\\"checkbox\\\" class=\\\"\").concat(allCls, \"\\\" \").concat(isAllSelected ? 'checked' : '', \"><span>\").concat(cellTitle, \"</span></div></th>\");\n                        }\n                        return \"<th class=\\\"\".concat(classNames.join(' '), \"\\\" title=\\\"\").concat(cellTitle, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \"><span>\").concat(formatText(cellTitle, true), \"</span></div></th>\");\n                    }).join(''), \"</tr>\"));\n                }\n                tables.push('</thead>');\n            }\n            if (datas.length) {\n                tables.push('<tbody>');\n                if (treeConfig) {\n                    datas.forEach(function (item) {\n                        tables.push('<tr>' + columns.map(function (column) {\n                            var cellAlign = column.align || allAlign;\n                            var classNames = hasEllipsis(column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];\n                            var cellValue = item[column.id];\n                            if (cellAlign) {\n                                classNames.push(\"col--\".concat(cellAlign));\n                            }\n                            if (column.treeNode) {\n                                var treeIcon = '';\n                                if (item._hasChild) {\n                                    treeIcon = \"<i class=\\\"\".concat(item._expand ? 'vxe-table--tree-fold-icon' : 'vxe-table--tree-unfold-icon', \"\\\"></i>\");\n                                }\n                                classNames.push('vxe-table--tree-node');\n                                if (column.type === 'radio') {\n                                    return \"<td class=\\\"\".concat(classNames.join(' '), \"\\\" title=\\\"\").concat(cellValue, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \"><div class=\\\"vxe-table--tree-node-wrapper\\\" style=\\\"padding-left: \").concat(item._level * treeOpts.indent, \"px\\\"><div class=\\\"vxe-table--tree-icon-wrapper\\\">\").concat(treeIcon, \"</div><div class=\\\"vxe-table--tree-cell\\\"><input type=\\\"radio\\\" name=\\\"radio_\").concat(id, \"\\\" \").concat(item._radioDisabled ? 'disabled ' : '').concat(getBooleanValue(cellValue) ? 'checked' : '', \"><span>\").concat(item._radioLabel, \"</span></div></div></div></td>\");\n                                }\n                                else if (column.type === 'checkbox') {\n                                    return \"<td class=\\\"\".concat(classNames.join(' '), \"\\\" title=\\\"\").concat(cellValue, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \"><div class=\\\"vxe-table--tree-node-wrapper\\\" style=\\\"padding-left: \").concat(item._level * treeOpts.indent, \"px\\\"><div class=\\\"vxe-table--tree-icon-wrapper\\\">\").concat(treeIcon, \"</div><div class=\\\"vxe-table--tree-cell\\\"><input type=\\\"checkbox\\\" \").concat(item._checkboxDisabled ? 'disabled ' : '').concat(getBooleanValue(cellValue) ? 'checked' : '', \"><span>\").concat(item._checkboxLabel, \"</span></div></div></div></td>\");\n                                }\n                                return \"<td class=\\\"\".concat(classNames.join(' '), \"\\\" title=\\\"\").concat(cellValue, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \"><div class=\\\"vxe-table--tree-node-wrapper\\\" style=\\\"padding-left: \").concat(item._level * treeOpts.indent, \"px\\\"><div class=\\\"vxe-table--tree-icon-wrapper\\\">\").concat(treeIcon, \"</div><div class=\\\"vxe-table--tree-cell\\\">\").concat(cellValue, \"</div></div></div></td>\");\n                            }\n                            if (column.type === 'radio') {\n                                return \"<td class=\\\"\".concat(classNames.join(' '), \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \"><input type=\\\"radio\\\" name=\\\"radio_\").concat(id, \"\\\" \").concat(item._radioDisabled ? 'disabled ' : '').concat(getBooleanValue(cellValue) ? 'checked' : '', \"><span>\").concat(item._radioLabel, \"</span></div></td>\");\n                            }\n                            else if (column.type === 'checkbox') {\n                                return \"<td class=\\\"\".concat(classNames.join(' '), \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \"><input type=\\\"checkbox\\\" \").concat(item._checkboxDisabled ? 'disabled ' : '').concat(getBooleanValue(cellValue) ? 'checked' : '', \"><span>\").concat(item._checkboxLabel, \"</span></div></td>\");\n                            }\n                            return \"<td class=\\\"\".concat(classNames.join(' '), \"\\\" title=\\\"\").concat(cellValue, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \">\").concat(formatText(cellValue, true), \"</div></td>\");\n                        }).join('') + '</tr>');\n                    });\n                }\n                else {\n                    datas.forEach(function (item) {\n                        tables.push('<tr>' + columns.map(function (column) {\n                            var cellAlign = column.align || allAlign;\n                            var classNames = hasEllipsis(column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];\n                            var cellValue = item[column.id];\n                            var rowSpan = 1;\n                            var colSpan = 1;\n                            if (isMerge && mergeList.length) {\n                                var _rowIndex = $xetable.getVTRowIndex(item._row);\n                                var _columnIndex = $xetable.getVTColumnIndex(column);\n                                var spanRest = mergeBodyMethod(mergeList, _rowIndex, _columnIndex);\n                                if (spanRest) {\n                                    var rowspan = spanRest.rowspan, colspan = spanRest.colspan;\n                                    if (!rowspan || !colspan) {\n                                        return '';\n                                    }\n                                    if (rowspan > 1) {\n                                        rowSpan = rowspan;\n                                    }\n                                    if (colspan > 1) {\n                                        colSpan = colspan;\n                                    }\n                                }\n                            }\n                            if (cellAlign) {\n                                classNames.push(\"col--\".concat(cellAlign));\n                            }\n                            if (column.type === 'radio') {\n                                return \"<td class=\\\"\".concat(classNames.join(' '), \"\\\" rowspan=\\\"\").concat(rowSpan, \"\\\" colspan=\\\"\").concat(colSpan, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \"><input type=\\\"radio\\\" name=\\\"radio_\").concat(id, \"\\\" \").concat(item._radioDisabled ? 'disabled ' : '').concat(getBooleanValue(cellValue) ? 'checked' : '', \"><span>\").concat(item._radioLabel, \"</span></div></td>\");\n                            }\n                            else if (column.type === 'checkbox') {\n                                return \"<td class=\\\"\".concat(classNames.join(' '), \"\\\" rowspan=\\\"\").concat(rowSpan, \"\\\" colspan=\\\"\").concat(colSpan, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \"><input type=\\\"checkbox\\\" \").concat(item._checkboxDisabled ? 'disabled ' : '').concat(getBooleanValue(cellValue) ? 'checked' : '', \"><span>\").concat(item._checkboxLabel, \"</span></div></td>\");\n                            }\n                            return \"<td class=\\\"\".concat(classNames.join(' '), \"\\\" rowspan=\\\"\").concat(rowSpan, \"\\\" colspan=\\\"\").concat(colSpan, \"\\\" title=\\\"\").concat(cellValue, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \">\").concat(formatText(cellValue, true), \"</div></td>\");\n                        }).join('') + '</tr>');\n                    });\n                }\n                tables.push('</tbody>');\n            }\n            if (isFooter) {\n                var footerTableData = reactData.footerTableData;\n                var footers = getFooterData(opts, footerTableData);\n                if (footers.length) {\n                    tables.push('<tfoot>');\n                    footers.forEach(function (rows) {\n                        tables.push(\"<tr>\".concat(columns.map(function (column) {\n                            var footAlign = column.footerAlign || column.align || allFooterAlign || allAlign;\n                            var classNames = hasEllipsis(column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];\n                            var cellValue = getFooterCellValue(opts, rows, column);\n                            if (footAlign) {\n                                classNames.push(\"col--\".concat(footAlign));\n                            }\n                            return \"<td class=\\\"\".concat(classNames.join(' '), \"\\\" title=\\\"\").concat(cellValue, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \">\").concat(formatText(cellValue, true), \"</div></td>\");\n                        }).join(''), \"</tr>\"));\n                    });\n                    tables.push('</tfoot>');\n                }\n            }\n            // 是否半选状态\n            var script = !isAllSelected && isIndeterminate ? \"<script>(function(){var a=document.querySelector(\\\".\".concat(allCls, \"\\\");if(a){a.indeterminate=true}})()</script>\") : '';\n            tables.push('</table>', script);\n            return isPrint ? tables.join('') : createHtmlPage(opts, tables.join(''));\n        };\n        var toXML = function (opts, columns, datas) {\n            var xml = [\n                '<?xml version=\"1.0\"?>',\n                '<?mso-application progid=\"Excel.Sheet\"?>',\n                '<Workbook xmlns=\"urn:schemas-microsoft-com:office:spreadsheet\" xmlns:o=\"urn:schemas-microsoft-com:office:office\" xmlns:x=\"urn:schemas-microsoft-com:office:excel\" xmlns:ss=\"urn:schemas-microsoft-com:office:spreadsheet\" xmlns:html=\"http://www.w3.org/TR/REC-html40\">',\n                '<DocumentProperties xmlns=\"urn:schemas-microsoft-com:office:office\">',\n                '<Version>16.00</Version>',\n                '</DocumentProperties>',\n                '<ExcelWorkbook xmlns=\"urn:schemas-microsoft-com:office:excel\">',\n                '<WindowHeight>7920</WindowHeight>',\n                '<WindowWidth>21570</WindowWidth>',\n                '<WindowTopX>32767</WindowTopX>',\n                '<WindowTopY>32767</WindowTopY>',\n                '<ProtectStructure>False</ProtectStructure>',\n                '<ProtectWindows>False</ProtectWindows>',\n                '</ExcelWorkbook>',\n                \"<Worksheet ss:Name=\\\"\".concat(opts.sheetName, \"\\\">\"),\n                '<Table>',\n                columns.map(function (column) { return \"<Column ss:Width=\\\"\".concat(column.renderWidth, \"\\\"/>\"); }).join('')\n            ].join('');\n            if (opts.isHeader) {\n                xml += \"<Row>\".concat(columns.map(function (column) { return \"<Cell><Data ss:Type=\\\"String\\\">\".concat(getHeaderTitle(opts, column), \"</Data></Cell>\"); }).join(''), \"</Row>\");\n            }\n            datas.forEach(function (row) {\n                xml += '<Row>' + columns.map(function (column) { return \"<Cell><Data ss:Type=\\\"String\\\">\".concat(row[column.id], \"</Data></Cell>\"); }).join('') + '</Row>';\n            });\n            if (opts.isFooter) {\n                var footerTableData = reactData.footerTableData;\n                var footers = getFooterData(opts, footerTableData);\n                footers.forEach(function (rows) {\n                    xml += \"<Row>\".concat(columns.map(function (column) { return \"<Cell><Data ss:Type=\\\"String\\\">\".concat(getFooterCellValue(opts, rows, column), \"</Data></Cell>\"); }).join(''), \"</Row>\");\n                });\n            }\n            return \"\".concat(xml, \"</Table></Worksheet></Workbook>\");\n        };\n        var getContent = function (opts, columns, datas) {\n            if (columns.length) {\n                switch (opts.type) {\n                    case 'csv':\n                        return toCsv(opts, columns, datas);\n                    case 'txt':\n                        return toTxt(opts, columns, datas);\n                    case 'html':\n                        return toHtml(opts, columns, datas);\n                    case 'xml':\n                        return toXML(opts, columns, datas);\n                }\n            }\n            return '';\n        };\n        var downloadFile = function (opts, content) {\n            var filename = opts.filename, type = opts.type, download = opts.download;\n            if (!download) {\n                var blob = getExportBlobByContent(content, opts);\n                return Promise.resolve({ type: type, content: content, blob: blob });\n            }\n            saveLocalFile({ filename: filename, type: type, content: content }).then(function () {\n                if (opts.message !== false) {\n                    // 检测弹窗模块\n                    if (process.env.NODE_ENV === 'development') {\n                        if (!VXETable.modal) {\n                            errLog('vxe.error.reqModule', ['Modal']);\n                        }\n                    }\n                    VXETable.modal.message({ content: GlobalConfig.i18n('vxe.table.expSuccess'), status: 'success' });\n                }\n            });\n        };\n        var handleExport = function (opts) {\n            var remote = opts.remote, columns = opts.columns, colgroups = opts.colgroups, exportMethod = opts.exportMethod, afterExportMethod = opts.afterExportMethod;\n            return new Promise(function (resolve) {\n                if (remote) {\n                    var params = { options: opts, $table: $xetable, $grid: $xegrid };\n                    resolve(exportMethod ? exportMethod(params) : params);\n                }\n                else {\n                    var datas_1 = getExportData(opts);\n                    resolve($xetable.preventEvent(null, 'event.export', { options: opts, columns: columns, colgroups: colgroups, datas: datas_1 }, function () {\n                        return downloadFile(opts, getContent(opts, columns, datas_1));\n                    }));\n                }\n            }).then(function (params) {\n                clearColumnConvert(columns);\n                if (!opts.print) {\n                    if (afterExportMethod) {\n                        afterExportMethod({ status: true, options: opts, $table: $xetable, $grid: $xegrid });\n                    }\n                }\n                return Object.assign({ status: true }, params);\n            }).catch(function () {\n                clearColumnConvert(columns);\n                if (!opts.print) {\n                    if (afterExportMethod) {\n                        afterExportMethod({ status: false, options: opts, $table: $xetable, $grid: $xegrid });\n                    }\n                }\n                var params = { status: false };\n                return Promise.reject(params);\n            });\n        };\n        var handleImport = function (content, opts) {\n            var tableFullColumn = internalData.tableFullColumn, _importResolve = internalData._importResolve, _importReject = internalData._importReject;\n            var rest = { fields: [], rows: [] };\n            switch (opts.type) {\n                case 'csv':\n                    rest = parseCsv(tableFullColumn, content);\n                    break;\n                case 'txt':\n                    rest = parseTxt(tableFullColumn, content);\n                    break;\n                case 'html':\n                    rest = parseHTML(tableFullColumn, content);\n                    break;\n                case 'xml':\n                    rest = parseXML(tableFullColumn, content);\n                    break;\n            }\n            var fields = rest.fields, rows = rest.rows;\n            var status = checkImportData(tableFullColumn, fields);\n            if (status) {\n                $xetable.createData(rows)\n                    .then(function (data) {\n                    var loadRest;\n                    if (opts.mode === 'insert') {\n                        loadRest = $xetable.insert(data);\n                    }\n                    else {\n                        loadRest = $xetable.reloadData(data);\n                    }\n                    if (opts.message !== false) {\n                        // 检测弹窗模块\n                        if (process.env.NODE_ENV === 'development') {\n                            if (!VXETable.modal) {\n                                errLog('vxe.error.reqModule', ['Modal']);\n                            }\n                        }\n                        VXETable.modal.message({ content: GlobalConfig.i18n('vxe.table.impSuccess', [rows.length]), status: 'success' });\n                    }\n                    return loadRest.then(function () {\n                        if (_importResolve) {\n                            _importResolve({ status: true });\n                        }\n                    });\n                });\n            }\n            else if (opts.message !== false) {\n                // 检测弹窗模块\n                if (process.env.NODE_ENV === 'development') {\n                    if (!VXETable.modal) {\n                        errLog('vxe.error.reqModule', ['Modal']);\n                    }\n                }\n                VXETable.modal.message({ content: GlobalConfig.i18n('vxe.error.impFields'), status: 'error' });\n                if (_importReject) {\n                    _importReject({ status: false });\n                }\n            }\n        };\n        var handleFileImport = function (file, opts) {\n            var importMethod = opts.importMethod, afterImportMethod = opts.afterImportMethod;\n            var _a = parseFile(file), type = _a.type, filename = _a.filename;\n            // 检查类型，如果为自定义导出，则不需要校验类型\n            if (!importMethod && !XEUtils.includes(VXETable.globalConfs.importTypes, type)) {\n                if (opts.message !== false) {\n                    // 检测弹窗模块\n                    if (process.env.NODE_ENV === 'development') {\n                        if (!VXETable.modal) {\n                            errLog('vxe.error.reqModule', ['Modal']);\n                        }\n                    }\n                    VXETable.modal.message({ content: GlobalConfig.i18n('vxe.error.notType', [type]), status: 'error' });\n                }\n                var params = { status: false };\n                return Promise.reject(params);\n            }\n            var rest = new Promise(function (resolve, reject) {\n                var _importResolve = function (params) {\n                    resolve(params);\n                    internalData._importResolve = null;\n                    internalData._importReject = null;\n                };\n                var _importReject = function (params) {\n                    reject(params);\n                    internalData._importResolve = null;\n                    internalData._importReject = null;\n                };\n                internalData._importResolve = _importResolve;\n                internalData._importReject = _importReject;\n                if (window.FileReader) {\n                    var options_1 = Object.assign({ mode: 'insert' }, opts, { type: type, filename: filename });\n                    if (options_1.remote) {\n                        if (importMethod) {\n                            Promise.resolve(importMethod({ file: file, options: options_1, $table: $xetable })).then(function () {\n                                _importResolve({ status: true });\n                            }).catch(function () {\n                                _importResolve({ status: true });\n                            });\n                        }\n                        else {\n                            _importResolve({ status: true });\n                        }\n                    }\n                    else {\n                        var tableFullColumn = internalData.tableFullColumn;\n                        $xetable.preventEvent(null, 'event.import', { file: file, options: options_1, columns: tableFullColumn }, function () {\n                            var reader = new FileReader();\n                            reader.onerror = function () {\n                                errLog('vxe.error.notType', [type]);\n                                _importReject({ status: false });\n                            };\n                            reader.onload = function (e) {\n                                handleImport(e.target.result, options_1);\n                            };\n                            reader.readAsText(file, options_1.encoding || 'UTF-8');\n                        });\n                    }\n                }\n                else {\n                    // 不支持的浏览器\n                    if (process.env.NODE_ENV === 'development') {\n                        errLog('vxe.error.notExp');\n                    }\n                    _importResolve({ status: true });\n                }\n            });\n            return rest.then(function () {\n                if (afterImportMethod) {\n                    afterImportMethod({ status: true, options: opts, $table: $xetable });\n                }\n            }).catch(function (e) {\n                if (afterImportMethod) {\n                    afterImportMethod({ status: false, options: opts, $table: $xetable });\n                }\n                return Promise.reject(e);\n            });\n        };\n        var handleExportAndPrint = function (options, isPrint) {\n            var treeConfig = props.treeConfig, showHeader = props.showHeader, showFooter = props.showFooter;\n            var initStore = reactData.initStore, mergeList = reactData.mergeList, isGroup = reactData.isGroup, footerTableData = reactData.footerTableData, exportStore = reactData.exportStore, exportParams = reactData.exportParams;\n            var collectColumn = internalData.collectColumn;\n            var hasTree = treeConfig;\n            var customOpts = computeCustomOpts.value;\n            var selectRecords = $xetable.getCheckboxRecords();\n            var hasFooter = !!footerTableData.length;\n            var hasMerge = !hasTree && mergeList.length;\n            var defOpts = Object.assign({ message: true, isHeader: showHeader, isFooter: showFooter }, options);\n            var types = defOpts.types || VXETable.globalConfs.exportTypes;\n            var modes = defOpts.modes;\n            var checkMethod = customOpts.checkMethod;\n            var exportColumns = collectColumn.slice(0);\n            var columns = defOpts.columns;\n            // 处理类型\n            var typeList = types.map(function (value) {\n                return {\n                    value: value,\n                    label: \"vxe.export.types.\".concat(value)\n                };\n            });\n            var modeList = modes.map(function (value) {\n                return {\n                    value: value,\n                    label: \"vxe.export.modes.\".concat(value)\n                };\n            });\n            // 默认选中\n            XEUtils.eachTree(exportColumns, function (column, index, items, path, parent) {\n                var isColGroup = column.children && column.children.length;\n                if (isColGroup || defaultFilterExportColumn(column)) {\n                    column.checked = columns ? columns.some(function (item) {\n                        if (isColumnInfo(item)) {\n                            return column === item;\n                        }\n                        else if (XEUtils.isString(item)) {\n                            return column.field === item;\n                        }\n                        else {\n                            var colid = item.id || item.colId;\n                            var type = item.type;\n                            var field = item.property || item.field;\n                            if (colid) {\n                                return column.id === colid;\n                            }\n                            else if (field && type) {\n                                return column.property === field && column.type === type;\n                            }\n                            else if (field) {\n                                return column.property === field;\n                            }\n                            else if (type) {\n                                return column.type === type;\n                            }\n                        }\n                        return false;\n                    }) : column.visible;\n                    column.halfChecked = false;\n                    column.disabled = (parent && parent.disabled) || (checkMethod ? !checkMethod({ column: column }) : false);\n                }\n            });\n            // 更新条件\n            Object.assign(exportStore, {\n                columns: exportColumns,\n                typeList: typeList,\n                modeList: modeList,\n                hasFooter: hasFooter,\n                hasMerge: hasMerge,\n                hasTree: hasTree,\n                isPrint: isPrint,\n                hasColgroup: isGroup,\n                visible: true\n            });\n            // 默认参数\n            Object.assign(exportParams, {\n                mode: selectRecords.length ? 'selected' : 'current'\n            }, defOpts);\n            if (modes.indexOf(exportParams.mode) === -1) {\n                exportParams.mode = modes[0];\n            }\n            if (types.indexOf(exportParams.type) === -1) {\n                exportParams.type = types[0];\n            }\n            initStore.export = true;\n            return nextTick();\n        };\n        var exportMethods = {\n            /**\n             * 导出文件，支持 csv/html/xml/txt\n             * 如果是树表格，则默认是导出所有节点\n             * 如果是启用了虚拟滚动，则只能导出数据源，可以配合 dataFilterMethod 函数自行转换数据\n             * @param {Object} options 参数\n             */\n            exportData: function (options) {\n                var treeConfig = props.treeConfig;\n                var isGroup = reactData.isGroup, tableGroupColumn = reactData.tableGroupColumn;\n                var tableFullColumn = internalData.tableFullColumn, afterFullData = internalData.afterFullData;\n                var exportOpts = computeExportOpts.value;\n                var treeOpts = computeTreeOpts.value;\n                var opts = Object.assign({\n                    // filename: '',\n                    // sheetName: '',\n                    // original: false,\n                    // message: false,\n                    isHeader: true,\n                    isFooter: true,\n                    isColgroup: true,\n                    // isMerge: false,\n                    // isAllExpand: false,\n                    download: true,\n                    type: 'csv',\n                    mode: 'current'\n                    // data: null,\n                    // remote: false,\n                    // dataFilterMethod: null,\n                    // footerFilterMethod: null,\n                    // exportMethod: null,\n                    // columnFilterMethod: null,\n                    // beforeExportMethod: null,\n                    // afterExportMethod: null\n                }, exportOpts, {\n                    print: false\n                }, options);\n                var type = opts.type, mode = opts.mode, columns = opts.columns, original = opts.original, beforeExportMethod = opts.beforeExportMethod;\n                var groups = [];\n                var customCols = columns && columns.length ? columns : null;\n                var columnFilterMethod = opts.columnFilterMethod;\n                // 如果设置源数据，则默认导出设置了字段的列\n                if (!customCols && !columnFilterMethod) {\n                    columnFilterMethod = original ? function (_a) {\n                        var column = _a.column;\n                        return column.property;\n                    } : function (_a) {\n                        var column = _a.column;\n                        return defaultFilterExportColumn(column);\n                    };\n                }\n                if (customCols) {\n                    opts._isCustomColumn = true;\n                    groups = XEUtils.searchTree(XEUtils.mapTree(customCols, function (item) {\n                        var targetColumn;\n                        if (item) {\n                            if (isColumnInfo(item)) {\n                                targetColumn = item;\n                            }\n                            else if (XEUtils.isString(item)) {\n                                targetColumn = $xetable.getColumnByField(item);\n                            }\n                            else {\n                                var colid = item.id || item.colId;\n                                var type_1 = item.type;\n                                var field_1 = item.property || item.field;\n                                if (colid) {\n                                    targetColumn = $xetable.getColumnById(colid);\n                                }\n                                else if (field_1 && type_1) {\n                                    targetColumn = tableFullColumn.find(function (column) { return column.property === field_1 && column.type === type_1; });\n                                }\n                                else if (field_1) {\n                                    targetColumn = $xetable.getColumnByField(field_1);\n                                }\n                                else if (type_1) {\n                                    targetColumn = tableFullColumn.find(function (column) { return column.type === type_1; });\n                                }\n                            }\n                            return targetColumn || {};\n                        }\n                    }, {\n                        children: 'childNodes',\n                        mapChildren: '_children'\n                    }), function (column, index) { return isColumnInfo(column) && (!columnFilterMethod || columnFilterMethod({ column: column, $columnIndex: index })); }, {\n                        children: '_children',\n                        mapChildren: 'childNodes',\n                        original: true\n                    });\n                }\n                else {\n                    groups = XEUtils.searchTree(isGroup ? tableGroupColumn : tableFullColumn, function (column, index) { return column.visible && (!columnFilterMethod || columnFilterMethod({ column: column, $columnIndex: index })); }, { children: 'children', mapChildren: 'childNodes', original: true });\n                }\n                // 获取所有列\n                var cols = [];\n                XEUtils.eachTree(groups, function (column) {\n                    var isColGroup = column.children && column.children.length;\n                    if (!isColGroup) {\n                        cols.push(column);\n                    }\n                }, { children: 'childNodes' });\n                // 构建分组层级\n                opts.columns = cols;\n                opts.colgroups = convertToRows(groups);\n                if (!opts.filename) {\n                    opts.filename = GlobalConfig.i18n(opts.original ? 'vxe.table.expOriginFilename' : 'vxe.table.expFilename', [XEUtils.toDateString(Date.now(), 'yyyyMMddHHmmss')]);\n                }\n                if (!opts.sheetName) {\n                    opts.sheetName = document.title;\n                }\n                // 检查类型，如果为自定义导出，则不需要校验类型\n                if (!opts.exportMethod && !XEUtils.includes(VXETable.globalConfs.exportTypes, type)) {\n                    if (process.env.NODE_ENV === 'development') {\n                        errLog('vxe.error.notType', [type]);\n                    }\n                    var params = { status: false };\n                    return Promise.reject(params);\n                }\n                if (!opts.print) {\n                    if (beforeExportMethod) {\n                        beforeExportMethod({ options: opts, $table: $xetable, $grid: $xegrid });\n                    }\n                }\n                if (!opts.data) {\n                    opts.data = afterFullData;\n                    if (mode === 'selected') {\n                        var selectRecords_1 = $xetable.getCheckboxRecords();\n                        if (['html', 'pdf'].indexOf(type) > -1 && treeConfig) {\n                            opts.data = XEUtils.searchTree($xetable.getTableData().fullData, function (item) { return $xetable.findRowIndexOf(selectRecords_1, item) > -1; }, Object.assign({}, treeOpts, { data: '_row' }));\n                        }\n                        else {\n                            opts.data = selectRecords_1;\n                        }\n                    }\n                    else if (mode === 'all') {\n                        if (process.env.NODE_ENV === 'development') {\n                            if (!$xegrid) {\n                                warnLog('vxe.error.errProp', ['all', 'mode=current,selected']);\n                            }\n                        }\n                        if ($xegrid && !opts.remote) {\n                            var gridReactData = $xegrid.reactData;\n                            var computeProxyOpts = $xegrid.getComputeMaps().computeProxyOpts;\n                            var proxyOpts = computeProxyOpts.value;\n                            var beforeQueryAll = proxyOpts.beforeQueryAll, afterQueryAll_1 = proxyOpts.afterQueryAll, _a = proxyOpts.ajax, ajax = _a === void 0 ? {} : _a, _b = proxyOpts.props, props_1 = _b === void 0 ? {} : _b;\n                            var ajaxMethods = ajax.queryAll;\n                            if (process.env.NODE_ENV === 'development') {\n                                if (!ajaxMethods) {\n                                    warnLog('vxe.error.notFunc', ['proxy-config.ajax.queryAll']);\n                                }\n                            }\n                            if (ajaxMethods) {\n                                var params_1 = {\n                                    $table: $xetable,\n                                    $grid: $xegrid,\n                                    sort: gridReactData.sortData,\n                                    filters: gridReactData.filterData,\n                                    form: gridReactData.formData,\n                                    target: ajaxMethods,\n                                    options: opts\n                                };\n                                return Promise.resolve((beforeQueryAll || ajaxMethods)(params_1))\n                                    .catch(function (e) { return e; })\n                                    .then(function (rest) {\n                                    opts.data = (props_1.list ? XEUtils.get(rest, props_1.list) : rest) || [];\n                                    if (afterQueryAll_1) {\n                                        afterQueryAll_1(params_1);\n                                    }\n                                    return handleExport(opts);\n                                });\n                            }\n                        }\n                    }\n                }\n                return handleExport(opts);\n            },\n            importByFile: function (file, options) {\n                var opts = Object.assign({}, options);\n                var beforeImportMethod = opts.beforeImportMethod;\n                if (beforeImportMethod) {\n                    beforeImportMethod({ options: opts, $table: $xetable });\n                }\n                return handleFileImport(file, opts);\n            },\n            importData: function (options) {\n                var importOpts = computeImportOpts.value;\n                var opts = Object.assign({\n                    types: VXETable.globalConfs.importTypes\n                    // beforeImportMethod: null,\n                    // afterImportMethod: null\n                }, importOpts, options);\n                var beforeImportMethod = opts.beforeImportMethod, afterImportMethod = opts.afterImportMethod;\n                if (beforeImportMethod) {\n                    beforeImportMethod({ options: opts, $table: $xetable });\n                }\n                return readLocalFile(opts).catch(function (e) {\n                    if (afterImportMethod) {\n                        afterImportMethod({ status: false, options: opts, $table: $xetable });\n                    }\n                    return Promise.reject(e);\n                }).then(function (params) {\n                    var file = params.file;\n                    return handleFileImport(file, opts);\n                });\n            },\n            saveFile: function (options) {\n                return saveLocalFile(options);\n            },\n            readFile: function (options) {\n                return readLocalFile(options);\n            },\n            print: function (options) {\n                var printOpts = computePrintOpts.value;\n                var opts = Object.assign({\n                    original: false\n                    // beforePrintMethod\n                }, printOpts, options, {\n                    type: 'html',\n                    download: false,\n                    remote: false,\n                    print: true\n                });\n                if (!opts.sheetName) {\n                    opts.sheetName = document.title;\n                }\n                return new Promise(function (resolve) {\n                    if (opts.content) {\n                        resolve(handlePrint($xetable, opts, opts.content));\n                    }\n                    else {\n                        resolve(exportMethods.exportData(opts).then(function (_a) {\n                            var content = _a.content;\n                            return handlePrint($xetable, opts, content);\n                        }));\n                    }\n                });\n            },\n            openImport: function (options) {\n                var treeConfig = props.treeConfig, importConfig = props.importConfig;\n                var initStore = reactData.initStore, importStore = reactData.importStore, importParams = reactData.importParams;\n                var importOpts = computeImportOpts.value;\n                var defOpts = Object.assign({ mode: 'insert', message: true, types: VXETable.globalConfs.importTypes }, options, importOpts);\n                var types = defOpts.types;\n                var isTree = !!treeConfig;\n                if (isTree) {\n                    if (defOpts.message) {\n                        VXETable.modal.message({ content: GlobalConfig.i18n('vxe.error.treeNotImp'), status: 'error' });\n                    }\n                    return;\n                }\n                if (!importConfig) {\n                    errLog('vxe.error.reqProp', ['import-config']);\n                }\n                // 处理类型\n                var typeList = types.map(function (value) {\n                    return {\n                        value: value,\n                        label: \"vxe.export.types.\".concat(value)\n                    };\n                });\n                var modeList = defOpts.modes.map(function (value) {\n                    return {\n                        value: value,\n                        label: \"vxe.import.modes.\".concat(value)\n                    };\n                });\n                Object.assign(importStore, {\n                    file: null,\n                    type: '',\n                    filename: '',\n                    modeList: modeList,\n                    typeList: typeList,\n                    visible: true\n                });\n                Object.assign(importParams, defOpts);\n                initStore.import = true;\n            },\n            openExport: function (options) {\n                var exportOpts = computeExportOpts.value;\n                if (process.env.NODE_ENV === 'development') {\n                    if (!props.exportConfig) {\n                        errLog('vxe.error.reqProp', ['export-config']);\n                    }\n                }\n                handleExportAndPrint(Object.assign({}, exportOpts, options));\n            },\n            openPrint: function (options) {\n                var printOpts = computePrintOpts.value;\n                if (process.env.NODE_ENV === 'development') {\n                    if (!props.printConfig) {\n                        errLog('vxe.error.reqProp', ['print-config']);\n                    }\n                }\n                handleExportAndPrint(Object.assign({}, printOpts, options), true);\n            }\n        };\n        return exportMethods;\n    },\n    setupGrid: function ($xegrid) {\n        return $xegrid.extendTableMethods(tableExportMethodKeys);\n    }\n};\nexport default tableExportHook;\n",
      "start": 1714699767734,
      "end": 1714699767753,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1714699767753,
      "end": 1714699767753,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1714699767753,
      "end": 1714699767753,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1714699767753,
      "end": 1714699767753,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1714699767753,
      "end": 1714699767753,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1714699767753,
      "end": 1714699767753,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1714699767753,
      "end": 1714699767753,
      "order": "normal"
    },
    {
      "name": "vite-plugin-vconsole",
      "result": "import { inject, nextTick } from 'vue';\nimport XEUtils from 'xe-utils';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport { VXETable } from '../../v-x-e-table';\nimport { isColumnInfo, mergeBodyMethod, getCellValue } from '../../table/src/util';\nimport { parseFile, formatText } from '../../tools/utils';\nimport { warnLog, errLog } from '../../tools/log';\nimport { readLocalFile, handlePrint, saveLocalFile, createHtmlPage, getExportBlobByContent } from './util';\nvar htmlCellElem;\nvar csvBOM = '\\ufeff';\nvar enterSymbol = '\\r\\n';\nfunction defaultFilterExportColumn(column) {\n    return column.property || ['seq', 'checkbox', 'radio'].indexOf(column.type) > -1;\n}\nvar getConvertColumns = function (columns) {\n    var result = [];\n    columns.forEach(function (column) {\n        if (column.childNodes && column.childNodes.length) {\n            result.push(column);\n            result.push.apply(result, getConvertColumns(column.childNodes));\n        }\n        else {\n            result.push(column);\n        }\n    });\n    return result;\n};\nvar convertToRows = function (originColumns) {\n    var maxLevel = 1;\n    var traverse = function (column, parent) {\n        if (parent) {\n            column._level = parent._level + 1;\n            if (maxLevel < column._level) {\n                maxLevel = column._level;\n            }\n        }\n        if (column.childNodes && column.childNodes.length) {\n            var colSpan_1 = 0;\n            column.childNodes.forEach(function (subColumn) {\n                traverse(subColumn, column);\n                colSpan_1 += subColumn._colSpan;\n            });\n            column._colSpan = colSpan_1;\n        }\n        else {\n            column._colSpan = 1;\n        }\n    };\n    originColumns.forEach(function (column) {\n        column._level = 1;\n        traverse(column);\n    });\n    var rows = [];\n    for (var i = 0; i < maxLevel; i++) {\n        rows.push([]);\n    }\n    var allColumns = getConvertColumns(originColumns);\n    allColumns.forEach(function (column) {\n        if (column.childNodes && column.childNodes.length) {\n            column._rowSpan = 1;\n        }\n        else {\n            column._rowSpan = maxLevel - column._level + 1;\n        }\n        rows[column._level - 1].push(column);\n    });\n    return rows;\n};\nfunction toTableBorder(border) {\n    if (border === true) {\n        return 'full';\n    }\n    if (border) {\n        return border;\n    }\n    return 'default';\n}\nfunction getBooleanValue(cellValue) {\n    return cellValue === 'TRUE' || cellValue === 'true' || cellValue === true;\n}\nfunction getFooterData(opts, footerTableData) {\n    var footerFilterMethod = opts.footerFilterMethod;\n    return footerFilterMethod ? footerTableData.filter(function (items, index) { return footerFilterMethod({ items: items, $rowIndex: index }); }) : footerTableData;\n}\nfunction getCsvCellTypeLabel(column, cellValue) {\n    if (cellValue) {\n        if (column.type === 'seq') {\n            return \"\\t\".concat(cellValue);\n        }\n        switch (column.cellType) {\n            case 'string':\n                if (!isNaN(cellValue)) {\n                    return \"\\t\".concat(cellValue);\n                }\n                break;\n            case 'number':\n                break;\n            default:\n                if (cellValue.length >= 12 && !isNaN(cellValue)) {\n                    return \"\\t\".concat(cellValue);\n                }\n                break;\n        }\n    }\n    return cellValue;\n}\nfunction toTxtCellLabel(val) {\n    if (/[\",\\s\\n]/.test(val)) {\n        return \"\\\"\".concat(val.replace(/\"/g, '\"\"'), \"\\\"\");\n    }\n    return val;\n}\nfunction getElementsByTagName(elem, qualifiedName) {\n    return elem.getElementsByTagName(qualifiedName);\n}\nfunction getTxtCellKey(now) {\n    return \"#\".concat(now, \"@\").concat(XEUtils.uniqueId());\n}\nfunction replaceTxtCell(cell, vMaps) {\n    return cell.replace(/#\\d+@\\d+/g, function (key) { return XEUtils.hasOwnProp(vMaps, key) ? vMaps[key] : key; });\n}\nfunction getTxtCellValue(val, vMaps) {\n    var rest = replaceTxtCell(val, vMaps);\n    return rest.replace(/^\"+$/g, function (qVal) { return '\"'.repeat(Math.ceil(qVal.length / 2)); });\n}\nfunction parseCsvAndTxt(columns, content, cellSeparator) {\n    var list = content.split(enterSymbol);\n    var rows = [];\n    var fields = [];\n    if (list.length) {\n        var vMaps_1 = {};\n        var now_1 = Date.now();\n        list.forEach(function (rVal) {\n            if (rVal) {\n                var item_1 = {};\n                rVal = rVal.replace(/(\"\")|(\\n)/g, function (text, dVal) {\n                    var key = getTxtCellKey(now_1);\n                    vMaps_1[key] = dVal ? '\"' : '\\n';\n                    return key;\n                }).replace(/\"(.*?)\"/g, function (text, cVal) {\n                    var key = getTxtCellKey(now_1);\n                    vMaps_1[key] = replaceTxtCell(cVal, vMaps_1);\n                    return key;\n                });\n                var cells = rVal.split(cellSeparator);\n                if (!fields.length) {\n                    fields = cells.map(function (val) { return getTxtCellValue(val.trim(), vMaps_1); });\n                }\n                else {\n                    cells.forEach(function (val, colIndex) {\n                        if (colIndex < fields.length) {\n                            item_1[fields[colIndex]] = getTxtCellValue(val.trim(), vMaps_1);\n                        }\n                    });\n                    rows.push(item_1);\n                }\n            }\n        });\n    }\n    return { fields: fields, rows: rows };\n}\nfunction parseCsv(columns, content) {\n    return parseCsvAndTxt(columns, content, ',');\n}\nfunction parseTxt(columns, content) {\n    return parseCsvAndTxt(columns, content, '\\t');\n}\nfunction parseHTML(columns, content) {\n    var domParser = new DOMParser();\n    var xmlDoc = domParser.parseFromString(content, 'text/html');\n    var bodyNodes = getElementsByTagName(xmlDoc, 'body');\n    var rows = [];\n    var fields = [];\n    if (bodyNodes.length) {\n        var tableNodes = getElementsByTagName(bodyNodes[0], 'table');\n        if (tableNodes.length) {\n            var theadNodes = getElementsByTagName(tableNodes[0], 'thead');\n            if (theadNodes.length) {\n                XEUtils.arrayEach(getElementsByTagName(theadNodes[0], 'tr'), function (rowNode) {\n                    XEUtils.arrayEach(getElementsByTagName(rowNode, 'th'), function (cellNode) {\n                        fields.push(cellNode.textContent);\n                    });\n                });\n                var tbodyNodes = getElementsByTagName(tableNodes[0], 'tbody');\n                if (tbodyNodes.length) {\n                    XEUtils.arrayEach(getElementsByTagName(tbodyNodes[0], 'tr'), function (rowNode) {\n                        var item = {};\n                        XEUtils.arrayEach(getElementsByTagName(rowNode, 'td'), function (cellNode, colIndex) {\n                            if (fields[colIndex]) {\n                                item[fields[colIndex]] = cellNode.textContent || '';\n                            }\n                        });\n                        rows.push(item);\n                    });\n                }\n            }\n        }\n    }\n    return { fields: fields, rows: rows };\n}\nfunction parseXML(columns, content) {\n    var domParser = new DOMParser();\n    var xmlDoc = domParser.parseFromString(content, 'application/xml');\n    var sheetNodes = getElementsByTagName(xmlDoc, 'Worksheet');\n    var rows = [];\n    var fields = [];\n    if (sheetNodes.length) {\n        var tableNodes = getElementsByTagName(sheetNodes[0], 'Table');\n        if (tableNodes.length) {\n            var rowNodes = getElementsByTagName(tableNodes[0], 'Row');\n            if (rowNodes.length) {\n                XEUtils.arrayEach(getElementsByTagName(rowNodes[0], 'Cell'), function (cellNode) {\n                    fields.push(cellNode.textContent);\n                });\n                XEUtils.arrayEach(rowNodes, function (rowNode, index) {\n                    if (index) {\n                        var item_2 = {};\n                        var cellNodes = getElementsByTagName(rowNode, 'Cell');\n                        XEUtils.arrayEach(cellNodes, function (cellNode, colIndex) {\n                            if (fields[colIndex]) {\n                                item_2[fields[colIndex]] = cellNode.textContent;\n                            }\n                        });\n                        rows.push(item_2);\n                    }\n                });\n            }\n        }\n    }\n    return { fields: fields, rows: rows };\n}\nfunction clearColumnConvert(columns) {\n    XEUtils.eachTree(columns, function (column) {\n        delete column._level;\n        delete column._colSpan;\n        delete column._rowSpan;\n        delete column._children;\n        delete column.childNodes;\n    }, { children: 'children' });\n}\n/**\n * 检查导入的列是否完整\n * @param {Array} fields 字段名列表\n * @param {Array} rows 数据列表\n */\nfunction checkImportData(columns, fields) {\n    var tableFields = [];\n    columns.forEach(function (column) {\n        var field = column.property;\n        if (field) {\n            tableFields.push(field);\n        }\n    });\n    return fields.some(function (field) { return tableFields.indexOf(field) > -1; });\n}\nvar tableExportMethodKeys = ['exportData', 'importByFile', 'importData', 'saveFile', 'readFile', 'print', 'openImport', 'openExport', 'openPrint'];\nvar tableExportHook = {\n    setupTable: function ($xetable) {\n        var props = $xetable.props, reactData = $xetable.reactData, internalData = $xetable.internalData;\n        var _a = $xetable.getComputeMaps(), computeTreeOpts = _a.computeTreeOpts, computePrintOpts = _a.computePrintOpts, computeExportOpts = _a.computeExportOpts, computeImportOpts = _a.computeImportOpts, computeCustomOpts = _a.computeCustomOpts, computeSeqOpts = _a.computeSeqOpts, computeRadioOpts = _a.computeRadioOpts, computeCheckboxOpts = _a.computeCheckboxOpts, computeColumnOpts = _a.computeColumnOpts;\n        var $xegrid = inject('$xegrid', null);\n        var hasTreeChildren = function (row) {\n            var treeOpts = computeTreeOpts.value;\n            var childrenField = treeOpts.children || treeOpts.childrenField;\n            return row[childrenField] && row[childrenField].length;\n        };\n        var getSeq = function (row, $rowIndex, column, $columnIndex) {\n            var seqOpts = computeSeqOpts.value;\n            var seqMethod = seqOpts.seqMethod || column.seqMethod;\n            if (seqMethod) {\n                return seqMethod({\n                    row: row,\n                    rowIndex: $xetable.getRowIndex(row),\n                    $rowIndex: $rowIndex,\n                    column: column,\n                    columnIndex: $xetable.getColumnIndex(column),\n                    $columnIndex: $columnIndex\n                });\n            }\n            return $xetable.getRowSeq(row);\n        };\n        function getHeaderTitle(opts, column) {\n            var columnOpts = computeColumnOpts.value;\n            var headExportMethod = column.headerExportMethod || columnOpts.headerExportMethod;\n            return headExportMethod ? headExportMethod({ column: column, options: opts, $table: $xetable }) : ((opts.original ? column.property : column.getTitle()) || '');\n        }\n        var toBooleanValue = function (cellValue) {\n            return XEUtils.isBoolean(cellValue) ? (cellValue ? 'TRUE' : 'FALSE') : cellValue;\n        };\n        var getLabelData = function (opts, columns, datas) {\n            var isAllExpand = opts.isAllExpand, mode = opts.mode;\n            var treeConfig = props.treeConfig;\n            var radioOpts = computeRadioOpts.value;\n            var checkboxOpts = computeCheckboxOpts.value;\n            var treeOpts = computeTreeOpts.value;\n            var columnOpts = computeColumnOpts.value;\n            if (!htmlCellElem) {\n                htmlCellElem = document.createElement('div');\n            }\n            if (treeConfig) {\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                // 如果是树表格只允许导出数据源\n                var rest_1 = [];\n                var expandMaps_1 = new Map();\n                XEUtils.eachTree(datas, function (item, $rowIndex, items, path, parent, nodes) {\n                    var row = item._row || item;\n                    var parentRow = parent && parent._row ? parent._row : parent;\n                    if ((isAllExpand || !parentRow || (expandMaps_1.has(parentRow) && $xetable.isTreeExpandByRow(parentRow)))) {\n                        var hasRowChild = hasTreeChildren(row);\n                        var item_3 = {\n                            _row: row,\n                            _level: nodes.length - 1,\n                            _hasChild: hasRowChild,\n                            _expand: hasRowChild && $xetable.isTreeExpandByRow(row)\n                        };\n                        columns.forEach(function (column, $columnIndex) {\n                            var cellValue = '';\n                            var renderOpts = column.editRender || column.cellRender;\n                            var bodyExportMethod = column.exportMethod;\n                            if (!bodyExportMethod && renderOpts && renderOpts.name) {\n                                var compConf = VXETable.renderer.get(renderOpts.name);\n                                if (compConf) {\n                                    bodyExportMethod = compConf.exportMethod;\n                                }\n                            }\n                            if (!bodyExportMethod) {\n                                bodyExportMethod = columnOpts.exportMethod;\n                            }\n                            if (bodyExportMethod) {\n                                cellValue = bodyExportMethod({ $table: $xetable, row: row, column: column, options: opts });\n                            }\n                            else {\n                                switch (column.type) {\n                                    case 'seq':\n                                        cellValue = mode === 'all' ? path.map(function (num, i) { return i % 2 === 0 ? (Number(num) + 1) : '.'; }).join('') : getSeq(row, $rowIndex, column, $columnIndex);\n                                        break;\n                                    case 'checkbox':\n                                        cellValue = toBooleanValue($xetable.isCheckedByCheckboxRow(row));\n                                        item_3._checkboxLabel = checkboxOpts.labelField ? XEUtils.get(row, checkboxOpts.labelField) : '';\n                                        item_3._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({ row: row });\n                                        break;\n                                    case 'radio':\n                                        cellValue = toBooleanValue($xetable.isCheckedByRadioRow(row));\n                                        item_3._radioLabel = radioOpts.labelField ? XEUtils.get(row, radioOpts.labelField) : '';\n                                        item_3._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({ row: row });\n                                        break;\n                                    default:\n                                        if (opts.original) {\n                                            cellValue = getCellValue(row, column);\n                                        }\n                                        else {\n                                            cellValue = $xetable.getCellLabel(row, column);\n                                            if (column.type === 'html') {\n                                                htmlCellElem.innerHTML = cellValue;\n                                                cellValue = htmlCellElem.innerText.trim();\n                                            }\n                                            else {\n                                                var cell = $xetable.getCell(row, column);\n                                                if (cell) {\n                                                    cellValue = cell.innerText.trim();\n                                                }\n                                            }\n                                        }\n                                }\n                            }\n                            item_3[column.id] = XEUtils.toValueString(cellValue);\n                        });\n                        expandMaps_1.set(row, 1);\n                        rest_1.push(Object.assign(item_3, row));\n                    }\n                }, { children: childrenField });\n                return rest_1;\n            }\n            return datas.map(function (row, $rowIndex) {\n                var item = {\n                    _row: row\n                };\n                columns.forEach(function (column, $columnIndex) {\n                    var cellValue = '';\n                    var renderOpts = column.editRender || column.cellRender;\n                    var exportLabelMethod = column.exportMethod;\n                    if (!exportLabelMethod && renderOpts && renderOpts.name) {\n                        var compConf = VXETable.renderer.get(renderOpts.name);\n                        if (compConf) {\n                            exportLabelMethod = compConf.exportMethod;\n                        }\n                    }\n                    if (exportLabelMethod) {\n                        cellValue = exportLabelMethod({ $table: $xetable, row: row, column: column, options: opts });\n                    }\n                    else {\n                        switch (column.type) {\n                            case 'seq':\n                                cellValue = mode === 'all' ? $rowIndex + 1 : getSeq(row, $rowIndex, column, $columnIndex);\n                                break;\n                            case 'checkbox':\n                                cellValue = toBooleanValue($xetable.isCheckedByCheckboxRow(row));\n                                item._checkboxLabel = checkboxOpts.labelField ? XEUtils.get(row, checkboxOpts.labelField) : '';\n                                item._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({ row: row });\n                                break;\n                            case 'radio':\n                                cellValue = toBooleanValue($xetable.isCheckedByRadioRow(row));\n                                item._radioLabel = radioOpts.labelField ? XEUtils.get(row, radioOpts.labelField) : '';\n                                item._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({ row: row });\n                                break;\n                            default:\n                                if (opts.original) {\n                                    cellValue = getCellValue(row, column);\n                                }\n                                else {\n                                    cellValue = $xetable.getCellLabel(row, column);\n                                    if (column.type === 'html') {\n                                        htmlCellElem.innerHTML = cellValue;\n                                        cellValue = htmlCellElem.innerText.trim();\n                                    }\n                                    else {\n                                        var cell = $xetable.getCell(row, column);\n                                        if (cell) {\n                                            cellValue = cell.innerText.trim();\n                                        }\n                                    }\n                                }\n                        }\n                    }\n                    item[column.id] = XEUtils.toValueString(cellValue);\n                });\n                return item;\n            });\n        };\n        var getExportData = function (opts) {\n            var columns = opts.columns, dataFilterMethod = opts.dataFilterMethod;\n            var datas = opts.data;\n            if (dataFilterMethod) {\n                datas = datas.filter(function (row, index) { return dataFilterMethod({ row: row, $rowIndex: index }); });\n            }\n            return getLabelData(opts, columns, datas);\n        };\n        var getFooterCellValue = function (opts, items, column) {\n            var columnOpts = computeColumnOpts.value;\n            var renderOpts = column.editRender || column.cellRender;\n            var footLabelMethod = column.footerExportMethod;\n            if (!footLabelMethod && renderOpts && renderOpts.name) {\n                var compConf = VXETable.renderer.get(renderOpts.name);\n                if (compConf) {\n                    footLabelMethod = compConf.footerExportMethod;\n                }\n            }\n            if (!footLabelMethod) {\n                footLabelMethod = columnOpts.footerExportMethod;\n            }\n            var _columnIndex = $xetable.getVTColumnIndex(column);\n            var cellValue = footLabelMethod ? footLabelMethod({ $table: $xetable, items: items, itemIndex: _columnIndex, _columnIndex: _columnIndex, column: column, options: opts }) : XEUtils.toValueString(items[_columnIndex]);\n            return cellValue;\n        };\n        var toCsv = function (opts, columns, datas) {\n            var content = csvBOM;\n            if (opts.isHeader) {\n                content += columns.map(function (column) { return toTxtCellLabel(getHeaderTitle(opts, column)); }).join(',') + enterSymbol;\n            }\n            datas.forEach(function (row) {\n                content += columns.map(function (column) { return toTxtCellLabel(getCsvCellTypeLabel(column, row[column.id])); }).join(',') + enterSymbol;\n            });\n            if (opts.isFooter) {\n                var footerTableData = reactData.footerTableData;\n                var footers = getFooterData(opts, footerTableData);\n                footers.forEach(function (rows) {\n                    content += columns.map(function (column) { return toTxtCellLabel(getFooterCellValue(opts, rows, column)); }).join(',') + enterSymbol;\n                });\n            }\n            return content;\n        };\n        var toTxt = function (opts, columns, datas) {\n            var content = '';\n            if (opts.isHeader) {\n                content += columns.map(function (column) { return toTxtCellLabel(getHeaderTitle(opts, column)); }).join('\\t') + enterSymbol;\n            }\n            datas.forEach(function (row) {\n                content += columns.map(function (column) { return toTxtCellLabel(row[column.id]); }).join('\\t') + enterSymbol;\n            });\n            if (opts.isFooter) {\n                var footerTableData = reactData.footerTableData;\n                var footers = getFooterData(opts, footerTableData);\n                footers.forEach(function (rows) {\n                    content += columns.map(function (column) { return toTxtCellLabel(getFooterCellValue(opts, rows, column)); }).join(',') + enterSymbol;\n                });\n            }\n            return content;\n        };\n        var hasEllipsis = function (column, property, allColumnOverflow) {\n            var columnOverflow = column[property];\n            var headOverflow = XEUtils.isUndefined(columnOverflow) || XEUtils.isNull(columnOverflow) ? allColumnOverflow : columnOverflow;\n            var showEllipsis = headOverflow === 'ellipsis';\n            var showTitle = headOverflow === 'title';\n            var showTooltip = headOverflow === true || headOverflow === 'tooltip';\n            var isEllipsis = showTitle || showTooltip || showEllipsis;\n            // 虚拟滚动不支持动态高度\n            var scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad;\n            if ((scrollXLoad || scrollYLoad) && !isEllipsis) {\n                isEllipsis = true;\n            }\n            return isEllipsis;\n        };\n        var toHtml = function (opts, columns, datas) {\n            var id = props.id, border = props.border, treeConfig = props.treeConfig, allHeaderAlign = props.headerAlign, allAlign = props.align, allFooterAlign = props.footerAlign, allColumnOverflow = props.showOverflow, allColumnHeaderOverflow = props.showHeaderOverflow;\n            var isAllSelected = reactData.isAllSelected, isIndeterminate = reactData.isIndeterminate, mergeList = reactData.mergeList;\n            var treeOpts = computeTreeOpts.value;\n            var isPrint = opts.print, isHeader = opts.isHeader, isFooter = opts.isFooter, isColgroup = opts.isColgroup, isMerge = opts.isMerge, colgroups = opts.colgroups, original = opts.original;\n            var allCls = 'check-all';\n            var clss = [\n                'vxe-table',\n                \"border--\".concat(toTableBorder(border)),\n                isPrint ? 'is--print' : '',\n                isHeader ? 'is--header' : ''\n            ].filter(function (cls) { return cls; });\n            var tables = [\n                \"<table class=\\\"\".concat(clss.join(' '), \"\\\" border=\\\"0\\\" cellspacing=\\\"0\\\" cellpadding=\\\"0\\\">\"),\n                \"<colgroup>\".concat(columns.map(function (column) { return \"<col style=\\\"width:\".concat(column.renderWidth, \"px\\\">\"); }).join(''), \"</colgroup>\")\n            ];\n            if (isHeader) {\n                tables.push('<thead>');\n                if (isColgroup && !original) {\n                    colgroups.forEach(function (cols) {\n                        tables.push(\"<tr>\".concat(cols.map(function (column) {\n                            var headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;\n                            var classNames = hasEllipsis(column, 'showHeaderOverflow', allColumnHeaderOverflow) ? ['col--ellipsis'] : [];\n                            var cellTitle = getHeaderTitle(opts, column);\n                            var childWidth = 0;\n                            var countChild = 0;\n                            XEUtils.eachTree([column], function (item) {\n                                if (!item.childNodes || !column.childNodes.length) {\n                                    countChild++;\n                                }\n                                childWidth += item.renderWidth;\n                            }, { children: 'childNodes' });\n                            var cellWidth = childWidth - countChild;\n                            if (headAlign) {\n                                classNames.push(\"col--\".concat(headAlign));\n                            }\n                            if (column.type === 'checkbox') {\n                                return \"<th class=\\\"\".concat(classNames.join(' '), \"\\\" colspan=\\\"\").concat(column._colSpan, \"\\\" rowspan=\\\"\").concat(column._rowSpan, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(cellWidth, \"px\\\"\"), \"><input type=\\\"checkbox\\\" class=\\\"\").concat(allCls, \"\\\" \").concat(isAllSelected ? 'checked' : '', \"><span>\").concat(cellTitle, \"</span></div></th>\");\n                            }\n                            return \"<th class=\\\"\".concat(classNames.join(' '), \"\\\" colspan=\\\"\").concat(column._colSpan, \"\\\" rowspan=\\\"\").concat(column._rowSpan, \"\\\" title=\\\"\").concat(cellTitle, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(cellWidth, \"px\\\"\"), \"><span>\").concat(formatText(cellTitle, true), \"</span></div></th>\");\n                        }).join(''), \"</tr>\"));\n                    });\n                }\n                else {\n                    tables.push(\"<tr>\".concat(columns.map(function (column) {\n                        var headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;\n                        var classNames = hasEllipsis(column, 'showHeaderOverflow', allColumnHeaderOverflow) ? ['col--ellipsis'] : [];\n                        var cellTitle = getHeaderTitle(opts, column);\n                        if (headAlign) {\n                            classNames.push(\"col--\".concat(headAlign));\n                        }\n                        if (column.type === 'checkbox') {\n                            return \"<th class=\\\"\".concat(classNames.join(' '), \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \"><input type=\\\"checkbox\\\" class=\\\"\").concat(allCls, \"\\\" \").concat(isAllSelected ? 'checked' : '', \"><span>\").concat(cellTitle, \"</span></div></th>\");\n                        }\n                        return \"<th class=\\\"\".concat(classNames.join(' '), \"\\\" title=\\\"\").concat(cellTitle, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \"><span>\").concat(formatText(cellTitle, true), \"</span></div></th>\");\n                    }).join(''), \"</tr>\"));\n                }\n                tables.push('</thead>');\n            }\n            if (datas.length) {\n                tables.push('<tbody>');\n                if (treeConfig) {\n                    datas.forEach(function (item) {\n                        tables.push('<tr>' + columns.map(function (column) {\n                            var cellAlign = column.align || allAlign;\n                            var classNames = hasEllipsis(column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];\n                            var cellValue = item[column.id];\n                            if (cellAlign) {\n                                classNames.push(\"col--\".concat(cellAlign));\n                            }\n                            if (column.treeNode) {\n                                var treeIcon = '';\n                                if (item._hasChild) {\n                                    treeIcon = \"<i class=\\\"\".concat(item._expand ? 'vxe-table--tree-fold-icon' : 'vxe-table--tree-unfold-icon', \"\\\"></i>\");\n                                }\n                                classNames.push('vxe-table--tree-node');\n                                if (column.type === 'radio') {\n                                    return \"<td class=\\\"\".concat(classNames.join(' '), \"\\\" title=\\\"\").concat(cellValue, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \"><div class=\\\"vxe-table--tree-node-wrapper\\\" style=\\\"padding-left: \").concat(item._level * treeOpts.indent, \"px\\\"><div class=\\\"vxe-table--tree-icon-wrapper\\\">\").concat(treeIcon, \"</div><div class=\\\"vxe-table--tree-cell\\\"><input type=\\\"radio\\\" name=\\\"radio_\").concat(id, \"\\\" \").concat(item._radioDisabled ? 'disabled ' : '').concat(getBooleanValue(cellValue) ? 'checked' : '', \"><span>\").concat(item._radioLabel, \"</span></div></div></div></td>\");\n                                }\n                                else if (column.type === 'checkbox') {\n                                    return \"<td class=\\\"\".concat(classNames.join(' '), \"\\\" title=\\\"\").concat(cellValue, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \"><div class=\\\"vxe-table--tree-node-wrapper\\\" style=\\\"padding-left: \").concat(item._level * treeOpts.indent, \"px\\\"><div class=\\\"vxe-table--tree-icon-wrapper\\\">\").concat(treeIcon, \"</div><div class=\\\"vxe-table--tree-cell\\\"><input type=\\\"checkbox\\\" \").concat(item._checkboxDisabled ? 'disabled ' : '').concat(getBooleanValue(cellValue) ? 'checked' : '', \"><span>\").concat(item._checkboxLabel, \"</span></div></div></div></td>\");\n                                }\n                                return \"<td class=\\\"\".concat(classNames.join(' '), \"\\\" title=\\\"\").concat(cellValue, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \"><div class=\\\"vxe-table--tree-node-wrapper\\\" style=\\\"padding-left: \").concat(item._level * treeOpts.indent, \"px\\\"><div class=\\\"vxe-table--tree-icon-wrapper\\\">\").concat(treeIcon, \"</div><div class=\\\"vxe-table--tree-cell\\\">\").concat(cellValue, \"</div></div></div></td>\");\n                            }\n                            if (column.type === 'radio') {\n                                return \"<td class=\\\"\".concat(classNames.join(' '), \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \"><input type=\\\"radio\\\" name=\\\"radio_\").concat(id, \"\\\" \").concat(item._radioDisabled ? 'disabled ' : '').concat(getBooleanValue(cellValue) ? 'checked' : '', \"><span>\").concat(item._radioLabel, \"</span></div></td>\");\n                            }\n                            else if (column.type === 'checkbox') {\n                                return \"<td class=\\\"\".concat(classNames.join(' '), \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \"><input type=\\\"checkbox\\\" \").concat(item._checkboxDisabled ? 'disabled ' : '').concat(getBooleanValue(cellValue) ? 'checked' : '', \"><span>\").concat(item._checkboxLabel, \"</span></div></td>\");\n                            }\n                            return \"<td class=\\\"\".concat(classNames.join(' '), \"\\\" title=\\\"\").concat(cellValue, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \">\").concat(formatText(cellValue, true), \"</div></td>\");\n                        }).join('') + '</tr>');\n                    });\n                }\n                else {\n                    datas.forEach(function (item) {\n                        tables.push('<tr>' + columns.map(function (column) {\n                            var cellAlign = column.align || allAlign;\n                            var classNames = hasEllipsis(column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];\n                            var cellValue = item[column.id];\n                            var rowSpan = 1;\n                            var colSpan = 1;\n                            if (isMerge && mergeList.length) {\n                                var _rowIndex = $xetable.getVTRowIndex(item._row);\n                                var _columnIndex = $xetable.getVTColumnIndex(column);\n                                var spanRest = mergeBodyMethod(mergeList, _rowIndex, _columnIndex);\n                                if (spanRest) {\n                                    var rowspan = spanRest.rowspan, colspan = spanRest.colspan;\n                                    if (!rowspan || !colspan) {\n                                        return '';\n                                    }\n                                    if (rowspan > 1) {\n                                        rowSpan = rowspan;\n                                    }\n                                    if (colspan > 1) {\n                                        colSpan = colspan;\n                                    }\n                                }\n                            }\n                            if (cellAlign) {\n                                classNames.push(\"col--\".concat(cellAlign));\n                            }\n                            if (column.type === 'radio') {\n                                return \"<td class=\\\"\".concat(classNames.join(' '), \"\\\" rowspan=\\\"\").concat(rowSpan, \"\\\" colspan=\\\"\").concat(colSpan, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \"><input type=\\\"radio\\\" name=\\\"radio_\").concat(id, \"\\\" \").concat(item._radioDisabled ? 'disabled ' : '').concat(getBooleanValue(cellValue) ? 'checked' : '', \"><span>\").concat(item._radioLabel, \"</span></div></td>\");\n                            }\n                            else if (column.type === 'checkbox') {\n                                return \"<td class=\\\"\".concat(classNames.join(' '), \"\\\" rowspan=\\\"\").concat(rowSpan, \"\\\" colspan=\\\"\").concat(colSpan, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \"><input type=\\\"checkbox\\\" \").concat(item._checkboxDisabled ? 'disabled ' : '').concat(getBooleanValue(cellValue) ? 'checked' : '', \"><span>\").concat(item._checkboxLabel, \"</span></div></td>\");\n                            }\n                            return \"<td class=\\\"\".concat(classNames.join(' '), \"\\\" rowspan=\\\"\").concat(rowSpan, \"\\\" colspan=\\\"\").concat(colSpan, \"\\\" title=\\\"\").concat(cellValue, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \">\").concat(formatText(cellValue, true), \"</div></td>\");\n                        }).join('') + '</tr>');\n                    });\n                }\n                tables.push('</tbody>');\n            }\n            if (isFooter) {\n                var footerTableData = reactData.footerTableData;\n                var footers = getFooterData(opts, footerTableData);\n                if (footers.length) {\n                    tables.push('<tfoot>');\n                    footers.forEach(function (rows) {\n                        tables.push(\"<tr>\".concat(columns.map(function (column) {\n                            var footAlign = column.footerAlign || column.align || allFooterAlign || allAlign;\n                            var classNames = hasEllipsis(column, 'showOverflow', allColumnOverflow) ? ['col--ellipsis'] : [];\n                            var cellValue = getFooterCellValue(opts, rows, column);\n                            if (footAlign) {\n                                classNames.push(\"col--\".concat(footAlign));\n                            }\n                            return \"<td class=\\\"\".concat(classNames.join(' '), \"\\\" title=\\\"\").concat(cellValue, \"\\\"><div \").concat(isPrint ? '' : \"style=\\\"width: \".concat(column.renderWidth, \"px\\\"\"), \">\").concat(formatText(cellValue, true), \"</div></td>\");\n                        }).join(''), \"</tr>\"));\n                    });\n                    tables.push('</tfoot>');\n                }\n            }\n            // 是否半选状态\n            var script = !isAllSelected && isIndeterminate ? \"<script>(function(){var a=document.querySelector(\\\".\".concat(allCls, \"\\\");if(a){a.indeterminate=true}})()</script>\") : '';\n            tables.push('</table>', script);\n            return isPrint ? tables.join('') : createHtmlPage(opts, tables.join(''));\n        };\n        var toXML = function (opts, columns, datas) {\n            var xml = [\n                '<?xml version=\"1.0\"?>',\n                '<?mso-application progid=\"Excel.Sheet\"?>',\n                '<Workbook xmlns=\"urn:schemas-microsoft-com:office:spreadsheet\" xmlns:o=\"urn:schemas-microsoft-com:office:office\" xmlns:x=\"urn:schemas-microsoft-com:office:excel\" xmlns:ss=\"urn:schemas-microsoft-com:office:spreadsheet\" xmlns:html=\"http://www.w3.org/TR/REC-html40\">',\n                '<DocumentProperties xmlns=\"urn:schemas-microsoft-com:office:office\">',\n                '<Version>16.00</Version>',\n                '</DocumentProperties>',\n                '<ExcelWorkbook xmlns=\"urn:schemas-microsoft-com:office:excel\">',\n                '<WindowHeight>7920</WindowHeight>',\n                '<WindowWidth>21570</WindowWidth>',\n                '<WindowTopX>32767</WindowTopX>',\n                '<WindowTopY>32767</WindowTopY>',\n                '<ProtectStructure>False</ProtectStructure>',\n                '<ProtectWindows>False</ProtectWindows>',\n                '</ExcelWorkbook>',\n                \"<Worksheet ss:Name=\\\"\".concat(opts.sheetName, \"\\\">\"),\n                '<Table>',\n                columns.map(function (column) { return \"<Column ss:Width=\\\"\".concat(column.renderWidth, \"\\\"/>\"); }).join('')\n            ].join('');\n            if (opts.isHeader) {\n                xml += \"<Row>\".concat(columns.map(function (column) { return \"<Cell><Data ss:Type=\\\"String\\\">\".concat(getHeaderTitle(opts, column), \"</Data></Cell>\"); }).join(''), \"</Row>\");\n            }\n            datas.forEach(function (row) {\n                xml += '<Row>' + columns.map(function (column) { return \"<Cell><Data ss:Type=\\\"String\\\">\".concat(row[column.id], \"</Data></Cell>\"); }).join('') + '</Row>';\n            });\n            if (opts.isFooter) {\n                var footerTableData = reactData.footerTableData;\n                var footers = getFooterData(opts, footerTableData);\n                footers.forEach(function (rows) {\n                    xml += \"<Row>\".concat(columns.map(function (column) { return \"<Cell><Data ss:Type=\\\"String\\\">\".concat(getFooterCellValue(opts, rows, column), \"</Data></Cell>\"); }).join(''), \"</Row>\");\n                });\n            }\n            return \"\".concat(xml, \"</Table></Worksheet></Workbook>\");\n        };\n        var getContent = function (opts, columns, datas) {\n            if (columns.length) {\n                switch (opts.type) {\n                    case 'csv':\n                        return toCsv(opts, columns, datas);\n                    case 'txt':\n                        return toTxt(opts, columns, datas);\n                    case 'html':\n                        return toHtml(opts, columns, datas);\n                    case 'xml':\n                        return toXML(opts, columns, datas);\n                }\n            }\n            return '';\n        };\n        var downloadFile = function (opts, content) {\n            var filename = opts.filename, type = opts.type, download = opts.download;\n            if (!download) {\n                var blob = getExportBlobByContent(content, opts);\n                return Promise.resolve({ type: type, content: content, blob: blob });\n            }\n            saveLocalFile({ filename: filename, type: type, content: content }).then(function () {\n                if (opts.message !== false) {\n                    // 检测弹窗模块\n                    if (process.env.NODE_ENV === 'development') {\n                        if (!VXETable.modal) {\n                            errLog('vxe.error.reqModule', ['Modal']);\n                        }\n                    }\n                    VXETable.modal.message({ content: GlobalConfig.i18n('vxe.table.expSuccess'), status: 'success' });\n                }\n            });\n        };\n        var handleExport = function (opts) {\n            var remote = opts.remote, columns = opts.columns, colgroups = opts.colgroups, exportMethod = opts.exportMethod, afterExportMethod = opts.afterExportMethod;\n            return new Promise(function (resolve) {\n                if (remote) {\n                    var params = { options: opts, $table: $xetable, $grid: $xegrid };\n                    resolve(exportMethod ? exportMethod(params) : params);\n                }\n                else {\n                    var datas_1 = getExportData(opts);\n                    resolve($xetable.preventEvent(null, 'event.export', { options: opts, columns: columns, colgroups: colgroups, datas: datas_1 }, function () {\n                        return downloadFile(opts, getContent(opts, columns, datas_1));\n                    }));\n                }\n            }).then(function (params) {\n                clearColumnConvert(columns);\n                if (!opts.print) {\n                    if (afterExportMethod) {\n                        afterExportMethod({ status: true, options: opts, $table: $xetable, $grid: $xegrid });\n                    }\n                }\n                return Object.assign({ status: true }, params);\n            }).catch(function () {\n                clearColumnConvert(columns);\n                if (!opts.print) {\n                    if (afterExportMethod) {\n                        afterExportMethod({ status: false, options: opts, $table: $xetable, $grid: $xegrid });\n                    }\n                }\n                var params = { status: false };\n                return Promise.reject(params);\n            });\n        };\n        var handleImport = function (content, opts) {\n            var tableFullColumn = internalData.tableFullColumn, _importResolve = internalData._importResolve, _importReject = internalData._importReject;\n            var rest = { fields: [], rows: [] };\n            switch (opts.type) {\n                case 'csv':\n                    rest = parseCsv(tableFullColumn, content);\n                    break;\n                case 'txt':\n                    rest = parseTxt(tableFullColumn, content);\n                    break;\n                case 'html':\n                    rest = parseHTML(tableFullColumn, content);\n                    break;\n                case 'xml':\n                    rest = parseXML(tableFullColumn, content);\n                    break;\n            }\n            var fields = rest.fields, rows = rest.rows;\n            var status = checkImportData(tableFullColumn, fields);\n            if (status) {\n                $xetable.createData(rows)\n                    .then(function (data) {\n                    var loadRest;\n                    if (opts.mode === 'insert') {\n                        loadRest = $xetable.insert(data);\n                    }\n                    else {\n                        loadRest = $xetable.reloadData(data);\n                    }\n                    if (opts.message !== false) {\n                        // 检测弹窗模块\n                        if (process.env.NODE_ENV === 'development') {\n                            if (!VXETable.modal) {\n                                errLog('vxe.error.reqModule', ['Modal']);\n                            }\n                        }\n                        VXETable.modal.message({ content: GlobalConfig.i18n('vxe.table.impSuccess', [rows.length]), status: 'success' });\n                    }\n                    return loadRest.then(function () {\n                        if (_importResolve) {\n                            _importResolve({ status: true });\n                        }\n                    });\n                });\n            }\n            else if (opts.message !== false) {\n                // 检测弹窗模块\n                if (process.env.NODE_ENV === 'development') {\n                    if (!VXETable.modal) {\n                        errLog('vxe.error.reqModule', ['Modal']);\n                    }\n                }\n                VXETable.modal.message({ content: GlobalConfig.i18n('vxe.error.impFields'), status: 'error' });\n                if (_importReject) {\n                    _importReject({ status: false });\n                }\n            }\n        };\n        var handleFileImport = function (file, opts) {\n            var importMethod = opts.importMethod, afterImportMethod = opts.afterImportMethod;\n            var _a = parseFile(file), type = _a.type, filename = _a.filename;\n            // 检查类型，如果为自定义导出，则不需要校验类型\n            if (!importMethod && !XEUtils.includes(VXETable.globalConfs.importTypes, type)) {\n                if (opts.message !== false) {\n                    // 检测弹窗模块\n                    if (process.env.NODE_ENV === 'development') {\n                        if (!VXETable.modal) {\n                            errLog('vxe.error.reqModule', ['Modal']);\n                        }\n                    }\n                    VXETable.modal.message({ content: GlobalConfig.i18n('vxe.error.notType', [type]), status: 'error' });\n                }\n                var params = { status: false };\n                return Promise.reject(params);\n            }\n            var rest = new Promise(function (resolve, reject) {\n                var _importResolve = function (params) {\n                    resolve(params);\n                    internalData._importResolve = null;\n                    internalData._importReject = null;\n                };\n                var _importReject = function (params) {\n                    reject(params);\n                    internalData._importResolve = null;\n                    internalData._importReject = null;\n                };\n                internalData._importResolve = _importResolve;\n                internalData._importReject = _importReject;\n                if (window.FileReader) {\n                    var options_1 = Object.assign({ mode: 'insert' }, opts, { type: type, filename: filename });\n                    if (options_1.remote) {\n                        if (importMethod) {\n                            Promise.resolve(importMethod({ file: file, options: options_1, $table: $xetable })).then(function () {\n                                _importResolve({ status: true });\n                            }).catch(function () {\n                                _importResolve({ status: true });\n                            });\n                        }\n                        else {\n                            _importResolve({ status: true });\n                        }\n                    }\n                    else {\n                        var tableFullColumn = internalData.tableFullColumn;\n                        $xetable.preventEvent(null, 'event.import', { file: file, options: options_1, columns: tableFullColumn }, function () {\n                            var reader = new FileReader();\n                            reader.onerror = function () {\n                                errLog('vxe.error.notType', [type]);\n                                _importReject({ status: false });\n                            };\n                            reader.onload = function (e) {\n                                handleImport(e.target.result, options_1);\n                            };\n                            reader.readAsText(file, options_1.encoding || 'UTF-8');\n                        });\n                    }\n                }\n                else {\n                    // 不支持的浏览器\n                    if (process.env.NODE_ENV === 'development') {\n                        errLog('vxe.error.notExp');\n                    }\n                    _importResolve({ status: true });\n                }\n            });\n            return rest.then(function () {\n                if (afterImportMethod) {\n                    afterImportMethod({ status: true, options: opts, $table: $xetable });\n                }\n            }).catch(function (e) {\n                if (afterImportMethod) {\n                    afterImportMethod({ status: false, options: opts, $table: $xetable });\n                }\n                return Promise.reject(e);\n            });\n        };\n        var handleExportAndPrint = function (options, isPrint) {\n            var treeConfig = props.treeConfig, showHeader = props.showHeader, showFooter = props.showFooter;\n            var initStore = reactData.initStore, mergeList = reactData.mergeList, isGroup = reactData.isGroup, footerTableData = reactData.footerTableData, exportStore = reactData.exportStore, exportParams = reactData.exportParams;\n            var collectColumn = internalData.collectColumn;\n            var hasTree = treeConfig;\n            var customOpts = computeCustomOpts.value;\n            var selectRecords = $xetable.getCheckboxRecords();\n            var hasFooter = !!footerTableData.length;\n            var hasMerge = !hasTree && mergeList.length;\n            var defOpts = Object.assign({ message: true, isHeader: showHeader, isFooter: showFooter }, options);\n            var types = defOpts.types || VXETable.globalConfs.exportTypes;\n            var modes = defOpts.modes;\n            var checkMethod = customOpts.checkMethod;\n            var exportColumns = collectColumn.slice(0);\n            var columns = defOpts.columns;\n            // 处理类型\n            var typeList = types.map(function (value) {\n                return {\n                    value: value,\n                    label: \"vxe.export.types.\".concat(value)\n                };\n            });\n            var modeList = modes.map(function (value) {\n                return {\n                    value: value,\n                    label: \"vxe.export.modes.\".concat(value)\n                };\n            });\n            // 默认选中\n            XEUtils.eachTree(exportColumns, function (column, index, items, path, parent) {\n                var isColGroup = column.children && column.children.length;\n                if (isColGroup || defaultFilterExportColumn(column)) {\n                    column.checked = columns ? columns.some(function (item) {\n                        if (isColumnInfo(item)) {\n                            return column === item;\n                        }\n                        else if (XEUtils.isString(item)) {\n                            return column.field === item;\n                        }\n                        else {\n                            var colid = item.id || item.colId;\n                            var type = item.type;\n                            var field = item.property || item.field;\n                            if (colid) {\n                                return column.id === colid;\n                            }\n                            else if (field && type) {\n                                return column.property === field && column.type === type;\n                            }\n                            else if (field) {\n                                return column.property === field;\n                            }\n                            else if (type) {\n                                return column.type === type;\n                            }\n                        }\n                        return false;\n                    }) : column.visible;\n                    column.halfChecked = false;\n                    column.disabled = (parent && parent.disabled) || (checkMethod ? !checkMethod({ column: column }) : false);\n                }\n            });\n            // 更新条件\n            Object.assign(exportStore, {\n                columns: exportColumns,\n                typeList: typeList,\n                modeList: modeList,\n                hasFooter: hasFooter,\n                hasMerge: hasMerge,\n                hasTree: hasTree,\n                isPrint: isPrint,\n                hasColgroup: isGroup,\n                visible: true\n            });\n            // 默认参数\n            Object.assign(exportParams, {\n                mode: selectRecords.length ? 'selected' : 'current'\n            }, defOpts);\n            if (modes.indexOf(exportParams.mode) === -1) {\n                exportParams.mode = modes[0];\n            }\n            if (types.indexOf(exportParams.type) === -1) {\n                exportParams.type = types[0];\n            }\n            initStore.export = true;\n            return nextTick();\n        };\n        var exportMethods = {\n            /**\n             * 导出文件，支持 csv/html/xml/txt\n             * 如果是树表格，则默认是导出所有节点\n             * 如果是启用了虚拟滚动，则只能导出数据源，可以配合 dataFilterMethod 函数自行转换数据\n             * @param {Object} options 参数\n             */\n            exportData: function (options) {\n                var treeConfig = props.treeConfig;\n                var isGroup = reactData.isGroup, tableGroupColumn = reactData.tableGroupColumn;\n                var tableFullColumn = internalData.tableFullColumn, afterFullData = internalData.afterFullData;\n                var exportOpts = computeExportOpts.value;\n                var treeOpts = computeTreeOpts.value;\n                var opts = Object.assign({\n                    // filename: '',\n                    // sheetName: '',\n                    // original: false,\n                    // message: false,\n                    isHeader: true,\n                    isFooter: true,\n                    isColgroup: true,\n                    // isMerge: false,\n                    // isAllExpand: false,\n                    download: true,\n                    type: 'csv',\n                    mode: 'current'\n                    // data: null,\n                    // remote: false,\n                    // dataFilterMethod: null,\n                    // footerFilterMethod: null,\n                    // exportMethod: null,\n                    // columnFilterMethod: null,\n                    // beforeExportMethod: null,\n                    // afterExportMethod: null\n                }, exportOpts, {\n                    print: false\n                }, options);\n                var type = opts.type, mode = opts.mode, columns = opts.columns, original = opts.original, beforeExportMethod = opts.beforeExportMethod;\n                var groups = [];\n                var customCols = columns && columns.length ? columns : null;\n                var columnFilterMethod = opts.columnFilterMethod;\n                // 如果设置源数据，则默认导出设置了字段的列\n                if (!customCols && !columnFilterMethod) {\n                    columnFilterMethod = original ? function (_a) {\n                        var column = _a.column;\n                        return column.property;\n                    } : function (_a) {\n                        var column = _a.column;\n                        return defaultFilterExportColumn(column);\n                    };\n                }\n                if (customCols) {\n                    opts._isCustomColumn = true;\n                    groups = XEUtils.searchTree(XEUtils.mapTree(customCols, function (item) {\n                        var targetColumn;\n                        if (item) {\n                            if (isColumnInfo(item)) {\n                                targetColumn = item;\n                            }\n                            else if (XEUtils.isString(item)) {\n                                targetColumn = $xetable.getColumnByField(item);\n                            }\n                            else {\n                                var colid = item.id || item.colId;\n                                var type_1 = item.type;\n                                var field_1 = item.property || item.field;\n                                if (colid) {\n                                    targetColumn = $xetable.getColumnById(colid);\n                                }\n                                else if (field_1 && type_1) {\n                                    targetColumn = tableFullColumn.find(function (column) { return column.property === field_1 && column.type === type_1; });\n                                }\n                                else if (field_1) {\n                                    targetColumn = $xetable.getColumnByField(field_1);\n                                }\n                                else if (type_1) {\n                                    targetColumn = tableFullColumn.find(function (column) { return column.type === type_1; });\n                                }\n                            }\n                            return targetColumn || {};\n                        }\n                    }, {\n                        children: 'childNodes',\n                        mapChildren: '_children'\n                    }), function (column, index) { return isColumnInfo(column) && (!columnFilterMethod || columnFilterMethod({ column: column, $columnIndex: index })); }, {\n                        children: '_children',\n                        mapChildren: 'childNodes',\n                        original: true\n                    });\n                }\n                else {\n                    groups = XEUtils.searchTree(isGroup ? tableGroupColumn : tableFullColumn, function (column, index) { return column.visible && (!columnFilterMethod || columnFilterMethod({ column: column, $columnIndex: index })); }, { children: 'children', mapChildren: 'childNodes', original: true });\n                }\n                // 获取所有列\n                var cols = [];\n                XEUtils.eachTree(groups, function (column) {\n                    var isColGroup = column.children && column.children.length;\n                    if (!isColGroup) {\n                        cols.push(column);\n                    }\n                }, { children: 'childNodes' });\n                // 构建分组层级\n                opts.columns = cols;\n                opts.colgroups = convertToRows(groups);\n                if (!opts.filename) {\n                    opts.filename = GlobalConfig.i18n(opts.original ? 'vxe.table.expOriginFilename' : 'vxe.table.expFilename', [XEUtils.toDateString(Date.now(), 'yyyyMMddHHmmss')]);\n                }\n                if (!opts.sheetName) {\n                    opts.sheetName = document.title;\n                }\n                // 检查类型，如果为自定义导出，则不需要校验类型\n                if (!opts.exportMethod && !XEUtils.includes(VXETable.globalConfs.exportTypes, type)) {\n                    if (process.env.NODE_ENV === 'development') {\n                        errLog('vxe.error.notType', [type]);\n                    }\n                    var params = { status: false };\n                    return Promise.reject(params);\n                }\n                if (!opts.print) {\n                    if (beforeExportMethod) {\n                        beforeExportMethod({ options: opts, $table: $xetable, $grid: $xegrid });\n                    }\n                }\n                if (!opts.data) {\n                    opts.data = afterFullData;\n                    if (mode === 'selected') {\n                        var selectRecords_1 = $xetable.getCheckboxRecords();\n                        if (['html', 'pdf'].indexOf(type) > -1 && treeConfig) {\n                            opts.data = XEUtils.searchTree($xetable.getTableData().fullData, function (item) { return $xetable.findRowIndexOf(selectRecords_1, item) > -1; }, Object.assign({}, treeOpts, { data: '_row' }));\n                        }\n                        else {\n                            opts.data = selectRecords_1;\n                        }\n                    }\n                    else if (mode === 'all') {\n                        if (process.env.NODE_ENV === 'development') {\n                            if (!$xegrid) {\n                                warnLog('vxe.error.errProp', ['all', 'mode=current,selected']);\n                            }\n                        }\n                        if ($xegrid && !opts.remote) {\n                            var gridReactData = $xegrid.reactData;\n                            var computeProxyOpts = $xegrid.getComputeMaps().computeProxyOpts;\n                            var proxyOpts = computeProxyOpts.value;\n                            var beforeQueryAll = proxyOpts.beforeQueryAll, afterQueryAll_1 = proxyOpts.afterQueryAll, _a = proxyOpts.ajax, ajax = _a === void 0 ? {} : _a, _b = proxyOpts.props, props_1 = _b === void 0 ? {} : _b;\n                            var ajaxMethods = ajax.queryAll;\n                            if (process.env.NODE_ENV === 'development') {\n                                if (!ajaxMethods) {\n                                    warnLog('vxe.error.notFunc', ['proxy-config.ajax.queryAll']);\n                                }\n                            }\n                            if (ajaxMethods) {\n                                var params_1 = {\n                                    $table: $xetable,\n                                    $grid: $xegrid,\n                                    sort: gridReactData.sortData,\n                                    filters: gridReactData.filterData,\n                                    form: gridReactData.formData,\n                                    target: ajaxMethods,\n                                    options: opts\n                                };\n                                return Promise.resolve((beforeQueryAll || ajaxMethods)(params_1))\n                                    .catch(function (e) { return e; })\n                                    .then(function (rest) {\n                                    opts.data = (props_1.list ? XEUtils.get(rest, props_1.list) : rest) || [];\n                                    if (afterQueryAll_1) {\n                                        afterQueryAll_1(params_1);\n                                    }\n                                    return handleExport(opts);\n                                });\n                            }\n                        }\n                    }\n                }\n                return handleExport(opts);\n            },\n            importByFile: function (file, options) {\n                var opts = Object.assign({}, options);\n                var beforeImportMethod = opts.beforeImportMethod;\n                if (beforeImportMethod) {\n                    beforeImportMethod({ options: opts, $table: $xetable });\n                }\n                return handleFileImport(file, opts);\n            },\n            importData: function (options) {\n                var importOpts = computeImportOpts.value;\n                var opts = Object.assign({\n                    types: VXETable.globalConfs.importTypes\n                    // beforeImportMethod: null,\n                    // afterImportMethod: null\n                }, importOpts, options);\n                var beforeImportMethod = opts.beforeImportMethod, afterImportMethod = opts.afterImportMethod;\n                if (beforeImportMethod) {\n                    beforeImportMethod({ options: opts, $table: $xetable });\n                }\n                return readLocalFile(opts).catch(function (e) {\n                    if (afterImportMethod) {\n                        afterImportMethod({ status: false, options: opts, $table: $xetable });\n                    }\n                    return Promise.reject(e);\n                }).then(function (params) {\n                    var file = params.file;\n                    return handleFileImport(file, opts);\n                });\n            },\n            saveFile: function (options) {\n                return saveLocalFile(options);\n            },\n            readFile: function (options) {\n                return readLocalFile(options);\n            },\n            print: function (options) {\n                var printOpts = computePrintOpts.value;\n                var opts = Object.assign({\n                    original: false\n                    // beforePrintMethod\n                }, printOpts, options, {\n                    type: 'html',\n                    download: false,\n                    remote: false,\n                    print: true\n                });\n                if (!opts.sheetName) {\n                    opts.sheetName = document.title;\n                }\n                return new Promise(function (resolve) {\n                    if (opts.content) {\n                        resolve(handlePrint($xetable, opts, opts.content));\n                    }\n                    else {\n                        resolve(exportMethods.exportData(opts).then(function (_a) {\n                            var content = _a.content;\n                            return handlePrint($xetable, opts, content);\n                        }));\n                    }\n                });\n            },\n            openImport: function (options) {\n                var treeConfig = props.treeConfig, importConfig = props.importConfig;\n                var initStore = reactData.initStore, importStore = reactData.importStore, importParams = reactData.importParams;\n                var importOpts = computeImportOpts.value;\n                var defOpts = Object.assign({ mode: 'insert', message: true, types: VXETable.globalConfs.importTypes }, options, importOpts);\n                var types = defOpts.types;\n                var isTree = !!treeConfig;\n                if (isTree) {\n                    if (defOpts.message) {\n                        VXETable.modal.message({ content: GlobalConfig.i18n('vxe.error.treeNotImp'), status: 'error' });\n                    }\n                    return;\n                }\n                if (!importConfig) {\n                    errLog('vxe.error.reqProp', ['import-config']);\n                }\n                // 处理类型\n                var typeList = types.map(function (value) {\n                    return {\n                        value: value,\n                        label: \"vxe.export.types.\".concat(value)\n                    };\n                });\n                var modeList = defOpts.modes.map(function (value) {\n                    return {\n                        value: value,\n                        label: \"vxe.import.modes.\".concat(value)\n                    };\n                });\n                Object.assign(importStore, {\n                    file: null,\n                    type: '',\n                    filename: '',\n                    modeList: modeList,\n                    typeList: typeList,\n                    visible: true\n                });\n                Object.assign(importParams, defOpts);\n                initStore.import = true;\n            },\n            openExport: function (options) {\n                var exportOpts = computeExportOpts.value;\n                if (process.env.NODE_ENV === 'development') {\n                    if (!props.exportConfig) {\n                        errLog('vxe.error.reqProp', ['export-config']);\n                    }\n                }\n                handleExportAndPrint(Object.assign({}, exportOpts, options));\n            },\n            openPrint: function (options) {\n                var printOpts = computePrintOpts.value;\n                if (process.env.NODE_ENV === 'development') {\n                    if (!props.printConfig) {\n                        errLog('vxe.error.reqProp', ['print-config']);\n                    }\n                }\n                handleExportAndPrint(Object.assign({}, printOpts, options), true);\n            }\n        };\n        return exportMethods;\n    },\n    setupGrid: function ($xegrid) {\n        return $xegrid.extendTableMethods(tableExportMethodKeys);\n    }\n};\nexport default tableExportHook;\n",
      "start": 1714699767753,
      "end": 1714699767753,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "esbuild",
      "start": 1714699767753,
      "end": 1714699767753,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { inject, nextTick } from \"vue\";\nimport XEUtils from \"xe-utils\";\nimport GlobalConfig from \"../../v-x-e-table/src/conf\";\nimport { VXETable } from \"../../v-x-e-table\";\nimport { isColumnInfo, mergeBodyMethod, getCellValue } from \"../../table/src/util\";\nimport { parseFile, formatText } from \"../../tools/utils\";\nimport { warnLog, errLog } from \"../../tools/log\";\nimport { readLocalFile, handlePrint, saveLocalFile, createHtmlPage, getExportBlobByContent } from \"./util\";\nvar htmlCellElem;\nvar csvBOM = \"\\uFEFF\";\nvar enterSymbol = \"\\r\\n\";\nfunction defaultFilterExportColumn(column) {\n  return column.property || [\"seq\", \"checkbox\", \"radio\"].indexOf(column.type) > -1;\n}\nvar getConvertColumns = function(columns) {\n  var result = [];\n  columns.forEach(function(column) {\n    if (column.childNodes && column.childNodes.length) {\n      result.push(column);\n      result.push.apply(result, getConvertColumns(column.childNodes));\n    } else {\n      result.push(column);\n    }\n  });\n  return result;\n};\nvar convertToRows = function(originColumns) {\n  var maxLevel = 1;\n  var traverse = function(column, parent) {\n    if (parent) {\n      column._level = parent._level + 1;\n      if (maxLevel < column._level) {\n        maxLevel = column._level;\n      }\n    }\n    if (column.childNodes && column.childNodes.length) {\n      var colSpan_1 = 0;\n      column.childNodes.forEach(function(subColumn) {\n        traverse(subColumn, column);\n        colSpan_1 += subColumn._colSpan;\n      });\n      column._colSpan = colSpan_1;\n    } else {\n      column._colSpan = 1;\n    }\n  };\n  originColumns.forEach(function(column) {\n    column._level = 1;\n    traverse(column);\n  });\n  var rows = [];\n  for (var i = 0; i < maxLevel; i++) {\n    rows.push([]);\n  }\n  var allColumns = getConvertColumns(originColumns);\n  allColumns.forEach(function(column) {\n    if (column.childNodes && column.childNodes.length) {\n      column._rowSpan = 1;\n    } else {\n      column._rowSpan = maxLevel - column._level + 1;\n    }\n    rows[column._level - 1].push(column);\n  });\n  return rows;\n};\nfunction toTableBorder(border) {\n  if (border === true) {\n    return \"full\";\n  }\n  if (border) {\n    return border;\n  }\n  return \"default\";\n}\nfunction getBooleanValue(cellValue) {\n  return cellValue === \"TRUE\" || cellValue === \"true\" || cellValue === true;\n}\nfunction getFooterData(opts, footerTableData) {\n  var footerFilterMethod = opts.footerFilterMethod;\n  return footerFilterMethod ? footerTableData.filter(function(items, index) {\n    return footerFilterMethod({ items, $rowIndex: index });\n  }) : footerTableData;\n}\nfunction getCsvCellTypeLabel(column, cellValue) {\n  if (cellValue) {\n    if (column.type === \"seq\") {\n      return \"\t\".concat(cellValue);\n    }\n    switch (column.cellType) {\n      case \"string\":\n        if (!isNaN(cellValue)) {\n          return \"\t\".concat(cellValue);\n        }\n        break;\n      case \"number\":\n        break;\n      default:\n        if (cellValue.length >= 12 && !isNaN(cellValue)) {\n          return \"\t\".concat(cellValue);\n        }\n        break;\n    }\n  }\n  return cellValue;\n}\nfunction toTxtCellLabel(val) {\n  if (/[\",\\s\\n]/.test(val)) {\n    return '\"'.concat(val.replace(/\"/g, '\"\"'), '\"');\n  }\n  return val;\n}\nfunction getElementsByTagName(elem, qualifiedName) {\n  return elem.getElementsByTagName(qualifiedName);\n}\nfunction getTxtCellKey(now) {\n  return \"#\".concat(now, \"@\").concat(XEUtils.uniqueId());\n}\nfunction replaceTxtCell(cell, vMaps) {\n  return cell.replace(/#\\d+@\\d+/g, function(key) {\n    return XEUtils.hasOwnProp(vMaps, key) ? vMaps[key] : key;\n  });\n}\nfunction getTxtCellValue(val, vMaps) {\n  var rest = replaceTxtCell(val, vMaps);\n  return rest.replace(/^\"+$/g, function(qVal) {\n    return '\"'.repeat(Math.ceil(qVal.length / 2));\n  });\n}\nfunction parseCsvAndTxt(columns, content, cellSeparator) {\n  var list = content.split(enterSymbol);\n  var rows = [];\n  var fields = [];\n  if (list.length) {\n    var vMaps_1 = {};\n    var now_1 = Date.now();\n    list.forEach(function(rVal) {\n      if (rVal) {\n        var item_1 = {};\n        rVal = rVal.replace(/(\"\")|(\\n)/g, function(text, dVal) {\n          var key = getTxtCellKey(now_1);\n          vMaps_1[key] = dVal ? '\"' : \"\\n\";\n          return key;\n        }).replace(/\"(.*?)\"/g, function(text, cVal) {\n          var key = getTxtCellKey(now_1);\n          vMaps_1[key] = replaceTxtCell(cVal, vMaps_1);\n          return key;\n        });\n        var cells = rVal.split(cellSeparator);\n        if (!fields.length) {\n          fields = cells.map(function(val) {\n            return getTxtCellValue(val.trim(), vMaps_1);\n          });\n        } else {\n          cells.forEach(function(val, colIndex) {\n            if (colIndex < fields.length) {\n              item_1[fields[colIndex]] = getTxtCellValue(val.trim(), vMaps_1);\n            }\n          });\n          rows.push(item_1);\n        }\n      }\n    });\n  }\n  return { fields, rows };\n}\nfunction parseCsv(columns, content) {\n  return parseCsvAndTxt(columns, content, \",\");\n}\nfunction parseTxt(columns, content) {\n  return parseCsvAndTxt(columns, content, \"\t\");\n}\nfunction parseHTML(columns, content) {\n  var domParser = new DOMParser();\n  var xmlDoc = domParser.parseFromString(content, \"text/html\");\n  var bodyNodes = getElementsByTagName(xmlDoc, \"body\");\n  var rows = [];\n  var fields = [];\n  if (bodyNodes.length) {\n    var tableNodes = getElementsByTagName(bodyNodes[0], \"table\");\n    if (tableNodes.length) {\n      var theadNodes = getElementsByTagName(tableNodes[0], \"thead\");\n      if (theadNodes.length) {\n        XEUtils.arrayEach(getElementsByTagName(theadNodes[0], \"tr\"), function(rowNode) {\n          XEUtils.arrayEach(getElementsByTagName(rowNode, \"th\"), function(cellNode) {\n            fields.push(cellNode.textContent);\n          });\n        });\n        var tbodyNodes = getElementsByTagName(tableNodes[0], \"tbody\");\n        if (tbodyNodes.length) {\n          XEUtils.arrayEach(getElementsByTagName(tbodyNodes[0], \"tr\"), function(rowNode) {\n            var item = {};\n            XEUtils.arrayEach(getElementsByTagName(rowNode, \"td\"), function(cellNode, colIndex) {\n              if (fields[colIndex]) {\n                item[fields[colIndex]] = cellNode.textContent || \"\";\n              }\n            });\n            rows.push(item);\n          });\n        }\n      }\n    }\n  }\n  return { fields, rows };\n}\nfunction parseXML(columns, content) {\n  var domParser = new DOMParser();\n  var xmlDoc = domParser.parseFromString(content, \"application/xml\");\n  var sheetNodes = getElementsByTagName(xmlDoc, \"Worksheet\");\n  var rows = [];\n  var fields = [];\n  if (sheetNodes.length) {\n    var tableNodes = getElementsByTagName(sheetNodes[0], \"Table\");\n    if (tableNodes.length) {\n      var rowNodes = getElementsByTagName(tableNodes[0], \"Row\");\n      if (rowNodes.length) {\n        XEUtils.arrayEach(getElementsByTagName(rowNodes[0], \"Cell\"), function(cellNode) {\n          fields.push(cellNode.textContent);\n        });\n        XEUtils.arrayEach(rowNodes, function(rowNode, index) {\n          if (index) {\n            var item_2 = {};\n            var cellNodes = getElementsByTagName(rowNode, \"Cell\");\n            XEUtils.arrayEach(cellNodes, function(cellNode, colIndex) {\n              if (fields[colIndex]) {\n                item_2[fields[colIndex]] = cellNode.textContent;\n              }\n            });\n            rows.push(item_2);\n          }\n        });\n      }\n    }\n  }\n  return { fields, rows };\n}\nfunction clearColumnConvert(columns) {\n  XEUtils.eachTree(columns, function(column) {\n    delete column._level;\n    delete column._colSpan;\n    delete column._rowSpan;\n    delete column._children;\n    delete column.childNodes;\n  }, { children: \"children\" });\n}\nfunction checkImportData(columns, fields) {\n  var tableFields = [];\n  columns.forEach(function(column) {\n    var field = column.property;\n    if (field) {\n      tableFields.push(field);\n    }\n  });\n  return fields.some(function(field) {\n    return tableFields.indexOf(field) > -1;\n  });\n}\nvar tableExportMethodKeys = [\"exportData\", \"importByFile\", \"importData\", \"saveFile\", \"readFile\", \"print\", \"openImport\", \"openExport\", \"openPrint\"];\nvar tableExportHook = {\n  setupTable: function($xetable) {\n    var props = $xetable.props, reactData = $xetable.reactData, internalData = $xetable.internalData;\n    var _a = $xetable.getComputeMaps(), computeTreeOpts = _a.computeTreeOpts, computePrintOpts = _a.computePrintOpts, computeExportOpts = _a.computeExportOpts, computeImportOpts = _a.computeImportOpts, computeCustomOpts = _a.computeCustomOpts, computeSeqOpts = _a.computeSeqOpts, computeRadioOpts = _a.computeRadioOpts, computeCheckboxOpts = _a.computeCheckboxOpts, computeColumnOpts = _a.computeColumnOpts;\n    var $xegrid = inject(\"$xegrid\", null);\n    var hasTreeChildren = function(row) {\n      var treeOpts = computeTreeOpts.value;\n      var childrenField = treeOpts.children || treeOpts.childrenField;\n      return row[childrenField] && row[childrenField].length;\n    };\n    var getSeq = function(row, $rowIndex, column, $columnIndex) {\n      var seqOpts = computeSeqOpts.value;\n      var seqMethod = seqOpts.seqMethod || column.seqMethod;\n      if (seqMethod) {\n        return seqMethod({\n          row,\n          rowIndex: $xetable.getRowIndex(row),\n          $rowIndex,\n          column,\n          columnIndex: $xetable.getColumnIndex(column),\n          $columnIndex\n        });\n      }\n      return $xetable.getRowSeq(row);\n    };\n    function getHeaderTitle(opts, column) {\n      var columnOpts = computeColumnOpts.value;\n      var headExportMethod = column.headerExportMethod || columnOpts.headerExportMethod;\n      return headExportMethod ? headExportMethod({ column, options: opts, $table: $xetable }) : (opts.original ? column.property : column.getTitle()) || \"\";\n    }\n    var toBooleanValue = function(cellValue) {\n      return XEUtils.isBoolean(cellValue) ? cellValue ? \"TRUE\" : \"FALSE\" : cellValue;\n    };\n    var getLabelData = function(opts, columns, datas) {\n      var isAllExpand = opts.isAllExpand, mode = opts.mode;\n      var treeConfig = props.treeConfig;\n      var radioOpts = computeRadioOpts.value;\n      var checkboxOpts = computeCheckboxOpts.value;\n      var treeOpts = computeTreeOpts.value;\n      var columnOpts = computeColumnOpts.value;\n      if (!htmlCellElem) {\n        htmlCellElem = document.createElement(\"div\");\n      }\n      if (treeConfig) {\n        var childrenField = treeOpts.children || treeOpts.childrenField;\n        var rest_1 = [];\n        var expandMaps_1 = /* @__PURE__ */ new Map();\n        XEUtils.eachTree(datas, function(item, $rowIndex, items, path, parent, nodes) {\n          var row = item._row || item;\n          var parentRow = parent && parent._row ? parent._row : parent;\n          if (isAllExpand || !parentRow || expandMaps_1.has(parentRow) && $xetable.isTreeExpandByRow(parentRow)) {\n            var hasRowChild = hasTreeChildren(row);\n            var item_3 = {\n              _row: row,\n              _level: nodes.length - 1,\n              _hasChild: hasRowChild,\n              _expand: hasRowChild && $xetable.isTreeExpandByRow(row)\n            };\n            columns.forEach(function(column, $columnIndex) {\n              var cellValue = \"\";\n              var renderOpts = column.editRender || column.cellRender;\n              var bodyExportMethod = column.exportMethod;\n              if (!bodyExportMethod && renderOpts && renderOpts.name) {\n                var compConf = VXETable.renderer.get(renderOpts.name);\n                if (compConf) {\n                  bodyExportMethod = compConf.exportMethod;\n                }\n              }\n              if (!bodyExportMethod) {\n                bodyExportMethod = columnOpts.exportMethod;\n              }\n              if (bodyExportMethod) {\n                cellValue = bodyExportMethod({ $table: $xetable, row, column, options: opts });\n              } else {\n                switch (column.type) {\n                  case \"seq\":\n                    cellValue = mode === \"all\" ? path.map(function(num, i) {\n                      return i % 2 === 0 ? Number(num) + 1 : \".\";\n                    }).join(\"\") : getSeq(row, $rowIndex, column, $columnIndex);\n                    break;\n                  case \"checkbox\":\n                    cellValue = toBooleanValue($xetable.isCheckedByCheckboxRow(row));\n                    item_3._checkboxLabel = checkboxOpts.labelField ? XEUtils.get(row, checkboxOpts.labelField) : \"\";\n                    item_3._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({ row });\n                    break;\n                  case \"radio\":\n                    cellValue = toBooleanValue($xetable.isCheckedByRadioRow(row));\n                    item_3._radioLabel = radioOpts.labelField ? XEUtils.get(row, radioOpts.labelField) : \"\";\n                    item_3._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({ row });\n                    break;\n                  default:\n                    if (opts.original) {\n                      cellValue = getCellValue(row, column);\n                    } else {\n                      cellValue = $xetable.getCellLabel(row, column);\n                      if (column.type === \"html\") {\n                        htmlCellElem.innerHTML = cellValue;\n                        cellValue = htmlCellElem.innerText.trim();\n                      } else {\n                        var cell = $xetable.getCell(row, column);\n                        if (cell) {\n                          cellValue = cell.innerText.trim();\n                        }\n                      }\n                    }\n                }\n              }\n              item_3[column.id] = XEUtils.toValueString(cellValue);\n            });\n            expandMaps_1.set(row, 1);\n            rest_1.push(Object.assign(item_3, row));\n          }\n        }, { children: childrenField });\n        return rest_1;\n      }\n      return datas.map(function(row, $rowIndex) {\n        var item = {\n          _row: row\n        };\n        columns.forEach(function(column, $columnIndex) {\n          var cellValue = \"\";\n          var renderOpts = column.editRender || column.cellRender;\n          var exportLabelMethod = column.exportMethod;\n          if (!exportLabelMethod && renderOpts && renderOpts.name) {\n            var compConf = VXETable.renderer.get(renderOpts.name);\n            if (compConf) {\n              exportLabelMethod = compConf.exportMethod;\n            }\n          }\n          if (exportLabelMethod) {\n            cellValue = exportLabelMethod({ $table: $xetable, row, column, options: opts });\n          } else {\n            switch (column.type) {\n              case \"seq\":\n                cellValue = mode === \"all\" ? $rowIndex + 1 : getSeq(row, $rowIndex, column, $columnIndex);\n                break;\n              case \"checkbox\":\n                cellValue = toBooleanValue($xetable.isCheckedByCheckboxRow(row));\n                item._checkboxLabel = checkboxOpts.labelField ? XEUtils.get(row, checkboxOpts.labelField) : \"\";\n                item._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({ row });\n                break;\n              case \"radio\":\n                cellValue = toBooleanValue($xetable.isCheckedByRadioRow(row));\n                item._radioLabel = radioOpts.labelField ? XEUtils.get(row, radioOpts.labelField) : \"\";\n                item._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({ row });\n                break;\n              default:\n                if (opts.original) {\n                  cellValue = getCellValue(row, column);\n                } else {\n                  cellValue = $xetable.getCellLabel(row, column);\n                  if (column.type === \"html\") {\n                    htmlCellElem.innerHTML = cellValue;\n                    cellValue = htmlCellElem.innerText.trim();\n                  } else {\n                    var cell = $xetable.getCell(row, column);\n                    if (cell) {\n                      cellValue = cell.innerText.trim();\n                    }\n                  }\n                }\n            }\n          }\n          item[column.id] = XEUtils.toValueString(cellValue);\n        });\n        return item;\n      });\n    };\n    var getExportData = function(opts) {\n      var columns = opts.columns, dataFilterMethod = opts.dataFilterMethod;\n      var datas = opts.data;\n      if (dataFilterMethod) {\n        datas = datas.filter(function(row, index) {\n          return dataFilterMethod({ row, $rowIndex: index });\n        });\n      }\n      return getLabelData(opts, columns, datas);\n    };\n    var getFooterCellValue = function(opts, items, column) {\n      var columnOpts = computeColumnOpts.value;\n      var renderOpts = column.editRender || column.cellRender;\n      var footLabelMethod = column.footerExportMethod;\n      if (!footLabelMethod && renderOpts && renderOpts.name) {\n        var compConf = VXETable.renderer.get(renderOpts.name);\n        if (compConf) {\n          footLabelMethod = compConf.footerExportMethod;\n        }\n      }\n      if (!footLabelMethod) {\n        footLabelMethod = columnOpts.footerExportMethod;\n      }\n      var _columnIndex = $xetable.getVTColumnIndex(column);\n      var cellValue = footLabelMethod ? footLabelMethod({ $table: $xetable, items, itemIndex: _columnIndex, _columnIndex, column, options: opts }) : XEUtils.toValueString(items[_columnIndex]);\n      return cellValue;\n    };\n    var toCsv = function(opts, columns, datas) {\n      var content = csvBOM;\n      if (opts.isHeader) {\n        content += columns.map(function(column) {\n          return toTxtCellLabel(getHeaderTitle(opts, column));\n        }).join(\",\") + enterSymbol;\n      }\n      datas.forEach(function(row) {\n        content += columns.map(function(column) {\n          return toTxtCellLabel(getCsvCellTypeLabel(column, row[column.id]));\n        }).join(\",\") + enterSymbol;\n      });\n      if (opts.isFooter) {\n        var footerTableData = reactData.footerTableData;\n        var footers = getFooterData(opts, footerTableData);\n        footers.forEach(function(rows) {\n          content += columns.map(function(column) {\n            return toTxtCellLabel(getFooterCellValue(opts, rows, column));\n          }).join(\",\") + enterSymbol;\n        });\n      }\n      return content;\n    };\n    var toTxt = function(opts, columns, datas) {\n      var content = \"\";\n      if (opts.isHeader) {\n        content += columns.map(function(column) {\n          return toTxtCellLabel(getHeaderTitle(opts, column));\n        }).join(\"\t\") + enterSymbol;\n      }\n      datas.forEach(function(row) {\n        content += columns.map(function(column) {\n          return toTxtCellLabel(row[column.id]);\n        }).join(\"\t\") + enterSymbol;\n      });\n      if (opts.isFooter) {\n        var footerTableData = reactData.footerTableData;\n        var footers = getFooterData(opts, footerTableData);\n        footers.forEach(function(rows) {\n          content += columns.map(function(column) {\n            return toTxtCellLabel(getFooterCellValue(opts, rows, column));\n          }).join(\",\") + enterSymbol;\n        });\n      }\n      return content;\n    };\n    var hasEllipsis = function(column, property, allColumnOverflow) {\n      var columnOverflow = column[property];\n      var headOverflow = XEUtils.isUndefined(columnOverflow) || XEUtils.isNull(columnOverflow) ? allColumnOverflow : columnOverflow;\n      var showEllipsis = headOverflow === \"ellipsis\";\n      var showTitle = headOverflow === \"title\";\n      var showTooltip = headOverflow === true || headOverflow === \"tooltip\";\n      var isEllipsis = showTitle || showTooltip || showEllipsis;\n      var scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad;\n      if ((scrollXLoad || scrollYLoad) && !isEllipsis) {\n        isEllipsis = true;\n      }\n      return isEllipsis;\n    };\n    var toHtml = function(opts, columns, datas) {\n      var id = props.id, border = props.border, treeConfig = props.treeConfig, allHeaderAlign = props.headerAlign, allAlign = props.align, allFooterAlign = props.footerAlign, allColumnOverflow = props.showOverflow, allColumnHeaderOverflow = props.showHeaderOverflow;\n      var isAllSelected = reactData.isAllSelected, isIndeterminate = reactData.isIndeterminate, mergeList = reactData.mergeList;\n      var treeOpts = computeTreeOpts.value;\n      var isPrint = opts.print, isHeader = opts.isHeader, isFooter = opts.isFooter, isColgroup = opts.isColgroup, isMerge = opts.isMerge, colgroups = opts.colgroups, original = opts.original;\n      var allCls = \"check-all\";\n      var clss = [\n        \"vxe-table\",\n        \"border--\".concat(toTableBorder(border)),\n        isPrint ? \"is--print\" : \"\",\n        isHeader ? \"is--header\" : \"\"\n      ].filter(function(cls) {\n        return cls;\n      });\n      var tables = [\n        '<table class=\"'.concat(clss.join(\" \"), '\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\">'),\n        \"<colgroup>\".concat(columns.map(function(column) {\n          return '<col style=\"width:'.concat(column.renderWidth, 'px\">');\n        }).join(\"\"), \"</colgroup>\")\n      ];\n      if (isHeader) {\n        tables.push(\"<thead>\");\n        if (isColgroup && !original) {\n          colgroups.forEach(function(cols) {\n            tables.push(\"<tr>\".concat(cols.map(function(column) {\n              var headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;\n              var classNames = hasEllipsis(column, \"showHeaderOverflow\", allColumnHeaderOverflow) ? [\"col--ellipsis\"] : [];\n              var cellTitle = getHeaderTitle(opts, column);\n              var childWidth = 0;\n              var countChild = 0;\n              XEUtils.eachTree([column], function(item) {\n                if (!item.childNodes || !column.childNodes.length) {\n                  countChild++;\n                }\n                childWidth += item.renderWidth;\n              }, { children: \"childNodes\" });\n              var cellWidth = childWidth - countChild;\n              if (headAlign) {\n                classNames.push(\"col--\".concat(headAlign));\n              }\n              if (column.type === \"checkbox\") {\n                return '<th class=\"'.concat(classNames.join(\" \"), '\" colspan=\"').concat(column._colSpan, '\" rowspan=\"').concat(column._rowSpan, '\"><div ').concat(isPrint ? \"\" : 'style=\"width: '.concat(cellWidth, 'px\"'), '><input type=\"checkbox\" class=\"').concat(allCls, '\" ').concat(isAllSelected ? \"checked\" : \"\", \"><span>\").concat(cellTitle, \"</span></div></th>\");\n              }\n              return '<th class=\"'.concat(classNames.join(\" \"), '\" colspan=\"').concat(column._colSpan, '\" rowspan=\"').concat(column._rowSpan, '\" title=\"').concat(cellTitle, '\"><div ').concat(isPrint ? \"\" : 'style=\"width: '.concat(cellWidth, 'px\"'), \"><span>\").concat(formatText(cellTitle, true), \"</span></div></th>\");\n            }).join(\"\"), \"</tr>\"));\n          });\n        } else {\n          tables.push(\"<tr>\".concat(columns.map(function(column) {\n            var headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;\n            var classNames = hasEllipsis(column, \"showHeaderOverflow\", allColumnHeaderOverflow) ? [\"col--ellipsis\"] : [];\n            var cellTitle = getHeaderTitle(opts, column);\n            if (headAlign) {\n              classNames.push(\"col--\".concat(headAlign));\n            }\n            if (column.type === \"checkbox\") {\n              return '<th class=\"'.concat(classNames.join(\" \"), '\"><div ').concat(isPrint ? \"\" : 'style=\"width: '.concat(column.renderWidth, 'px\"'), '><input type=\"checkbox\" class=\"').concat(allCls, '\" ').concat(isAllSelected ? \"checked\" : \"\", \"><span>\").concat(cellTitle, \"</span></div></th>\");\n            }\n            return '<th class=\"'.concat(classNames.join(\" \"), '\" title=\"').concat(cellTitle, '\"><div ').concat(isPrint ? \"\" : 'style=\"width: '.concat(column.renderWidth, 'px\"'), \"><span>\").concat(formatText(cellTitle, true), \"</span></div></th>\");\n          }).join(\"\"), \"</tr>\"));\n        }\n        tables.push(\"</thead>\");\n      }\n      if (datas.length) {\n        tables.push(\"<tbody>\");\n        if (treeConfig) {\n          datas.forEach(function(item) {\n            tables.push(\"<tr>\" + columns.map(function(column) {\n              var cellAlign = column.align || allAlign;\n              var classNames = hasEllipsis(column, \"showOverflow\", allColumnOverflow) ? [\"col--ellipsis\"] : [];\n              var cellValue = item[column.id];\n              if (cellAlign) {\n                classNames.push(\"col--\".concat(cellAlign));\n              }\n              if (column.treeNode) {\n                var treeIcon = \"\";\n                if (item._hasChild) {\n                  treeIcon = '<i class=\"'.concat(item._expand ? \"vxe-table--tree-fold-icon\" : \"vxe-table--tree-unfold-icon\", '\"></i>');\n                }\n                classNames.push(\"vxe-table--tree-node\");\n                if (column.type === \"radio\") {\n                  return '<td class=\"'.concat(classNames.join(\" \"), '\" title=\"').concat(cellValue, '\"><div ').concat(isPrint ? \"\" : 'style=\"width: '.concat(column.renderWidth, 'px\"'), '><div class=\"vxe-table--tree-node-wrapper\" style=\"padding-left: ').concat(item._level * treeOpts.indent, 'px\"><div class=\"vxe-table--tree-icon-wrapper\">').concat(treeIcon, '</div><div class=\"vxe-table--tree-cell\"><input type=\"radio\" name=\"radio_').concat(id, '\" ').concat(item._radioDisabled ? \"disabled \" : \"\").concat(getBooleanValue(cellValue) ? \"checked\" : \"\", \"><span>\").concat(item._radioLabel, \"</span></div></div></div></td>\");\n                } else if (column.type === \"checkbox\") {\n                  return '<td class=\"'.concat(classNames.join(\" \"), '\" title=\"').concat(cellValue, '\"><div ').concat(isPrint ? \"\" : 'style=\"width: '.concat(column.renderWidth, 'px\"'), '><div class=\"vxe-table--tree-node-wrapper\" style=\"padding-left: ').concat(item._level * treeOpts.indent, 'px\"><div class=\"vxe-table--tree-icon-wrapper\">').concat(treeIcon, '</div><div class=\"vxe-table--tree-cell\"><input type=\"checkbox\" ').concat(item._checkboxDisabled ? \"disabled \" : \"\").concat(getBooleanValue(cellValue) ? \"checked\" : \"\", \"><span>\").concat(item._checkboxLabel, \"</span></div></div></div></td>\");\n                }\n                return '<td class=\"'.concat(classNames.join(\" \"), '\" title=\"').concat(cellValue, '\"><div ').concat(isPrint ? \"\" : 'style=\"width: '.concat(column.renderWidth, 'px\"'), '><div class=\"vxe-table--tree-node-wrapper\" style=\"padding-left: ').concat(item._level * treeOpts.indent, 'px\"><div class=\"vxe-table--tree-icon-wrapper\">').concat(treeIcon, '</div><div class=\"vxe-table--tree-cell\">').concat(cellValue, \"</div></div></div></td>\");\n              }\n              if (column.type === \"radio\") {\n                return '<td class=\"'.concat(classNames.join(\" \"), '\"><div ').concat(isPrint ? \"\" : 'style=\"width: '.concat(column.renderWidth, 'px\"'), '><input type=\"radio\" name=\"radio_').concat(id, '\" ').concat(item._radioDisabled ? \"disabled \" : \"\").concat(getBooleanValue(cellValue) ? \"checked\" : \"\", \"><span>\").concat(item._radioLabel, \"</span></div></td>\");\n              } else if (column.type === \"checkbox\") {\n                return '<td class=\"'.concat(classNames.join(\" \"), '\"><div ').concat(isPrint ? \"\" : 'style=\"width: '.concat(column.renderWidth, 'px\"'), '><input type=\"checkbox\" ').concat(item._checkboxDisabled ? \"disabled \" : \"\").concat(getBooleanValue(cellValue) ? \"checked\" : \"\", \"><span>\").concat(item._checkboxLabel, \"</span></div></td>\");\n              }\n              return '<td class=\"'.concat(classNames.join(\" \"), '\" title=\"').concat(cellValue, '\"><div ').concat(isPrint ? \"\" : 'style=\"width: '.concat(column.renderWidth, 'px\"'), \">\").concat(formatText(cellValue, true), \"</div></td>\");\n            }).join(\"\") + \"</tr>\");\n          });\n        } else {\n          datas.forEach(function(item) {\n            tables.push(\"<tr>\" + columns.map(function(column) {\n              var cellAlign = column.align || allAlign;\n              var classNames = hasEllipsis(column, \"showOverflow\", allColumnOverflow) ? [\"col--ellipsis\"] : [];\n              var cellValue = item[column.id];\n              var rowSpan = 1;\n              var colSpan = 1;\n              if (isMerge && mergeList.length) {\n                var _rowIndex = $xetable.getVTRowIndex(item._row);\n                var _columnIndex = $xetable.getVTColumnIndex(column);\n                var spanRest = mergeBodyMethod(mergeList, _rowIndex, _columnIndex);\n                if (spanRest) {\n                  var rowspan = spanRest.rowspan, colspan = spanRest.colspan;\n                  if (!rowspan || !colspan) {\n                    return \"\";\n                  }\n                  if (rowspan > 1) {\n                    rowSpan = rowspan;\n                  }\n                  if (colspan > 1) {\n                    colSpan = colspan;\n                  }\n                }\n              }\n              if (cellAlign) {\n                classNames.push(\"col--\".concat(cellAlign));\n              }\n              if (column.type === \"radio\") {\n                return '<td class=\"'.concat(classNames.join(\" \"), '\" rowspan=\"').concat(rowSpan, '\" colspan=\"').concat(colSpan, '\"><div ').concat(isPrint ? \"\" : 'style=\"width: '.concat(column.renderWidth, 'px\"'), '><input type=\"radio\" name=\"radio_').concat(id, '\" ').concat(item._radioDisabled ? \"disabled \" : \"\").concat(getBooleanValue(cellValue) ? \"checked\" : \"\", \"><span>\").concat(item._radioLabel, \"</span></div></td>\");\n              } else if (column.type === \"checkbox\") {\n                return '<td class=\"'.concat(classNames.join(\" \"), '\" rowspan=\"').concat(rowSpan, '\" colspan=\"').concat(colSpan, '\"><div ').concat(isPrint ? \"\" : 'style=\"width: '.concat(column.renderWidth, 'px\"'), '><input type=\"checkbox\" ').concat(item._checkboxDisabled ? \"disabled \" : \"\").concat(getBooleanValue(cellValue) ? \"checked\" : \"\", \"><span>\").concat(item._checkboxLabel, \"</span></div></td>\");\n              }\n              return '<td class=\"'.concat(classNames.join(\" \"), '\" rowspan=\"').concat(rowSpan, '\" colspan=\"').concat(colSpan, '\" title=\"').concat(cellValue, '\"><div ').concat(isPrint ? \"\" : 'style=\"width: '.concat(column.renderWidth, 'px\"'), \">\").concat(formatText(cellValue, true), \"</div></td>\");\n            }).join(\"\") + \"</tr>\");\n          });\n        }\n        tables.push(\"</tbody>\");\n      }\n      if (isFooter) {\n        var footerTableData = reactData.footerTableData;\n        var footers = getFooterData(opts, footerTableData);\n        if (footers.length) {\n          tables.push(\"<tfoot>\");\n          footers.forEach(function(rows) {\n            tables.push(\"<tr>\".concat(columns.map(function(column) {\n              var footAlign = column.footerAlign || column.align || allFooterAlign || allAlign;\n              var classNames = hasEllipsis(column, \"showOverflow\", allColumnOverflow) ? [\"col--ellipsis\"] : [];\n              var cellValue = getFooterCellValue(opts, rows, column);\n              if (footAlign) {\n                classNames.push(\"col--\".concat(footAlign));\n              }\n              return '<td class=\"'.concat(classNames.join(\" \"), '\" title=\"').concat(cellValue, '\"><div ').concat(isPrint ? \"\" : 'style=\"width: '.concat(column.renderWidth, 'px\"'), \">\").concat(formatText(cellValue, true), \"</div></td>\");\n            }).join(\"\"), \"</tr>\"));\n          });\n          tables.push(\"</tfoot>\");\n        }\n      }\n      var script = !isAllSelected && isIndeterminate ? '<script>(function(){var a=document.querySelector(\".'.concat(allCls, '\");if(a){a.indeterminate=true}})()</script>') : \"\";\n      tables.push(\"</table>\", script);\n      return isPrint ? tables.join(\"\") : createHtmlPage(opts, tables.join(\"\"));\n    };\n    var toXML = function(opts, columns, datas) {\n      var xml = [\n        '<?xml version=\"1.0\"?>',\n        '<?mso-application progid=\"Excel.Sheet\"?>',\n        '<Workbook xmlns=\"urn:schemas-microsoft-com:office:spreadsheet\" xmlns:o=\"urn:schemas-microsoft-com:office:office\" xmlns:x=\"urn:schemas-microsoft-com:office:excel\" xmlns:ss=\"urn:schemas-microsoft-com:office:spreadsheet\" xmlns:html=\"http://www.w3.org/TR/REC-html40\">',\n        '<DocumentProperties xmlns=\"urn:schemas-microsoft-com:office:office\">',\n        \"<Version>16.00</Version>\",\n        \"</DocumentProperties>\",\n        '<ExcelWorkbook xmlns=\"urn:schemas-microsoft-com:office:excel\">',\n        \"<WindowHeight>7920</WindowHeight>\",\n        \"<WindowWidth>21570</WindowWidth>\",\n        \"<WindowTopX>32767</WindowTopX>\",\n        \"<WindowTopY>32767</WindowTopY>\",\n        \"<ProtectStructure>False</ProtectStructure>\",\n        \"<ProtectWindows>False</ProtectWindows>\",\n        \"</ExcelWorkbook>\",\n        '<Worksheet ss:Name=\"'.concat(opts.sheetName, '\">'),\n        \"<Table>\",\n        columns.map(function(column) {\n          return '<Column ss:Width=\"'.concat(column.renderWidth, '\"/>');\n        }).join(\"\")\n      ].join(\"\");\n      if (opts.isHeader) {\n        xml += \"<Row>\".concat(columns.map(function(column) {\n          return '<Cell><Data ss:Type=\"String\">'.concat(getHeaderTitle(opts, column), \"</Data></Cell>\");\n        }).join(\"\"), \"</Row>\");\n      }\n      datas.forEach(function(row) {\n        xml += \"<Row>\" + columns.map(function(column) {\n          return '<Cell><Data ss:Type=\"String\">'.concat(row[column.id], \"</Data></Cell>\");\n        }).join(\"\") + \"</Row>\";\n      });\n      if (opts.isFooter) {\n        var footerTableData = reactData.footerTableData;\n        var footers = getFooterData(opts, footerTableData);\n        footers.forEach(function(rows) {\n          xml += \"<Row>\".concat(columns.map(function(column) {\n            return '<Cell><Data ss:Type=\"String\">'.concat(getFooterCellValue(opts, rows, column), \"</Data></Cell>\");\n          }).join(\"\"), \"</Row>\");\n        });\n      }\n      return \"\".concat(xml, \"</Table></Worksheet></Workbook>\");\n    };\n    var getContent = function(opts, columns, datas) {\n      if (columns.length) {\n        switch (opts.type) {\n          case \"csv\":\n            return toCsv(opts, columns, datas);\n          case \"txt\":\n            return toTxt(opts, columns, datas);\n          case \"html\":\n            return toHtml(opts, columns, datas);\n          case \"xml\":\n            return toXML(opts, columns, datas);\n        }\n      }\n      return \"\";\n    };\n    var downloadFile = function(opts, content) {\n      var filename = opts.filename, type = opts.type, download = opts.download;\n      if (!download) {\n        var blob = getExportBlobByContent(content, opts);\n        return Promise.resolve({ type, content, blob });\n      }\n      saveLocalFile({ filename, type, content }).then(function() {\n        if (opts.message !== false) {\n          if (false) {\n            if (!VXETable.modal) {\n              errLog(\"vxe.error.reqModule\", [\"Modal\"]);\n            }\n          }\n          VXETable.modal.message({ content: GlobalConfig.i18n(\"vxe.table.expSuccess\"), status: \"success\" });\n        }\n      });\n    };\n    var handleExport = function(opts) {\n      var remote = opts.remote, columns = opts.columns, colgroups = opts.colgroups, exportMethod = opts.exportMethod, afterExportMethod = opts.afterExportMethod;\n      return new Promise(function(resolve) {\n        if (remote) {\n          var params = { options: opts, $table: $xetable, $grid: $xegrid };\n          resolve(exportMethod ? exportMethod(params) : params);\n        } else {\n          var datas_1 = getExportData(opts);\n          resolve($xetable.preventEvent(null, \"event.export\", { options: opts, columns, colgroups, datas: datas_1 }, function() {\n            return downloadFile(opts, getContent(opts, columns, datas_1));\n          }));\n        }\n      }).then(function(params) {\n        clearColumnConvert(columns);\n        if (!opts.print) {\n          if (afterExportMethod) {\n            afterExportMethod({ status: true, options: opts, $table: $xetable, $grid: $xegrid });\n          }\n        }\n        return Object.assign({ status: true }, params);\n      }).catch(function() {\n        clearColumnConvert(columns);\n        if (!opts.print) {\n          if (afterExportMethod) {\n            afterExportMethod({ status: false, options: opts, $table: $xetable, $grid: $xegrid });\n          }\n        }\n        var params = { status: false };\n        return Promise.reject(params);\n      });\n    };\n    var handleImport = function(content, opts) {\n      var tableFullColumn = internalData.tableFullColumn, _importResolve = internalData._importResolve, _importReject = internalData._importReject;\n      var rest = { fields: [], rows: [] };\n      switch (opts.type) {\n        case \"csv\":\n          rest = parseCsv(tableFullColumn, content);\n          break;\n        case \"txt\":\n          rest = parseTxt(tableFullColumn, content);\n          break;\n        case \"html\":\n          rest = parseHTML(tableFullColumn, content);\n          break;\n        case \"xml\":\n          rest = parseXML(tableFullColumn, content);\n          break;\n      }\n      var fields = rest.fields, rows = rest.rows;\n      var status = checkImportData(tableFullColumn, fields);\n      if (status) {\n        $xetable.createData(rows).then(function(data) {\n          var loadRest;\n          if (opts.mode === \"insert\") {\n            loadRest = $xetable.insert(data);\n          } else {\n            loadRest = $xetable.reloadData(data);\n          }\n          if (opts.message !== false) {\n            if (false) {\n              if (!VXETable.modal) {\n                errLog(\"vxe.error.reqModule\", [\"Modal\"]);\n              }\n            }\n            VXETable.modal.message({ content: GlobalConfig.i18n(\"vxe.table.impSuccess\", [rows.length]), status: \"success\" });\n          }\n          return loadRest.then(function() {\n            if (_importResolve) {\n              _importResolve({ status: true });\n            }\n          });\n        });\n      } else if (opts.message !== false) {\n        if (false) {\n          if (!VXETable.modal) {\n            errLog(\"vxe.error.reqModule\", [\"Modal\"]);\n          }\n        }\n        VXETable.modal.message({ content: GlobalConfig.i18n(\"vxe.error.impFields\"), status: \"error\" });\n        if (_importReject) {\n          _importReject({ status: false });\n        }\n      }\n    };\n    var handleFileImport = function(file, opts) {\n      var importMethod = opts.importMethod, afterImportMethod = opts.afterImportMethod;\n      var _a2 = parseFile(file), type = _a2.type, filename = _a2.filename;\n      if (!importMethod && !XEUtils.includes(VXETable.globalConfs.importTypes, type)) {\n        if (opts.message !== false) {\n          if (false) {\n            if (!VXETable.modal) {\n              errLog(\"vxe.error.reqModule\", [\"Modal\"]);\n            }\n          }\n          VXETable.modal.message({ content: GlobalConfig.i18n(\"vxe.error.notType\", [type]), status: \"error\" });\n        }\n        var params = { status: false };\n        return Promise.reject(params);\n      }\n      var rest = new Promise(function(resolve, reject) {\n        var _importResolve = function(params2) {\n          resolve(params2);\n          internalData._importResolve = null;\n          internalData._importReject = null;\n        };\n        var _importReject = function(params2) {\n          reject(params2);\n          internalData._importResolve = null;\n          internalData._importReject = null;\n        };\n        internalData._importResolve = _importResolve;\n        internalData._importReject = _importReject;\n        if (window.FileReader) {\n          var options_1 = Object.assign({ mode: \"insert\" }, opts, { type, filename });\n          if (options_1.remote) {\n            if (importMethod) {\n              Promise.resolve(importMethod({ file, options: options_1, $table: $xetable })).then(function() {\n                _importResolve({ status: true });\n              }).catch(function() {\n                _importResolve({ status: true });\n              });\n            } else {\n              _importResolve({ status: true });\n            }\n          } else {\n            var tableFullColumn = internalData.tableFullColumn;\n            $xetable.preventEvent(null, \"event.import\", { file, options: options_1, columns: tableFullColumn }, function() {\n              var reader = new FileReader();\n              reader.onerror = function() {\n                errLog(\"vxe.error.notType\", [type]);\n                _importReject({ status: false });\n              };\n              reader.onload = function(e) {\n                handleImport(e.target.result, options_1);\n              };\n              reader.readAsText(file, options_1.encoding || \"UTF-8\");\n            });\n          }\n        } else {\n          if (false) {\n            errLog(\"vxe.error.notExp\");\n          }\n          _importResolve({ status: true });\n        }\n      });\n      return rest.then(function() {\n        if (afterImportMethod) {\n          afterImportMethod({ status: true, options: opts, $table: $xetable });\n        }\n      }).catch(function(e) {\n        if (afterImportMethod) {\n          afterImportMethod({ status: false, options: opts, $table: $xetable });\n        }\n        return Promise.reject(e);\n      });\n    };\n    var handleExportAndPrint = function(options, isPrint) {\n      var treeConfig = props.treeConfig, showHeader = props.showHeader, showFooter = props.showFooter;\n      var initStore = reactData.initStore, mergeList = reactData.mergeList, isGroup = reactData.isGroup, footerTableData = reactData.footerTableData, exportStore = reactData.exportStore, exportParams = reactData.exportParams;\n      var collectColumn = internalData.collectColumn;\n      var hasTree = treeConfig;\n      var customOpts = computeCustomOpts.value;\n      var selectRecords = $xetable.getCheckboxRecords();\n      var hasFooter = !!footerTableData.length;\n      var hasMerge = !hasTree && mergeList.length;\n      var defOpts = Object.assign({ message: true, isHeader: showHeader, isFooter: showFooter }, options);\n      var types = defOpts.types || VXETable.globalConfs.exportTypes;\n      var modes = defOpts.modes;\n      var checkMethod = customOpts.checkMethod;\n      var exportColumns = collectColumn.slice(0);\n      var columns = defOpts.columns;\n      var typeList = types.map(function(value) {\n        return {\n          value,\n          label: \"vxe.export.types.\".concat(value)\n        };\n      });\n      var modeList = modes.map(function(value) {\n        return {\n          value,\n          label: \"vxe.export.modes.\".concat(value)\n        };\n      });\n      XEUtils.eachTree(exportColumns, function(column, index, items, path, parent) {\n        var isColGroup = column.children && column.children.length;\n        if (isColGroup || defaultFilterExportColumn(column)) {\n          column.checked = columns ? columns.some(function(item) {\n            if (isColumnInfo(item)) {\n              return column === item;\n            } else if (XEUtils.isString(item)) {\n              return column.field === item;\n            } else {\n              var colid = item.id || item.colId;\n              var type = item.type;\n              var field = item.property || item.field;\n              if (colid) {\n                return column.id === colid;\n              } else if (field && type) {\n                return column.property === field && column.type === type;\n              } else if (field) {\n                return column.property === field;\n              } else if (type) {\n                return column.type === type;\n              }\n            }\n            return false;\n          }) : column.visible;\n          column.halfChecked = false;\n          column.disabled = parent && parent.disabled || (checkMethod ? !checkMethod({ column }) : false);\n        }\n      });\n      Object.assign(exportStore, {\n        columns: exportColumns,\n        typeList,\n        modeList,\n        hasFooter,\n        hasMerge,\n        hasTree,\n        isPrint,\n        hasColgroup: isGroup,\n        visible: true\n      });\n      Object.assign(exportParams, {\n        mode: selectRecords.length ? \"selected\" : \"current\"\n      }, defOpts);\n      if (modes.indexOf(exportParams.mode) === -1) {\n        exportParams.mode = modes[0];\n      }\n      if (types.indexOf(exportParams.type) === -1) {\n        exportParams.type = types[0];\n      }\n      initStore.export = true;\n      return nextTick();\n    };\n    var exportMethods = {\n      /**\n       * 导出文件，支持 csv/html/xml/txt\n       * 如果是树表格，则默认是导出所有节点\n       * 如果是启用了虚拟滚动，则只能导出数据源，可以配合 dataFilterMethod 函数自行转换数据\n       * @param {Object} options 参数\n       */\n      exportData: function(options) {\n        var treeConfig = props.treeConfig;\n        var isGroup = reactData.isGroup, tableGroupColumn = reactData.tableGroupColumn;\n        var tableFullColumn = internalData.tableFullColumn, afterFullData = internalData.afterFullData;\n        var exportOpts = computeExportOpts.value;\n        var treeOpts = computeTreeOpts.value;\n        var opts = Object.assign({\n          // filename: '',\n          // sheetName: '',\n          // original: false,\n          // message: false,\n          isHeader: true,\n          isFooter: true,\n          isColgroup: true,\n          // isMerge: false,\n          // isAllExpand: false,\n          download: true,\n          type: \"csv\",\n          mode: \"current\"\n          // data: null,\n          // remote: false,\n          // dataFilterMethod: null,\n          // footerFilterMethod: null,\n          // exportMethod: null,\n          // columnFilterMethod: null,\n          // beforeExportMethod: null,\n          // afterExportMethod: null\n        }, exportOpts, {\n          print: false\n        }, options);\n        var type = opts.type, mode = opts.mode, columns = opts.columns, original = opts.original, beforeExportMethod = opts.beforeExportMethod;\n        var groups = [];\n        var customCols = columns && columns.length ? columns : null;\n        var columnFilterMethod = opts.columnFilterMethod;\n        if (!customCols && !columnFilterMethod) {\n          columnFilterMethod = original ? function(_a3) {\n            var column = _a3.column;\n            return column.property;\n          } : function(_a3) {\n            var column = _a3.column;\n            return defaultFilterExportColumn(column);\n          };\n        }\n        if (customCols) {\n          opts._isCustomColumn = true;\n          groups = XEUtils.searchTree(XEUtils.mapTree(customCols, function(item) {\n            var targetColumn;\n            if (item) {\n              if (isColumnInfo(item)) {\n                targetColumn = item;\n              } else if (XEUtils.isString(item)) {\n                targetColumn = $xetable.getColumnByField(item);\n              } else {\n                var colid = item.id || item.colId;\n                var type_1 = item.type;\n                var field_1 = item.property || item.field;\n                if (colid) {\n                  targetColumn = $xetable.getColumnById(colid);\n                } else if (field_1 && type_1) {\n                  targetColumn = tableFullColumn.find(function(column) {\n                    return column.property === field_1 && column.type === type_1;\n                  });\n                } else if (field_1) {\n                  targetColumn = $xetable.getColumnByField(field_1);\n                } else if (type_1) {\n                  targetColumn = tableFullColumn.find(function(column) {\n                    return column.type === type_1;\n                  });\n                }\n              }\n              return targetColumn || {};\n            }\n          }, {\n            children: \"childNodes\",\n            mapChildren: \"_children\"\n          }), function(column, index) {\n            return isColumnInfo(column) && (!columnFilterMethod || columnFilterMethod({ column, $columnIndex: index }));\n          }, {\n            children: \"_children\",\n            mapChildren: \"childNodes\",\n            original: true\n          });\n        } else {\n          groups = XEUtils.searchTree(isGroup ? tableGroupColumn : tableFullColumn, function(column, index) {\n            return column.visible && (!columnFilterMethod || columnFilterMethod({ column, $columnIndex: index }));\n          }, { children: \"children\", mapChildren: \"childNodes\", original: true });\n        }\n        var cols = [];\n        XEUtils.eachTree(groups, function(column) {\n          var isColGroup = column.children && column.children.length;\n          if (!isColGroup) {\n            cols.push(column);\n          }\n        }, { children: \"childNodes\" });\n        opts.columns = cols;\n        opts.colgroups = convertToRows(groups);\n        if (!opts.filename) {\n          opts.filename = GlobalConfig.i18n(opts.original ? \"vxe.table.expOriginFilename\" : \"vxe.table.expFilename\", [XEUtils.toDateString(Date.now(), \"yyyyMMddHHmmss\")]);\n        }\n        if (!opts.sheetName) {\n          opts.sheetName = document.title;\n        }\n        if (!opts.exportMethod && !XEUtils.includes(VXETable.globalConfs.exportTypes, type)) {\n          if (false) {\n            errLog(\"vxe.error.notType\", [type]);\n          }\n          var params = { status: false };\n          return Promise.reject(params);\n        }\n        if (!opts.print) {\n          if (beforeExportMethod) {\n            beforeExportMethod({ options: opts, $table: $xetable, $grid: $xegrid });\n          }\n        }\n        if (!opts.data) {\n          opts.data = afterFullData;\n          if (mode === \"selected\") {\n            var selectRecords_1 = $xetable.getCheckboxRecords();\n            if ([\"html\", \"pdf\"].indexOf(type) > -1 && treeConfig) {\n              opts.data = XEUtils.searchTree($xetable.getTableData().fullData, function(item) {\n                return $xetable.findRowIndexOf(selectRecords_1, item) > -1;\n              }, Object.assign({}, treeOpts, { data: \"_row\" }));\n            } else {\n              opts.data = selectRecords_1;\n            }\n          } else if (mode === \"all\") {\n            if (false) {\n              if (!$xegrid) {\n                warnLog(\"vxe.error.errProp\", [\"all\", \"mode=current,selected\"]);\n              }\n            }\n            if ($xegrid && !opts.remote) {\n              var gridReactData = $xegrid.reactData;\n              var computeProxyOpts = $xegrid.getComputeMaps().computeProxyOpts;\n              var proxyOpts = computeProxyOpts.value;\n              var beforeQueryAll = proxyOpts.beforeQueryAll, afterQueryAll_1 = proxyOpts.afterQueryAll, _a2 = proxyOpts.ajax, ajax = _a2 === void 0 ? {} : _a2, _b = proxyOpts.props, props_1 = _b === void 0 ? {} : _b;\n              var ajaxMethods = ajax.queryAll;\n              if (false) {\n                if (!ajaxMethods) {\n                  warnLog(\"vxe.error.notFunc\", [\"proxy-config.ajax.queryAll\"]);\n                }\n              }\n              if (ajaxMethods) {\n                var params_1 = {\n                  $table: $xetable,\n                  $grid: $xegrid,\n                  sort: gridReactData.sortData,\n                  filters: gridReactData.filterData,\n                  form: gridReactData.formData,\n                  target: ajaxMethods,\n                  options: opts\n                };\n                return Promise.resolve((beforeQueryAll || ajaxMethods)(params_1)).catch(function(e) {\n                  return e;\n                }).then(function(rest) {\n                  opts.data = (props_1.list ? XEUtils.get(rest, props_1.list) : rest) || [];\n                  if (afterQueryAll_1) {\n                    afterQueryAll_1(params_1);\n                  }\n                  return handleExport(opts);\n                });\n              }\n            }\n          }\n        }\n        return handleExport(opts);\n      },\n      importByFile: function(file, options) {\n        var opts = Object.assign({}, options);\n        var beforeImportMethod = opts.beforeImportMethod;\n        if (beforeImportMethod) {\n          beforeImportMethod({ options: opts, $table: $xetable });\n        }\n        return handleFileImport(file, opts);\n      },\n      importData: function(options) {\n        var importOpts = computeImportOpts.value;\n        var opts = Object.assign({\n          types: VXETable.globalConfs.importTypes\n          // beforeImportMethod: null,\n          // afterImportMethod: null\n        }, importOpts, options);\n        var beforeImportMethod = opts.beforeImportMethod, afterImportMethod = opts.afterImportMethod;\n        if (beforeImportMethod) {\n          beforeImportMethod({ options: opts, $table: $xetable });\n        }\n        return readLocalFile(opts).catch(function(e) {\n          if (afterImportMethod) {\n            afterImportMethod({ status: false, options: opts, $table: $xetable });\n          }\n          return Promise.reject(e);\n        }).then(function(params) {\n          var file = params.file;\n          return handleFileImport(file, opts);\n        });\n      },\n      saveFile: function(options) {\n        return saveLocalFile(options);\n      },\n      readFile: function(options) {\n        return readLocalFile(options);\n      },\n      print: function(options) {\n        var printOpts = computePrintOpts.value;\n        var opts = Object.assign({\n          original: false\n          // beforePrintMethod\n        }, printOpts, options, {\n          type: \"html\",\n          download: false,\n          remote: false,\n          print: true\n        });\n        if (!opts.sheetName) {\n          opts.sheetName = document.title;\n        }\n        return new Promise(function(resolve) {\n          if (opts.content) {\n            resolve(handlePrint($xetable, opts, opts.content));\n          } else {\n            resolve(exportMethods.exportData(opts).then(function(_a2) {\n              var content = _a2.content;\n              return handlePrint($xetable, opts, content);\n            }));\n          }\n        });\n      },\n      openImport: function(options) {\n        var treeConfig = props.treeConfig, importConfig = props.importConfig;\n        var initStore = reactData.initStore, importStore = reactData.importStore, importParams = reactData.importParams;\n        var importOpts = computeImportOpts.value;\n        var defOpts = Object.assign({ mode: \"insert\", message: true, types: VXETable.globalConfs.importTypes }, options, importOpts);\n        var types = defOpts.types;\n        var isTree = !!treeConfig;\n        if (isTree) {\n          if (defOpts.message) {\n            VXETable.modal.message({ content: GlobalConfig.i18n(\"vxe.error.treeNotImp\"), status: \"error\" });\n          }\n          return;\n        }\n        if (!importConfig) {\n          errLog(\"vxe.error.reqProp\", [\"import-config\"]);\n        }\n        var typeList = types.map(function(value) {\n          return {\n            value,\n            label: \"vxe.export.types.\".concat(value)\n          };\n        });\n        var modeList = defOpts.modes.map(function(value) {\n          return {\n            value,\n            label: \"vxe.import.modes.\".concat(value)\n          };\n        });\n        Object.assign(importStore, {\n          file: null,\n          type: \"\",\n          filename: \"\",\n          modeList,\n          typeList,\n          visible: true\n        });\n        Object.assign(importParams, defOpts);\n        initStore.import = true;\n      },\n      openExport: function(options) {\n        var exportOpts = computeExportOpts.value;\n        if (false) {\n          if (!props.exportConfig) {\n            errLog(\"vxe.error.reqProp\", [\"export-config\"]);\n          }\n        }\n        handleExportAndPrint(Object.assign({}, exportOpts, options));\n      },\n      openPrint: function(options) {\n        var printOpts = computePrintOpts.value;\n        if (false) {\n          if (!props.printConfig) {\n            errLog(\"vxe.error.reqProp\", [\"print-config\"]);\n          }\n        }\n        handleExportAndPrint(Object.assign({}, printOpts, options), true);\n      }\n    };\n    return exportMethods;\n  },\n  setupGrid: function($xegrid) {\n    return $xegrid.extendTableMethods(tableExportMethodKeys);\n  }\n};\nexport default tableExportHook;\n",
      "start": 1714699767753,
      "end": 1714699768362,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-post",
      "start": 1714699768362,
      "end": 1714699768362,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1714699768362,
      "end": 1714699768362,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1714699768362,
      "end": 1714699768362,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1714699768362,
      "end": 1714699768362,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1714699768362,
      "end": 1714699768365,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1714699768365,
      "end": 1714699768365,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1714699768365,
      "end": 1714699768365,
      "order": "normal"
    },
    {
      "name": "unplugin-auto-import",
      "start": 1714699768365,
      "end": 1714699768365,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1714699768365,
      "end": 1714699768365,
      "order": "post"
    },
    {
      "name": "vite:style-import",
      "start": 1714699768365,
      "end": 1714699768365,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1714699768365,
      "end": 1714699768365,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1714699768365,
      "end": 1714699768365,
      "order": "normal"
    }
  ]
}
