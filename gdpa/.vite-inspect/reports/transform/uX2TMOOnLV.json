{
  "resolvedId": "/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/vxe-table@4.5.21_vue@3.4.19_xe-utils@3.5.24/node_modules/vxe-table/es/form/src/form.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { defineComponent, h, ref, resolveComponent, createCommentVNode, provide, computed, inject, reactive, watch, nextTick, onMounted } from 'vue';\nimport XEUtils from 'xe-utils';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport { VXETable } from '../../v-x-e-table';\nimport { getFuncText, isEnableConf, eqEmptyValue } from '../../tools/utils';\nimport { errLog, warnLog } from '../../tools/log';\nimport { scrollToView } from '../../tools/dom';\nimport { createItem, handleFieldOrItem, isHiddenItem, isActivetem } from './util';\nimport { useSize } from '../../hooks/size';\nimport VxeFormConfigItem from './form-config-item';\nimport VxeLoading from '../../loading/index';\nimport { getSlotVNs } from '../../tools/vn';\nvar Rule = /** @class */ (function () {\n    function Rule(rule) {\n        Object.assign(this, {\n            $options: rule,\n            required: rule.required,\n            min: rule.min,\n            max: rule.min,\n            type: rule.type,\n            pattern: rule.pattern,\n            validator: rule.validator,\n            trigger: rule.trigger,\n            maxWidth: rule.maxWidth\n        });\n    }\n    Object.defineProperty(Rule.prototype, \"content\", {\n        get: function () {\n            return getFuncText(this.$options.content || this.$options.message);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rule.prototype, \"message\", {\n        get: function () {\n            return this.content;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Rule;\n}());\nvar validErrorRuleValue = function (rule, val) {\n    var type = rule.type, min = rule.min, max = rule.max, pattern = rule.pattern;\n    var isNumType = type === 'number';\n    var numVal = isNumType ? XEUtils.toNumber(val) : XEUtils.getSize(val);\n    // 判断数值\n    if (isNumType && isNaN(val)) {\n        return true;\n    }\n    // 如果存在 min，判断最小值\n    if (!XEUtils.eqNull(min) && numVal < XEUtils.toNumber(min)) {\n        return true;\n    }\n    // 如果存在 max，判断最大值\n    if (!XEUtils.eqNull(max) && numVal > XEUtils.toNumber(max)) {\n        return true;\n    }\n    // 如果存在 pattern，正则校验\n    if (pattern && !(XEUtils.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {\n        return true;\n    }\n    return false;\n};\nfunction getResetValue(value, resetValue) {\n    if (XEUtils.isArray(value)) {\n        resetValue = [];\n    }\n    return resetValue;\n}\nexport default defineComponent({\n    name: 'VxeForm',\n    props: {\n        collapseStatus: { type: Boolean, default: true },\n        loading: Boolean,\n        data: Object,\n        size: { type: String, default: function () { return GlobalConfig.form.size || GlobalConfig.size; } },\n        span: { type: [String, Number], default: function () { return GlobalConfig.form.span; } },\n        align: { type: String, default: function () { return GlobalConfig.form.align; } },\n        titleAlign: { type: String, default: function () { return GlobalConfig.form.titleAlign; } },\n        titleWidth: { type: [String, Number], default: function () { return GlobalConfig.form.titleWidth; } },\n        titleColon: { type: Boolean, default: function () { return GlobalConfig.form.titleColon; } },\n        titleAsterisk: { type: Boolean, default: function () { return GlobalConfig.form.titleAsterisk; } },\n        titleOverflow: { type: [Boolean, String], default: null },\n        vertical: {\n            type: Boolean,\n            default: null\n        },\n        className: [String, Function],\n        readonly: Boolean,\n        items: Array,\n        rules: Object,\n        preventSubmit: { type: Boolean, default: function () { return GlobalConfig.form.preventSubmit; } },\n        validConfig: Object,\n        tooltipConfig: Object,\n        customLayout: { type: Boolean, default: function () { return GlobalConfig.form.customLayout; } }\n    },\n    emits: [\n        'update:collapseStatus',\n        'collapse',\n        'toggle-collapse',\n        'submit',\n        'submit-invalid',\n        'reset'\n    ],\n    setup: function (props, context) {\n        var hasUseTooltip = VXETable.tooltip;\n        var slots = context.slots, emit = context.emit;\n        var xID = XEUtils.uniqueId();\n        var computeSize = useSize(props);\n        var reactData = reactive({\n            collapseAll: props.collapseStatus,\n            staticItems: [],\n            formItems: []\n        });\n        var internalData = reactive({\n            tooltipTimeout: null,\n            tooltipStore: {\n                item: null,\n                visible: false\n            }\n        });\n        var $xegrid = inject('$xegrid', null);\n        var refElem = ref();\n        var refTooltip = ref();\n        var formMethods = {};\n        var computeValidOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.form.validConfig, props.validConfig);\n        });\n        var computeTooltipOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.tooltip, GlobalConfig.form.tooltipConfig, props.tooltipConfig);\n        });\n        var refMaps = {\n            refElem: refElem\n        };\n        var computeMaps = {\n            computeSize: computeSize,\n            computeValidOpts: computeValidOpts,\n            computeTooltipOpts: computeTooltipOpts\n        };\n        var $xeform = {\n            xID: xID,\n            props: props,\n            context: context,\n            reactData: reactData,\n            xegrid: $xegrid,\n            getRefMaps: function () { return refMaps; },\n            getComputeMaps: function () { return computeMaps; }\n        };\n        var callSlot = function (slotFunc, params) {\n            if (slotFunc) {\n                if (XEUtils.isString(slotFunc)) {\n                    slotFunc = slots[slotFunc] || null;\n                }\n                if (XEUtils.isFunction(slotFunc)) {\n                    return getSlotVNs(slotFunc(params));\n                }\n            }\n            return [];\n        };\n        var loadItem = function (list) {\n            if (list.length) {\n                if (process.env.NODE_ENV === 'development') {\n                    list.forEach(function (item) {\n                        if (item.slots) {\n                            XEUtils.each(item.slots, function (func) {\n                                if (!XEUtils.isFunction(func)) {\n                                    if (!slots[func]) {\n                                        errLog('vxe.error.notSlot', [func]);\n                                    }\n                                }\n                            });\n                        }\n                    });\n                }\n                reactData.staticItems = XEUtils.mapTree(list, function (item) { return createItem($xeform, item); }, { children: 'children' });\n            }\n            return nextTick();\n        };\n        var getItems = function () {\n            var itemList = [];\n            XEUtils.eachTree(reactData.formItems, function (item) {\n                itemList.push(item);\n            }, { children: 'children' });\n            return itemList;\n        };\n        var getItemByField = function (field) {\n            var rest = XEUtils.findTree(reactData.formItems, function (item) { return item.field === field; }, { children: 'children' });\n            return rest ? rest.item : null;\n        };\n        var getCollapseStatus = function () {\n            return reactData.collapseAll;\n        };\n        var toggleCollapse = function () {\n            var status = !getCollapseStatus();\n            reactData.collapseAll = status;\n            emit('update:collapseStatus', status);\n            return nextTick();\n        };\n        var toggleCollapseEvent = function (evnt) {\n            toggleCollapse();\n            var status = getCollapseStatus();\n            formMethods.dispatchEvent('toggle-collapse', { status: status, collapse: status, data: props.data }, evnt);\n            formMethods.dispatchEvent('collapse', { status: status, collapse: status, data: props.data }, evnt);\n        };\n        var clearValidate = function (fieldOrItem) {\n            if (fieldOrItem) {\n                var fields = fieldOrItem;\n                if (!XEUtils.isArray(fieldOrItem)) {\n                    fields = [fieldOrItem];\n                }\n                fields.forEach(function (field) {\n                    if (field) {\n                        var item = handleFieldOrItem($xeform, field);\n                        if (item) {\n                            item.showError = false;\n                        }\n                    }\n                });\n            }\n            else {\n                getItems().forEach(function (item) {\n                    item.showError = false;\n                });\n            }\n            return nextTick();\n        };\n        var reset = function () {\n            var data = props.data;\n            var itemList = getItems();\n            if (data) {\n                itemList.forEach(function (item) {\n                    var field = item.field, resetValue = item.resetValue, itemRender = item.itemRender;\n                    if (isEnableConf(itemRender)) {\n                        var compConf = VXETable.renderer.get(itemRender.name);\n                        if (compConf && compConf.itemResetMethod) {\n                            compConf.itemResetMethod({ data: data, field: field, property: field, item: item, $form: $xeform, $grid: $xeform.xegrid });\n                        }\n                        else if (field) {\n                            XEUtils.set(data, field, resetValue === null ? getResetValue(XEUtils.get(data, field), undefined) : XEUtils.clone(resetValue, true));\n                        }\n                    }\n                });\n            }\n            return clearValidate();\n        };\n        var resetEvent = function (evnt) {\n            evnt.preventDefault();\n            reset();\n            formMethods.dispatchEvent('reset', { data: props.data }, evnt);\n        };\n        var handleFocus = function (fields) {\n            var el = refElem.value;\n            for (var i = 0; i < fields.length; i++) {\n                var property = fields[i];\n                var item = getItemByField(property);\n                if (item && isEnableConf(item.itemRender)) {\n                    var itemRender = item.itemRender;\n                    var compConf = VXETable.renderer.get(itemRender.name);\n                    var inputElem = null;\n                    // 定位到第一个\n                    if (!i) {\n                        scrollToView(el.querySelector(\".\".concat(item.id)));\n                    }\n                    // 如果指定了聚焦 class\n                    if (itemRender.autofocus) {\n                        inputElem = el.querySelector(\".\".concat(item.id, \" \").concat(itemRender.autofocus));\n                    }\n                    // 渲染器的聚焦处理\n                    if (!inputElem && compConf && compConf.autofocus) {\n                        inputElem = el.querySelector(\".\".concat(item.id, \" \").concat(compConf.autofocus));\n                    }\n                    if (inputElem) {\n                        inputElem.focus();\n                        break;\n                    }\n                }\n            }\n        };\n        /**\n         * 校验数据\n         * 按表格行、列顺序依次校验（同步或异步）\n         * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列\n         * 如果校验失败则，触发回调或者 Promise<(ErrMap 校验不通过列的信息)>\n         * 如果是传回调方式这返回一个 (ErrMap 校验不通过列的信息)\n         *\n         * rule 配置：\n         *  required=Boolean 是否必填\n         *  min=Number 最小长度\n         *  max=Number 最大长度\n         *  validator=Function({ itemValue, rule, rules, data, property }) 自定义校验，接收一个 Promise\n         *  trigger=change 触发方式\n         */\n        var validItemRules = function (validType, fields, val) {\n            var data = props.data, formRules = props.rules;\n            var errorMaps = {};\n            if (!XEUtils.isArray(fields)) {\n                fields = [fields];\n            }\n            return Promise.all(fields.map(function (property) {\n                var errorRules = [];\n                var syncVailds = [];\n                if (property && formRules) {\n                    var rules_1 = XEUtils.get(formRules, property);\n                    if (rules_1) {\n                        var itemValue_1 = XEUtils.isUndefined(val) ? XEUtils.get(data, property) : val;\n                        rules_1.forEach(function (rule) {\n                            var type = rule.type, trigger = rule.trigger, required = rule.required, validator = rule.validator;\n                            if (validType === 'all' || !trigger || validType === trigger) {\n                                if (validator) {\n                                    var validParams = {\n                                        itemValue: itemValue_1,\n                                        rule: rule,\n                                        rules: rules_1,\n                                        data: data,\n                                        field: property,\n                                        property: property,\n                                        $form: $xeform\n                                    };\n                                    var customValid = void 0;\n                                    if (XEUtils.isString(validator)) {\n                                        var gvItem = VXETable.validators.get(validator);\n                                        if (gvItem) {\n                                            if (gvItem.itemValidatorMethod) {\n                                                customValid = gvItem.itemValidatorMethod(validParams);\n                                            }\n                                            else {\n                                                if (process.env.NODE_ENV === 'development') {\n                                                    warnLog('vxe.error.notValidators', [validator]);\n                                                }\n                                            }\n                                        }\n                                        else {\n                                            if (process.env.NODE_ENV === 'development') {\n                                                errLog('vxe.error.notValidators', [validator]);\n                                            }\n                                        }\n                                    }\n                                    else {\n                                        customValid = validator(validParams);\n                                    }\n                                    if (customValid) {\n                                        if (XEUtils.isError(customValid)) {\n                                            errorRules.push(new Rule({ type: 'custom', trigger: trigger, content: customValid.message, rule: new Rule(rule) }));\n                                        }\n                                        else if (customValid.catch) {\n                                            // 如果为异步校验（注：异步校验是并发无序的）\n                                            syncVailds.push(customValid.catch(function (e) {\n                                                errorRules.push(new Rule({ type: 'custom', trigger: trigger, content: e ? e.message : (rule.content || rule.message), rule: new Rule(rule) }));\n                                            }));\n                                        }\n                                    }\n                                }\n                                else {\n                                    var isArrType = type === 'array';\n                                    var isArrVal = XEUtils.isArray(itemValue_1);\n                                    var hasEmpty = true;\n                                    if (isArrType || isArrVal) {\n                                        hasEmpty = !isArrVal || !itemValue_1.length;\n                                    }\n                                    else if (XEUtils.isString(itemValue_1)) {\n                                        hasEmpty = eqEmptyValue(itemValue_1.trim());\n                                    }\n                                    else {\n                                        hasEmpty = eqEmptyValue(itemValue_1);\n                                    }\n                                    if (required ? (hasEmpty || validErrorRuleValue(rule, itemValue_1)) : (!hasEmpty && validErrorRuleValue(rule, itemValue_1))) {\n                                        errorRules.push(new Rule(rule));\n                                    }\n                                }\n                            }\n                        });\n                    }\n                }\n                return Promise.all(syncVailds).then(function () {\n                    if (errorRules.length) {\n                        errorMaps[property] = errorRules.map(function (rule) {\n                            return {\n                                $form: $xeform,\n                                rule: rule,\n                                data: data,\n                                field: property,\n                                property: property\n                            };\n                        });\n                    }\n                });\n            })).then(function () {\n                if (!XEUtils.isEmpty(errorMaps)) {\n                    return Promise.reject(errorMaps);\n                }\n            });\n        };\n        var showErrTime;\n        var beginValidate = function (itemList, type, callback) {\n            var data = props.data, formRules = props.rules;\n            var validOpts = computeValidOpts.value;\n            var validRest = {};\n            var validFields = [];\n            var itemValids = [];\n            clearTimeout(showErrTime);\n            if (data && formRules) {\n                itemList.forEach(function (item) {\n                    var field = item.field;\n                    if (field && !isHiddenItem($xeform, item) && isActivetem($xeform, item)) {\n                        itemValids.push(validItemRules(type || 'all', field).then(function () {\n                            item.errRule = null;\n                        }).catch(function (errorMaps) {\n                            var rest = errorMaps[field];\n                            if (!validRest[field]) {\n                                validRest[field] = [];\n                            }\n                            validRest[field].push(rest);\n                            validFields.push(field);\n                            item.errRule = rest[0].rule;\n                            return Promise.reject(rest);\n                        }));\n                    }\n                });\n                return Promise.all(itemValids).then(function () {\n                    if (callback) {\n                        callback();\n                    }\n                }).catch(function () {\n                    return new Promise(function (resolve) {\n                        showErrTime = window.setTimeout(function () {\n                            itemList.forEach(function (item) {\n                                if (item.errRule) {\n                                    item.showError = true;\n                                }\n                            });\n                        }, 20);\n                        if (validOpts.autoPos !== false) {\n                            nextTick(function () {\n                                handleFocus(validFields);\n                            });\n                        }\n                        if (callback) {\n                            callback(validRest);\n                            resolve();\n                        }\n                        else {\n                            resolve(validRest);\n                        }\n                    });\n                });\n            }\n            if (callback) {\n                callback();\n            }\n            return Promise.resolve();\n        };\n        var validate = function (callback) {\n            clearValidate();\n            return beginValidate(getItems(), '', callback);\n        };\n        var validateField = function (fieldOrItem, callback) {\n            var fields = [];\n            if (XEUtils.isArray(fieldOrItem)) {\n                fields = fieldOrItem;\n            }\n            else {\n                fields = [fieldOrItem];\n            }\n            return beginValidate(fields.map(function (field) { return handleFieldOrItem($xeform, field); }), '', callback);\n        };\n        var submitEvent = function (evnt) {\n            evnt.preventDefault();\n            if (!props.preventSubmit) {\n                clearValidate();\n                beginValidate(getItems()).then(function (errMap) {\n                    if (errMap) {\n                        formMethods.dispatchEvent('submit-invalid', { data: props.data, errMap: errMap }, evnt);\n                    }\n                    else {\n                        formMethods.dispatchEvent('submit', { data: props.data }, evnt);\n                    }\n                });\n            }\n        };\n        var closeTooltip = function () {\n            var tooltipStore = internalData.tooltipStore;\n            var $tooltip = refTooltip.value;\n            if (tooltipStore.visible) {\n                Object.assign(tooltipStore, {\n                    item: null,\n                    visible: false\n                });\n                if ($tooltip) {\n                    $tooltip.close();\n                }\n            }\n            return nextTick();\n        };\n        var triggerTitleTipEvent = function (evnt, params) {\n            var item = params.item;\n            var tooltipStore = internalData.tooltipStore;\n            var $tooltip = refTooltip.value;\n            var overflowElem = evnt.currentTarget.children[0];\n            var content = (overflowElem.textContent || '').trim();\n            var isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;\n            clearTimeout(internalData.tooltipTimeout);\n            if (tooltipStore.item !== item) {\n                closeTooltip();\n            }\n            if (content && isCellOverflow) {\n                Object.assign(tooltipStore, {\n                    item: item,\n                    visible: true\n                });\n                if ($tooltip) {\n                    $tooltip.open(overflowElem, content);\n                }\n            }\n        };\n        var handleTitleTipLeaveEvent = function () {\n            var tooltipOpts = computeTooltipOpts.value;\n            var $tooltip = refTooltip.value;\n            if ($tooltip) {\n                $tooltip.setActived(false);\n            }\n            if (tooltipOpts.enterable) {\n                internalData.tooltipTimeout = setTimeout(function () {\n                    $tooltip = refTooltip.value;\n                    if ($tooltip && !$tooltip.isActived()) {\n                        closeTooltip();\n                    }\n                }, tooltipOpts.leaveDelay);\n            }\n            else {\n                closeTooltip();\n            }\n        };\n        var triggerItemEvent = function (evnt, field, itemValue) {\n            if (field) {\n                return validItemRules(evnt ? (['blur'].includes(evnt.type) ? 'blur' : 'change') : 'all', field, itemValue)\n                    .then(function () {\n                    clearValidate(field);\n                })\n                    .catch(function (errorMaps) {\n                    var rest = errorMaps[field];\n                    var item = getItemByField(field);\n                    if (rest && item) {\n                        item.showError = true;\n                        item.errRule = rest[0].rule;\n                    }\n                });\n            }\n            return nextTick();\n        };\n        /**\n         * 更新项状态\n         * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一项编辑状态\n         * 如果单元格配置了校验规则，则会进行校验\n         */\n        var updateStatus = function (scope, itemValue) {\n            var field = scope.field;\n            return triggerItemEvent(new Event('change'), field, itemValue);\n        };\n        formMethods = {\n            dispatchEvent: function (type, params, evnt) {\n                emit(type, Object.assign({ $form: $xeform, $grid: $xegrid, $event: evnt }, params));\n            },\n            reset: reset,\n            validate: validate,\n            validateField: validateField,\n            clearValidate: clearValidate,\n            updateStatus: updateStatus,\n            toggleCollapse: toggleCollapse,\n            getItems: getItems,\n            getItemByField: getItemByField,\n            closeTooltip: closeTooltip\n        };\n        var formPrivateMethods = {\n            callSlot: callSlot,\n            triggerItemEvent: triggerItemEvent,\n            toggleCollapseEvent: toggleCollapseEvent,\n            triggerTitleTipEvent: triggerTitleTipEvent,\n            handleTitleTipLeaveEvent: handleTitleTipLeaveEvent\n        };\n        Object.assign($xeform, formMethods, formPrivateMethods);\n        var staticItemFlag = ref(0);\n        watch(function () { return reactData.staticItems.length; }, function () {\n            staticItemFlag.value++;\n        });\n        watch(function () { return reactData.staticItems; }, function () {\n            staticItemFlag.value++;\n        });\n        watch(staticItemFlag, function () {\n            reactData.formItems = reactData.staticItems;\n        });\n        var itemFlag = ref(0);\n        watch(function () { return props.items ? props.items.length : -1; }, function () {\n            itemFlag.value++;\n        });\n        watch(function () { return props.items; }, function () {\n            itemFlag.value++;\n        });\n        watch(itemFlag, function () {\n            loadItem(props.items || []);\n        });\n        watch(function () { return props.collapseStatus; }, function (value) {\n            reactData.collapseAll = !!value;\n        });\n        onMounted(function () {\n            nextTick(function () {\n                if (process.env.NODE_ENV === 'development') {\n                    if (props.customLayout && props.items) {\n                        errLog('vxe.error.errConflicts', ['custom-layout', 'items']);\n                    }\n                }\n                loadItem(props.items || []);\n            });\n        });\n        var renderVN = function () {\n            var _a;\n            var loading = props.loading, className = props.className, data = props.data, customLayout = props.customLayout;\n            var formItems = reactData.formItems;\n            // const formItems: any[] = []\n            var vSize = computeSize.value;\n            var tooltipOpts = computeTooltipOpts.value;\n            var defaultSlot = slots.default;\n            return h('form', {\n                ref: refElem,\n                class: ['vxe-form', className ? (XEUtils.isFunction(className) ? className({ items: formItems, data: data, $form: $xeform }) : className) : '', (_a = {},\n                        _a[\"size--\".concat(vSize)] = vSize,\n                        _a['is--loading'] = loading,\n                        _a)],\n                onSubmit: submitEvent,\n                onReset: resetEvent\n            }, [\n                h('div', {\n                    class: 'vxe-form--wrapper vxe-row'\n                }, customLayout ? (defaultSlot ? defaultSlot({}) : []) : formItems.map(function (item, index) {\n                    return h(VxeFormConfigItem, {\n                        key: index,\n                        itemConfig: item\n                    });\n                })),\n                h('div', {\n                    class: 'vxe-form-slots',\n                    ref: 'hideItem'\n                }, customLayout ? [] : (defaultSlot ? defaultSlot({}) : [])),\n                /**\n                 * 加载中\n                 */\n                h(VxeLoading, {\n                    class: 'vxe-form--loading',\n                    modelValue: loading\n                }),\n                /**\n                 * 工具提示\n                 */\n                hasUseTooltip ? h(resolveComponent('vxe-tooltip'), __assign({ ref: refTooltip }, tooltipOpts)) : createCommentVNode()\n            ]);\n        };\n        $xeform.renderVN = renderVN;\n        provide('$xeform', $xeform);\n        provide('$xeformgather', null);\n        provide('$xeformitem', null);\n        provide('$xeformiteminfo', null);\n        return $xeform;\n    },\n    render: function () {\n        return this.renderVN();\n    }\n});\n",
      "start": 1714699767753,
      "end": 1714699767806,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1714699767806,
      "end": 1714699767806,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1714699767806,
      "end": 1714699767806,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1714699767806,
      "end": 1714699767806,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1714699767806,
      "end": 1714699767806,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1714699767806,
      "end": 1714699767806,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1714699767806,
      "end": 1714699767806,
      "order": "normal"
    },
    {
      "name": "vite-plugin-vconsole",
      "result": "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { defineComponent, h, ref, resolveComponent, createCommentVNode, provide, computed, inject, reactive, watch, nextTick, onMounted } from 'vue';\nimport XEUtils from 'xe-utils';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport { VXETable } from '../../v-x-e-table';\nimport { getFuncText, isEnableConf, eqEmptyValue } from '../../tools/utils';\nimport { errLog, warnLog } from '../../tools/log';\nimport { scrollToView } from '../../tools/dom';\nimport { createItem, handleFieldOrItem, isHiddenItem, isActivetem } from './util';\nimport { useSize } from '../../hooks/size';\nimport VxeFormConfigItem from './form-config-item';\nimport VxeLoading from '../../loading/index';\nimport { getSlotVNs } from '../../tools/vn';\nvar Rule = /** @class */ (function () {\n    function Rule(rule) {\n        Object.assign(this, {\n            $options: rule,\n            required: rule.required,\n            min: rule.min,\n            max: rule.min,\n            type: rule.type,\n            pattern: rule.pattern,\n            validator: rule.validator,\n            trigger: rule.trigger,\n            maxWidth: rule.maxWidth\n        });\n    }\n    Object.defineProperty(Rule.prototype, \"content\", {\n        get: function () {\n            return getFuncText(this.$options.content || this.$options.message);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rule.prototype, \"message\", {\n        get: function () {\n            return this.content;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Rule;\n}());\nvar validErrorRuleValue = function (rule, val) {\n    var type = rule.type, min = rule.min, max = rule.max, pattern = rule.pattern;\n    var isNumType = type === 'number';\n    var numVal = isNumType ? XEUtils.toNumber(val) : XEUtils.getSize(val);\n    // 判断数值\n    if (isNumType && isNaN(val)) {\n        return true;\n    }\n    // 如果存在 min，判断最小值\n    if (!XEUtils.eqNull(min) && numVal < XEUtils.toNumber(min)) {\n        return true;\n    }\n    // 如果存在 max，判断最大值\n    if (!XEUtils.eqNull(max) && numVal > XEUtils.toNumber(max)) {\n        return true;\n    }\n    // 如果存在 pattern，正则校验\n    if (pattern && !(XEUtils.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {\n        return true;\n    }\n    return false;\n};\nfunction getResetValue(value, resetValue) {\n    if (XEUtils.isArray(value)) {\n        resetValue = [];\n    }\n    return resetValue;\n}\nexport default defineComponent({\n    name: 'VxeForm',\n    props: {\n        collapseStatus: { type: Boolean, default: true },\n        loading: Boolean,\n        data: Object,\n        size: { type: String, default: function () { return GlobalConfig.form.size || GlobalConfig.size; } },\n        span: { type: [String, Number], default: function () { return GlobalConfig.form.span; } },\n        align: { type: String, default: function () { return GlobalConfig.form.align; } },\n        titleAlign: { type: String, default: function () { return GlobalConfig.form.titleAlign; } },\n        titleWidth: { type: [String, Number], default: function () { return GlobalConfig.form.titleWidth; } },\n        titleColon: { type: Boolean, default: function () { return GlobalConfig.form.titleColon; } },\n        titleAsterisk: { type: Boolean, default: function () { return GlobalConfig.form.titleAsterisk; } },\n        titleOverflow: { type: [Boolean, String], default: null },\n        vertical: {\n            type: Boolean,\n            default: null\n        },\n        className: [String, Function],\n        readonly: Boolean,\n        items: Array,\n        rules: Object,\n        preventSubmit: { type: Boolean, default: function () { return GlobalConfig.form.preventSubmit; } },\n        validConfig: Object,\n        tooltipConfig: Object,\n        customLayout: { type: Boolean, default: function () { return GlobalConfig.form.customLayout; } }\n    },\n    emits: [\n        'update:collapseStatus',\n        'collapse',\n        'toggle-collapse',\n        'submit',\n        'submit-invalid',\n        'reset'\n    ],\n    setup: function (props, context) {\n        var hasUseTooltip = VXETable.tooltip;\n        var slots = context.slots, emit = context.emit;\n        var xID = XEUtils.uniqueId();\n        var computeSize = useSize(props);\n        var reactData = reactive({\n            collapseAll: props.collapseStatus,\n            staticItems: [],\n            formItems: []\n        });\n        var internalData = reactive({\n            tooltipTimeout: null,\n            tooltipStore: {\n                item: null,\n                visible: false\n            }\n        });\n        var $xegrid = inject('$xegrid', null);\n        var refElem = ref();\n        var refTooltip = ref();\n        var formMethods = {};\n        var computeValidOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.form.validConfig, props.validConfig);\n        });\n        var computeTooltipOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.tooltip, GlobalConfig.form.tooltipConfig, props.tooltipConfig);\n        });\n        var refMaps = {\n            refElem: refElem\n        };\n        var computeMaps = {\n            computeSize: computeSize,\n            computeValidOpts: computeValidOpts,\n            computeTooltipOpts: computeTooltipOpts\n        };\n        var $xeform = {\n            xID: xID,\n            props: props,\n            context: context,\n            reactData: reactData,\n            xegrid: $xegrid,\n            getRefMaps: function () { return refMaps; },\n            getComputeMaps: function () { return computeMaps; }\n        };\n        var callSlot = function (slotFunc, params) {\n            if (slotFunc) {\n                if (XEUtils.isString(slotFunc)) {\n                    slotFunc = slots[slotFunc] || null;\n                }\n                if (XEUtils.isFunction(slotFunc)) {\n                    return getSlotVNs(slotFunc(params));\n                }\n            }\n            return [];\n        };\n        var loadItem = function (list) {\n            if (list.length) {\n                if (process.env.NODE_ENV === 'development') {\n                    list.forEach(function (item) {\n                        if (item.slots) {\n                            XEUtils.each(item.slots, function (func) {\n                                if (!XEUtils.isFunction(func)) {\n                                    if (!slots[func]) {\n                                        errLog('vxe.error.notSlot', [func]);\n                                    }\n                                }\n                            });\n                        }\n                    });\n                }\n                reactData.staticItems = XEUtils.mapTree(list, function (item) { return createItem($xeform, item); }, { children: 'children' });\n            }\n            return nextTick();\n        };\n        var getItems = function () {\n            var itemList = [];\n            XEUtils.eachTree(reactData.formItems, function (item) {\n                itemList.push(item);\n            }, { children: 'children' });\n            return itemList;\n        };\n        var getItemByField = function (field) {\n            var rest = XEUtils.findTree(reactData.formItems, function (item) { return item.field === field; }, { children: 'children' });\n            return rest ? rest.item : null;\n        };\n        var getCollapseStatus = function () {\n            return reactData.collapseAll;\n        };\n        var toggleCollapse = function () {\n            var status = !getCollapseStatus();\n            reactData.collapseAll = status;\n            emit('update:collapseStatus', status);\n            return nextTick();\n        };\n        var toggleCollapseEvent = function (evnt) {\n            toggleCollapse();\n            var status = getCollapseStatus();\n            formMethods.dispatchEvent('toggle-collapse', { status: status, collapse: status, data: props.data }, evnt);\n            formMethods.dispatchEvent('collapse', { status: status, collapse: status, data: props.data }, evnt);\n        };\n        var clearValidate = function (fieldOrItem) {\n            if (fieldOrItem) {\n                var fields = fieldOrItem;\n                if (!XEUtils.isArray(fieldOrItem)) {\n                    fields = [fieldOrItem];\n                }\n                fields.forEach(function (field) {\n                    if (field) {\n                        var item = handleFieldOrItem($xeform, field);\n                        if (item) {\n                            item.showError = false;\n                        }\n                    }\n                });\n            }\n            else {\n                getItems().forEach(function (item) {\n                    item.showError = false;\n                });\n            }\n            return nextTick();\n        };\n        var reset = function () {\n            var data = props.data;\n            var itemList = getItems();\n            if (data) {\n                itemList.forEach(function (item) {\n                    var field = item.field, resetValue = item.resetValue, itemRender = item.itemRender;\n                    if (isEnableConf(itemRender)) {\n                        var compConf = VXETable.renderer.get(itemRender.name);\n                        if (compConf && compConf.itemResetMethod) {\n                            compConf.itemResetMethod({ data: data, field: field, property: field, item: item, $form: $xeform, $grid: $xeform.xegrid });\n                        }\n                        else if (field) {\n                            XEUtils.set(data, field, resetValue === null ? getResetValue(XEUtils.get(data, field), undefined) : XEUtils.clone(resetValue, true));\n                        }\n                    }\n                });\n            }\n            return clearValidate();\n        };\n        var resetEvent = function (evnt) {\n            evnt.preventDefault();\n            reset();\n            formMethods.dispatchEvent('reset', { data: props.data }, evnt);\n        };\n        var handleFocus = function (fields) {\n            var el = refElem.value;\n            for (var i = 0; i < fields.length; i++) {\n                var property = fields[i];\n                var item = getItemByField(property);\n                if (item && isEnableConf(item.itemRender)) {\n                    var itemRender = item.itemRender;\n                    var compConf = VXETable.renderer.get(itemRender.name);\n                    var inputElem = null;\n                    // 定位到第一个\n                    if (!i) {\n                        scrollToView(el.querySelector(\".\".concat(item.id)));\n                    }\n                    // 如果指定了聚焦 class\n                    if (itemRender.autofocus) {\n                        inputElem = el.querySelector(\".\".concat(item.id, \" \").concat(itemRender.autofocus));\n                    }\n                    // 渲染器的聚焦处理\n                    if (!inputElem && compConf && compConf.autofocus) {\n                        inputElem = el.querySelector(\".\".concat(item.id, \" \").concat(compConf.autofocus));\n                    }\n                    if (inputElem) {\n                        inputElem.focus();\n                        break;\n                    }\n                }\n            }\n        };\n        /**\n         * 校验数据\n         * 按表格行、列顺序依次校验（同步或异步）\n         * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列\n         * 如果校验失败则，触发回调或者 Promise<(ErrMap 校验不通过列的信息)>\n         * 如果是传回调方式这返回一个 (ErrMap 校验不通过列的信息)\n         *\n         * rule 配置：\n         *  required=Boolean 是否必填\n         *  min=Number 最小长度\n         *  max=Number 最大长度\n         *  validator=Function({ itemValue, rule, rules, data, property }) 自定义校验，接收一个 Promise\n         *  trigger=change 触发方式\n         */\n        var validItemRules = function (validType, fields, val) {\n            var data = props.data, formRules = props.rules;\n            var errorMaps = {};\n            if (!XEUtils.isArray(fields)) {\n                fields = [fields];\n            }\n            return Promise.all(fields.map(function (property) {\n                var errorRules = [];\n                var syncVailds = [];\n                if (property && formRules) {\n                    var rules_1 = XEUtils.get(formRules, property);\n                    if (rules_1) {\n                        var itemValue_1 = XEUtils.isUndefined(val) ? XEUtils.get(data, property) : val;\n                        rules_1.forEach(function (rule) {\n                            var type = rule.type, trigger = rule.trigger, required = rule.required, validator = rule.validator;\n                            if (validType === 'all' || !trigger || validType === trigger) {\n                                if (validator) {\n                                    var validParams = {\n                                        itemValue: itemValue_1,\n                                        rule: rule,\n                                        rules: rules_1,\n                                        data: data,\n                                        field: property,\n                                        property: property,\n                                        $form: $xeform\n                                    };\n                                    var customValid = void 0;\n                                    if (XEUtils.isString(validator)) {\n                                        var gvItem = VXETable.validators.get(validator);\n                                        if (gvItem) {\n                                            if (gvItem.itemValidatorMethod) {\n                                                customValid = gvItem.itemValidatorMethod(validParams);\n                                            }\n                                            else {\n                                                if (process.env.NODE_ENV === 'development') {\n                                                    warnLog('vxe.error.notValidators', [validator]);\n                                                }\n                                            }\n                                        }\n                                        else {\n                                            if (process.env.NODE_ENV === 'development') {\n                                                errLog('vxe.error.notValidators', [validator]);\n                                            }\n                                        }\n                                    }\n                                    else {\n                                        customValid = validator(validParams);\n                                    }\n                                    if (customValid) {\n                                        if (XEUtils.isError(customValid)) {\n                                            errorRules.push(new Rule({ type: 'custom', trigger: trigger, content: customValid.message, rule: new Rule(rule) }));\n                                        }\n                                        else if (customValid.catch) {\n                                            // 如果为异步校验（注：异步校验是并发无序的）\n                                            syncVailds.push(customValid.catch(function (e) {\n                                                errorRules.push(new Rule({ type: 'custom', trigger: trigger, content: e ? e.message : (rule.content || rule.message), rule: new Rule(rule) }));\n                                            }));\n                                        }\n                                    }\n                                }\n                                else {\n                                    var isArrType = type === 'array';\n                                    var isArrVal = XEUtils.isArray(itemValue_1);\n                                    var hasEmpty = true;\n                                    if (isArrType || isArrVal) {\n                                        hasEmpty = !isArrVal || !itemValue_1.length;\n                                    }\n                                    else if (XEUtils.isString(itemValue_1)) {\n                                        hasEmpty = eqEmptyValue(itemValue_1.trim());\n                                    }\n                                    else {\n                                        hasEmpty = eqEmptyValue(itemValue_1);\n                                    }\n                                    if (required ? (hasEmpty || validErrorRuleValue(rule, itemValue_1)) : (!hasEmpty && validErrorRuleValue(rule, itemValue_1))) {\n                                        errorRules.push(new Rule(rule));\n                                    }\n                                }\n                            }\n                        });\n                    }\n                }\n                return Promise.all(syncVailds).then(function () {\n                    if (errorRules.length) {\n                        errorMaps[property] = errorRules.map(function (rule) {\n                            return {\n                                $form: $xeform,\n                                rule: rule,\n                                data: data,\n                                field: property,\n                                property: property\n                            };\n                        });\n                    }\n                });\n            })).then(function () {\n                if (!XEUtils.isEmpty(errorMaps)) {\n                    return Promise.reject(errorMaps);\n                }\n            });\n        };\n        var showErrTime;\n        var beginValidate = function (itemList, type, callback) {\n            var data = props.data, formRules = props.rules;\n            var validOpts = computeValidOpts.value;\n            var validRest = {};\n            var validFields = [];\n            var itemValids = [];\n            clearTimeout(showErrTime);\n            if (data && formRules) {\n                itemList.forEach(function (item) {\n                    var field = item.field;\n                    if (field && !isHiddenItem($xeform, item) && isActivetem($xeform, item)) {\n                        itemValids.push(validItemRules(type || 'all', field).then(function () {\n                            item.errRule = null;\n                        }).catch(function (errorMaps) {\n                            var rest = errorMaps[field];\n                            if (!validRest[field]) {\n                                validRest[field] = [];\n                            }\n                            validRest[field].push(rest);\n                            validFields.push(field);\n                            item.errRule = rest[0].rule;\n                            return Promise.reject(rest);\n                        }));\n                    }\n                });\n                return Promise.all(itemValids).then(function () {\n                    if (callback) {\n                        callback();\n                    }\n                }).catch(function () {\n                    return new Promise(function (resolve) {\n                        showErrTime = window.setTimeout(function () {\n                            itemList.forEach(function (item) {\n                                if (item.errRule) {\n                                    item.showError = true;\n                                }\n                            });\n                        }, 20);\n                        if (validOpts.autoPos !== false) {\n                            nextTick(function () {\n                                handleFocus(validFields);\n                            });\n                        }\n                        if (callback) {\n                            callback(validRest);\n                            resolve();\n                        }\n                        else {\n                            resolve(validRest);\n                        }\n                    });\n                });\n            }\n            if (callback) {\n                callback();\n            }\n            return Promise.resolve();\n        };\n        var validate = function (callback) {\n            clearValidate();\n            return beginValidate(getItems(), '', callback);\n        };\n        var validateField = function (fieldOrItem, callback) {\n            var fields = [];\n            if (XEUtils.isArray(fieldOrItem)) {\n                fields = fieldOrItem;\n            }\n            else {\n                fields = [fieldOrItem];\n            }\n            return beginValidate(fields.map(function (field) { return handleFieldOrItem($xeform, field); }), '', callback);\n        };\n        var submitEvent = function (evnt) {\n            evnt.preventDefault();\n            if (!props.preventSubmit) {\n                clearValidate();\n                beginValidate(getItems()).then(function (errMap) {\n                    if (errMap) {\n                        formMethods.dispatchEvent('submit-invalid', { data: props.data, errMap: errMap }, evnt);\n                    }\n                    else {\n                        formMethods.dispatchEvent('submit', { data: props.data }, evnt);\n                    }\n                });\n            }\n        };\n        var closeTooltip = function () {\n            var tooltipStore = internalData.tooltipStore;\n            var $tooltip = refTooltip.value;\n            if (tooltipStore.visible) {\n                Object.assign(tooltipStore, {\n                    item: null,\n                    visible: false\n                });\n                if ($tooltip) {\n                    $tooltip.close();\n                }\n            }\n            return nextTick();\n        };\n        var triggerTitleTipEvent = function (evnt, params) {\n            var item = params.item;\n            var tooltipStore = internalData.tooltipStore;\n            var $tooltip = refTooltip.value;\n            var overflowElem = evnt.currentTarget.children[0];\n            var content = (overflowElem.textContent || '').trim();\n            var isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;\n            clearTimeout(internalData.tooltipTimeout);\n            if (tooltipStore.item !== item) {\n                closeTooltip();\n            }\n            if (content && isCellOverflow) {\n                Object.assign(tooltipStore, {\n                    item: item,\n                    visible: true\n                });\n                if ($tooltip) {\n                    $tooltip.open(overflowElem, content);\n                }\n            }\n        };\n        var handleTitleTipLeaveEvent = function () {\n            var tooltipOpts = computeTooltipOpts.value;\n            var $tooltip = refTooltip.value;\n            if ($tooltip) {\n                $tooltip.setActived(false);\n            }\n            if (tooltipOpts.enterable) {\n                internalData.tooltipTimeout = setTimeout(function () {\n                    $tooltip = refTooltip.value;\n                    if ($tooltip && !$tooltip.isActived()) {\n                        closeTooltip();\n                    }\n                }, tooltipOpts.leaveDelay);\n            }\n            else {\n                closeTooltip();\n            }\n        };\n        var triggerItemEvent = function (evnt, field, itemValue) {\n            if (field) {\n                return validItemRules(evnt ? (['blur'].includes(evnt.type) ? 'blur' : 'change') : 'all', field, itemValue)\n                    .then(function () {\n                    clearValidate(field);\n                })\n                    .catch(function (errorMaps) {\n                    var rest = errorMaps[field];\n                    var item = getItemByField(field);\n                    if (rest && item) {\n                        item.showError = true;\n                        item.errRule = rest[0].rule;\n                    }\n                });\n            }\n            return nextTick();\n        };\n        /**\n         * 更新项状态\n         * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一项编辑状态\n         * 如果单元格配置了校验规则，则会进行校验\n         */\n        var updateStatus = function (scope, itemValue) {\n            var field = scope.field;\n            return triggerItemEvent(new Event('change'), field, itemValue);\n        };\n        formMethods = {\n            dispatchEvent: function (type, params, evnt) {\n                emit(type, Object.assign({ $form: $xeform, $grid: $xegrid, $event: evnt }, params));\n            },\n            reset: reset,\n            validate: validate,\n            validateField: validateField,\n            clearValidate: clearValidate,\n            updateStatus: updateStatus,\n            toggleCollapse: toggleCollapse,\n            getItems: getItems,\n            getItemByField: getItemByField,\n            closeTooltip: closeTooltip\n        };\n        var formPrivateMethods = {\n            callSlot: callSlot,\n            triggerItemEvent: triggerItemEvent,\n            toggleCollapseEvent: toggleCollapseEvent,\n            triggerTitleTipEvent: triggerTitleTipEvent,\n            handleTitleTipLeaveEvent: handleTitleTipLeaveEvent\n        };\n        Object.assign($xeform, formMethods, formPrivateMethods);\n        var staticItemFlag = ref(0);\n        watch(function () { return reactData.staticItems.length; }, function () {\n            staticItemFlag.value++;\n        });\n        watch(function () { return reactData.staticItems; }, function () {\n            staticItemFlag.value++;\n        });\n        watch(staticItemFlag, function () {\n            reactData.formItems = reactData.staticItems;\n        });\n        var itemFlag = ref(0);\n        watch(function () { return props.items ? props.items.length : -1; }, function () {\n            itemFlag.value++;\n        });\n        watch(function () { return props.items; }, function () {\n            itemFlag.value++;\n        });\n        watch(itemFlag, function () {\n            loadItem(props.items || []);\n        });\n        watch(function () { return props.collapseStatus; }, function (value) {\n            reactData.collapseAll = !!value;\n        });\n        onMounted(function () {\n            nextTick(function () {\n                if (process.env.NODE_ENV === 'development') {\n                    if (props.customLayout && props.items) {\n                        errLog('vxe.error.errConflicts', ['custom-layout', 'items']);\n                    }\n                }\n                loadItem(props.items || []);\n            });\n        });\n        var renderVN = function () {\n            var _a;\n            var loading = props.loading, className = props.className, data = props.data, customLayout = props.customLayout;\n            var formItems = reactData.formItems;\n            // const formItems: any[] = []\n            var vSize = computeSize.value;\n            var tooltipOpts = computeTooltipOpts.value;\n            var defaultSlot = slots.default;\n            return h('form', {\n                ref: refElem,\n                class: ['vxe-form', className ? (XEUtils.isFunction(className) ? className({ items: formItems, data: data, $form: $xeform }) : className) : '', (_a = {},\n                        _a[\"size--\".concat(vSize)] = vSize,\n                        _a['is--loading'] = loading,\n                        _a)],\n                onSubmit: submitEvent,\n                onReset: resetEvent\n            }, [\n                h('div', {\n                    class: 'vxe-form--wrapper vxe-row'\n                }, customLayout ? (defaultSlot ? defaultSlot({}) : []) : formItems.map(function (item, index) {\n                    return h(VxeFormConfigItem, {\n                        key: index,\n                        itemConfig: item\n                    });\n                })),\n                h('div', {\n                    class: 'vxe-form-slots',\n                    ref: 'hideItem'\n                }, customLayout ? [] : (defaultSlot ? defaultSlot({}) : [])),\n                /**\n                 * 加载中\n                 */\n                h(VxeLoading, {\n                    class: 'vxe-form--loading',\n                    modelValue: loading\n                }),\n                /**\n                 * 工具提示\n                 */\n                hasUseTooltip ? h(resolveComponent('vxe-tooltip'), __assign({ ref: refTooltip }, tooltipOpts)) : createCommentVNode()\n            ]);\n        };\n        $xeform.renderVN = renderVN;\n        provide('$xeform', $xeform);\n        provide('$xeformgather', null);\n        provide('$xeformitem', null);\n        provide('$xeformiteminfo', null);\n        return $xeform;\n    },\n    render: function () {\n        return this.renderVN();\n    }\n});\n",
      "start": 1714699767806,
      "end": 1714699767806,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "esbuild",
      "start": 1714699767806,
      "end": 1714699767806,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "var __assign = function() {\n  __assign = Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s)\n        if (Object.prototype.hasOwnProperty.call(s, p))\n          t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport { defineComponent, h, ref, resolveComponent, createCommentVNode, provide, computed, inject, reactive, watch, nextTick, onMounted } from \"vue\";\nimport XEUtils from \"xe-utils\";\nimport GlobalConfig from \"../../v-x-e-table/src/conf\";\nimport { VXETable } from \"../../v-x-e-table\";\nimport { getFuncText, isEnableConf, eqEmptyValue } from \"../../tools/utils\";\nimport { errLog, warnLog } from \"../../tools/log\";\nimport { scrollToView } from \"../../tools/dom\";\nimport { createItem, handleFieldOrItem, isHiddenItem, isActivetem } from \"./util\";\nimport { useSize } from \"../../hooks/size\";\nimport VxeFormConfigItem from \"./form-config-item\";\nimport VxeLoading from \"../../loading/index\";\nimport { getSlotVNs } from \"../../tools/vn\";\nvar Rule = (\n  /** @class */\n  function() {\n    function Rule2(rule) {\n      Object.assign(this, {\n        $options: rule,\n        required: rule.required,\n        min: rule.min,\n        max: rule.min,\n        type: rule.type,\n        pattern: rule.pattern,\n        validator: rule.validator,\n        trigger: rule.trigger,\n        maxWidth: rule.maxWidth\n      });\n    }\n    Object.defineProperty(Rule2.prototype, \"content\", {\n      get: function() {\n        return getFuncText(this.$options.content || this.$options.message);\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(Rule2.prototype, \"message\", {\n      get: function() {\n        return this.content;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    return Rule2;\n  }()\n);\nvar validErrorRuleValue = function(rule, val) {\n  var type = rule.type, min = rule.min, max = rule.max, pattern = rule.pattern;\n  var isNumType = type === \"number\";\n  var numVal = isNumType ? XEUtils.toNumber(val) : XEUtils.getSize(val);\n  if (isNumType && isNaN(val)) {\n    return true;\n  }\n  if (!XEUtils.eqNull(min) && numVal < XEUtils.toNumber(min)) {\n    return true;\n  }\n  if (!XEUtils.eqNull(max) && numVal > XEUtils.toNumber(max)) {\n    return true;\n  }\n  if (pattern && !(XEUtils.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {\n    return true;\n  }\n  return false;\n};\nfunction getResetValue(value, resetValue) {\n  if (XEUtils.isArray(value)) {\n    resetValue = [];\n  }\n  return resetValue;\n}\nexport default defineComponent({\n  name: \"VxeForm\",\n  props: {\n    collapseStatus: { type: Boolean, default: true },\n    loading: Boolean,\n    data: Object,\n    size: { type: String, default: function() {\n      return GlobalConfig.form.size || GlobalConfig.size;\n    } },\n    span: { type: [String, Number], default: function() {\n      return GlobalConfig.form.span;\n    } },\n    align: { type: String, default: function() {\n      return GlobalConfig.form.align;\n    } },\n    titleAlign: { type: String, default: function() {\n      return GlobalConfig.form.titleAlign;\n    } },\n    titleWidth: { type: [String, Number], default: function() {\n      return GlobalConfig.form.titleWidth;\n    } },\n    titleColon: { type: Boolean, default: function() {\n      return GlobalConfig.form.titleColon;\n    } },\n    titleAsterisk: { type: Boolean, default: function() {\n      return GlobalConfig.form.titleAsterisk;\n    } },\n    titleOverflow: { type: [Boolean, String], default: null },\n    vertical: {\n      type: Boolean,\n      default: null\n    },\n    className: [String, Function],\n    readonly: Boolean,\n    items: Array,\n    rules: Object,\n    preventSubmit: { type: Boolean, default: function() {\n      return GlobalConfig.form.preventSubmit;\n    } },\n    validConfig: Object,\n    tooltipConfig: Object,\n    customLayout: { type: Boolean, default: function() {\n      return GlobalConfig.form.customLayout;\n    } }\n  },\n  emits: [\n    \"update:collapseStatus\",\n    \"collapse\",\n    \"toggle-collapse\",\n    \"submit\",\n    \"submit-invalid\",\n    \"reset\"\n  ],\n  setup: function(props, context) {\n    var hasUseTooltip = VXETable.tooltip;\n    var slots = context.slots, emit = context.emit;\n    var xID = XEUtils.uniqueId();\n    var computeSize = useSize(props);\n    var reactData = reactive({\n      collapseAll: props.collapseStatus,\n      staticItems: [],\n      formItems: []\n    });\n    var internalData = reactive({\n      tooltipTimeout: null,\n      tooltipStore: {\n        item: null,\n        visible: false\n      }\n    });\n    var $xegrid = inject(\"$xegrid\", null);\n    var refElem = ref();\n    var refTooltip = ref();\n    var formMethods = {};\n    var computeValidOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.form.validConfig, props.validConfig);\n    });\n    var computeTooltipOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.tooltip, GlobalConfig.form.tooltipConfig, props.tooltipConfig);\n    });\n    var refMaps = {\n      refElem\n    };\n    var computeMaps = {\n      computeSize,\n      computeValidOpts,\n      computeTooltipOpts\n    };\n    var $xeform = {\n      xID,\n      props,\n      context,\n      reactData,\n      xegrid: $xegrid,\n      getRefMaps: function() {\n        return refMaps;\n      },\n      getComputeMaps: function() {\n        return computeMaps;\n      }\n    };\n    var callSlot = function(slotFunc, params) {\n      if (slotFunc) {\n        if (XEUtils.isString(slotFunc)) {\n          slotFunc = slots[slotFunc] || null;\n        }\n        if (XEUtils.isFunction(slotFunc)) {\n          return getSlotVNs(slotFunc(params));\n        }\n      }\n      return [];\n    };\n    var loadItem = function(list) {\n      if (list.length) {\n        if (false) {\n          list.forEach(function(item) {\n            if (item.slots) {\n              XEUtils.each(item.slots, function(func) {\n                if (!XEUtils.isFunction(func)) {\n                  if (!slots[func]) {\n                    errLog(\"vxe.error.notSlot\", [func]);\n                  }\n                }\n              });\n            }\n          });\n        }\n        reactData.staticItems = XEUtils.mapTree(list, function(item) {\n          return createItem($xeform, item);\n        }, { children: \"children\" });\n      }\n      return nextTick();\n    };\n    var getItems = function() {\n      var itemList = [];\n      XEUtils.eachTree(reactData.formItems, function(item) {\n        itemList.push(item);\n      }, { children: \"children\" });\n      return itemList;\n    };\n    var getItemByField = function(field) {\n      var rest = XEUtils.findTree(reactData.formItems, function(item) {\n        return item.field === field;\n      }, { children: \"children\" });\n      return rest ? rest.item : null;\n    };\n    var getCollapseStatus = function() {\n      return reactData.collapseAll;\n    };\n    var toggleCollapse = function() {\n      var status = !getCollapseStatus();\n      reactData.collapseAll = status;\n      emit(\"update:collapseStatus\", status);\n      return nextTick();\n    };\n    var toggleCollapseEvent = function(evnt) {\n      toggleCollapse();\n      var status = getCollapseStatus();\n      formMethods.dispatchEvent(\"toggle-collapse\", { status, collapse: status, data: props.data }, evnt);\n      formMethods.dispatchEvent(\"collapse\", { status, collapse: status, data: props.data }, evnt);\n    };\n    var clearValidate = function(fieldOrItem) {\n      if (fieldOrItem) {\n        var fields = fieldOrItem;\n        if (!XEUtils.isArray(fieldOrItem)) {\n          fields = [fieldOrItem];\n        }\n        fields.forEach(function(field) {\n          if (field) {\n            var item = handleFieldOrItem($xeform, field);\n            if (item) {\n              item.showError = false;\n            }\n          }\n        });\n      } else {\n        getItems().forEach(function(item) {\n          item.showError = false;\n        });\n      }\n      return nextTick();\n    };\n    var reset = function() {\n      var data = props.data;\n      var itemList = getItems();\n      if (data) {\n        itemList.forEach(function(item) {\n          var field = item.field, resetValue = item.resetValue, itemRender = item.itemRender;\n          if (isEnableConf(itemRender)) {\n            var compConf = VXETable.renderer.get(itemRender.name);\n            if (compConf && compConf.itemResetMethod) {\n              compConf.itemResetMethod({ data, field, property: field, item, $form: $xeform, $grid: $xeform.xegrid });\n            } else if (field) {\n              XEUtils.set(data, field, resetValue === null ? getResetValue(XEUtils.get(data, field), void 0) : XEUtils.clone(resetValue, true));\n            }\n          }\n        });\n      }\n      return clearValidate();\n    };\n    var resetEvent = function(evnt) {\n      evnt.preventDefault();\n      reset();\n      formMethods.dispatchEvent(\"reset\", { data: props.data }, evnt);\n    };\n    var handleFocus = function(fields) {\n      var el = refElem.value;\n      for (var i = 0; i < fields.length; i++) {\n        var property = fields[i];\n        var item = getItemByField(property);\n        if (item && isEnableConf(item.itemRender)) {\n          var itemRender = item.itemRender;\n          var compConf = VXETable.renderer.get(itemRender.name);\n          var inputElem = null;\n          if (!i) {\n            scrollToView(el.querySelector(\".\".concat(item.id)));\n          }\n          if (itemRender.autofocus) {\n            inputElem = el.querySelector(\".\".concat(item.id, \" \").concat(itemRender.autofocus));\n          }\n          if (!inputElem && compConf && compConf.autofocus) {\n            inputElem = el.querySelector(\".\".concat(item.id, \" \").concat(compConf.autofocus));\n          }\n          if (inputElem) {\n            inputElem.focus();\n            break;\n          }\n        }\n      }\n    };\n    var validItemRules = function(validType, fields, val) {\n      var data = props.data, formRules = props.rules;\n      var errorMaps = {};\n      if (!XEUtils.isArray(fields)) {\n        fields = [fields];\n      }\n      return Promise.all(fields.map(function(property) {\n        var errorRules = [];\n        var syncVailds = [];\n        if (property && formRules) {\n          var rules_1 = XEUtils.get(formRules, property);\n          if (rules_1) {\n            var itemValue_1 = XEUtils.isUndefined(val) ? XEUtils.get(data, property) : val;\n            rules_1.forEach(function(rule) {\n              var type = rule.type, trigger = rule.trigger, required = rule.required, validator = rule.validator;\n              if (validType === \"all\" || !trigger || validType === trigger) {\n                if (validator) {\n                  var validParams = {\n                    itemValue: itemValue_1,\n                    rule,\n                    rules: rules_1,\n                    data,\n                    field: property,\n                    property,\n                    $form: $xeform\n                  };\n                  var customValid = void 0;\n                  if (XEUtils.isString(validator)) {\n                    var gvItem = VXETable.validators.get(validator);\n                    if (gvItem) {\n                      if (gvItem.itemValidatorMethod) {\n                        customValid = gvItem.itemValidatorMethod(validParams);\n                      } else {\n                        if (false) {\n                          warnLog(\"vxe.error.notValidators\", [validator]);\n                        }\n                      }\n                    } else {\n                      if (false) {\n                        errLog(\"vxe.error.notValidators\", [validator]);\n                      }\n                    }\n                  } else {\n                    customValid = validator(validParams);\n                  }\n                  if (customValid) {\n                    if (XEUtils.isError(customValid)) {\n                      errorRules.push(new Rule({ type: \"custom\", trigger, content: customValid.message, rule: new Rule(rule) }));\n                    } else if (customValid.catch) {\n                      syncVailds.push(customValid.catch(function(e) {\n                        errorRules.push(new Rule({ type: \"custom\", trigger, content: e ? e.message : rule.content || rule.message, rule: new Rule(rule) }));\n                      }));\n                    }\n                  }\n                } else {\n                  var isArrType = type === \"array\";\n                  var isArrVal = XEUtils.isArray(itemValue_1);\n                  var hasEmpty = true;\n                  if (isArrType || isArrVal) {\n                    hasEmpty = !isArrVal || !itemValue_1.length;\n                  } else if (XEUtils.isString(itemValue_1)) {\n                    hasEmpty = eqEmptyValue(itemValue_1.trim());\n                  } else {\n                    hasEmpty = eqEmptyValue(itemValue_1);\n                  }\n                  if (required ? hasEmpty || validErrorRuleValue(rule, itemValue_1) : !hasEmpty && validErrorRuleValue(rule, itemValue_1)) {\n                    errorRules.push(new Rule(rule));\n                  }\n                }\n              }\n            });\n          }\n        }\n        return Promise.all(syncVailds).then(function() {\n          if (errorRules.length) {\n            errorMaps[property] = errorRules.map(function(rule) {\n              return {\n                $form: $xeform,\n                rule,\n                data,\n                field: property,\n                property\n              };\n            });\n          }\n        });\n      })).then(function() {\n        if (!XEUtils.isEmpty(errorMaps)) {\n          return Promise.reject(errorMaps);\n        }\n      });\n    };\n    var showErrTime;\n    var beginValidate = function(itemList, type, callback) {\n      var data = props.data, formRules = props.rules;\n      var validOpts = computeValidOpts.value;\n      var validRest = {};\n      var validFields = [];\n      var itemValids = [];\n      clearTimeout(showErrTime);\n      if (data && formRules) {\n        itemList.forEach(function(item) {\n          var field = item.field;\n          if (field && !isHiddenItem($xeform, item) && isActivetem($xeform, item)) {\n            itemValids.push(validItemRules(type || \"all\", field).then(function() {\n              item.errRule = null;\n            }).catch(function(errorMaps) {\n              var rest = errorMaps[field];\n              if (!validRest[field]) {\n                validRest[field] = [];\n              }\n              validRest[field].push(rest);\n              validFields.push(field);\n              item.errRule = rest[0].rule;\n              return Promise.reject(rest);\n            }));\n          }\n        });\n        return Promise.all(itemValids).then(function() {\n          if (callback) {\n            callback();\n          }\n        }).catch(function() {\n          return new Promise(function(resolve) {\n            showErrTime = window.setTimeout(function() {\n              itemList.forEach(function(item) {\n                if (item.errRule) {\n                  item.showError = true;\n                }\n              });\n            }, 20);\n            if (validOpts.autoPos !== false) {\n              nextTick(function() {\n                handleFocus(validFields);\n              });\n            }\n            if (callback) {\n              callback(validRest);\n              resolve();\n            } else {\n              resolve(validRest);\n            }\n          });\n        });\n      }\n      if (callback) {\n        callback();\n      }\n      return Promise.resolve();\n    };\n    var validate = function(callback) {\n      clearValidate();\n      return beginValidate(getItems(), \"\", callback);\n    };\n    var validateField = function(fieldOrItem, callback) {\n      var fields = [];\n      if (XEUtils.isArray(fieldOrItem)) {\n        fields = fieldOrItem;\n      } else {\n        fields = [fieldOrItem];\n      }\n      return beginValidate(fields.map(function(field) {\n        return handleFieldOrItem($xeform, field);\n      }), \"\", callback);\n    };\n    var submitEvent = function(evnt) {\n      evnt.preventDefault();\n      if (!props.preventSubmit) {\n        clearValidate();\n        beginValidate(getItems()).then(function(errMap) {\n          if (errMap) {\n            formMethods.dispatchEvent(\"submit-invalid\", { data: props.data, errMap }, evnt);\n          } else {\n            formMethods.dispatchEvent(\"submit\", { data: props.data }, evnt);\n          }\n        });\n      }\n    };\n    var closeTooltip = function() {\n      var tooltipStore = internalData.tooltipStore;\n      var $tooltip = refTooltip.value;\n      if (tooltipStore.visible) {\n        Object.assign(tooltipStore, {\n          item: null,\n          visible: false\n        });\n        if ($tooltip) {\n          $tooltip.close();\n        }\n      }\n      return nextTick();\n    };\n    var triggerTitleTipEvent = function(evnt, params) {\n      var item = params.item;\n      var tooltipStore = internalData.tooltipStore;\n      var $tooltip = refTooltip.value;\n      var overflowElem = evnt.currentTarget.children[0];\n      var content = (overflowElem.textContent || \"\").trim();\n      var isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;\n      clearTimeout(internalData.tooltipTimeout);\n      if (tooltipStore.item !== item) {\n        closeTooltip();\n      }\n      if (content && isCellOverflow) {\n        Object.assign(tooltipStore, {\n          item,\n          visible: true\n        });\n        if ($tooltip) {\n          $tooltip.open(overflowElem, content);\n        }\n      }\n    };\n    var handleTitleTipLeaveEvent = function() {\n      var tooltipOpts = computeTooltipOpts.value;\n      var $tooltip = refTooltip.value;\n      if ($tooltip) {\n        $tooltip.setActived(false);\n      }\n      if (tooltipOpts.enterable) {\n        internalData.tooltipTimeout = setTimeout(function() {\n          $tooltip = refTooltip.value;\n          if ($tooltip && !$tooltip.isActived()) {\n            closeTooltip();\n          }\n        }, tooltipOpts.leaveDelay);\n      } else {\n        closeTooltip();\n      }\n    };\n    var triggerItemEvent = function(evnt, field, itemValue) {\n      if (field) {\n        return validItemRules(evnt ? [\"blur\"].includes(evnt.type) ? \"blur\" : \"change\" : \"all\", field, itemValue).then(function() {\n          clearValidate(field);\n        }).catch(function(errorMaps) {\n          var rest = errorMaps[field];\n          var item = getItemByField(field);\n          if (rest && item) {\n            item.showError = true;\n            item.errRule = rest[0].rule;\n          }\n        });\n      }\n      return nextTick();\n    };\n    var updateStatus = function(scope, itemValue) {\n      var field = scope.field;\n      return triggerItemEvent(new Event(\"change\"), field, itemValue);\n    };\n    formMethods = {\n      dispatchEvent: function(type, params, evnt) {\n        emit(type, Object.assign({ $form: $xeform, $grid: $xegrid, $event: evnt }, params));\n      },\n      reset,\n      validate,\n      validateField,\n      clearValidate,\n      updateStatus,\n      toggleCollapse,\n      getItems,\n      getItemByField,\n      closeTooltip\n    };\n    var formPrivateMethods = {\n      callSlot,\n      triggerItemEvent,\n      toggleCollapseEvent,\n      triggerTitleTipEvent,\n      handleTitleTipLeaveEvent\n    };\n    Object.assign($xeform, formMethods, formPrivateMethods);\n    var staticItemFlag = ref(0);\n    watch(function() {\n      return reactData.staticItems.length;\n    }, function() {\n      staticItemFlag.value++;\n    });\n    watch(function() {\n      return reactData.staticItems;\n    }, function() {\n      staticItemFlag.value++;\n    });\n    watch(staticItemFlag, function() {\n      reactData.formItems = reactData.staticItems;\n    });\n    var itemFlag = ref(0);\n    watch(function() {\n      return props.items ? props.items.length : -1;\n    }, function() {\n      itemFlag.value++;\n    });\n    watch(function() {\n      return props.items;\n    }, function() {\n      itemFlag.value++;\n    });\n    watch(itemFlag, function() {\n      loadItem(props.items || []);\n    });\n    watch(function() {\n      return props.collapseStatus;\n    }, function(value) {\n      reactData.collapseAll = !!value;\n    });\n    onMounted(function() {\n      nextTick(function() {\n        if (false) {\n          if (props.customLayout && props.items) {\n            errLog(\"vxe.error.errConflicts\", [\"custom-layout\", \"items\"]);\n          }\n        }\n        loadItem(props.items || []);\n      });\n    });\n    var renderVN = function() {\n      var _a;\n      var loading = props.loading, className = props.className, data = props.data, customLayout = props.customLayout;\n      var formItems = reactData.formItems;\n      var vSize = computeSize.value;\n      var tooltipOpts = computeTooltipOpts.value;\n      var defaultSlot = slots.default;\n      return h(\"form\", {\n        ref: refElem,\n        class: [\"vxe-form\", className ? XEUtils.isFunction(className) ? className({ items: formItems, data, $form: $xeform }) : className : \"\", (_a = {}, _a[\"size--\".concat(vSize)] = vSize, _a[\"is--loading\"] = loading, _a)],\n        onSubmit: submitEvent,\n        onReset: resetEvent\n      }, [\n        h(\"div\", {\n          class: \"vxe-form--wrapper vxe-row\"\n        }, customLayout ? defaultSlot ? defaultSlot({}) : [] : formItems.map(function(item, index) {\n          return h(VxeFormConfigItem, {\n            key: index,\n            itemConfig: item\n          });\n        })),\n        h(\"div\", {\n          class: \"vxe-form-slots\",\n          ref: \"hideItem\"\n        }, customLayout ? [] : defaultSlot ? defaultSlot({}) : []),\n        /**\n         * 加载中\n         */\n        h(VxeLoading, {\n          class: \"vxe-form--loading\",\n          modelValue: loading\n        }),\n        /**\n         * 工具提示\n         */\n        hasUseTooltip ? h(resolveComponent(\"vxe-tooltip\"), __assign({ ref: refTooltip }, tooltipOpts)) : createCommentVNode()\n      ]);\n    };\n    $xeform.renderVN = renderVN;\n    provide(\"$xeform\", $xeform);\n    provide(\"$xeformgather\", null);\n    provide(\"$xeformitem\", null);\n    provide(\"$xeformiteminfo\", null);\n    return $xeform;\n  },\n  render: function() {\n    return this.renderVN();\n  }\n});\n",
      "start": 1714699767806,
      "end": 1714699768585,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-post",
      "start": 1714699768585,
      "end": 1714699768585,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1714699768585,
      "end": 1714699768585,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1714699768585,
      "end": 1714699768585,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1714699768585,
      "end": 1714699768585,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1714699768585,
      "end": 1714699768587,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1714699768587,
      "end": 1714699768587,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1714699768587,
      "end": 1714699768587,
      "order": "normal"
    },
    {
      "name": "unplugin-auto-import",
      "start": 1714699768587,
      "end": 1714699768587,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1714699768587,
      "end": 1714699768587,
      "order": "post"
    },
    {
      "name": "vite:style-import",
      "start": 1714699768587,
      "end": 1714699768587,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1714699768587,
      "end": 1714699768587,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1714699768587,
      "end": 1714699768587,
      "order": "normal"
    }
  ]
}
