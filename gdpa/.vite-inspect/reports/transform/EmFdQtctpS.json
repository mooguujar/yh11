{
  "resolvedId": "/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/vxe-table@4.5.21_vue@3.4.19_xe-utils@3.5.24/node_modules/vxe-table/es/table/src/table.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { defineComponent, getCurrentInstance, h, createCommentVNode, resolveComponent, reactive, ref, provide, inject, nextTick, onActivated, onDeactivated, onBeforeUnmount, onUnmounted, watch, computed, onMounted } from 'vue';\nimport XEUtils from 'xe-utils';\nimport { browse, isPx, isScale, hasClass, addClass, removeClass, getEventTargetNode, getPaddingTopBottomSize, setScrollTop, setScrollLeft, isNodeElement } from '../../tools/dom';\nimport { getLastZIndex, nextZIndex, hasChildrenList, getFuncText, isEnableConf, formatText, eqEmptyValue } from '../../tools/utils';\nimport { warnLog, errLog } from '../../tools/log';\nimport { createResizeEvent } from '../../tools/resize';\nimport { GlobalEvent, hasEventKey, EVENT_KEYS } from '../../tools/event';\nimport { useSize } from '../../hooks/size';\nimport { VXETable } from '../../v-x-e-table';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport Cell from './cell';\nimport TableBodyComponent from './body';\nimport TableHeaderComponent from '../../header';\nimport TableFooterComponent from '../../footer';\nimport tableProps from './props';\nimport tableEmits from './emits';\nimport VxeLoading from '../../loading/index';\nimport { getRowUniqueId, clearTableAllStatus, getRowkey, getRowid, rowToVisible, colToVisible, getCellValue, setCellValue, handleFieldOrColumn, toTreePathSeq, restoreScrollLocation, restoreScrollListener, getRootColumn } from './util';\nimport { getSlotVNs } from '../../tools/vn';\nvar isWebkit = browse['-webkit'] && !browse.edge;\nvar resizableStorageKey = 'VXE_TABLE_CUSTOM_COLUMN_WIDTH';\nvar visibleStorageKey = 'VXE_TABLE_CUSTOM_COLUMN_VISIBLE';\nvar fixedStorageKey = 'VXE_TABLE_CUSTOM_COLUMN_FIXED';\nvar orderStorageKey = 'VXE_TABLE_CUSTOM_COLUMN_ORDER';\nexport default defineComponent({\n    name: 'VxeTable',\n    props: tableProps,\n    emits: tableEmits,\n    setup: function (props, context) {\n        var slots = context.slots, emit = context.emit;\n        var hasUseTooltip = VXETable.tooltip;\n        var xID = XEUtils.uniqueId();\n        var computeSize = useSize(props);\n        var instance = getCurrentInstance();\n        var reactData = reactive({\n            // 低性能的静态列\n            staticColumns: [],\n            // 渲染的列分组\n            tableGroupColumn: [],\n            // 可视区渲染的列\n            tableColumn: [],\n            // 渲染中的数据\n            tableData: [],\n            // 是否启用了横向 X 可视渲染方式加载\n            scrollXLoad: false,\n            // 是否启用了纵向 Y 可视渲染方式加载\n            scrollYLoad: false,\n            // 是否存在纵向滚动条\n            overflowY: true,\n            // 是否存在横向滚动条\n            overflowX: false,\n            // 纵向滚动条的宽度\n            scrollbarWidth: 0,\n            // 横向滚动条的高度\n            scrollbarHeight: 0,\n            // 最后滚动时间戳\n            lastScrollTime: 0,\n            // 行高\n            rowHeight: 0,\n            // 表格父容器的高度\n            parentHeight: 0,\n            // 是否使用分组表头\n            isGroup: false,\n            isAllOverflow: false,\n            // 复选框属性，是否全选\n            isAllSelected: false,\n            // 复选框属性，有选中且非全选状态\n            isIndeterminate: false,\n            // 复选框属性，已选中的行集合\n            selectCheckboxMaps: {},\n            // 当前行\n            currentRow: null,\n            // 单选框属性，选中列\n            currentColumn: null,\n            // 单选框属性，选中行\n            selectRadioRow: null,\n            // 表尾合计数据\n            footerTableData: [],\n            // 展开列信息\n            expandColumn: null,\n            // 树节点列信息\n            treeNodeColumn: null,\n            hasFixedColumn: false,\n            // 已展开的行集合\n            rowExpandedMaps: {},\n            // 懒加载中的展开行的集合\n            rowExpandLazyLoadedMaps: {},\n            // 已展开树节点集合\n            treeExpandedMaps: {},\n            // 懒加载中的树节点的集合\n            treeExpandLazyLoadedMaps: {},\n            // 树节点不确定状态的集合\n            treeIndeterminateMaps: {},\n            // 合并单元格的对象集\n            mergeList: [],\n            // 合并表尾数据的对象集\n            mergeFooterList: [],\n            // 刷新列标识，当列筛选被改变时，触发表格刷新数据\n            upDataFlag: 0,\n            // 刷新列标识，当列的特定属性被改变时，触发表格刷新列\n            reColumnFlag: 0,\n            // 已标记的对象集\n            pendingRowMaps: {},\n            // 已标记的行\n            pendingRowList: [],\n            // 初始化标识\n            initStore: {\n                filter: false,\n                import: false,\n                export: false\n            },\n            // 当前选中的筛选列\n            filterStore: {\n                isAllSelected: false,\n                isIndeterminate: false,\n                style: null,\n                options: [],\n                column: null,\n                multiple: false,\n                visible: false,\n                maxHeight: null\n            },\n            // 存放列相关的信息\n            columnStore: {\n                leftList: [],\n                centerList: [],\n                rightList: [],\n                resizeList: [],\n                pxList: [],\n                pxMinList: [],\n                scaleList: [],\n                scaleMinList: [],\n                autoList: []\n            },\n            // 存放快捷菜单的信息\n            ctxMenuStore: {\n                selected: null,\n                visible: false,\n                showChild: false,\n                selectChild: null,\n                list: [],\n                style: null\n            },\n            // 存放可编辑相关信息\n            editStore: {\n                indexs: {\n                    columns: []\n                },\n                titles: {\n                    columns: []\n                },\n                // 选中源\n                selected: {\n                    row: null,\n                    column: null\n                },\n                // 已复制源\n                copyed: {\n                    cut: false,\n                    rows: [],\n                    columns: []\n                },\n                // 激活\n                actived: {\n                    row: null,\n                    column: null\n                },\n                insertMaps: {},\n                removeMaps: {}\n            },\n            // 存放 tooltip 相关信息\n            tooltipStore: {\n                row: null,\n                column: null,\n                content: null,\n                visible: false,\n                currOpts: null\n            },\n            // 存放数据校验相关信息\n            validStore: {\n                visible: false\n            },\n            validErrorMaps: {},\n            // 导入相关信息\n            importStore: {\n                inited: false,\n                file: null,\n                type: '',\n                modeList: [],\n                typeList: [],\n                filename: '',\n                visible: false\n            },\n            importParams: {\n                mode: '',\n                types: null,\n                message: true\n            },\n            // 导出相关信息\n            exportStore: {\n                inited: false,\n                name: '',\n                modeList: [],\n                typeList: [],\n                columns: [],\n                isPrint: false,\n                hasFooter: false,\n                hasMerge: false,\n                hasTree: false,\n                hasColgroup: false,\n                visible: false\n            },\n            exportParams: {\n                filename: '',\n                sheetName: '',\n                mode: '',\n                type: '',\n                isColgroup: false,\n                isMerge: false,\n                isAllExpand: false,\n                useStyle: false,\n                original: false,\n                message: true,\n                isHeader: false,\n                isFooter: false\n            },\n            scrollVMLoading: false,\n            _isResize: false\n        });\n        var internalData = {\n            tZindex: 0,\n            elemStore: {},\n            // 存放横向 X 虚拟滚动相关的信息\n            scrollXStore: {\n                offsetSize: 0,\n                visibleSize: 0,\n                startIndex: 0,\n                endIndex: 0\n            },\n            // 存放纵向 Y 虚拟滚动相关信息\n            scrollYStore: {\n                rowHeight: 0,\n                offsetSize: 0,\n                visibleSize: 0,\n                startIndex: 0,\n                endIndex: 0\n            },\n            // 表格宽度\n            tableWidth: 0,\n            // 表格高度\n            tableHeight: 0,\n            // 表头高度\n            headerHeight: 0,\n            // 表尾高度\n            footerHeight: 0,\n            customHeight: 0,\n            customMinHeight: 0,\n            customMaxHeight: 0,\n            // 当前 hover 行\n            hoverRow: null,\n            // 最后滚动位置\n            lastScrollLeft: 0,\n            lastScrollTop: 0,\n            // 单选框属性，已选中保留的行\n            radioReserveRow: null,\n            // 复选框属性，已选中保留的行集合\n            checkboxReserveRowMap: {},\n            // 行数据，已展开保留的行集合\n            rowExpandedReserveRowMap: {},\n            // 树结构数据，已展开保留的行集合\n            treeExpandedReserveRowMap: {},\n            // 树结构数据，不确定状态的集合\n            treeIndeterminateRowMaps: {},\n            // 列表完整数据、条件处理后\n            tableFullData: [],\n            afterFullData: [],\n            afterTreeFullData: [],\n            // 列表条件处理后数据集合\n            afterFullRowMaps: {},\n            // 树结构完整数据、条件处理后\n            tableFullTreeData: [],\n            tableSynchData: [],\n            tableSourceData: [],\n            // 收集的列配置（带分组）\n            collectColumn: [],\n            // 完整所有列（不带分组）\n            tableFullColumn: [],\n            // 渲染所有列\n            visibleColumn: [],\n            // 总的缓存数据集\n            fullAllDataRowIdData: {},\n            // 渲染中缓存数据\n            sourceDataRowIdData: {},\n            fullDataRowIdData: {},\n            fullColumnIdData: {},\n            fullColumnFieldData: {},\n            inited: false,\n            tooltipTimeout: null,\n            initStatus: false,\n            isActivated: false\n        };\n        var tableMethods = {};\n        var tablePrivateMethods = {};\n        var refElem = ref();\n        var refTooltip = ref();\n        var refCommTooltip = ref();\n        var refValidTooltip = ref();\n        var refTableFilter = ref();\n        var refTableMenu = ref();\n        var refTableHeader = ref();\n        var refTableBody = ref();\n        var refTableFooter = ref();\n        var refTableLeftHeader = ref();\n        var refTableLeftBody = ref();\n        var refTableLeftFooter = ref();\n        var refTableRightHeader = ref();\n        var refTableRightBody = ref();\n        var refTableRightFooter = ref();\n        var refLeftContainer = ref();\n        var refRightContainer = ref();\n        var refCellResizeBar = ref();\n        var refEmptyPlaceholder = ref();\n        var $xegrid = inject('$xegrid', null);\n        var $xetoolbar;\n        var computeValidOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.validConfig, props.validConfig);\n        });\n        var computeSXOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.scrollX, props.scrollX);\n        });\n        var computeSYOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.scrollY, props.scrollY);\n        });\n        var computeRowHeightMaps = computed(function () {\n            return {\n                default: 48,\n                medium: 44,\n                small: 40,\n                mini: 36\n            };\n        });\n        var computeColumnOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.columnConfig, props.columnConfig);\n        });\n        var computeRowOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.rowConfig, props.rowConfig);\n        });\n        var computeResizeleOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.resizeConfig, props.resizeConfig);\n        });\n        var computeResizableOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.resizableConfig, props.resizableConfig);\n        });\n        var computeSeqOpts = computed(function () {\n            return Object.assign({ startIndex: 0 }, GlobalConfig.table.seqConfig, props.seqConfig);\n        });\n        var computeRadioOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.radioConfig, props.radioConfig);\n        });\n        var computeCheckboxOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.checkboxConfig, props.checkboxConfig);\n        });\n        var computeTooltipOpts = ref();\n        computeTooltipOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.tooltip, GlobalConfig.table.tooltipConfig, props.tooltipConfig);\n        });\n        var computeTipConfig = computed(function () {\n            var tooltipStore = reactData.tooltipStore;\n            var tooltipOpts = computeTooltipOpts.value;\n            return __assign(__assign({}, tooltipOpts), tooltipStore.currOpts);\n        });\n        var computeValidTipOpts = computed(function () {\n            var tooltipOpts = computeTooltipOpts.value;\n            return Object.assign({ isArrow: false }, tooltipOpts);\n        });\n        var computeEditOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.editConfig, props.editConfig);\n        });\n        var computeSortOpts = computed(function () {\n            return Object.assign({ orders: ['asc', 'desc', null] }, GlobalConfig.table.sortConfig, props.sortConfig);\n        });\n        var computeFilterOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.filterConfig, props.filterConfig);\n        });\n        var computeMouseOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.mouseConfig, props.mouseConfig);\n        });\n        var computeAreaOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.areaConfig, props.areaConfig);\n        });\n        var computeKeyboardOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.keyboardConfig, props.keyboardConfig);\n        });\n        var computeClipOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.clipConfig, props.clipConfig);\n        });\n        var computeFNROpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.fnrConfig, props.fnrConfig);\n        });\n        var computeMenuOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.menuConfig, props.menuConfig);\n        });\n        var computeHeaderMenu = computed(function () {\n            var menuOpts = computeMenuOpts.value;\n            var headerOpts = menuOpts.header;\n            return headerOpts && headerOpts.options ? headerOpts.options : [];\n        });\n        var computeBodyMenu = computed(function () {\n            var menuOpts = computeMenuOpts.value;\n            var bodyOpts = menuOpts.body;\n            return bodyOpts && bodyOpts.options ? bodyOpts.options : [];\n        });\n        var computeFooterMenu = computed(function () {\n            var menuOpts = computeMenuOpts.value;\n            var footerOpts = menuOpts.footer;\n            return footerOpts && footerOpts.options ? footerOpts.options : [];\n        });\n        var computeIsMenu = computed(function () {\n            var menuOpts = computeMenuOpts.value;\n            var headerMenu = computeHeaderMenu.value;\n            var bodyMenu = computeBodyMenu.value;\n            var footerMenu = computeFooterMenu.value;\n            return !!(props.menuConfig && isEnableConf(menuOpts) && (headerMenu.length || bodyMenu.length || footerMenu.length));\n        });\n        var computeMenuList = computed(function () {\n            var ctxMenuStore = reactData.ctxMenuStore;\n            var rest = [];\n            ctxMenuStore.list.forEach(function (list) {\n                list.forEach(function (item) {\n                    rest.push(item);\n                });\n            });\n            return rest;\n        });\n        var computeExportOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.exportConfig, props.exportConfig);\n        });\n        var computeImportOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.importConfig, props.importConfig);\n        });\n        var computePrintOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.printConfig, props.printConfig);\n        });\n        var computeExpandOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.expandConfig, props.expandConfig);\n        });\n        var computeTreeOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.treeConfig, props.treeConfig);\n        });\n        var computeEmptyOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.emptyRender, props.emptyRender);\n        });\n        var computeLoadingOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.loadingConfig, props.loadingConfig);\n        });\n        var computeCellOffsetWidth = computed(function () {\n            return props.border ? Math.max(2, Math.ceil(reactData.scrollbarWidth / reactData.tableColumn.length)) : 1;\n        });\n        var computeCustomOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.customConfig, props.customConfig);\n        });\n        var computeFixedColumnSize = computed(function () {\n            var tableFullColumn = internalData.tableFullColumn;\n            var fixedSize = 0;\n            tableFullColumn.forEach(function (column) {\n                if (column.fixed) {\n                    fixedSize++;\n                }\n            });\n            return fixedSize;\n        });\n        var computeIsMaxFixedColumn = computed(function () {\n            var fixedColumnSize = computeFixedColumnSize.value;\n            var columnOpts = computeColumnOpts.value;\n            var maxFixedSize = columnOpts.maxFixedSize;\n            if (maxFixedSize) {\n                return fixedColumnSize >= maxFixedSize;\n            }\n            return false;\n        });\n        var computeTableBorder = computed(function () {\n            var border = props.border;\n            if (border === true) {\n                return 'full';\n            }\n            if (border) {\n                return border;\n            }\n            return 'default';\n        });\n        var computeIsAllCheckboxDisabled = computed(function () {\n            var treeConfig = props.treeConfig;\n            var tableData = reactData.tableData;\n            var tableFullData = internalData.tableFullData;\n            var checkboxOpts = computeCheckboxOpts.value;\n            var strict = checkboxOpts.strict, checkMethod = checkboxOpts.checkMethod;\n            if (strict) {\n                if (tableData.length || tableFullData.length) {\n                    if (checkMethod) {\n                        if (treeConfig) {\n                            // 暂时不支持树形结构\n                        }\n                        // 如果所有行都被禁用\n                        return tableFullData.every(function (row) { return !checkMethod({ row: row }); });\n                    }\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        });\n        var refMaps = {\n            refElem: refElem,\n            refTooltip: refTooltip,\n            refValidTooltip: refValidTooltip,\n            refTableFilter: refTableFilter,\n            refTableMenu: refTableMenu,\n            refTableHeader: refTableHeader,\n            refTableBody: refTableBody,\n            refTableFooter: refTableFooter,\n            refTableLeftHeader: refTableLeftHeader,\n            refTableLeftBody: refTableLeftBody,\n            refTableLeftFooter: refTableLeftFooter,\n            refTableRightHeader: refTableRightHeader,\n            refTableRightBody: refTableRightBody,\n            refTableRightFooter: refTableRightFooter,\n            refLeftContainer: refLeftContainer,\n            refRightContainer: refRightContainer,\n            refCellResizeBar: refCellResizeBar\n        };\n        var computeMaps = {\n            computeSize: computeSize,\n            computeValidOpts: computeValidOpts,\n            computeSXOpts: computeSXOpts,\n            computeSYOpts: computeSYOpts,\n            computeColumnOpts: computeColumnOpts,\n            computeRowOpts: computeRowOpts,\n            computeResizeleOpts: computeResizeleOpts,\n            computeResizableOpts: computeResizableOpts,\n            computeSeqOpts: computeSeqOpts,\n            computeRadioOpts: computeRadioOpts,\n            computeCheckboxOpts: computeCheckboxOpts,\n            computeTooltipOpts: computeTooltipOpts,\n            computeEditOpts: computeEditOpts,\n            computeSortOpts: computeSortOpts,\n            computeFilterOpts: computeFilterOpts,\n            computeMouseOpts: computeMouseOpts,\n            computeAreaOpts: computeAreaOpts,\n            computeKeyboardOpts: computeKeyboardOpts,\n            computeClipOpts: computeClipOpts,\n            computeFNROpts: computeFNROpts,\n            computeHeaderMenu: computeHeaderMenu,\n            computeBodyMenu: computeBodyMenu,\n            computeFooterMenu: computeFooterMenu,\n            computeIsMenu: computeIsMenu,\n            computeMenuOpts: computeMenuOpts,\n            computeExportOpts: computeExportOpts,\n            computeImportOpts: computeImportOpts,\n            computePrintOpts: computePrintOpts,\n            computeExpandOpts: computeExpandOpts,\n            computeTreeOpts: computeTreeOpts,\n            computeEmptyOpts: computeEmptyOpts,\n            computeLoadingOpts: computeLoadingOpts,\n            computeCustomOpts: computeCustomOpts,\n            computeFixedColumnSize: computeFixedColumnSize,\n            computeIsMaxFixedColumn: computeIsMaxFixedColumn,\n            computeIsAllCheckboxDisabled: computeIsAllCheckboxDisabled\n        };\n        var $xetable = {\n            xID: xID,\n            props: props,\n            context: context,\n            instance: instance,\n            reactData: reactData,\n            internalData: internalData,\n            getRefMaps: function () { return refMaps; },\n            getComputeMaps: function () { return computeMaps; },\n            xegrid: $xegrid\n        };\n        var eqCellValue = function (row1, row2, field) {\n            var val1 = XEUtils.get(row1, field);\n            var val2 = XEUtils.get(row2, field);\n            if (eqEmptyValue(val1) && eqEmptyValue(val2)) {\n                return true;\n            }\n            if (XEUtils.isString(val1) || XEUtils.isNumber(val1)) {\n                return ('' + val1) === ('' + val2);\n            }\n            return XEUtils.isEqual(val1, val2);\n        };\n        var getNextSortOrder = function (column) {\n            var sortOpts = computeSortOpts.value;\n            var orders = sortOpts.orders;\n            var currOrder = column.order || null;\n            var oIndex = orders.indexOf(currOrder) + 1;\n            return orders[oIndex < orders.length ? oIndex : 0];\n        };\n        var getCustomStorageMap = function (key) {\n            var version = GlobalConfig.version;\n            var rest = XEUtils.toStringJSON(localStorage.getItem(key) || '');\n            return rest && rest._v === version ? rest : { _v: version };\n        };\n        var getRecoverRowMaps = function (keyMaps) {\n            var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n            var restKeys = {};\n            XEUtils.each(keyMaps, function (row, rowid) {\n                if (fullAllDataRowIdData[rowid]) {\n                    restKeys[rowid] = row;\n                }\n            });\n            return restKeys;\n        };\n        var handleReserveRow = function (reserveRowMap) {\n            var fullDataRowIdData = internalData.fullDataRowIdData;\n            var reserveList = [];\n            XEUtils.each(reserveRowMap, function (item, rowid) {\n                if (fullDataRowIdData[rowid] && $xetable.findRowIndexOf(reserveList, fullDataRowIdData[rowid].row) === -1) {\n                    reserveList.push(fullDataRowIdData[rowid].row);\n                }\n            });\n            return reserveList;\n        };\n        var computeVirtualX = function () {\n            var visibleColumn = internalData.visibleColumn;\n            var tableBody = refTableBody.value;\n            var tableBodyElem = tableBody ? tableBody.$el : null;\n            if (tableBodyElem) {\n                var scrollLeft = tableBodyElem.scrollLeft, clientWidth = tableBodyElem.clientWidth;\n                var endWidth = scrollLeft + clientWidth;\n                var toVisibleIndex = -1;\n                var cWidth = 0;\n                var visibleSize = 0;\n                for (var colIndex = 0, colLen = visibleColumn.length; colIndex < colLen; colIndex++) {\n                    cWidth += visibleColumn[colIndex].renderWidth;\n                    if (toVisibleIndex === -1 && scrollLeft < cWidth) {\n                        toVisibleIndex = colIndex;\n                    }\n                    if (toVisibleIndex >= 0) {\n                        visibleSize++;\n                        if (cWidth > endWidth) {\n                            break;\n                        }\n                    }\n                }\n                return { toVisibleIndex: Math.max(0, toVisibleIndex), visibleSize: Math.max(8, visibleSize) };\n            }\n            return { toVisibleIndex: 0, visibleSize: 8 };\n        };\n        var computeVirtualY = function () {\n            var tableHeader = refTableHeader.value;\n            var tableBody = refTableBody.value;\n            var tableBodyElem = tableBody ? tableBody.$el : null;\n            var vSize = computeSize.value;\n            var rowHeightMaps = computeRowHeightMaps.value;\n            if (tableBodyElem) {\n                var tableHeaderElem = tableHeader ? tableHeader.$el : null;\n                var rowHeight = 0;\n                var firstTrElem = void 0;\n                firstTrElem = tableBodyElem.querySelector('tr');\n                if (!firstTrElem && tableHeaderElem) {\n                    firstTrElem = tableHeaderElem.querySelector('tr');\n                }\n                if (firstTrElem) {\n                    rowHeight = firstTrElem.clientHeight;\n                }\n                if (!rowHeight) {\n                    rowHeight = rowHeightMaps[vSize || 'default'];\n                }\n                var visibleSize = Math.max(8, Math.ceil(tableBodyElem.clientHeight / rowHeight) + 2);\n                return { rowHeight: rowHeight, visibleSize: visibleSize };\n            }\n            return { rowHeight: 0, visibleSize: 8 };\n        };\n        var calculateMergerOffserIndex = function (list, offsetItem, type) {\n            for (var mcIndex = 0, len = list.length; mcIndex < len; mcIndex++) {\n                var mergeItem = list[mcIndex];\n                var startIndex = offsetItem.startIndex, endIndex = offsetItem.endIndex;\n                var mergeStartIndex = mergeItem[type];\n                var mergeSpanNumber = mergeItem[type + 'span'];\n                var mergeEndIndex = mergeStartIndex + mergeSpanNumber;\n                if (mergeStartIndex < startIndex && startIndex < mergeEndIndex) {\n                    offsetItem.startIndex = mergeStartIndex;\n                }\n                if (mergeStartIndex < endIndex && endIndex < mergeEndIndex) {\n                    offsetItem.endIndex = mergeEndIndex;\n                }\n                if (offsetItem.startIndex !== startIndex || offsetItem.endIndex !== endIndex) {\n                    mcIndex = -1;\n                }\n            }\n        };\n        var setMerges = function (merges, mList, rowList) {\n            if (merges) {\n                var treeConfig = props.treeConfig;\n                var visibleColumn_1 = internalData.visibleColumn;\n                if (!XEUtils.isArray(merges)) {\n                    merges = [merges];\n                }\n                if (treeConfig && merges.length) {\n                    errLog('vxe.error.noTree', ['merge-cells | merge-footer-items']);\n                }\n                merges.forEach(function (item) {\n                    var row = item.row, col = item.col, rowspan = item.rowspan, colspan = item.colspan;\n                    if (rowList && XEUtils.isNumber(row)) {\n                        row = rowList[row];\n                    }\n                    if (XEUtils.isNumber(col)) {\n                        col = visibleColumn_1[col];\n                    }\n                    if ((rowList ? row : XEUtils.isNumber(row)) && col && (rowspan || colspan)) {\n                        rowspan = XEUtils.toNumber(rowspan) || 1;\n                        colspan = XEUtils.toNumber(colspan) || 1;\n                        if (rowspan > 1 || colspan > 1) {\n                            var mcIndex = XEUtils.findIndexOf(mList, function (item) { return (item._row === row || getRowid($xetable, item._row) === getRowid($xetable, row)) && (item._col.id === col || item._col.id === col.id); });\n                            var mergeItem = mList[mcIndex];\n                            if (mergeItem) {\n                                mergeItem.rowspan = rowspan;\n                                mergeItem.colspan = colspan;\n                                mergeItem._rowspan = rowspan;\n                                mergeItem._colspan = colspan;\n                            }\n                            else {\n                                var mergeRowIndex = rowList ? $xetable.findRowIndexOf(rowList, row) : row;\n                                var mergeColIndex = tableMethods.getVTColumnIndex(col);\n                                mList.push({\n                                    row: mergeRowIndex,\n                                    col: mergeColIndex,\n                                    rowspan: rowspan,\n                                    colspan: colspan,\n                                    _row: row,\n                                    _col: col,\n                                    _rowspan: rowspan,\n                                    _colspan: colspan\n                                });\n                            }\n                        }\n                    }\n                });\n            }\n        };\n        var removeMerges = function (merges, mList, rowList) {\n            var rest = [];\n            if (merges) {\n                var treeConfig = props.treeConfig;\n                var visibleColumn_2 = internalData.visibleColumn;\n                if (!XEUtils.isArray(merges)) {\n                    merges = [merges];\n                }\n                if (treeConfig && merges.length) {\n                    errLog('vxe.error.noTree', ['merge-cells | merge-footer-items']);\n                }\n                merges.forEach(function (item) {\n                    var row = item.row, col = item.col;\n                    if (rowList && XEUtils.isNumber(row)) {\n                        row = rowList[row];\n                    }\n                    if (XEUtils.isNumber(col)) {\n                        col = visibleColumn_2[col];\n                    }\n                    var mcIndex = XEUtils.findIndexOf(mList, function (item) { return (item._row === row || getRowid($xetable, item._row) === getRowid($xetable, row)) && (item._col.id === col || item._col.id === col.id); });\n                    if (mcIndex > -1) {\n                        var rItems = mList.splice(mcIndex, 1);\n                        rest.push(rItems[0]);\n                    }\n                });\n            }\n            return rest;\n        };\n        var clearAllSort = function () {\n            var tableFullColumn = internalData.tableFullColumn;\n            tableFullColumn.forEach(function (column) {\n                column.order = null;\n            });\n        };\n        var calcHeight = function (key) {\n            var parentHeight = reactData.parentHeight;\n            var val = props[key];\n            var num = 0;\n            if (val) {\n                if (val === 'auto') {\n                    num = parentHeight;\n                }\n                else {\n                    var excludeHeight = $xetable.getExcludeHeight();\n                    if (isScale(val)) {\n                        num = Math.floor((XEUtils.toInteger(val) || 1) / 100 * parentHeight);\n                    }\n                    else {\n                        num = XEUtils.toNumber(val);\n                    }\n                    num = Math.max(40, num - excludeHeight);\n                }\n            }\n            return num;\n        };\n        /**\n         * 还原自定义列操作状态\n         */\n        var restoreCustomStorage = function () {\n            var id = props.id, customConfig = props.customConfig;\n            var collectColumn = internalData.collectColumn;\n            var customOpts = computeCustomOpts.value;\n            var storage = customOpts.storage;\n            var isCustomResizable = storage === true || (storage && storage.resizable);\n            var isCustomVisible = storage === true || (storage && storage.visible);\n            var isCustomFixed = storage === true || (storage && storage.fixed);\n            var isCustomOrder = storage === true || (storage && storage.order);\n            if (customConfig && (isCustomResizable || isCustomVisible || isCustomFixed || isCustomOrder)) {\n                var customMap_1 = {};\n                if (!id) {\n                    errLog('vxe.error.reqProp', ['id']);\n                    return;\n                }\n                // 自定义列宽\n                if (isCustomResizable) {\n                    var columnWidthStorage = getCustomStorageMap(resizableStorageKey)[id];\n                    if (columnWidthStorage) {\n                        XEUtils.each(columnWidthStorage, function (resizeWidth, colKey) {\n                            customMap_1[colKey] = { resizeWidth: resizeWidth };\n                        });\n                    }\n                }\n                // 自定义固定列\n                if (isCustomFixed) {\n                    var columnFixedStorage = getCustomStorageMap(fixedStorageKey)[id];\n                    if (columnFixedStorage) {\n                        var colFixeds = columnFixedStorage.split(',');\n                        colFixeds.forEach(function (fixConf) {\n                            var _a = fixConf.split('|'), colKey = _a[0], fixed = _a[1];\n                            if (customMap_1[colKey]) {\n                                customMap_1[colKey].fixed = fixed;\n                            }\n                            else {\n                                customMap_1[colKey] = { fixed: fixed };\n                            }\n                        });\n                    }\n                }\n                // 自定义顺序\n                if (isCustomOrder) {\n                    var columnOrderStorage = getCustomStorageMap(orderStorageKey)[id];\n                    if (columnOrderStorage) {\n                        // const colOrderSeqs = columnOrderStorage.split(',')\n                        // colOrderSeqs.forEach((orderConf: any) => {\n                        //   const [colKey, order] = orderConf.split('|')\n                        //   if (customMap[colKey]) {\n                        //     customMap[colKey].order = order\n                        //   } else {\n                        //     customMap[colKey] = { order }\n                        //   }\n                        // })\n                    }\n                }\n                // 自定义隐藏列\n                if (isCustomVisible) {\n                    var columnVisibleStorage = getCustomStorageMap(visibleStorageKey)[id];\n                    if (columnVisibleStorage) {\n                        var colVisibles = columnVisibleStorage.split('|');\n                        var colHides = colVisibles[0] ? colVisibles[0].split(',') : [];\n                        var colShows = colVisibles[1] ? colVisibles[1].split(',') : [];\n                        colHides.forEach(function (colKey) {\n                            if (customMap_1[colKey]) {\n                                customMap_1[colKey].visible = false;\n                            }\n                            else {\n                                customMap_1[colKey] = { visible: false };\n                            }\n                        });\n                        colShows.forEach(function (colKey) {\n                            if (customMap_1[colKey]) {\n                                customMap_1[colKey].visible = true;\n                            }\n                            else {\n                                customMap_1[colKey] = { visible: true };\n                            }\n                        });\n                    }\n                }\n                var keyMap_1 = {};\n                XEUtils.eachTree(collectColumn, function (column) {\n                    var colKey = column.getKey();\n                    if (colKey) {\n                        keyMap_1[colKey] = column;\n                    }\n                });\n                XEUtils.each(customMap_1, function (_a, colKey) {\n                    var visible = _a.visible, resizeWidth = _a.resizeWidth, fixed = _a.fixed, order = _a.order;\n                    var column = keyMap_1[colKey];\n                    if (column) {\n                        if (XEUtils.isNumber(resizeWidth)) {\n                            column.resizeWidth = resizeWidth;\n                        }\n                        if (XEUtils.isBoolean(visible)) {\n                            column.visible = visible;\n                        }\n                        if (fixed) {\n                            column.fixed = fixed;\n                        }\n                        if (order) {\n                            column.customOrder = order;\n                        }\n                    }\n                });\n            }\n        };\n        /**\n         * 更新数据列的 Map\n         * 牺牲数据组装的耗时，用来换取使用过程中的流畅\n         */\n        var cacheColumnMap = function () {\n            var tableFullColumn = internalData.tableFullColumn, collectColumn = internalData.collectColumn;\n            var fullColumnIdData = internalData.fullColumnIdData = {};\n            var fullColumnFieldData = internalData.fullColumnFieldData = {};\n            var mouseOpts = computeMouseOpts.value;\n            var columnOpts = computeColumnOpts.value;\n            var rowOpts = computeRowOpts.value;\n            var isGroup = collectColumn.some(hasChildrenList);\n            var isAllOverflow = !!props.showOverflow;\n            var expandColumn;\n            var treeNodeColumn;\n            var checkboxColumn;\n            var radioColumn;\n            var htmlColumn;\n            var hasFixed;\n            var handleFunc = function (column, index, items, path, parent) {\n                var colid = column.id, field = column.field, fixed = column.fixed, type = column.type, treeNode = column.treeNode;\n                var rest = { column: column, colid: colid, index: index, items: items, parent: parent };\n                if (field) {\n                    if (process.env.NODE_ENV === 'development') {\n                        if (fullColumnFieldData[field]) {\n                            warnLog('vxe.error.colRepet', ['field', field]);\n                        }\n                    }\n                    fullColumnFieldData[field] = rest;\n                }\n                if (!hasFixed && fixed) {\n                    hasFixed = fixed;\n                }\n                if (!htmlColumn && type === 'html') {\n                    htmlColumn = column;\n                }\n                if (treeNode) {\n                    if (process.env.NODE_ENV === 'development') {\n                        if (treeNodeColumn) {\n                            warnLog('vxe.error.colRepet', ['tree-node', treeNode]);\n                        }\n                    }\n                    if (!treeNodeColumn) {\n                        treeNodeColumn = column;\n                    }\n                }\n                else if (type === 'expand') {\n                    if (process.env.NODE_ENV === 'development') {\n                        if (expandColumn) {\n                            warnLog('vxe.error.colRepet', ['type', type]);\n                        }\n                    }\n                    if (!expandColumn) {\n                        expandColumn = column;\n                    }\n                }\n                if (process.env.NODE_ENV === 'development') {\n                    if (type === 'checkbox') {\n                        if (checkboxColumn) {\n                            warnLog('vxe.error.colRepet', ['type', type]);\n                        }\n                        if (!checkboxColumn) {\n                            checkboxColumn = column;\n                        }\n                    }\n                    else if (type === 'radio') {\n                        if (radioColumn) {\n                            warnLog('vxe.error.colRepet', ['type', type]);\n                        }\n                        if (!radioColumn) {\n                            radioColumn = column;\n                        }\n                    }\n                }\n                if (isAllOverflow && column.showOverflow === false) {\n                    isAllOverflow = false;\n                }\n                if (fullColumnIdData[colid]) {\n                    errLog('vxe.error.colRepet', ['colId', colid]);\n                }\n                fullColumnIdData[colid] = rest;\n            };\n            if (isGroup) {\n                XEUtils.eachTree(collectColumn, function (column, index, items, path, parent, nodes) {\n                    column.level = nodes.length;\n                    handleFunc(column, index, items, path, parent);\n                });\n            }\n            else {\n                tableFullColumn.forEach(handleFunc);\n            }\n            if (process.env.NODE_ENV === 'development') {\n                if (expandColumn && mouseOpts.area) {\n                    errLog('vxe.error.errConflicts', ['mouse-config.area', 'column.type=expand']);\n                }\n            }\n            if (process.env.NODE_ENV === 'development') {\n                if (htmlColumn) {\n                    if (!columnOpts.useKey) {\n                        errLog('vxe.error.reqProp', ['column-config.useKey', 'column.type=html']);\n                    }\n                    if (!rowOpts.useKey) {\n                        errLog('vxe.error.reqProp', ['row-config.useKey', 'column.type=html']);\n                    }\n                }\n            }\n            reactData.isGroup = isGroup;\n            reactData.treeNodeColumn = treeNodeColumn;\n            reactData.expandColumn = expandColumn;\n            reactData.isAllOverflow = isAllOverflow;\n        };\n        var updateHeight = function () {\n            internalData.customHeight = calcHeight('height');\n            internalData.customMinHeight = calcHeight('minHeight');\n            internalData.customMaxHeight = calcHeight('maxHeight');\n        };\n        /**\n         * 列宽算法\n         * 支持 px、%、固定 混合分配\n         * 支持动态列表调整分配\n         * 支持自动分配偏移量\n         */\n        var autoCellWidth = function () {\n            var tableHeader = refTableHeader.value;\n            var tableBody = refTableBody.value;\n            var tableFooter = refTableFooter.value;\n            var bodyElem = tableBody ? tableBody.$el : null;\n            var headerElem = tableHeader ? tableHeader.$el : null;\n            var footerElem = tableFooter ? tableFooter.$el : null;\n            if (!bodyElem) {\n                return;\n            }\n            var tableWidth = 0;\n            var minCellWidth = 40; // 列宽最少限制 40px\n            var bodyWidth = bodyElem.clientWidth - 1;\n            var remainWidth = bodyWidth;\n            var meanWidth = remainWidth / 100;\n            var fit = props.fit;\n            var columnStore = reactData.columnStore;\n            var resizeList = columnStore.resizeList, pxMinList = columnStore.pxMinList, pxList = columnStore.pxList, scaleList = columnStore.scaleList, scaleMinList = columnStore.scaleMinList, autoList = columnStore.autoList;\n            // 最小宽\n            pxMinList.forEach(function (column) {\n                var minWidth = XEUtils.toInteger(column.minWidth);\n                tableWidth += minWidth;\n                column.renderWidth = minWidth;\n            });\n            // 最小百分比\n            scaleMinList.forEach(function (column) {\n                var scaleWidth = Math.floor(XEUtils.toInteger(column.minWidth) * meanWidth);\n                tableWidth += scaleWidth;\n                column.renderWidth = scaleWidth;\n            });\n            // 固定百分比\n            scaleList.forEach(function (column) {\n                var scaleWidth = Math.floor(XEUtils.toInteger(column.width) * meanWidth);\n                tableWidth += scaleWidth;\n                column.renderWidth = scaleWidth;\n            });\n            // 固定宽\n            pxList.forEach(function (column) {\n                var width = XEUtils.toInteger(column.width);\n                tableWidth += width;\n                column.renderWidth = width;\n            });\n            // 调整了列宽\n            resizeList.forEach(function (column) {\n                var width = XEUtils.toInteger(column.resizeWidth);\n                tableWidth += width;\n                column.renderWidth = width;\n            });\n            remainWidth -= tableWidth;\n            meanWidth = remainWidth > 0 ? Math.floor(remainWidth / (scaleMinList.length + pxMinList.length + autoList.length)) : 0;\n            if (fit) {\n                if (remainWidth > 0) {\n                    scaleMinList.concat(pxMinList).forEach(function (column) {\n                        tableWidth += meanWidth;\n                        column.renderWidth += meanWidth;\n                    });\n                }\n            }\n            else {\n                meanWidth = minCellWidth;\n            }\n            // 自适应\n            autoList.forEach(function (column) {\n                var width = Math.max(meanWidth, minCellWidth);\n                column.renderWidth = width;\n                tableWidth += width;\n            });\n            if (fit) {\n                /**\n                 * 偏移量算法\n                 * 如果所有列足够放的情况下，从最后动态列开始分配\n                 */\n                var dynamicList = scaleList.concat(scaleMinList).concat(pxMinList).concat(autoList);\n                var dynamicSize = dynamicList.length - 1;\n                if (dynamicSize > 0) {\n                    var odiffer = bodyWidth - tableWidth;\n                    if (odiffer > 0) {\n                        while (odiffer > 0 && dynamicSize >= 0) {\n                            odiffer--;\n                            dynamicList[dynamicSize--].renderWidth++;\n                        }\n                        tableWidth = bodyWidth;\n                    }\n                }\n            }\n            var tableHeight = bodyElem.offsetHeight;\n            var overflowY = bodyElem.scrollHeight > bodyElem.clientHeight;\n            var scrollbarWidth = 0;\n            if (overflowY) {\n                scrollbarWidth = Math.max(bodyElem.offsetWidth - bodyElem.clientWidth, 0);\n            }\n            reactData.scrollbarWidth = scrollbarWidth;\n            reactData.overflowY = overflowY;\n            internalData.tableWidth = tableWidth;\n            internalData.tableHeight = tableHeight;\n            var headerHeight = 0;\n            if (headerElem) {\n                headerHeight = headerElem.clientHeight;\n                nextTick(function () {\n                    // 检测是否同步滚动\n                    if (headerElem && bodyElem && headerElem.scrollLeft !== bodyElem.scrollLeft) {\n                        headerElem.scrollLeft = bodyElem.scrollLeft;\n                    }\n                });\n            }\n            internalData.headerHeight = headerHeight;\n            var overflowX = false;\n            var footerHeight = 0;\n            var scrollbarHeight = 0;\n            if (footerElem) {\n                footerHeight = footerElem.offsetHeight;\n                overflowX = tableWidth > footerElem.clientWidth;\n                if (overflowX) {\n                    scrollbarHeight = Math.max(footerHeight - footerElem.clientHeight, 0);\n                }\n            }\n            else {\n                overflowX = tableWidth > bodyWidth;\n                if (overflowX) {\n                    scrollbarHeight = Math.max(tableHeight - bodyElem.clientHeight, 0);\n                }\n            }\n            internalData.footerHeight = footerHeight;\n            reactData.overflowX = overflowX;\n            reactData.scrollbarHeight = scrollbarHeight;\n            updateHeight();\n            reactData.parentHeight = Math.max(internalData.headerHeight + footerHeight + 20, tablePrivateMethods.getParentHeight());\n            if (overflowX) {\n                tablePrivateMethods.checkScrolling();\n            }\n        };\n        var getOrderField = function (column) {\n            var sortBy = column.sortBy, sortType = column.sortType;\n            return function (row) {\n                var cellValue;\n                if (sortBy) {\n                    cellValue = XEUtils.isFunction(sortBy) ? sortBy({ row: row, column: column }) : XEUtils.get(row, sortBy);\n                }\n                else {\n                    cellValue = tablePrivateMethods.getCellLabel(row, column);\n                }\n                if (!sortType || sortType === 'auto') {\n                    return isNaN(cellValue) ? cellValue : XEUtils.toNumber(cellValue);\n                }\n                else if (sortType === 'number') {\n                    return XEUtils.toNumber(cellValue);\n                }\n                else if (sortType === 'string') {\n                    return XEUtils.toValueString(cellValue);\n                }\n                return cellValue;\n            };\n        };\n        /**\n         * 预编译\n         * 对渲染中的数据提前解析序号及索引。牺牲提前编译耗时换取渲染中额外损耗，使运行时更加流畅\n         */\n        var updateAfterDataIndex = function () {\n            var treeConfig = props.treeConfig;\n            var afterFullData = internalData.afterFullData, fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n            var afterTreeFullData = internalData.afterTreeFullData;\n            var treeOpts = computeTreeOpts.value;\n            var childrenField = treeOpts.children || treeOpts.childrenField;\n            var fullMaps = {};\n            if (treeConfig) {\n                XEUtils.eachTree(afterTreeFullData, function (row, index, items, path) {\n                    var rowid = getRowid($xetable, row);\n                    var allrest = fullAllDataRowIdData[rowid];\n                    var seq = path.map(function (num, i) { return i % 2 === 0 ? (Number(num) + 1) : '.'; }).join('');\n                    if (allrest) {\n                        allrest.seq = seq;\n                        allrest._index = index;\n                    }\n                    else {\n                        var rest = { row: row, rowid: rowid, seq: seq, index: -1, $index: -1, _index: index, items: [], parent: null, level: 0 };\n                        fullAllDataRowIdData[rowid] = rest;\n                        fullDataRowIdData[rowid] = rest;\n                    }\n                    fullMaps[rowid] = row;\n                }, { children: treeOpts.transform ? treeOpts.mapChildrenField : childrenField });\n            }\n            else {\n                afterFullData.forEach(function (row, index) {\n                    var rowid = getRowid($xetable, row);\n                    var allrest = fullAllDataRowIdData[rowid];\n                    var seq = index + 1;\n                    if (allrest) {\n                        allrest.seq = seq;\n                        allrest._index = index;\n                    }\n                    else {\n                        var rest = { row: row, rowid: rowid, seq: seq, index: -1, $index: -1, _index: index, items: [], parent: null, level: 0 };\n                        fullAllDataRowIdData[rowid] = rest;\n                        fullDataRowIdData[rowid] = rest;\n                    }\n                    fullMaps[rowid] = row;\n                });\n            }\n            internalData.afterFullRowMaps = fullMaps;\n        };\n        /**\n         * 如果为虚拟树，将树结构拍平\n         * @returns\n         */\n        var handleVirtualTreeToList = function () {\n            var treeConfig = props.treeConfig;\n            var treeExpandedMaps = reactData.treeExpandedMaps;\n            var treeOpts = computeTreeOpts.value;\n            if (treeConfig && treeOpts.transform) {\n                var fullData_1 = [];\n                var expandMaps_1 = {};\n                XEUtils.eachTree(internalData.afterTreeFullData, function (row, index, items, path, parent) {\n                    var rowid = getRowid($xetable, row);\n                    var parentRowid = getRowid($xetable, parent);\n                    if (!parent || (expandMaps_1[parentRowid] && treeExpandedMaps[parentRowid])) {\n                        expandMaps_1[rowid] = 1;\n                        fullData_1.push(row);\n                    }\n                }, { children: treeOpts.mapChildrenField });\n                internalData.afterFullData = fullData_1;\n                updateScrollYStatus(fullData_1);\n                return fullData_1;\n            }\n            return internalData.afterFullData;\n        };\n        /**\n         * 获取处理后全量的表格数据\n         * 如果存在筛选条件，继续处理\n         */\n        var updateAfterFullData = function () {\n            var treeConfig = props.treeConfig;\n            var tableFullColumn = internalData.tableFullColumn, tableFullData = internalData.tableFullData, tableFullTreeData = internalData.tableFullTreeData;\n            var filterOpts = computeFilterOpts.value;\n            var sortOpts = computeSortOpts.value;\n            var treeOpts = computeTreeOpts.value;\n            var transform = treeOpts.transform;\n            var allRemoteFilter = filterOpts.remote, allFilterMethod = filterOpts.filterMethod;\n            var allRemoteSort = sortOpts.remote, allSortMethod = sortOpts.sortMethod, sortMultiple = sortOpts.multiple, chronological = sortOpts.chronological;\n            var tableData = [];\n            var tableTree = [];\n            // 处理列\n            if (!allRemoteFilter || !allRemoteSort) {\n                var filterColumns_1 = [];\n                var orderColumns_1 = [];\n                tableFullColumn.forEach(function (column) {\n                    var field = column.field, sortable = column.sortable, order = column.order, filters = column.filters;\n                    if (!allRemoteFilter && filters && filters.length) {\n                        var valueList_1 = [];\n                        var itemList_1 = [];\n                        filters.forEach(function (item) {\n                            if (item.checked) {\n                                itemList_1.push(item);\n                                valueList_1.push(item.value);\n                            }\n                        });\n                        if (itemList_1.length) {\n                            filterColumns_1.push({ column: column, valueList: valueList_1, itemList: itemList_1 });\n                        }\n                    }\n                    if (!allRemoteSort && sortable && order) {\n                        orderColumns_1.push({ column: column, field: field, property: field, order: order, sortTime: column.sortTime });\n                    }\n                });\n                if (sortMultiple && chronological && orderColumns_1.length > 1) {\n                    orderColumns_1 = XEUtils.orderBy(orderColumns_1, 'sortTime');\n                }\n                // 处理筛选\n                // 支持单列、多列、组合筛选\n                if (!allRemoteFilter && filterColumns_1.length) {\n                    var handleFilter = function (row) {\n                        return filterColumns_1.every(function (_a) {\n                            var column = _a.column, valueList = _a.valueList, itemList = _a.itemList;\n                            var filterMethod = column.filterMethod, filterRender = column.filterRender;\n                            var compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;\n                            var compFilterMethod = compConf ? compConf.filterMethod : null;\n                            var defaultFilterMethod = compConf ? compConf.defaultFilterMethod : null;\n                            var cellValue = getCellValue(row, column);\n                            if (filterMethod) {\n                                return itemList.some(function (item) { return filterMethod({ value: item.value, option: item, cellValue: cellValue, row: row, column: column, $table: $xetable }); });\n                            }\n                            else if (compFilterMethod) {\n                                return itemList.some(function (item) { return compFilterMethod({ value: item.value, option: item, cellValue: cellValue, row: row, column: column, $table: $xetable }); });\n                            }\n                            else if (allFilterMethod) {\n                                return allFilterMethod({ options: itemList, values: valueList, cellValue: cellValue, row: row, column: column });\n                            }\n                            else if (defaultFilterMethod) {\n                                return itemList.some(function (item) { return defaultFilterMethod({ value: item.value, option: item, cellValue: cellValue, row: row, column: column, $table: $xetable }); });\n                            }\n                            return valueList.indexOf(XEUtils.get(row, column.field)) > -1;\n                        });\n                    };\n                    if (treeConfig && transform) {\n                        // 筛选虚拟树\n                        tableTree = XEUtils.searchTree(tableFullTreeData, handleFilter, __assign(__assign({}, treeOpts), { original: true }));\n                        tableData = tableTree;\n                    }\n                    else {\n                        tableData = treeConfig ? tableFullTreeData.filter(handleFilter) : tableFullData.filter(handleFilter);\n                        tableTree = tableData;\n                    }\n                }\n                else {\n                    if (treeConfig && transform) {\n                        // 还原虚拟树\n                        tableTree = XEUtils.searchTree(tableFullTreeData, function () { return true; }, __assign(__assign({}, treeOpts), { original: true }));\n                        tableData = tableTree;\n                    }\n                    else {\n                        tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);\n                        tableTree = tableData;\n                    }\n                }\n                // 处理排序（不能用于树形结构）\n                // 支持单列、多列、组合排序\n                if (!allRemoteSort && orderColumns_1.length) {\n                    if (treeConfig && transform) {\n                        // 虚拟树和列表一样，只能排序根级节点\n                        if (allSortMethod) {\n                            var sortRests = allSortMethod({ data: tableTree, sortList: orderColumns_1, $table: $xetable });\n                            tableTree = XEUtils.isArray(sortRests) ? sortRests : tableTree;\n                        }\n                        else {\n                            tableTree = XEUtils.orderBy(tableTree, orderColumns_1.map(function (_a) {\n                                var column = _a.column, order = _a.order;\n                                return [getOrderField(column), order];\n                            }));\n                        }\n                        tableData = tableTree;\n                    }\n                    else {\n                        if (allSortMethod) {\n                            var sortRests = allSortMethod({ data: tableData, sortList: orderColumns_1, $table: $xetable });\n                            tableData = XEUtils.isArray(sortRests) ? sortRests : tableData;\n                        }\n                        else {\n                            tableData = XEUtils.orderBy(tableData, orderColumns_1.map(function (_a) {\n                                var column = _a.column, order = _a.order;\n                                return [getOrderField(column), order];\n                            }));\n                        }\n                        tableTree = tableData;\n                    }\n                }\n            }\n            else {\n                if (treeConfig && transform) {\n                    // 还原虚拟树\n                    tableTree = XEUtils.searchTree(tableFullTreeData, function () { return true; }, __assign(__assign({}, treeOpts), { original: true }));\n                    tableData = tableTree;\n                }\n                else {\n                    tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);\n                    tableTree = tableData;\n                }\n            }\n            internalData.afterFullData = tableData;\n            internalData.afterTreeFullData = tableTree;\n            updateAfterDataIndex();\n        };\n        var updateStyle = function () {\n            var border = props.border, showFooter = props.showFooter, allColumnOverflow = props.showOverflow, allColumnHeaderOverflow = props.showHeaderOverflow, allColumnFooterOverflow = props.showFooterOverflow, mouseConfig = props.mouseConfig, spanMethod = props.spanMethod, footerSpanMethod = props.footerSpanMethod, keyboardConfig = props.keyboardConfig;\n            var isGroup = reactData.isGroup, currentRow = reactData.currentRow, tableColumn = reactData.tableColumn, scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad, scrollbarWidth = reactData.scrollbarWidth, scrollbarHeight = reactData.scrollbarHeight, columnStore = reactData.columnStore, editStore = reactData.editStore, mergeList = reactData.mergeList, mergeFooterList = reactData.mergeFooterList, isAllOverflow = reactData.isAllOverflow;\n            var visibleColumn = internalData.visibleColumn, fullColumnIdData = internalData.fullColumnIdData, tableHeight = internalData.tableHeight, tableWidth = internalData.tableWidth, headerHeight = internalData.headerHeight, footerHeight = internalData.footerHeight, elemStore = internalData.elemStore, customHeight = internalData.customHeight, customMinHeight = internalData.customMinHeight, customMaxHeight = internalData.customMaxHeight;\n            var containerList = ['main', 'left', 'right'];\n            var emptyPlaceholderElem = refEmptyPlaceholder.value;\n            var cellOffsetWidth = computeCellOffsetWidth.value;\n            var mouseOpts = computeMouseOpts.value;\n            var keyboardOpts = computeKeyboardOpts.value;\n            var bodyWrapperRef = elemStore['main-body-wrapper'];\n            var bodyWrapperElem = bodyWrapperRef ? bodyWrapperRef.value : null;\n            if (emptyPlaceholderElem) {\n                emptyPlaceholderElem.style.top = \"\".concat(headerHeight, \"px\");\n                emptyPlaceholderElem.style.height = bodyWrapperElem ? \"\".concat(bodyWrapperElem.offsetHeight - scrollbarHeight, \"px\") : '';\n            }\n            if (customHeight > 0) {\n                if (showFooter) {\n                    customHeight += scrollbarHeight;\n                }\n            }\n            containerList.forEach(function (name, index) {\n                var fixedType = index > 0 ? name : '';\n                var layoutList = ['header', 'body', 'footer'];\n                var isFixedLeft = fixedType === 'left';\n                var fixedColumn = [];\n                var fixedWrapperElem;\n                if (fixedType) {\n                    fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;\n                    fixedWrapperElem = isFixedLeft ? refLeftContainer.value : refRightContainer.value;\n                }\n                layoutList.forEach(function (layout) {\n                    var wrapperRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-wrapper\")];\n                    var wrapperElem = wrapperRef ? wrapperRef.value : null;\n                    var tableRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-table\")];\n                    var tableElem = tableRef ? tableRef.value : null;\n                    if (layout === 'header') {\n                        // 表头体样式处理\n                        // 横向滚动渲染\n                        var tWidth = tableWidth;\n                        var renderColumnList = tableColumn;\n                        if (isGroup) {\n                            renderColumnList = visibleColumn;\n                        }\n                        else {\n                            // 如果是使用优化模式\n                            if (fixedType) {\n                                if (scrollXLoad || allColumnHeaderOverflow) {\n                                    renderColumnList = fixedColumn;\n                                }\n                            }\n                        }\n                        tWidth = renderColumnList.reduce(function (previous, column) { return previous + column.renderWidth; }, 0);\n                        if (tableElem) {\n                            tableElem.style.width = tWidth ? \"\".concat(tWidth + scrollbarWidth, \"px\") : '';\n                        }\n                        var repairRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-repair\")];\n                        var repairElem = repairRef ? repairRef.value : null;\n                        if (repairElem) {\n                            repairElem.style.width = \"\".concat(tableWidth, \"px\");\n                        }\n                        var listRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-list\")];\n                        var listElem = listRef ? listRef.value : null;\n                        if (isGroup && listElem) {\n                            XEUtils.arrayEach(listElem.querySelectorAll('.col--group'), function (thElem) {\n                                var colNode = tableMethods.getColumnNode(thElem);\n                                if (colNode) {\n                                    var column_1 = colNode.item;\n                                    var showHeaderOverflow = column_1.showHeaderOverflow;\n                                    var cellOverflow = XEUtils.isBoolean(showHeaderOverflow) ? showHeaderOverflow : allColumnHeaderOverflow;\n                                    var showEllipsis = cellOverflow === 'ellipsis';\n                                    var showTitle = cellOverflow === 'title';\n                                    var showTooltip = cellOverflow === true || cellOverflow === 'tooltip';\n                                    var hasEllipsis = showTitle || showTooltip || showEllipsis;\n                                    var childWidth_1 = 0;\n                                    var countChild_1 = 0;\n                                    if (hasEllipsis) {\n                                        XEUtils.eachTree(column_1.children, function (item) {\n                                            if (!item.children || !column_1.children.length) {\n                                                countChild_1++;\n                                            }\n                                            childWidth_1 += item.renderWidth;\n                                        }, { children: 'children' });\n                                    }\n                                    thElem.style.width = hasEllipsis ? \"\".concat(childWidth_1 - countChild_1 - (border ? 2 : 0), \"px\") : '';\n                                }\n                            });\n                        }\n                    }\n                    else if (layout === 'body') {\n                        var emptyBlockRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-emptyBlock\")];\n                        var emptyBlockElem = emptyBlockRef ? emptyBlockRef.value : null;\n                        if (isNodeElement(wrapperElem)) {\n                            var bodyMaxHeight = 0;\n                            var bodyMinHeight = customMinHeight - headerHeight - footerHeight;\n                            if (customMaxHeight) {\n                                bodyMaxHeight = customMaxHeight - headerHeight - footerHeight;\n                                // 如果是固定列\n                                if (fixedType) {\n                                    bodyMaxHeight -= (showFooter ? 0 : scrollbarHeight);\n                                }\n                                bodyMaxHeight = Math.max(bodyMinHeight, bodyMaxHeight);\n                                wrapperElem.style.maxHeight = \"\".concat(bodyMaxHeight, \"px\");\n                            }\n                            if (customHeight) {\n                                var bodyHeight = customHeight - headerHeight - footerHeight;\n                                // 如果是固定列\n                                if (fixedType) {\n                                    bodyHeight -= (showFooter ? 0 : scrollbarHeight);\n                                }\n                                if (bodyMaxHeight) {\n                                    bodyHeight = Math.min(bodyMaxHeight, bodyHeight);\n                                }\n                                wrapperElem.style.height = \"\".concat(Math.max(bodyMinHeight, bodyHeight), \"px\");\n                            }\n                            else {\n                                wrapperElem.style.height = '';\n                            }\n                            wrapperElem.style.minHeight = \"\".concat(bodyMinHeight, \"px\");\n                        }\n                        // 如果是固定列\n                        if (fixedWrapperElem) {\n                            if (isNodeElement(wrapperElem)) {\n                                wrapperElem.style.top = \"\".concat(headerHeight, \"px\");\n                            }\n                            fixedWrapperElem.style.height = \"\".concat((customHeight > 0 ? customHeight - headerHeight - footerHeight : tableHeight) + headerHeight + footerHeight - scrollbarHeight * (showFooter ? 2 : 1), \"px\");\n                            fixedWrapperElem.style.width = \"\".concat(fixedColumn.reduce(function (previous, column) { return previous + column.renderWidth; }, isFixedLeft ? 0 : scrollbarWidth), \"px\");\n                        }\n                        var tWidth = tableWidth;\n                        var renderColumnList = tableColumn;\n                        // 如果是使用优化模式\n                        if (fixedType) {\n                            // 如果存在展开行使用全量渲染\n                            if (!reactData.expandColumn && (scrollYLoad || (allColumnOverflow ? isAllOverflow : allColumnOverflow))) {\n                                if (!mergeList.length && !spanMethod && !(keyboardConfig && keyboardOpts.isMerge)) {\n                                    renderColumnList = fixedColumn;\n                                }\n                                else {\n                                    renderColumnList = visibleColumn;\n                                }\n                            }\n                            else {\n                                renderColumnList = visibleColumn;\n                            }\n                        }\n                        tWidth = renderColumnList.reduce(function (previous, column) { return previous + column.renderWidth; }, 0);\n                        if (tableElem) {\n                            tableElem.style.width = tWidth ? \"\".concat(tWidth, \"px\") : '';\n                            // 兼容性处理\n                            tableElem.style.paddingRight = scrollbarWidth && fixedType && (browse['-moz'] || browse.safari) ? \"\".concat(scrollbarWidth, \"px\") : '';\n                        }\n                        if (emptyBlockElem) {\n                            emptyBlockElem.style.width = tWidth ? \"\".concat(tWidth, \"px\") : '';\n                        }\n                    }\n                    else if (layout === 'footer') {\n                        var tWidth = tableWidth;\n                        var renderColumnList = tableColumn;\n                        // 如果是使用优化模式\n                        if (fixedType) {\n                            // 如果存在展开行使用全量渲染\n                            if (!reactData.expandColumn && (scrollXLoad || allColumnFooterOverflow)) {\n                                if (!mergeFooterList.length || !footerSpanMethod) {\n                                    renderColumnList = fixedColumn;\n                                }\n                                else {\n                                    renderColumnList = visibleColumn;\n                                }\n                            }\n                            else {\n                                renderColumnList = visibleColumn;\n                            }\n                        }\n                        tWidth = renderColumnList.reduce(function (previous, column) { return previous + column.renderWidth; }, 0);\n                        if (isNodeElement(wrapperElem)) {\n                            // 如果是固定列\n                            if (fixedWrapperElem) {\n                                wrapperElem.style.top = \"\".concat(customHeight > 0 ? customHeight - footerHeight : tableHeight + headerHeight, \"px\");\n                            }\n                            wrapperElem.style.marginTop = \"\".concat(-Math.max(1, scrollbarHeight), \"px\");\n                        }\n                        if (tableElem) {\n                            tableElem.style.width = tWidth ? \"\".concat(tWidth + scrollbarWidth, \"px\") : '';\n                        }\n                    }\n                    var colgroupRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-colgroup\")];\n                    var colgroupElem = colgroupRef ? colgroupRef.value : null;\n                    if (colgroupElem) {\n                        XEUtils.arrayEach(colgroupElem.children, function (colElem) {\n                            var colid = colElem.getAttribute('name');\n                            if (colid === 'col_gutter') {\n                                colElem.style.width = \"\".concat(scrollbarWidth, \"px\");\n                            }\n                            if (fullColumnIdData[colid]) {\n                                var column_2 = fullColumnIdData[colid].column;\n                                var showHeaderOverflow = column_2.showHeaderOverflow, showFooterOverflow = column_2.showFooterOverflow, showOverflow = column_2.showOverflow;\n                                var cellOverflow = void 0;\n                                colElem.style.width = \"\".concat(column_2.renderWidth, \"px\");\n                                if (layout === 'header') {\n                                    cellOverflow = XEUtils.isUndefined(showHeaderOverflow) || XEUtils.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;\n                                }\n                                else if (layout === 'footer') {\n                                    cellOverflow = XEUtils.isUndefined(showFooterOverflow) || XEUtils.isNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;\n                                }\n                                else {\n                                    cellOverflow = XEUtils.isUndefined(showOverflow) || XEUtils.isNull(showOverflow) ? allColumnOverflow : showOverflow;\n                                }\n                                var showEllipsis = cellOverflow === 'ellipsis';\n                                var showTitle = cellOverflow === 'title';\n                                var showTooltip = cellOverflow === true || cellOverflow === 'tooltip';\n                                var hasEllipsis_1 = showTitle || showTooltip || showEllipsis;\n                                var listRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-list\")];\n                                var listElem = listRef ? listRef.value : null;\n                                // 纵向虚拟滚动不支持动态行高\n                                if (scrollYLoad && !hasEllipsis_1) {\n                                    hasEllipsis_1 = true;\n                                }\n                                if (listElem) {\n                                    XEUtils.arrayEach(listElem.querySelectorAll(\".\".concat(column_2.id)), function (elem) {\n                                        var colspan = parseInt(elem.getAttribute('colspan') || 1);\n                                        var cellElem = elem.querySelector('.vxe-cell');\n                                        var colWidth = column_2.renderWidth;\n                                        if (cellElem) {\n                                            if (colspan > 1) {\n                                                var columnIndex = tableMethods.getColumnIndex(column_2);\n                                                for (var index_1 = 1; index_1 < colspan; index_1++) {\n                                                    var nextColumn = tableMethods.getColumns(columnIndex + index_1);\n                                                    if (nextColumn) {\n                                                        colWidth += nextColumn.renderWidth;\n                                                    }\n                                                }\n                                            }\n                                            cellElem.style.width = hasEllipsis_1 ? \"\".concat(colWidth - (cellOffsetWidth * colspan), \"px\") : '';\n                                        }\n                                    });\n                                }\n                            }\n                        });\n                    }\n                });\n            });\n            if (currentRow) {\n                tableMethods.setCurrentRow(currentRow);\n            }\n            if (mouseConfig && mouseOpts.selected && editStore.selected.row && editStore.selected.column) {\n                $xetable.addCellSelectedClass();\n            }\n            return nextTick();\n        };\n        var checkValidate = function (type) {\n            if ($xetable.triggerValidate) {\n                return $xetable.triggerValidate(type);\n            }\n            return nextTick();\n        };\n        /**\n         * 当单元格发生改变时\n         * 如果存在规则，则校验\n         */\n        var handleChangeCell = function (evnt, params) {\n            checkValidate('blur')\n                .catch(function (e) { return e; })\n                .then(function () {\n                $xetable.handleActived(params, evnt)\n                    .then(function () { return checkValidate('change'); })\n                    .catch(function (e) { return e; });\n            });\n        };\n        var handleDefaultSort = function () {\n            var sortConfig = props.sortConfig;\n            if (sortConfig) {\n                var sortOpts = computeSortOpts.value;\n                var defaultSort = sortOpts.defaultSort;\n                if (defaultSort) {\n                    if (!XEUtils.isArray(defaultSort)) {\n                        defaultSort = [defaultSort];\n                    }\n                    if (defaultSort.length) {\n                        (sortConfig.multiple ? defaultSort : defaultSort.slice(0, 1)).forEach(function (item, index) {\n                            var field = item.field, order = item.order;\n                            if (field && order) {\n                                var column = tableMethods.getColumnByField(field);\n                                if (column && column.sortable) {\n                                    column.order = order;\n                                    column.sortTime = Date.now() + index;\n                                }\n                            }\n                        });\n                        if (!sortOpts.remote) {\n                            tablePrivateMethods.handleTableData(true).then(updateStyle);\n                        }\n                    }\n                }\n            }\n        };\n        /**\n         * 处理默认勾选\n         */\n        var handleDefaultSelectionChecked = function () {\n            var checkboxConfig = props.checkboxConfig;\n            if (checkboxConfig) {\n                var fullDataRowIdData_1 = internalData.fullDataRowIdData;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var checkAll = checkboxOpts.checkAll, checkRowKeys = checkboxOpts.checkRowKeys;\n                if (checkAll) {\n                    handleCheckedAllCheckboxRow(true, true);\n                }\n                else if (checkRowKeys) {\n                    var defSelection_1 = [];\n                    checkRowKeys.forEach(function (rowid) {\n                        if (fullDataRowIdData_1[rowid]) {\n                            defSelection_1.push(fullDataRowIdData_1[rowid].row);\n                        }\n                    });\n                    handleCheckedCheckboxRow(defSelection_1, true, true);\n                }\n            }\n        };\n        /**\n         * 处理单选框默认勾选\n         */\n        var handleDefaultRadioChecked = function () {\n            var _a;\n            var radioConfig = props.radioConfig;\n            if (radioConfig) {\n                var fullDataRowIdData = internalData.fullDataRowIdData;\n                var radioOpts = computeRadioOpts.value;\n                var rowid = radioOpts.checkRowKey, reserve = radioOpts.reserve;\n                if (rowid) {\n                    if (fullDataRowIdData[rowid]) {\n                        handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);\n                    }\n                    if (reserve) {\n                        var rowkey = getRowkey($xetable);\n                        internalData.radioReserveRow = (_a = {}, _a[rowkey] = rowid, _a);\n                    }\n                }\n            }\n        };\n        /**\n         * 处理默认展开行\n         */\n        var handleDefaultRowExpand = function () {\n            var expandConfig = props.expandConfig;\n            if (expandConfig) {\n                var fullDataRowIdData_2 = internalData.fullDataRowIdData;\n                var expandOpts = computeExpandOpts.value;\n                var expandAll = expandOpts.expandAll, expandRowKeys = expandOpts.expandRowKeys;\n                if (expandAll) {\n                    tableMethods.setAllRowExpand(true);\n                }\n                else if (expandRowKeys) {\n                    var defExpandeds_1 = [];\n                    expandRowKeys.forEach(function (rowid) {\n                        if (fullDataRowIdData_2[rowid]) {\n                            defExpandeds_1.push(fullDataRowIdData_2[rowid].row);\n                        }\n                    });\n                    tableMethods.setRowExpand(defExpandeds_1, true);\n                }\n            }\n        };\n        var handleRadioReserveRow = function (row) {\n            var radioOpts = computeRadioOpts.value;\n            if (radioOpts.reserve) {\n                internalData.radioReserveRow = row;\n            }\n        };\n        var handleCheckboxReserveRow = function (row, checked) {\n            var checkboxReserveRowMap = internalData.checkboxReserveRowMap;\n            var checkboxOpts = computeCheckboxOpts.value;\n            if (checkboxOpts.reserve) {\n                var rowid = getRowid($xetable, row);\n                if (checked) {\n                    checkboxReserveRowMap[rowid] = row;\n                }\n                else if (checkboxReserveRowMap[rowid]) {\n                    delete checkboxReserveRowMap[rowid];\n                }\n            }\n        };\n        var handleCheckedRadioRow = function (row, isForce) {\n            var radioOpts = computeRadioOpts.value;\n            var checkMethod = radioOpts.checkMethod;\n            if (row && (isForce || (!checkMethod || checkMethod({ row: row })))) {\n                reactData.selectRadioRow = row;\n                handleRadioReserveRow(row);\n            }\n            return nextTick();\n        };\n        var handleCheckedCheckboxRow = function (rows, value, isForce) {\n            if (rows && !XEUtils.isArray(rows)) {\n                rows = [rows];\n            }\n            rows.forEach(function (row) { return tablePrivateMethods.handleSelectRow({ row: row }, !!value, isForce); });\n            return nextTick();\n        };\n        var handleCheckedAllCheckboxRow = function (value, isForce) {\n            var treeConfig = props.treeConfig;\n            var selectCheckboxMaps = reactData.selectCheckboxMaps;\n            var afterFullData = internalData.afterFullData, afterFullRowMaps = internalData.afterFullRowMaps, checkboxReserveRowMap = internalData.checkboxReserveRowMap;\n            var treeOpts = computeTreeOpts.value;\n            var childrenField = treeOpts.children || treeOpts.childrenField;\n            var checkboxOpts = computeCheckboxOpts.value;\n            var checkField = checkboxOpts.checkField, reserve = checkboxOpts.reserve, checkStrictly = checkboxOpts.checkStrictly, checkMethod = checkboxOpts.checkMethod;\n            var indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;\n            var selectRowMaps = {};\n            // 疑惑！\n            if (!treeConfig) {\n                XEUtils.each(selectCheckboxMaps, function (row, rowid) {\n                    if (!afterFullRowMaps[rowid]) {\n                        selectRowMaps[rowid] = row;\n                    }\n                });\n            }\n            // 疑惑！\n            if (checkStrictly) {\n                reactData.isAllSelected = value;\n            }\n            else {\n                /**\n                 * 绑定属性方式（高性能，有污染）\n                 * 必须在行数据存在对应的属性，否则将不响应\n                 */\n                if (checkField) {\n                    var checkValFn = function (row) {\n                        if (isForce || (!checkMethod || checkMethod({ row: row }))) {\n                            if (value) {\n                                selectRowMaps[getRowid($xetable, row)] = row;\n                            }\n                            XEUtils.set(row, checkField, value);\n                        }\n                        if (treeConfig && indeterminateField) {\n                            XEUtils.set(row, indeterminateField, false);\n                        }\n                    };\n                    // 如果存在选中方法\n                    // 如果方法成立，则更新值，否则忽略该数据\n                    if (treeConfig) {\n                        XEUtils.eachTree(afterFullData, checkValFn, { children: childrenField });\n                    }\n                    else {\n                        afterFullData.forEach(checkValFn);\n                    }\n                }\n                else {\n                    /**\n                     * 默认方式（低性能，无污染）\n                     * 无需任何属性，直接绑定\n                     */\n                    if (treeConfig) {\n                        if (value) {\n                            /**\n                             * 如果是树勾选\n                             * 如果方法成立，则添加到临时集合中\n                             */\n                            XEUtils.eachTree(afterFullData, function (row) {\n                                if (isForce || (!checkMethod || checkMethod({ row: row }))) {\n                                    selectRowMaps[getRowid($xetable, row)] = row;\n                                }\n                            }, { children: childrenField });\n                        }\n                        else {\n                            /**\n                             * 如果是树取消\n                             * 如果方法成立，则不添加到临时集合中\n                             */\n                            if (!isForce && checkMethod) {\n                                XEUtils.eachTree(afterFullData, function (row) {\n                                    var rowid = getRowid($xetable, row);\n                                    if (checkMethod({ row: row }) ? 0 : selectCheckboxMaps[rowid]) {\n                                        selectRowMaps[rowid] = row;\n                                    }\n                                }, { children: childrenField });\n                            }\n                        }\n                    }\n                    else {\n                        if (value) {\n                            /**\n                             * 如果是行勾选\n                             * 如果存在选中方法且成立或者本身已勾选，则添加到临时集合中\n                             * 如果不存在选中方法，则添加所有数据到临时集合中\n                             */\n                            if (!isForce && checkMethod) {\n                                afterFullData.forEach(function (row) {\n                                    var rowid = getRowid($xetable, row);\n                                    if (selectCheckboxMaps[rowid] || checkMethod({ row: row })) {\n                                        selectRowMaps[rowid] = row;\n                                    }\n                                });\n                            }\n                            else {\n                                afterFullData.forEach(function (row) {\n                                    selectRowMaps[getRowid($xetable, row)] = row;\n                                });\n                            }\n                        }\n                        else {\n                            /**\n                             * 如果是行取消\n                             * 如果方法成立，则不添加到临时集合中；如果方法不成立则判断当前是否已勾选，如果已被勾选则添加到新集合中\n                             * 如果不存在选中方法，无需处理，临时集合默认为空\n                             */\n                            if (!isForce && checkMethod) {\n                                afterFullData.forEach(function (row) {\n                                    var rowid = getRowid($xetable, row);\n                                    if (checkMethod({ row: row }) ? 0 : selectCheckboxMaps[rowid]) {\n                                        selectRowMaps[rowid] = row;\n                                    }\n                                });\n                            }\n                        }\n                    }\n                }\n                if (reserve) {\n                    if (value) {\n                        XEUtils.each(selectRowMaps, function (row, rowid) {\n                            checkboxReserveRowMap[rowid] = row;\n                        });\n                    }\n                    else {\n                        afterFullData.forEach(function (row) { return handleCheckboxReserveRow(row, false); });\n                    }\n                }\n                reactData.selectCheckboxMaps = checkField ? {} : selectRowMaps;\n            }\n            reactData.treeIndeterminateMaps = {};\n            internalData.treeIndeterminateRowMaps = {};\n            tablePrivateMethods.checkSelectionStatus();\n            return nextTick();\n        };\n        // 还原展开、选中等相关状态\n        var handleReserveStatus = function () {\n            var treeConfig = props.treeConfig;\n            var expandColumn = reactData.expandColumn, currentRow = reactData.currentRow, selectCheckboxMaps = reactData.selectCheckboxMaps, selectRadioRow = reactData.selectRadioRow, rowExpandedMaps = reactData.rowExpandedMaps, treeExpandedMaps = reactData.treeExpandedMaps;\n            var fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData, radioReserveRow = internalData.radioReserveRow;\n            var expandOpts = computeExpandOpts.value;\n            var treeOpts = computeTreeOpts.value;\n            var radioOpts = computeRadioOpts.value;\n            var checkboxOpts = computeCheckboxOpts.value;\n            // 单选框\n            if (selectRadioRow && !fullAllDataRowIdData[getRowid($xetable, selectRadioRow)]) {\n                reactData.selectRadioRow = null; // 刷新单选行状态\n            }\n            // 还原保留选中状态\n            if (radioOpts.reserve && radioReserveRow) {\n                var rowid = getRowid($xetable, radioReserveRow);\n                if (fullDataRowIdData[rowid]) {\n                    handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);\n                }\n            }\n            // 复选框\n            reactData.selectCheckboxMaps = getRecoverRowMaps(selectCheckboxMaps); // 刷新多选行状态\n            // 还原保留选中状态\n            if (checkboxOpts.reserve) {\n                handleCheckedCheckboxRow(handleReserveRow(internalData.checkboxReserveRowMap), true, true);\n            }\n            if (currentRow && !fullAllDataRowIdData[getRowid($xetable, currentRow)]) {\n                reactData.currentRow = null; // 刷新当前行状态\n            }\n            // 行展开\n            reactData.rowExpandedMaps = expandColumn ? getRecoverRowMaps(rowExpandedMaps) : {}; // 刷新行展开状态\n            // 还原保留状态\n            if (expandColumn && expandOpts.reserve) {\n                tableMethods.setRowExpand(handleReserveRow(internalData.rowExpandedReserveRowMap), true);\n            }\n            // 树展开\n            reactData.treeExpandedMaps = treeConfig ? getRecoverRowMaps(treeExpandedMaps) : {}; // 刷新树展开状态\n            if (treeConfig && treeOpts.reserve) {\n                tableMethods.setTreeExpand(handleReserveRow(internalData.treeExpandedReserveRowMap), true);\n            }\n        };\n        /**\n         * 处理默认展开树节点\n         */\n        var handleDefaultTreeExpand = function () {\n            var treeConfig = props.treeConfig;\n            if (treeConfig) {\n                var tableFullData_1 = internalData.tableFullData;\n                var treeOpts = computeTreeOpts.value;\n                var expandAll = treeOpts.expandAll, expandRowKeys = treeOpts.expandRowKeys;\n                var childrenField_1 = treeOpts.children || treeOpts.childrenField;\n                if (expandAll) {\n                    tableMethods.setAllTreeExpand(true);\n                }\n                else if (expandRowKeys) {\n                    var defExpandeds_2 = [];\n                    var rowkey_1 = getRowkey($xetable);\n                    expandRowKeys.forEach(function (rowid) {\n                        var matchObj = XEUtils.findTree(tableFullData_1, function (item) { return rowid === XEUtils.get(item, rowkey_1); }, { children: childrenField_1 });\n                        if (matchObj) {\n                            defExpandeds_2.push(matchObj.item);\n                        }\n                    });\n                    tableMethods.setTreeExpand(defExpandeds_2, true);\n                }\n            }\n        };\n        var handleAsyncTreeExpandChilds = function (row) {\n            var treeOpts = computeTreeOpts.value;\n            var checkboxOpts = computeCheckboxOpts.value;\n            var transform = treeOpts.transform, loadMethod = treeOpts.loadMethod;\n            var checkStrictly = checkboxOpts.checkStrictly;\n            return new Promise(function (resolve) {\n                if (loadMethod) {\n                    var treeExpandLazyLoadedMaps_1 = reactData.treeExpandLazyLoadedMaps;\n                    var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                    var rowid_1 = getRowid($xetable, row);\n                    var rest_1 = fullAllDataRowIdData[rowid_1];\n                    treeExpandLazyLoadedMaps_1[rowid_1] = row;\n                    loadMethod({ $table: $xetable, row: row }).then(function (childRecords) {\n                        rest_1.treeLoaded = true;\n                        if (treeExpandLazyLoadedMaps_1[rowid_1]) {\n                            delete treeExpandLazyLoadedMaps_1[rowid_1];\n                        }\n                        if (!XEUtils.isArray(childRecords)) {\n                            childRecords = [];\n                        }\n                        if (childRecords) {\n                            return tableMethods.loadTreeChildren(row, childRecords).then(function (childRows) {\n                                var treeExpandedMaps = reactData.treeExpandedMaps;\n                                if (childRows.length && !treeExpandedMaps[rowid_1]) {\n                                    treeExpandedMaps[rowid_1] = row;\n                                }\n                                // 如果当前节点已选中，则展开后子节点也被选中\n                                if (!checkStrictly && tableMethods.isCheckedByCheckboxRow(row)) {\n                                    handleCheckedCheckboxRow(childRows, true);\n                                }\n                                return nextTick().then(function () {\n                                    if (transform) {\n                                        return tablePrivateMethods.handleTableData();\n                                    }\n                                });\n                            });\n                        }\n                    }).catch(function () {\n                        var treeExpandLazyLoadedMaps = reactData.treeExpandLazyLoadedMaps;\n                        rest_1.treeLoaded = false;\n                        if (treeExpandLazyLoadedMaps[rowid_1]) {\n                            delete treeExpandLazyLoadedMaps[rowid_1];\n                        }\n                    }).finally(function () {\n                        nextTick().then(function () { return tableMethods.recalculate(); }).then(function () { return resolve(); });\n                    });\n                }\n                else {\n                    resolve();\n                }\n            });\n        };\n        var handleTreeExpandReserve = function (row, expanded) {\n            var treeExpandedReserveRowMap = internalData.treeExpandedReserveRowMap;\n            var treeOpts = computeTreeOpts.value;\n            if (treeOpts.reserve) {\n                var rowid = getRowid($xetable, row);\n                if (expanded) {\n                    treeExpandedReserveRowMap[rowid] = row;\n                }\n                else if (treeExpandedReserveRowMap[rowid]) {\n                    delete treeExpandedReserveRowMap[rowid];\n                }\n            }\n        };\n        var handleAsyncRowExpand = function (row) {\n            return new Promise(function (resolve) {\n                var expandOpts = computeExpandOpts.value;\n                var loadMethod = expandOpts.loadMethod;\n                if (loadMethod) {\n                    var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                    var rowExpandLazyLoadedMaps = reactData.rowExpandLazyLoadedMaps;\n                    var rowid_2 = getRowid($xetable, row);\n                    var rest_2 = fullAllDataRowIdData[rowid_2];\n                    rowExpandLazyLoadedMaps[rowid_2] = row;\n                    loadMethod({ $table: $xetable, row: row, rowIndex: tableMethods.getRowIndex(row), $rowIndex: tableMethods.getVMRowIndex(row) }).then(function () {\n                        var rowExpandedMaps = reactData.rowExpandedMaps;\n                        rest_2.expandLoaded = true;\n                        rowExpandedMaps[rowid_2] = row;\n                    }).catch(function () {\n                        rest_2.expandLoaded = false;\n                    }).finally(function () {\n                        var rowExpandLazyLoadedMaps = reactData.rowExpandLazyLoadedMaps;\n                        if (rowExpandLazyLoadedMaps[rowid_2]) {\n                            delete rowExpandLazyLoadedMaps[rowid_2];\n                        }\n                        nextTick().then(function () { return tableMethods.recalculate(); }).then(function () { return resolve(); });\n                    });\n                }\n                else {\n                    resolve();\n                }\n            });\n        };\n        var handleRowExpandReserve = function (row, expanded) {\n            var rowExpandedReserveRowMap = internalData.rowExpandedReserveRowMap;\n            var expandOpts = computeExpandOpts.value;\n            if (expandOpts.reserve) {\n                var rowid = getRowid($xetable, row);\n                if (expanded) {\n                    rowExpandedReserveRowMap[rowid] = row;\n                }\n                else if (rowExpandedReserveRowMap[rowid]) {\n                    delete rowExpandedReserveRowMap[rowid];\n                }\n            }\n        };\n        var handleDefaultMergeCells = function () {\n            var mergeCells = props.mergeCells;\n            if (mergeCells) {\n                tableMethods.setMergeCells(mergeCells);\n            }\n        };\n        var handleDefaultMergeFooterItems = function () {\n            var mergeFooterItems = props.mergeFooterItems;\n            if (mergeFooterItems) {\n                tableMethods.setMergeFooterItems(mergeFooterItems);\n            }\n        };\n        // 计算可视渲染相关数据\n        var computeScrollLoad = function () {\n            return nextTick().then(function () {\n                var scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad;\n                var scrollXStore = internalData.scrollXStore, scrollYStore = internalData.scrollYStore;\n                var sYOpts = computeSYOpts.value;\n                var sXOpts = computeSXOpts.value;\n                // 计算 X 逻辑\n                if (scrollXLoad) {\n                    var visibleXSize = computeVirtualX().visibleSize;\n                    var offsetXSize = sXOpts.oSize ? XEUtils.toNumber(sXOpts.oSize) : (browse.edge ? 5 : 0);\n                    scrollXStore.offsetSize = offsetXSize;\n                    scrollXStore.visibleSize = visibleXSize;\n                    scrollXStore.endIndex = Math.max(scrollXStore.startIndex + scrollXStore.visibleSize + offsetXSize, scrollXStore.endIndex);\n                    tablePrivateMethods.updateScrollXData();\n                }\n                else {\n                    tablePrivateMethods.updateScrollXSpace();\n                }\n                // 计算 Y 逻辑\n                var _a = computeVirtualY(), rowHeight = _a.rowHeight, visibleYSize = _a.visibleSize;\n                scrollYStore.rowHeight = rowHeight;\n                if (scrollYLoad) {\n                    var offsetYSize = sYOpts.oSize ? XEUtils.toNumber(sYOpts.oSize) : (browse.edge ? 10 : 0);\n                    scrollYStore.offsetSize = offsetYSize;\n                    scrollYStore.visibleSize = visibleYSize;\n                    scrollYStore.endIndex = Math.max(scrollYStore.startIndex + visibleYSize + offsetYSize, scrollYStore.endIndex);\n                    tablePrivateMethods.updateScrollYData();\n                }\n                else {\n                    tablePrivateMethods.updateScrollYSpace();\n                }\n                reactData.rowHeight = rowHeight;\n                nextTick(updateStyle);\n            });\n        };\n        /**\n         * 加载表格数据\n         * @param {Array} datas 数据\n         */\n        var loadTableData = function (datas) {\n            var keepSource = props.keepSource, treeConfig = props.treeConfig;\n            var editStore = reactData.editStore, oldScrollYLoad = reactData.scrollYLoad;\n            var scrollYStore = internalData.scrollYStore, scrollXStore = internalData.scrollXStore, lastScrollLeft = internalData.lastScrollLeft, lastScrollTop = internalData.lastScrollTop;\n            var treeOpts = computeTreeOpts.value;\n            var transform = treeOpts.transform;\n            var childrenField = treeOpts.children || treeOpts.childrenField;\n            var treeData = [];\n            var fullData = reactive(datas ? datas.slice(0) : []); // 转为响应式\n            if (treeConfig) {\n                if (transform) {\n                    // 树结构自动转换\n                    if (process.env.NODE_ENV === 'development') {\n                        if (!treeOpts.rowField) {\n                            errLog('vxe.error.reqProp', ['tree-config.rowField']);\n                        }\n                        if (!treeOpts.parentField) {\n                            errLog('vxe.error.reqProp', ['tree-config.parentField']);\n                        }\n                        if (!childrenField) {\n                            errLog('vxe.error.reqProp', ['tree-config.childrenField']);\n                        }\n                        if (!treeOpts.mapChildrenField) {\n                            errLog('vxe.error.reqProp', ['tree-config.mapChildrenField']);\n                        }\n                        if (childrenField === treeOpts.mapChildrenField) {\n                            errLog('vxe.error.errConflicts', ['tree-config.childrenField', 'tree-config.mapChildrenField']);\n                        }\n                        // fullData.forEach(row => {\n                        //   if (row[treeOpts.children] && row[treeOpts.children].length) {\n                        //     warnLog('vxe.error.errConflicts', ['tree-config.transform', `row.${treeOpts.children}`])\n                        //   }\n                        // })\n                    }\n                    treeData = XEUtils.toArrayTree(fullData, {\n                        key: treeOpts.rowField,\n                        parentKey: treeOpts.parentField,\n                        children: childrenField,\n                        mapChildren: treeOpts.mapChildrenField\n                    });\n                    fullData = treeData.slice(0);\n                }\n                else {\n                    treeData = fullData.slice(0);\n                }\n            }\n            scrollYStore.startIndex = 0;\n            scrollYStore.endIndex = 1;\n            scrollXStore.startIndex = 0;\n            scrollXStore.endIndex = 1;\n            reactData.scrollVMLoading = false;\n            editStore.insertMaps = {};\n            editStore.removeMaps = {};\n            var sYLoad = updateScrollYStatus(fullData);\n            reactData.scrollYLoad = sYLoad;\n            // 全量数据\n            internalData.tableFullData = fullData;\n            internalData.tableFullTreeData = treeData;\n            // 缓存数据\n            tablePrivateMethods.cacheRowMap(true);\n            // 原始数据\n            internalData.tableSynchData = datas;\n            // 克隆原数据，用于显示编辑状态，与编辑值做对比\n            if (keepSource) {\n                tablePrivateMethods.cacheSourceMap(fullData);\n            }\n            if (process.env.NODE_ENV === 'development') {\n                if (sYLoad) {\n                    if (!(props.height || props.maxHeight)) {\n                        errLog('vxe.error.reqProp', ['table.height | table.max-height | table.scroll-y={enabled: false}']);\n                    }\n                    if (!props.showOverflow) {\n                        warnLog('vxe.error.reqProp', ['table.show-overflow']);\n                    }\n                    if (props.spanMethod) {\n                        warnLog('vxe.error.scrollErrProp', ['table.span-method']);\n                    }\n                }\n            }\n            if ($xetable.clearCellAreas && props.mouseConfig) {\n                $xetable.clearCellAreas();\n                $xetable.clearCopyCellArea();\n            }\n            tableMethods.clearMergeCells();\n            tableMethods.clearMergeFooterItems();\n            tablePrivateMethods.handleTableData(true);\n            tableMethods.updateFooter();\n            return nextTick().then(function () {\n                updateHeight();\n                updateStyle();\n            }).then(function () {\n                computeScrollLoad();\n            }).then(function () {\n                // 是否启用了虚拟滚动\n                if (sYLoad) {\n                    scrollYStore.endIndex = scrollYStore.visibleSize;\n                }\n                handleReserveStatus();\n                tablePrivateMethods.checkSelectionStatus();\n                return new Promise(function (resolve) {\n                    nextTick()\n                        .then(function () { return tableMethods.recalculate(); })\n                        .then(function () {\n                        var targetScrollLeft = lastScrollLeft;\n                        var targetScrollTop = lastScrollTop;\n                        var sXOpts = computeSXOpts.value;\n                        var sYOpts = computeSYOpts.value;\n                        // 是否在更新数据之后自动滚动重置滚动条\n                        if (sXOpts.scrollToLeftOnChange) {\n                            targetScrollLeft = 0;\n                        }\n                        if (sYOpts.scrollToTopOnChange) {\n                            targetScrollTop = 0;\n                        }\n                        // 是否变更虚拟滚动\n                        if (oldScrollYLoad === sYLoad) {\n                            restoreScrollLocation($xetable, targetScrollLeft, targetScrollTop).then(resolve);\n                        }\n                        else {\n                            setTimeout(function () { return restoreScrollLocation($xetable, targetScrollLeft, targetScrollTop).then(resolve); });\n                        }\n                    });\n                });\n            });\n        };\n        /**\n         * 处理数据加载默认行为\n         * 默认执行一次，除非被重置\n         */\n        var handleLoadDefaults = function () {\n            handleDefaultSelectionChecked();\n            handleDefaultRadioChecked();\n            handleDefaultRowExpand();\n            handleDefaultTreeExpand();\n            handleDefaultMergeCells();\n            handleDefaultMergeFooterItems();\n            nextTick(function () { return setTimeout(function () { return tableMethods.recalculate(); }); });\n        };\n        /**\n         * 处理初始化的默认行为\n         * 只会执行一次\n         */\n        var handleInitDefaults = function () {\n            handleDefaultSort();\n        };\n        var handleTableColumn = function () {\n            var scrollXLoad = reactData.scrollXLoad;\n            var visibleColumn = internalData.visibleColumn, scrollXStore = internalData.scrollXStore, fullColumnIdData = internalData.fullColumnIdData;\n            var tableColumn = scrollXLoad ? visibleColumn.slice(scrollXStore.startIndex, scrollXStore.endIndex) : visibleColumn.slice(0);\n            tableColumn.forEach(function (column, $index) {\n                var colid = column.id;\n                var rest = fullColumnIdData[colid];\n                if (rest) {\n                    rest.$index = $index;\n                }\n            });\n            reactData.tableColumn = tableColumn;\n        };\n        var loadScrollXData = function () {\n            var mergeList = reactData.mergeList, mergeFooterList = reactData.mergeFooterList;\n            var scrollXStore = internalData.scrollXStore;\n            var startIndex = scrollXStore.startIndex, endIndex = scrollXStore.endIndex, offsetSize = scrollXStore.offsetSize;\n            var _a = computeVirtualX(), toVisibleIndex = _a.toVisibleIndex, visibleSize = _a.visibleSize;\n            var offsetItem = {\n                startIndex: Math.max(0, toVisibleIndex - 1 - offsetSize),\n                endIndex: toVisibleIndex + visibleSize + offsetSize\n            };\n            calculateMergerOffserIndex(mergeList.concat(mergeFooterList), offsetItem, 'col');\n            var offsetStartIndex = offsetItem.startIndex, offsetEndIndex = offsetItem.endIndex;\n            if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {\n                if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {\n                    scrollXStore.startIndex = offsetStartIndex;\n                    scrollXStore.endIndex = offsetEndIndex;\n                    tablePrivateMethods.updateScrollXData();\n                }\n            }\n            tableMethods.closeTooltip();\n        };\n        // 获取所有的列，排除分组\n        var getColumnList = function (columns) {\n            var result = [];\n            columns.forEach(function (column) {\n                result.push.apply(result, (column.children && column.children.length ? getColumnList(column.children) : [column]));\n            });\n            return result;\n        };\n        var parseColumns = function () {\n            var leftList = [];\n            var centerList = [];\n            var rightList = [];\n            var isGroup = reactData.isGroup, columnStore = reactData.columnStore;\n            var sXOpts = computeSXOpts.value;\n            var collectColumn = internalData.collectColumn, tableFullColumn = internalData.tableFullColumn, scrollXStore = internalData.scrollXStore, fullColumnIdData = internalData.fullColumnIdData;\n            // 如果是分组表头，如果子列全部被隐藏，则根列也隐藏\n            if (isGroup) {\n                var leftGroupList_1 = [];\n                var centerGroupList_1 = [];\n                var rightGroupList_1 = [];\n                XEUtils.eachTree(collectColumn, function (column, index, items, path, parent) {\n                    var isColGroup = hasChildrenList(column);\n                    // 如果是分组，必须按组设置固定列，不允许给子列设置固定\n                    if (parent && parent.fixed) {\n                        column.fixed = parent.fixed;\n                    }\n                    if (parent && column.fixed !== parent.fixed) {\n                        errLog('vxe.error.groupFixed');\n                    }\n                    if (isColGroup) {\n                        column.visible = !!XEUtils.findTree(column.children, function (subColumn) { return hasChildrenList(subColumn) ? false : subColumn.visible; });\n                    }\n                    else if (column.visible) {\n                        if (column.fixed === 'left') {\n                            leftList.push(column);\n                        }\n                        else if (column.fixed === 'right') {\n                            rightList.push(column);\n                        }\n                        else {\n                            centerList.push(column);\n                        }\n                    }\n                });\n                collectColumn.forEach(function (column) {\n                    if (column.visible) {\n                        if (column.fixed === 'left') {\n                            leftGroupList_1.push(column);\n                        }\n                        else if (column.fixed === 'right') {\n                            rightGroupList_1.push(column);\n                        }\n                        else {\n                            centerGroupList_1.push(column);\n                        }\n                    }\n                });\n                reactData.tableGroupColumn = leftGroupList_1.concat(centerGroupList_1).concat(rightGroupList_1);\n            }\n            else {\n                // 重新分配列\n                tableFullColumn.forEach(function (column) {\n                    if (column.visible) {\n                        if (column.fixed === 'left') {\n                            leftList.push(column);\n                        }\n                        else if (column.fixed === 'right') {\n                            rightList.push(column);\n                        }\n                        else {\n                            centerList.push(column);\n                        }\n                    }\n                });\n            }\n            var visibleColumn = leftList.concat(centerList).concat(rightList);\n            // 如果gt为0，则总是启用\n            var scrollXLoad = !!sXOpts.enabled && sXOpts.gt > -1 && (sXOpts.gt === 0 || sXOpts.gt < tableFullColumn.length);\n            reactData.hasFixedColumn = leftList.length > 0 || rightList.length > 0;\n            Object.assign(columnStore, { leftList: leftList, centerList: centerList, rightList: rightList });\n            if (scrollXLoad) {\n                if (process.env.NODE_ENV === 'development') {\n                    // if (props.showHeader && !props.showHeaderOverflow) {\n                    //   warnLog('vxe.error.reqProp', ['show-header-overflow'])\n                    // }\n                    // if (props.showFooter && !props.showFooterOverflow) {\n                    //   warnLog('vxe.error.reqProp', ['show-footer-overflow'])\n                    // }\n                    if (props.spanMethod) {\n                        warnLog('vxe.error.scrollErrProp', ['span-method']);\n                    }\n                    if (props.footerSpanMethod) {\n                        warnLog('vxe.error.scrollErrProp', ['footer-span-method']);\n                    }\n                }\n                var visibleSize = computeVirtualX().visibleSize;\n                scrollXStore.startIndex = 0;\n                scrollXStore.endIndex = visibleSize;\n                scrollXStore.visibleSize = visibleSize;\n            }\n            // 如果列被显示/隐藏，则清除合并状态\n            // 如果列被设置为固定，则清除合并状态\n            if (visibleColumn.length !== internalData.visibleColumn.length || !internalData.visibleColumn.every(function (column, index) { return column === visibleColumn[index]; })) {\n                tableMethods.clearMergeCells();\n                tableMethods.clearMergeFooterItems();\n            }\n            reactData.scrollXLoad = scrollXLoad;\n            visibleColumn.forEach(function (column, index) {\n                var colid = column.id;\n                var rest = fullColumnIdData[colid];\n                if (rest) {\n                    rest._index = index;\n                }\n            });\n            internalData.visibleColumn = visibleColumn;\n            handleTableColumn();\n            return tableMethods.updateFooter().then(function () {\n                return tableMethods.recalculate();\n            }).then(function () {\n                tableMethods.updateCellAreas();\n                return tableMethods.recalculate();\n            });\n        };\n        var handleColumn = function (collectColumn) {\n            internalData.collectColumn = collectColumn;\n            var tableFullColumn = getColumnList(collectColumn);\n            internalData.tableFullColumn = tableFullColumn;\n            cacheColumnMap();\n            restoreCustomStorage();\n            parseColumns().then(function () {\n                if (reactData.scrollXLoad) {\n                    loadScrollXData();\n                }\n            });\n            tableMethods.clearMergeCells();\n            tableMethods.clearMergeFooterItems();\n            tablePrivateMethods.handleTableData(true);\n            if (process.env.NODE_ENV === 'development') {\n                if ((reactData.scrollXLoad || reactData.scrollYLoad) && reactData.expandColumn) {\n                    warnLog('vxe.error.scrollErrProp', ['column.type=expand']);\n                }\n            }\n            return nextTick().then(function () {\n                if ($xetoolbar) {\n                    $xetoolbar.syncUpdate({ collectColumn: collectColumn, $table: $xetable });\n                }\n                return tableMethods.recalculate();\n            });\n        };\n        var updateScrollYStatus = function (fullData) {\n            var treeConfig = props.treeConfig;\n            var sYOpts = computeSYOpts.value;\n            var treeOpts = computeTreeOpts.value;\n            var transform = treeOpts.transform;\n            var allList = fullData || internalData.tableFullData;\n            // 如果gt为0，则总是启用\n            var scrollYLoad = (transform || !treeConfig) && !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt < allList.length);\n            reactData.scrollYLoad = scrollYLoad;\n            return scrollYLoad;\n        };\n        /**\n         * 展开与收起树节点\n         * @param rows\n         * @param expanded\n         * @returns\n         */\n        var handleBaseTreeExpand = function (rows, expanded) {\n            var treeExpandedMaps = reactData.treeExpandedMaps, treeExpandLazyLoadedMaps = reactData.treeExpandLazyLoadedMaps, treeNodeColumn = reactData.treeNodeColumn;\n            var treeTempExpandedMaps = __assign({}, treeExpandedMaps);\n            var fullAllDataRowIdData = internalData.fullAllDataRowIdData, tableFullData = internalData.tableFullData;\n            var treeOpts = computeTreeOpts.value;\n            var reserve = treeOpts.reserve, lazy = treeOpts.lazy, accordion = treeOpts.accordion, toggleMethod = treeOpts.toggleMethod;\n            var childrenField = treeOpts.children || treeOpts.childrenField;\n            var hasChildField = treeOpts.hasChild || treeOpts.hasChildField;\n            var result = [];\n            var columnIndex = tableMethods.getColumnIndex(treeNodeColumn);\n            var $columnIndex = tableMethods.getVMColumnIndex(treeNodeColumn);\n            var validRows = toggleMethod ? rows.filter(function (row) { return toggleMethod({ $table: $xetable, expanded: expanded, column: treeNodeColumn, columnIndex: columnIndex, $columnIndex: $columnIndex, row: row }); }) : rows;\n            if (accordion) {\n                validRows = validRows.length ? [validRows[validRows.length - 1]] : [];\n                // 同一级只能展开一个\n                var matchObj = XEUtils.findTree(tableFullData, function (item) { return item === validRows[0]; }, { children: childrenField });\n                if (matchObj) {\n                    matchObj.items.forEach(function (item) {\n                        var rowid = getRowid($xetable, item);\n                        if (treeTempExpandedMaps[rowid]) {\n                            delete treeTempExpandedMaps[rowid];\n                        }\n                    });\n                }\n            }\n            if (expanded) {\n                validRows.forEach(function (row) {\n                    var rowid = getRowid($xetable, row);\n                    if (!treeTempExpandedMaps[rowid]) {\n                        var rest = fullAllDataRowIdData[rowid];\n                        var isLoad = lazy && row[hasChildField] && !rest.treeLoaded && !treeExpandLazyLoadedMaps[rowid];\n                        // 是否使用懒加载\n                        if (isLoad) {\n                            result.push(handleAsyncTreeExpandChilds(row));\n                        }\n                        else {\n                            if (row[childrenField] && row[childrenField].length) {\n                                treeTempExpandedMaps[rowid] = row;\n                            }\n                        }\n                    }\n                });\n            }\n            else {\n                validRows.forEach(function (item) {\n                    var rowid = getRowid($xetable, item);\n                    if (treeTempExpandedMaps[rowid]) {\n                        delete treeTempExpandedMaps[rowid];\n                    }\n                });\n            }\n            if (reserve) {\n                validRows.forEach(function (row) { return handleTreeExpandReserve(row, expanded); });\n            }\n            reactData.treeExpandedMaps = treeTempExpandedMaps;\n            return Promise.all(result).then(function () {\n                return tableMethods.recalculate();\n            });\n        };\n        /**\n         * 虚拟树的展开与收起\n         * @param rows\n         * @param expanded\n         * @returns\n         */\n        var handleVirtualTreeExpand = function (rows, expanded) {\n            return handleBaseTreeExpand(rows, expanded).then(function () {\n                handleVirtualTreeToList();\n                return tablePrivateMethods.handleTableData();\n            }).then(function () {\n                return tableMethods.recalculate();\n            });\n        };\n        /**\n         * 纵向 Y 可视渲染处理\n         */\n        var loadScrollYData = function (evnt) {\n            var mergeList = reactData.mergeList;\n            var scrollYStore = internalData.scrollYStore;\n            var startIndex = scrollYStore.startIndex, endIndex = scrollYStore.endIndex, visibleSize = scrollYStore.visibleSize, offsetSize = scrollYStore.offsetSize, rowHeight = scrollYStore.rowHeight;\n            var scrollBodyElem = (evnt.currentTarget || evnt.target);\n            var scrollTop = scrollBodyElem.scrollTop;\n            var toVisibleIndex = Math.floor(scrollTop / rowHeight);\n            var offsetItem = {\n                startIndex: Math.max(0, toVisibleIndex - 1 - offsetSize),\n                endIndex: toVisibleIndex + visibleSize + offsetSize\n            };\n            calculateMergerOffserIndex(mergeList, offsetItem, 'row');\n            var offsetStartIndex = offsetItem.startIndex, offsetEndIndex = offsetItem.endIndex;\n            if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {\n                if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {\n                    scrollYStore.startIndex = offsetStartIndex;\n                    scrollYStore.endIndex = offsetEndIndex;\n                    tablePrivateMethods.updateScrollYData();\n                }\n            }\n        };\n        var createGetRowCacheProp = function (prop) {\n            return function (row) {\n                var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                if (row) {\n                    var rowid = getRowid($xetable, row);\n                    var rest = fullAllDataRowIdData[rowid];\n                    if (rest) {\n                        return rest[prop];\n                    }\n                }\n                return -1;\n            };\n        };\n        var createGetColumnCacheProp = function (prop) {\n            return function (column) {\n                var fullColumnIdData = internalData.fullColumnIdData;\n                if (column) {\n                    var rest = fullColumnIdData[column.id];\n                    if (rest) {\n                        return rest[prop];\n                    }\n                }\n                return -1;\n            };\n        };\n        var debounceScrollY = XEUtils.debounce(function (evnt) {\n            loadScrollYData(evnt);\n        }, 20, { leading: false, trailing: true });\n        var keyCtxTimeout;\n        tableMethods = {\n            dispatchEvent: function (type, params, evnt) {\n                emit(type, Object.assign({ $table: $xetable, $grid: $xegrid, $event: evnt }, params));\n            },\n            /**\n             * 重置表格的一切数据状态\n             */\n            clearAll: function () {\n                return clearTableAllStatus($xetable);\n            },\n            /**\n             * 同步 data 数据（即将废弃）\n             * 如果用了该方法，那么组件将不再记录增删改的状态，只能自行实现对应逻辑\n             * 对于某些特殊的场景，比如深层树节点元素发生变动时可能会用到\n             */\n            syncData: function () {\n                warnLog('vxe.error.delFunc', ['syncData', 'getData']);\n                return nextTick().then(function () {\n                    reactData.tableData = [];\n                    emit('update:data', internalData.tableFullData);\n                    return nextTick();\n                });\n            },\n            /**\n             * 手动处理数据，用于手动排序与筛选\n             * 对于手动更改了排序、筛选...等条件后需要重新处理数据时可能会用到\n             */\n            updateData: function () {\n                var scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad;\n                return tablePrivateMethods.handleTableData(true).then(function () {\n                    tableMethods.updateFooter();\n                    if (scrollXLoad || scrollYLoad) {\n                        if (scrollXLoad) {\n                            tablePrivateMethods.updateScrollXSpace();\n                        }\n                        if (scrollYLoad) {\n                            tablePrivateMethods.updateScrollYSpace();\n                        }\n                        return tableMethods.refreshScroll();\n                    }\n                }).then(function () {\n                    tableMethods.updateCellAreas();\n                    return tableMethods.recalculate(true);\n                }).then(function () {\n                    // 存在滚动行为未结束情况\n                    setTimeout(function () { return $xetable.recalculate(); }, 50);\n                });\n            },\n            /**\n             * 重新加载数据，不会清空表格状态\n             * @param {Array} datas 数据\n             */\n            loadData: function (datas) {\n                var inited = internalData.inited, initStatus = internalData.initStatus;\n                return loadTableData(datas).then(function () {\n                    internalData.inited = true;\n                    internalData.initStatus = true;\n                    if (!initStatus) {\n                        handleLoadDefaults();\n                    }\n                    if (!inited) {\n                        handleInitDefaults();\n                    }\n                    return tableMethods.recalculate();\n                });\n            },\n            /**\n             * 重新加载数据，会清空表格状态\n             * @param {Array} datas 数据\n             */\n            reloadData: function (datas) {\n                var inited = internalData.inited;\n                return tableMethods.clearAll()\n                    .then(function () {\n                    internalData.inited = true;\n                    internalData.initStatus = true;\n                    return loadTableData(datas);\n                })\n                    .then(function () {\n                    handleLoadDefaults();\n                    if (!inited) {\n                        handleInitDefaults();\n                    }\n                    return tableMethods.recalculate();\n                });\n            },\n            /**\n             * 局部加载行数据并恢复到初始状态\n             * 对于行数据需要局部更改的场景中可能会用到\n             * @param {Row} row 行对象\n             * @param {Object} record 新数据\n             * @param {String} field 字段名\n             */\n            reloadRow: function (row, record, field) {\n                var keepSource = props.keepSource;\n                var tableData = reactData.tableData;\n                var tableSourceData = internalData.tableSourceData;\n                if (keepSource) {\n                    var rowIndex = tableMethods.getRowIndex(row);\n                    var oRow = tableSourceData[rowIndex];\n                    if (oRow && row) {\n                        if (field) {\n                            var newValue = XEUtils.get(record || row, field);\n                            XEUtils.set(row, field, newValue);\n                            XEUtils.set(oRow, field, newValue);\n                        }\n                        else {\n                            var newRecord = XEUtils.clone(__assign({}, record), true);\n                            XEUtils.destructuring(oRow, Object.assign(row, newRecord));\n                        }\n                    }\n                    reactData.tableData = tableData.slice(0);\n                }\n                else {\n                    if (process.env.NODE_ENV === 'development') {\n                        warnLog('vxe.error.reqProp', ['keep-source']);\n                    }\n                }\n                return nextTick();\n            },\n            /**\n             * 用于树结构，给行数据加载子节点\n             */\n            loadTreeChildren: function (row, childRecords) {\n                var keepSource = props.keepSource;\n                var tableSourceData = internalData.tableSourceData, fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData, sourceDataRowIdData = internalData.sourceDataRowIdData;\n                var treeOpts = computeTreeOpts.value;\n                var transform = treeOpts.transform, mapChildrenField = treeOpts.mapChildrenField;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var parentRest = fullAllDataRowIdData[getRowid($xetable, row)];\n                var parentLevel = parentRest ? parentRest.level : 0;\n                return tableMethods.createData(childRecords).then(function (rows) {\n                    if (keepSource) {\n                        var rowid_3 = getRowid($xetable, row);\n                        var matchObj = XEUtils.findTree(tableSourceData, function (item) { return rowid_3 === getRowid($xetable, item); }, { children: childrenField });\n                        if (matchObj) {\n                            matchObj.item[childrenField] = XEUtils.clone(rows, true);\n                        }\n                        rows.forEach(function (childRow) {\n                            var rowid = getRowid($xetable, childRow);\n                            sourceDataRowIdData[rowid] = XEUtils.clone(childRow, true);\n                        });\n                    }\n                    XEUtils.eachTree(rows, function (childRow, index, items, path, parent, nodes) {\n                        var rowid = getRowid($xetable, childRow);\n                        var parentRow = parent || parentRest.row;\n                        var rest = { row: childRow, rowid: rowid, seq: -1, index: index, _index: -1, $index: -1, items: items, parent: parentRow, level: parentLevel + nodes.length };\n                        fullDataRowIdData[rowid] = rest;\n                        fullAllDataRowIdData[rowid] = rest;\n                    }, { children: childrenField });\n                    row[childrenField] = rows;\n                    if (transform) {\n                        row[mapChildrenField] = rows;\n                    }\n                    updateAfterDataIndex();\n                    return rows;\n                });\n            },\n            /**\n             * 加载列配置\n             * 对于表格列需要重载、局部递增场景下可能会用到\n             * @param {ColumnInfo} columns 列配置\n             */\n            loadColumn: function (columns) {\n                var collectColumn = XEUtils.mapTree(columns, function (column) { return reactive(Cell.createColumn($xetable, column)); });\n                return handleColumn(collectColumn);\n            },\n            /**\n             * 加载列配置并恢复到初始状态\n             * 对于表格列需要重载、局部递增场景下可能会用到\n             * @param {ColumnInfo} columns 列配置\n             */\n            reloadColumn: function (columns) {\n                return tableMethods.clearAll().then(function () {\n                    return tableMethods.loadColumn(columns);\n                });\n            },\n            /**\n             * 根据 tr 元素获取对应的 row 信息\n             * @param {Element} tr 元素\n             */\n            getRowNode: function (tr) {\n                if (tr) {\n                    var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                    var rowid = tr.getAttribute('rowid');\n                    if (rowid) {\n                        var rest = fullAllDataRowIdData[rowid];\n                        if (rest) {\n                            return { rowid: rest.rowid, item: rest.row, index: rest.index, items: rest.items, parent: rest.parent };\n                        }\n                    }\n                }\n                return null;\n            },\n            /**\n             * 根据 th/td 元素获取对应的 column 信息\n             * @param {Element} cell 元素\n             */\n            getColumnNode: function (cell) {\n                if (cell) {\n                    var fullColumnIdData = internalData.fullColumnIdData;\n                    var colid = cell.getAttribute('colid');\n                    if (colid) {\n                        var rest = fullColumnIdData[colid];\n                        if (rest) {\n                            return { colid: rest.colid, item: rest.column, index: rest.index, items: rest.items, parent: rest.parent };\n                        }\n                    }\n                }\n                return null;\n            },\n            /**\n             * 根据 row 获取序号\n             * @param {Row} row 行对象\n             */\n            getRowSeq: createGetRowCacheProp('seq'),\n            /**\n             * 根据 row 获取相对于 data 中的索引\n             * @param {Row} row 行对象\n             */\n            getRowIndex: createGetRowCacheProp('index'),\n            /**\n             * 根据 row 获取相对于当前数据中的索引\n             * @param {Row} row 行对象\n             */\n            getVTRowIndex: createGetRowCacheProp('_index'),\n            /**\n             * 根据 row 获取渲染中的虚拟索引\n             * @param {Row} row 行对象\n             */\n            getVMRowIndex: createGetRowCacheProp('$index'),\n            /**\n             * 根据 column 获取相对于 columns 中的索引\n             * @param {ColumnInfo} column 列配置\n             */\n            getColumnIndex: createGetColumnCacheProp('index'),\n            /**\n             * 根据 column 获取相对于当前表格列中的索引\n             * @param {ColumnInfo} column 列配置\n             */\n            getVTColumnIndex: createGetColumnCacheProp('_index'),\n            /**\n             * 根据 column 获取渲染中的虚拟索引\n             * @param {ColumnInfo} column 列配置\n             */\n            getVMColumnIndex: createGetColumnCacheProp('$index'),\n            /**\n             * 创建 data 对象\n             * 对于某些特殊场景可能会用到，会自动对数据的字段名进行检测，如果不存在就自动定义\n             * @param {Array} records 新数据\n             */\n            createData: function (records) {\n                return nextTick().then(function () {\n                    return reactive(tablePrivateMethods.defineField(records));\n                });\n            },\n            /**\n             * 创建 Row|Rows 对象\n             * 对于某些特殊场景需要对数据进行手动插入时可能会用到\n             * @param {Array/Object} records 新数据\n             */\n            createRow: function (records) {\n                var isArr = XEUtils.isArray(records);\n                if (!isArr) {\n                    records = [records || {}];\n                }\n                return tableMethods.createData(records).then(function (rows) { return isArr ? rows : rows[0]; });\n            },\n            /**\n             * 还原数据\n             * 如果不传任何参数，则还原整个表格\n             * 如果传 row 则还原一行\n             * 如果传 rows 则还原多行\n             * 如果还额外传了 field 则还原指定的单元格数据\n             */\n            revertData: function (rows, field) {\n                var keepSource = props.keepSource;\n                var tableSourceData = internalData.tableSourceData, sourceDataRowIdData = internalData.sourceDataRowIdData;\n                if (!keepSource) {\n                    if (process.env.NODE_ENV === 'development') {\n                        warnLog('vxe.error.reqProp', ['keep-source']);\n                    }\n                    return nextTick();\n                }\n                var targetRows = rows;\n                if (rows) {\n                    if (!XEUtils.isArray(rows)) {\n                        targetRows = [rows];\n                    }\n                }\n                else {\n                    targetRows = XEUtils.toArray($xetable.getUpdateRecords());\n                }\n                if (targetRows.length) {\n                    targetRows.forEach(function (row) {\n                        if (!tableMethods.isInsertByRow(row)) {\n                            var rowid = getRowid($xetable, row);\n                            var oRow = sourceDataRowIdData[rowid];\n                            if (oRow && row) {\n                                if (field) {\n                                    XEUtils.set(row, field, XEUtils.clone(XEUtils.get(oRow, field), true));\n                                }\n                                else {\n                                    XEUtils.destructuring(row, XEUtils.clone(oRow, true));\n                                }\n                            }\n                        }\n                    });\n                }\n                if (rows) {\n                    return nextTick();\n                }\n                return tableMethods.reloadData(tableSourceData);\n            },\n            /**\n             * 清空单元格内容\n             * 如果不创参数，则清空整个表格内容\n             * 如果传 row 则清空一行内容\n             * 如果传 rows 则清空多行内容\n             * 如果还额外传了 field 则清空指定单元格内容\n             * @param {Array/Row} rows 行数据\n             * @param {String} field 字段名\n             */\n            clearData: function (rows, field) {\n                var tableFullData = internalData.tableFullData, visibleColumn = internalData.visibleColumn;\n                if (!arguments.length) {\n                    rows = tableFullData;\n                }\n                else if (rows && !XEUtils.isArray(rows)) {\n                    rows = [rows];\n                }\n                if (field) {\n                    rows.forEach(function (row) { return XEUtils.set(row, field, null); });\n                }\n                else {\n                    rows.forEach(function (row) {\n                        visibleColumn.forEach(function (column) {\n                            if (column.field) {\n                                setCellValue(row, column, null);\n                            }\n                        });\n                    });\n                }\n                return nextTick();\n            },\n            /**\n             * 检查是否为临时行数据\n             * @param {Row} row 行对象\n             */\n            isInsertByRow: function (row) {\n                var editStore = reactData.editStore;\n                var rowid = getRowid($xetable, row);\n                return editStore.insertMaps[rowid];\n            },\n            /**\n             * 删除所有新增的临时数据\n             * @returns\n             */\n            removeInsertRow: function () {\n                var editStore = reactData.editStore;\n                editStore.insertMaps = {};\n                return $xetable.remove($xetable.getInsertRecords());\n            },\n            /**\n             * 检查行或列数据是否发生改变\n             * @param {Row} row 行对象\n             * @param {String} field 字段名\n             */\n            isUpdateByRow: function (row, field) {\n                var keepSource = props.keepSource;\n                var tableFullColumn = internalData.tableFullColumn, fullDataRowIdData = internalData.fullDataRowIdData, sourceDataRowIdData = internalData.sourceDataRowIdData;\n                if (keepSource) {\n                    var rowid = getRowid($xetable, row);\n                    // 新增的数据不需要检测\n                    if (!fullDataRowIdData[rowid]) {\n                        return false;\n                    }\n                    var oRow = sourceDataRowIdData[rowid];\n                    if (oRow) {\n                        if (arguments.length > 1) {\n                            return !eqCellValue(oRow, row, field);\n                        }\n                        for (var index = 0, len = tableFullColumn.length; index < len; index++) {\n                            var property = tableFullColumn[index].field;\n                            if (property && !eqCellValue(oRow, row, property)) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n                return false;\n            },\n            /**\n             * 获取表格的可视列，也可以指定索引获取列\n             * @param {Number} columnIndex 索引\n             */\n            getColumns: function (columnIndex) {\n                var columns = internalData.visibleColumn;\n                return XEUtils.isUndefined(columnIndex) ? columns.slice(0) : columns[columnIndex];\n            },\n            /**\n             * 根据列的唯一主键获取列\n             * @param {String} colid 列主键\n             */\n            getColumnById: function (colid) {\n                var fullColumnIdData = internalData.fullColumnIdData;\n                return fullColumnIdData[colid] ? fullColumnIdData[colid].column : null;\n            },\n            /**\n             * 根据列的字段名获取列\n             * @param {String} field 字段名\n             */\n            getColumnByField: function (field) {\n                var fullColumnFieldData = internalData.fullColumnFieldData;\n                return fullColumnFieldData[field] ? fullColumnFieldData[field].column : null;\n            },\n            /**\n             * 获取当前表格的列\n             * 收集到的全量列、全量表头列、处理条件之后的全量表头列、当前渲染中的表头列\n             */\n            getTableColumn: function () {\n                return {\n                    collectColumn: internalData.collectColumn.slice(0),\n                    fullColumn: internalData.tableFullColumn.slice(0),\n                    visibleColumn: internalData.visibleColumn.slice(0),\n                    tableColumn: reactData.tableColumn.slice(0)\n                };\n            },\n            /**\n             * 获取数据，和 data 的行为一致，也可以指定索引获取数据\n             */\n            getData: function (rowIndex) {\n                var tableSynchData = props.data || internalData.tableSynchData;\n                return XEUtils.isUndefined(rowIndex) ? tableSynchData.slice(0) : tableSynchData[rowIndex];\n            },\n            /**\n             * 用于多选行，获取已选中的数据\n             */\n            getCheckboxRecords: function (isFull) {\n                var treeConfig = props.treeConfig;\n                var tableFullData = internalData.tableFullData, afterFullData = internalData.afterFullData, afterTreeFullData = internalData.afterTreeFullData, tableFullTreeData = internalData.tableFullTreeData, fullDataRowIdData = internalData.fullDataRowIdData, afterFullRowMaps = internalData.afterFullRowMaps;\n                var treeOpts = computeTreeOpts.value;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var transform = treeOpts.transform, mapChildrenField = treeOpts.mapChildrenField;\n                var checkField = checkboxOpts.checkField;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var rowList = [];\n                var currTableData = isFull ? (transform ? tableFullTreeData : tableFullData) : (transform ? afterTreeFullData : afterFullData);\n                if (checkField) {\n                    if (treeConfig) {\n                        rowList = XEUtils.filterTree(currTableData, function (row) { return XEUtils.get(row, checkField); }, { children: transform ? mapChildrenField : childrenField });\n                    }\n                    else {\n                        rowList = currTableData.filter(function (row) { return XEUtils.get(row, checkField); });\n                    }\n                }\n                else {\n                    var selectCheckboxMaps = reactData.selectCheckboxMaps;\n                    XEUtils.each(selectCheckboxMaps, function (row, rowid) {\n                        if (isFull ? fullDataRowIdData[rowid] : afterFullRowMaps[rowid]) {\n                            rowList.push(row);\n                        }\n                    });\n                }\n                return rowList;\n            },\n            /**\n             * 只对 tree-config 有效，获取行的父级\n             */\n            getParentRow: function (rowOrRowid) {\n                var treeConfig = props.treeConfig;\n                var fullDataRowIdData = internalData.fullDataRowIdData;\n                if (rowOrRowid && treeConfig) {\n                    var rowid = void 0;\n                    if (XEUtils.isString(rowOrRowid)) {\n                        rowid = rowOrRowid;\n                    }\n                    else {\n                        rowid = getRowid($xetable, rowOrRowid);\n                    }\n                    if (rowid) {\n                        var rest = fullDataRowIdData[rowid];\n                        return rest ? rest.parent : null;\n                    }\n                }\n                return null;\n            },\n            /**\n             * 根据行的唯一主键获取行\n             * @param {String/Number} rowid 行主键\n             */\n            getRowById: function (cellValue) {\n                var fullDataRowIdData = internalData.fullDataRowIdData;\n                var rowid = XEUtils.eqNull(cellValue) ? '' : encodeURIComponent(cellValue);\n                return fullDataRowIdData[rowid] ? fullDataRowIdData[rowid].row : null;\n            },\n            /**\n             * 根据行获取行的唯一主键\n             * @param {Row} row 行对象\n             */\n            getRowid: function (row) {\n                return getRowid($xetable, row);\n            },\n            /**\n             * 获取处理后的表格数据\n             * 如果存在筛选条件，继续处理\n             * 如果存在排序，继续处理\n             */\n            getTableData: function () {\n                var tableData = reactData.tableData, footerTableData = reactData.footerTableData;\n                var tableFullData = internalData.tableFullData, afterFullData = internalData.afterFullData, tableFullTreeData = internalData.tableFullTreeData;\n                return {\n                    fullData: props.treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0),\n                    visibleData: afterFullData.slice(0),\n                    tableData: tableData.slice(0),\n                    footerData: footerTableData.slice(0)\n                };\n            },\n            /**\n             * 设置为固定列\n             */\n            setColumnFixed: function (fieldOrColumn, fixed) {\n                var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                var targetColumn = getRootColumn($xetable, column);\n                var isMaxFixedColumn = computeIsMaxFixedColumn.value;\n                var columnOpts = computeColumnOpts.value;\n                var maxFixedSize = columnOpts.maxFixedSize;\n                if (targetColumn && targetColumn.fixed !== fixed) {\n                    // 是否超过最大固定列数量\n                    if (!targetColumn.fixed && isMaxFixedColumn) {\n                        if (VXETable.modal) {\n                            VXETable.modal.message({\n                                status: 'error',\n                                content: GlobalConfig.i18n('vxe.table.maxFixedCol', [maxFixedSize])\n                            });\n                        }\n                        return nextTick();\n                    }\n                    XEUtils.eachTree([targetColumn], function (column) {\n                        column.fixed = fixed;\n                    });\n                    tablePrivateMethods.saveCustomFixed();\n                    return tableMethods.refreshColumn();\n                }\n                return nextTick();\n            },\n            /**\n             * 取消指定固定列\n             */\n            clearColumnFixed: function (fieldOrColumn) {\n                var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                var targetColumn = getRootColumn($xetable, column);\n                if (targetColumn && targetColumn.fixed) {\n                    XEUtils.eachTree([targetColumn], function (column) {\n                        column.fixed = null;\n                    });\n                    tablePrivateMethods.saveCustomFixed();\n                    return tableMethods.refreshColumn();\n                }\n                return nextTick();\n            },\n            /**\n             * 隐藏指定列\n             */\n            hideColumn: function (fieldOrColumn) {\n                var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                if (column && column.visible) {\n                    column.visible = false;\n                    return tablePrivateMethods.handleCustom();\n                }\n                return nextTick();\n            },\n            /**\n             * 显示指定列\n             */\n            showColumn: function (fieldOrColumn) {\n                var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                if (column && !column.visible) {\n                    column.visible = true;\n                    return tablePrivateMethods.handleCustom();\n                }\n                return nextTick();\n            },\n            setColumnWidth: function (fieldOrColumn, width) {\n                var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                if (column) {\n                    var colWidth = XEUtils.toInteger(width);\n                    var rdWidth = colWidth;\n                    if (isScale(width)) {\n                        var tableBody = refTableBody.value;\n                        var bodyElem = tableBody ? tableBody.$el : null;\n                        var bodyWidth = bodyElem ? bodyElem.clientWidth - 1 : 0;\n                        rdWidth = Math.floor(colWidth * bodyWidth);\n                    }\n                    column.renderWidth = rdWidth;\n                }\n                return nextTick();\n            },\n            getColumnWidth: function (fieldOrColumn) {\n                var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                if (column) {\n                    return column.renderWidth;\n                }\n                return 0;\n            },\n            /**\n             * 手动重置列的显示隐藏、列宽拖动的状态、固定列、排序列；\n             * 如果为 true 则重置所有状态\n             * 如果已关联工具栏，则会同步更新\n             */\n            resetColumn: function (options) {\n                var collectColumn = internalData.collectColumn;\n                var customOpts = computeCustomOpts.value;\n                var checkMethod = customOpts.checkMethod;\n                var opts = Object.assign({\n                    visible: true,\n                    resizable: options === true,\n                    fixed: options === true\n                }, options);\n                XEUtils.eachTree(collectColumn, function (column) {\n                    if (opts.resizable) {\n                        column.resizeWidth = 0;\n                    }\n                    if (opts.fixed) {\n                        column.fixed = column.defaultFixed;\n                    }\n                    if (!checkMethod || checkMethod({ column: column })) {\n                        column.visible = column.defaultVisible;\n                    }\n                });\n                if (opts.resizable) {\n                    tablePrivateMethods.saveCustomResizable(true);\n                }\n                if (opts.fixed) {\n                    tablePrivateMethods.saveCustomFixed();\n                }\n                return tablePrivateMethods.handleCustom();\n            },\n            /**\n             * 刷新列信息\n             * 将固定的列左边、右边分别靠边\n             */\n            refreshColumn: function () {\n                return parseColumns().then(function () {\n                    return tableMethods.refreshScroll();\n                }).then(function () {\n                    return tableMethods.recalculate();\n                });\n            },\n            /**\n             * 刷新滚动操作，手动同步滚动相关位置（对于某些特殊的操作，比如滚动条错位、固定列不同步）\n             */\n            refreshScroll: function () {\n                var lastScrollLeft = internalData.lastScrollLeft, lastScrollTop = internalData.lastScrollTop;\n                var tableBody = refTableBody.value;\n                var tableFooter = refTableFooter.value;\n                var leftBody = refTableLeftBody.value;\n                var rightBody = refTableRightBody.value;\n                var tableBodyElem = tableBody ? tableBody.$el : null;\n                var leftBodyElem = leftBody ? leftBody.$el : null;\n                var rightBodyElem = rightBody ? rightBody.$el : null;\n                var tableFooterElem = tableFooter ? tableFooter.$el : null;\n                return new Promise(function (resolve) {\n                    // 还原滚动条位置\n                    if (lastScrollLeft || lastScrollTop) {\n                        return restoreScrollLocation($xetable, lastScrollLeft, lastScrollTop).then().then(function () {\n                            // 存在滚动行为未结束情况\n                            setTimeout(resolve, 30);\n                        });\n                    }\n                    // 重置\n                    setScrollTop(tableBodyElem, lastScrollTop);\n                    setScrollTop(leftBodyElem, lastScrollTop);\n                    setScrollTop(rightBodyElem, lastScrollTop);\n                    setScrollLeft(tableFooterElem, lastScrollLeft);\n                    // 存在滚动行为未结束情况\n                    setTimeout(resolve, 30);\n                });\n            },\n            /**\n             * 计算单元格列宽，动态分配可用剩余空间\n             * 支持 width=? width=?px width=?% min-width=? min-width=?px min-width=?%\n             */\n            recalculate: function (refull) {\n                autoCellWidth();\n                if (refull === true) {\n                    // 初始化时需要在列计算之后再执行优化运算，达到最优显示效果\n                    return computeScrollLoad().then(function () {\n                        autoCellWidth();\n                        return computeScrollLoad();\n                    });\n                }\n                return computeScrollLoad();\n            },\n            openTooltip: function (target, content) {\n                var $commTip = refCommTooltip.value;\n                if ($commTip) {\n                    return $commTip.open(target, content);\n                }\n                return nextTick();\n            },\n            /**\n             * 关闭 tooltip\n             */\n            closeTooltip: function () {\n                var tooltipStore = reactData.tooltipStore;\n                var $tooltip = refTooltip.value;\n                var $commTip = refCommTooltip.value;\n                if (tooltipStore.visible) {\n                    Object.assign(tooltipStore, {\n                        row: null,\n                        column: null,\n                        content: null,\n                        visible: false\n                    });\n                    if ($tooltip) {\n                        $tooltip.close();\n                    }\n                }\n                if ($commTip) {\n                    $commTip.close();\n                }\n                return nextTick();\n            },\n            /**\n             * 判断列头复选框是否被选中\n             */\n            isAllCheckboxChecked: function () {\n                return reactData.isAllSelected;\n            },\n            /**\n             * 判断列头复选框是否被半选\n             */\n            isAllCheckboxIndeterminate: function () {\n                return !reactData.isAllSelected && reactData.isIndeterminate;\n            },\n            /**\n             * 获取复选框半选状态的行数据\n             */\n            getCheckboxIndeterminateRecords: function (isFull) {\n                var treeConfig = props.treeConfig;\n                var fullDataRowIdData = internalData.fullDataRowIdData;\n                var treeIndeterminateMaps = reactData.treeIndeterminateMaps;\n                if (treeConfig) {\n                    var fullRest_1 = [];\n                    var defRest_1 = [];\n                    XEUtils.each(treeIndeterminateMaps, function (item, rowid) {\n                        if (item) {\n                            fullRest_1.push(item);\n                            if (fullDataRowIdData[rowid]) {\n                                defRest_1.push(item);\n                            }\n                        }\n                    });\n                    if (isFull) {\n                        return fullRest_1;\n                    }\n                    return defRest_1;\n                }\n                return [];\n            },\n            /**\n             * 用于多选行，设置行为选中状态，第二个参数为选中与否\n             * @param {Array/Row} rows 行数据\n             * @param {Boolean} value 是否选中\n             */\n            setCheckboxRow: function (rows, value) {\n                return handleCheckedCheckboxRow(rows, value, true);\n            },\n            isCheckedByCheckboxRow: function (row) {\n                var selectCheckboxMaps = reactData.selectCheckboxMaps;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var checkField = checkboxOpts.checkField;\n                if (checkField) {\n                    return XEUtils.get(row, checkField);\n                }\n                return !!selectCheckboxMaps[getRowid($xetable, row)];\n            },\n            isIndeterminateByCheckboxRow: function (row) {\n                var treeIndeterminateMaps = reactData.treeIndeterminateMaps;\n                return !!treeIndeterminateMaps[getRowid($xetable, row)] && !tableMethods.isCheckedByCheckboxRow(row);\n            },\n            /**\n             * 多选，切换某一行的选中状态\n             */\n            toggleCheckboxRow: function (row) {\n                var selectCheckboxMaps = reactData.selectCheckboxMaps;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var checkField = checkboxOpts.checkField;\n                var value = checkField ? !XEUtils.get(row, checkField) : !selectCheckboxMaps[getRowid($xetable, row)];\n                tablePrivateMethods.handleSelectRow({ row: row }, value, true);\n                return nextTick();\n            },\n            /**\n             * 用于多选行，设置所有行的选中状态\n             * @param {Boolean} value 是否选中\n             */\n            setAllCheckboxRow: function (value) {\n                return handleCheckedAllCheckboxRow(value, true);\n            },\n            /**\n             * 获取单选框保留选中的行\n             */\n            getRadioReserveRecord: function (isFull) {\n                var treeConfig = props.treeConfig;\n                var fullDataRowIdData = internalData.fullDataRowIdData, radioReserveRow = internalData.radioReserveRow, afterFullData = internalData.afterFullData;\n                var radioOpts = computeRadioOpts.value;\n                var treeOpts = computeTreeOpts.value;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                if (radioOpts.reserve && radioReserveRow) {\n                    var rowid_4 = getRowid($xetable, radioReserveRow);\n                    if (isFull) {\n                        if (!fullDataRowIdData[rowid_4]) {\n                            return radioReserveRow;\n                        }\n                    }\n                    else {\n                        var rowkey_2 = getRowkey($xetable);\n                        if (treeConfig) {\n                            var matchObj = XEUtils.findTree(afterFullData, function (row) { return rowid_4 === XEUtils.get(row, rowkey_2); }, { children: childrenField });\n                            if (matchObj) {\n                                return radioReserveRow;\n                            }\n                        }\n                        else {\n                            if (!afterFullData.some(function (row) { return rowid_4 === XEUtils.get(row, rowkey_2); })) {\n                                return radioReserveRow;\n                            }\n                        }\n                    }\n                }\n                return null;\n            },\n            clearRadioReserve: function () {\n                internalData.radioReserveRow = null;\n                return nextTick();\n            },\n            /**\n             * 获取复选框保留选中的行\n             */\n            getCheckboxReserveRecords: function (isFull) {\n                var treeConfig = props.treeConfig;\n                var afterFullData = internalData.afterFullData, fullDataRowIdData = internalData.fullDataRowIdData, checkboxReserveRowMap = internalData.checkboxReserveRowMap;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var treeOpts = computeTreeOpts.value;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var reserveSelection = [];\n                if (checkboxOpts.reserve) {\n                    var afterFullIdMaps_1 = {};\n                    if (treeConfig) {\n                        XEUtils.eachTree(afterFullData, function (row) {\n                            afterFullIdMaps_1[getRowid($xetable, row)] = 1;\n                        }, { children: childrenField });\n                    }\n                    else {\n                        afterFullData.forEach(function (row) {\n                            afterFullIdMaps_1[getRowid($xetable, row)] = 1;\n                        });\n                    }\n                    XEUtils.each(checkboxReserveRowMap, function (oldRow, oldRowid) {\n                        if (oldRow) {\n                            if (isFull) {\n                                if (!fullDataRowIdData[oldRowid]) {\n                                    reserveSelection.push(oldRow);\n                                }\n                            }\n                            else {\n                                if (!afterFullIdMaps_1[oldRowid]) {\n                                    reserveSelection.push(oldRow);\n                                }\n                            }\n                        }\n                    });\n                }\n                return reserveSelection;\n            },\n            clearCheckboxReserve: function () {\n                internalData.checkboxReserveRowMap = {};\n                return nextTick();\n            },\n            /**\n             * 多选，切换所有行的选中状态\n             */\n            toggleAllCheckboxRow: function () {\n                tablePrivateMethods.triggerCheckAllEvent(null, !reactData.isAllSelected);\n                return nextTick();\n            },\n            /**\n             * 用于多选行，手动清空用户的选择\n             * 清空行为不管是否被禁用还是保留记录，都将彻底清空选中状态\n             */\n            clearCheckboxRow: function () {\n                var treeConfig = props.treeConfig;\n                var tableFullData = internalData.tableFullData;\n                var treeOpts = computeTreeOpts.value;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var checkField = checkboxOpts.checkField, reserve = checkboxOpts.reserve;\n                var indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;\n                if (checkField) {\n                    var handleClearChecked = function (item) {\n                        if (treeConfig && indeterminateField) {\n                            XEUtils.set(item, indeterminateField, false);\n                        }\n                        XEUtils.set(item, checkField, false);\n                    };\n                    if (treeConfig) {\n                        XEUtils.eachTree(tableFullData, handleClearChecked, { children: childrenField });\n                    }\n                    else {\n                        tableFullData.forEach(handleClearChecked);\n                    }\n                }\n                if (reserve) {\n                    tableFullData.forEach(function (row) { return handleCheckboxReserveRow(row, false); });\n                }\n                reactData.isAllSelected = false;\n                reactData.isIndeterminate = false;\n                reactData.selectCheckboxMaps = {};\n                reactData.treeIndeterminateMaps = {};\n                return nextTick();\n            },\n            /**\n             * 用于当前行，设置某一行为高亮状态\n             * @param {Row} row 行对象\n             */\n            setCurrentRow: function (row) {\n                var rowOpts = computeRowOpts.value;\n                var el = refElem.value;\n                tableMethods.clearCurrentRow();\n                // tableMethods.clearCurrentColumn()\n                reactData.currentRow = row;\n                if (rowOpts.isCurrent || props.highlightCurrentRow) {\n                    if (el) {\n                        XEUtils.arrayEach(el.querySelectorAll(\"[rowid=\\\"\".concat(getRowid($xetable, row), \"\\\"]\")), function (elem) { return addClass(elem, 'row--current'); });\n                    }\n                }\n                return nextTick();\n            },\n            isCheckedByRadioRow: function (row) {\n                return $xetable.eqRow(reactData.selectRadioRow, row);\n            },\n            /**\n             * 用于单选行，设置某一行为选中状态\n             * @param {Row} row 行对象\n             */\n            setRadioRow: function (row) {\n                return handleCheckedRadioRow(row, true);\n            },\n            /**\n             * 用于当前行，手动清空当前高亮的状态\n             */\n            clearCurrentRow: function () {\n                var el = refElem.value;\n                reactData.currentRow = null;\n                internalData.hoverRow = null;\n                if (el) {\n                    XEUtils.arrayEach(el.querySelectorAll('.row--current'), function (elem) { return removeClass(elem, 'row--current'); });\n                }\n                return nextTick();\n            },\n            /**\n             * 用于单选行，手动清空用户的选择\n             */\n            clearRadioRow: function () {\n                reactData.selectRadioRow = null;\n                return nextTick();\n            },\n            /**\n             * 用于当前行，获取当前行的数据\n             */\n            getCurrentRecord: function () {\n                var rowOpts = computeRowOpts.value;\n                return rowOpts.isCurrent || props.highlightCurrentRow ? reactData.currentRow : null;\n            },\n            /**\n             * 用于单选行，获取当已选中的数据\n             */\n            getRadioRecord: function (isFull) {\n                var fullDataRowIdData = internalData.fullDataRowIdData, afterFullRowMaps = internalData.afterFullRowMaps;\n                var selectRadioRow = reactData.selectRadioRow;\n                if (selectRadioRow) {\n                    var rowid = getRowid($xetable, selectRadioRow);\n                    if (isFull) {\n                        if (!fullDataRowIdData[rowid]) {\n                            return selectRadioRow;\n                        }\n                    }\n                    else {\n                        if (afterFullRowMaps[rowid]) {\n                            return selectRadioRow;\n                        }\n                    }\n                }\n                return null;\n            },\n            getCurrentColumn: function () {\n                var columnOpts = computeColumnOpts.value;\n                return columnOpts.isCurrent || props.highlightCurrentColumn ? reactData.currentColumn : null;\n            },\n            /**\n             * 用于当前列，设置某列行为高亮状态\n             */\n            setCurrentColumn: function (fieldOrColumn) {\n                var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                if (column) {\n                    // tableMethods.clearCurrentRow()\n                    tableMethods.clearCurrentColumn();\n                    reactData.currentColumn = column;\n                }\n                return nextTick();\n            },\n            /**\n             * 用于当前列，手动清空当前高亮的状态\n             */\n            clearCurrentColumn: function () {\n                reactData.currentColumn = null;\n                return nextTick();\n            },\n            setPendingRow: function (rows, status) {\n                var pendingMaps = __assign({}, reactData.pendingRowMaps);\n                var pendingList = __spreadArray([], reactData.pendingRowList, true);\n                if (rows && !XEUtils.isArray(rows)) {\n                    rows = [rows];\n                }\n                if (status) {\n                    rows.forEach(function (row) {\n                        var rowid = getRowid($xetable, row);\n                        if (rowid && !pendingMaps[rowid]) {\n                            pendingList.push(row);\n                            pendingMaps[rowid] = row;\n                        }\n                    });\n                }\n                else {\n                    rows.forEach(function (row) {\n                        var rowid = getRowid($xetable, row);\n                        if (rowid && pendingMaps[rowid]) {\n                            var pendingIndex = $xetable.findRowIndexOf(pendingList, row);\n                            if (pendingIndex > -1) {\n                                pendingList.splice(pendingIndex, 1);\n                            }\n                            delete pendingMaps[rowid];\n                        }\n                    });\n                }\n                reactData.pendingRowMaps = pendingMaps;\n                reactData.pendingRowList = pendingList;\n                return nextTick();\n            },\n            togglePendingRow: function (rows) {\n                var pendingMaps = __assign({}, reactData.pendingRowMaps);\n                var pendingList = __spreadArray([], reactData.pendingRowList, true);\n                if (rows && !XEUtils.isArray(rows)) {\n                    rows = [rows];\n                }\n                rows.forEach(function (row) {\n                    var rowid = getRowid($xetable, row);\n                    if (rowid) {\n                        if (pendingMaps[rowid]) {\n                            var pendingIndex = $xetable.findRowIndexOf(pendingList, row);\n                            if (pendingIndex > -1) {\n                                pendingList.splice(pendingIndex, 1);\n                            }\n                            delete pendingMaps[rowid];\n                        }\n                        else {\n                            pendingList.push(row);\n                            pendingMaps[rowid] = row;\n                        }\n                    }\n                });\n                reactData.pendingRowMaps = pendingMaps;\n                reactData.pendingRowList = pendingList;\n                return nextTick();\n            },\n            hasPendingByRow: function (row) {\n                var pendingRowMaps = reactData.pendingRowMaps;\n                var rowid = getRowid($xetable, row);\n                return !!pendingRowMaps[rowid];\n            },\n            getPendingRecords: function () {\n                var pendingRowList = reactData.pendingRowList;\n                return pendingRowList.slice(0);\n            },\n            clearPendingRow: function () {\n                reactData.pendingRowMaps = {};\n                reactData.pendingRowList = [];\n                return nextTick();\n            },\n            sort: function (sortConfs, sortOrder) {\n                var sortOpts = computeSortOpts.value;\n                var multiple = sortOpts.multiple, remote = sortOpts.remote, orders = sortOpts.orders;\n                if (sortConfs) {\n                    if (XEUtils.isString(sortConfs)) {\n                        sortConfs = [\n                            { field: sortConfs, order: sortOrder }\n                        ];\n                    }\n                }\n                if (!XEUtils.isArray(sortConfs)) {\n                    sortConfs = [sortConfs];\n                }\n                if (sortConfs.length) {\n                    if (!multiple) {\n                        clearAllSort();\n                    }\n                    (multiple ? sortConfs : [sortConfs[0]]).forEach(function (confs, index) {\n                        var field = confs.field, order = confs.order;\n                        var column = field;\n                        if (XEUtils.isString(field)) {\n                            column = tableMethods.getColumnByField(field);\n                        }\n                        if (column && column.sortable) {\n                            if (orders.indexOf(order) === -1) {\n                                order = getNextSortOrder(column);\n                            }\n                            if (column.order !== order) {\n                                column.order = order;\n                            }\n                            column.sortTime = Date.now() + index;\n                        }\n                    });\n                    // 如果是服务端排序，则跳过本地排序处理\n                    if (!remote) {\n                        tablePrivateMethods.handleTableData(true);\n                    }\n                    return nextTick().then(function () {\n                        tableMethods.updateCellAreas();\n                        return updateStyle();\n                    });\n                }\n                return nextTick();\n            },\n            /**\n             * 清空指定列的排序条件\n             * 如果为空则清空所有列的排序条件\n             * @param {String} fieldOrColumn 列或字段名\n             */\n            clearSort: function (fieldOrColumn) {\n                var sortOpts = computeSortOpts.value;\n                if (fieldOrColumn) {\n                    var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                    if (column) {\n                        column.order = null;\n                    }\n                }\n                else {\n                    clearAllSort();\n                }\n                if (!sortOpts.remote) {\n                    tablePrivateMethods.handleTableData(true);\n                }\n                return nextTick().then(updateStyle);\n            },\n            isSort: function (fieldOrColumn) {\n                if (fieldOrColumn) {\n                    var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                    return column ? column.sortable && !!column.order : false;\n                }\n                return tableMethods.getSortColumns().length > 0;\n            },\n            getSortColumns: function () {\n                var sortOpts = computeSortOpts.value;\n                var multiple = sortOpts.multiple, chronological = sortOpts.chronological;\n                var sortList = [];\n                var tableFullColumn = internalData.tableFullColumn;\n                tableFullColumn.forEach(function (column) {\n                    var field = column.field, order = column.order;\n                    if (column.sortable && order) {\n                        sortList.push({ column: column, field: field, property: field, order: order, sortTime: column.sortTime });\n                    }\n                });\n                if (multiple && chronological && sortList.length > 1) {\n                    return XEUtils.orderBy(sortList, 'sortTime');\n                }\n                return sortList;\n            },\n            /**\n             * 关闭筛选\n             * @param {Event} evnt 事件\n             */\n            closeFilter: function () {\n                var filterStore = reactData.filterStore;\n                var column = filterStore.column, visible = filterStore.visible;\n                Object.assign(filterStore, {\n                    isAllSelected: false,\n                    isIndeterminate: false,\n                    options: [],\n                    visible: false\n                });\n                if (visible) {\n                    $xetable.dispatchEvent('filter-visible', { column: column, property: column.field, field: column.field, filterList: $xetable.getCheckedFilters(), visible: false }, null);\n                }\n                return nextTick();\n            },\n            /**\n             * 判断指定列是否为筛选状态，如果为空则判断所有列\n             * @param {String} fieldOrColumn 字段名\n             */\n            isActiveFilterByColumn: function (fieldOrColumn) {\n                var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                if (column) {\n                    return column.filters && column.filters.some(function (option) { return option.checked; });\n                }\n                return $xetable.getCheckedFilters().length > 0;\n            },\n            isFilter: function (fieldOrColumn) {\n                return tableMethods.isActiveFilterByColumn(fieldOrColumn);\n            },\n            /**\n             * 判断展开行是否懒加载完成\n             * @param {Row} row 行对象\n             */\n            isRowExpandLoaded: function (row) {\n                var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                var rest = fullAllDataRowIdData[getRowid($xetable, row)];\n                return rest && !!rest.expandLoaded;\n            },\n            clearRowExpandLoaded: function (row) {\n                var rowExpandLazyLoadedMaps = reactData.rowExpandLazyLoadedMaps;\n                var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                var expandOpts = computeExpandOpts.value;\n                var lazy = expandOpts.lazy;\n                var rowid = getRowid($xetable, row);\n                var rest = fullAllDataRowIdData[rowid];\n                if (lazy && rest) {\n                    rest.expandLoaded = false;\n                    delete rowExpandLazyLoadedMaps[rowid];\n                }\n                return nextTick();\n            },\n            /**\n             * 重新懒加载展开行，并展开内容\n             * @param {Row} row 行对象\n             */\n            reloadRowExpand: function (row) {\n                var rowExpandLazyLoadedMaps = reactData.rowExpandLazyLoadedMaps;\n                var expandOpts = computeExpandOpts.value;\n                var lazy = expandOpts.lazy;\n                var rowid = getRowid($xetable, row);\n                if (lazy && !rowExpandLazyLoadedMaps[rowid]) {\n                    tableMethods.clearRowExpandLoaded(row)\n                        .then(function () { return handleAsyncRowExpand(row); });\n                }\n                return nextTick();\n            },\n            reloadExpandContent: function (row) {\n                if (process.env.NODE_ENV === 'development') {\n                    warnLog('vxe.error.delFunc', ['reloadExpandContent', 'reloadRowExpand']);\n                }\n                // 即将废弃\n                return tableMethods.reloadRowExpand(row);\n            },\n            /**\n             * 切换展开行\n             */\n            toggleRowExpand: function (row) {\n                return tableMethods.setRowExpand(row, !tableMethods.isRowExpandByRow(row));\n            },\n            /**\n             * 设置所有行的展开与否\n             * @param {Boolean} expanded 是否展开\n             */\n            setAllRowExpand: function (expanded) {\n                var treeOpts = computeTreeOpts.value;\n                var tableFullData = internalData.tableFullData, tableFullTreeData = internalData.tableFullTreeData;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var expandedRows = [];\n                if (props.treeConfig) {\n                    XEUtils.eachTree(tableFullTreeData, function (row) {\n                        expandedRows.push(row);\n                    }, { children: childrenField });\n                }\n                else {\n                    expandedRows = tableFullData;\n                }\n                return tableMethods.setRowExpand(expandedRows, expanded);\n            },\n            /**\n             * 设置展开行，二个参数设置这一行展开与否\n             * 支持单行\n             * 支持多行\n             * @param {Array/Row} rows 行数据\n             * @param {Boolean} expanded 是否展开\n             */\n            setRowExpand: function (rows, expanded) {\n                var rowExpandedMaps = reactData.rowExpandedMaps, rowExpandLazyLoadedMaps = reactData.rowExpandLazyLoadedMaps, column = reactData.expandColumn;\n                var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                var rExpandedMaps = __assign({}, rowExpandedMaps);\n                var expandOpts = computeExpandOpts.value;\n                var reserve = expandOpts.reserve, lazy = expandOpts.lazy, accordion = expandOpts.accordion, toggleMethod = expandOpts.toggleMethod;\n                var lazyRests = [];\n                var columnIndex = tableMethods.getColumnIndex(column);\n                var $columnIndex = tableMethods.getVMColumnIndex(column);\n                if (rows) {\n                    if (!XEUtils.isArray(rows)) {\n                        rows = [rows];\n                    }\n                    if (accordion) {\n                        // 只能同时展开一个\n                        rExpandedMaps = {};\n                        rows = rows.slice(rows.length - 1, rows.length);\n                    }\n                    var validRows = toggleMethod ? rows.filter(function (row) { return toggleMethod({ $table: $xetable, expanded: expanded, column: column, columnIndex: columnIndex, $columnIndex: $columnIndex, row: row, rowIndex: tableMethods.getRowIndex(row), $rowIndex: tableMethods.getVMRowIndex(row) }); }) : rows;\n                    if (expanded) {\n                        validRows.forEach(function (row) {\n                            var rowid = getRowid($xetable, row);\n                            if (!rExpandedMaps[rowid]) {\n                                var rest = fullAllDataRowIdData[rowid];\n                                var isLoad = lazy && !rest.expandLoaded && !rowExpandLazyLoadedMaps[rowid];\n                                if (isLoad) {\n                                    lazyRests.push(handleAsyncRowExpand(row));\n                                }\n                                else {\n                                    rExpandedMaps[rowid] = row;\n                                }\n                            }\n                        });\n                    }\n                    else {\n                        validRows.forEach(function (item) {\n                            var rowid = getRowid($xetable, item);\n                            if (rExpandedMaps[rowid]) {\n                                delete rExpandedMaps[rowid];\n                            }\n                        });\n                    }\n                    if (reserve) {\n                        validRows.forEach(function (row) { return handleRowExpandReserve(row, expanded); });\n                    }\n                }\n                reactData.rowExpandedMaps = rExpandedMaps;\n                return Promise.all(lazyRests).then(function () { return tableMethods.recalculate(); });\n            },\n            /**\n             * 判断行是否为展开状态\n             * @param {Row} row 行对象\n             */\n            isRowExpandByRow: function (row) {\n                var rowExpandedMaps = reactData.rowExpandedMaps;\n                var rowid = getRowid($xetable, row);\n                return !!rowExpandedMaps[rowid];\n            },\n            isExpandByRow: function (row) {\n                // if (process.env.NODE_ENV === 'development') {\n                //   warnLog('vxe.error.delFunc', ['isExpandByRow', 'isRowExpandByRow'])\n                // }\n                return tableMethods.isRowExpandByRow(row);\n            },\n            /**\n             * 手动清空展开行状态，数据会恢复成未展开的状态\n             */\n            clearRowExpand: function () {\n                var tableFullData = internalData.tableFullData;\n                var expandOpts = computeExpandOpts.value;\n                var reserve = expandOpts.reserve;\n                var expList = tableMethods.getRowExpandRecords();\n                reactData.rowExpandedMaps = {};\n                if (reserve) {\n                    tableFullData.forEach(function (row) { return handleRowExpandReserve(row, false); });\n                }\n                return nextTick().then(function () {\n                    if (expList.length) {\n                        tableMethods.recalculate();\n                    }\n                });\n            },\n            clearRowExpandReserve: function () {\n                internalData.rowExpandedReserveRowMap = {};\n                return nextTick();\n            },\n            getRowExpandRecords: function () {\n                var rest = [];\n                XEUtils.each(reactData.rowExpandedMaps, function (item) {\n                    if (item) {\n                        rest.push(item);\n                    }\n                });\n                return rest;\n            },\n            getTreeExpandRecords: function () {\n                var rest = [];\n                XEUtils.each(reactData.treeExpandedMaps, function (item) {\n                    if (item) {\n                        rest.push(item);\n                    }\n                });\n                return rest;\n            },\n            /**\n             * 判断树节点是否懒加载完成\n             * @param {Row} row 行对象\n             */\n            isTreeExpandLoaded: function (row) {\n                var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                var rest = fullAllDataRowIdData[getRowid($xetable, row)];\n                return rest && !!rest.treeLoaded;\n            },\n            clearTreeExpandLoaded: function (row) {\n                var treeExpandedMaps = reactData.treeExpandedMaps;\n                var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                var treeOpts = computeTreeOpts.value;\n                var transform = treeOpts.transform, lazy = treeOpts.lazy;\n                var rowid = getRowid($xetable, row);\n                var rest = fullAllDataRowIdData[rowid];\n                if (lazy && rest) {\n                    rest.treeLoaded = false;\n                    if (treeExpandedMaps[rowid]) {\n                        delete treeExpandedMaps[rowid];\n                    }\n                }\n                if (transform) {\n                    handleVirtualTreeToList();\n                    return tablePrivateMethods.handleTableData();\n                }\n                return nextTick();\n            },\n            /**\n             * 重新懒加载树节点，并展开该节点\n             * @param {Row} row 行对象\n             */\n            reloadTreeExpand: function (row) {\n                var treeExpandLazyLoadedMaps = reactData.treeExpandLazyLoadedMaps;\n                var treeOpts = computeTreeOpts.value;\n                var hasChildField = treeOpts.hasChild || treeOpts.hasChildField;\n                var transform = treeOpts.transform, lazy = treeOpts.lazy;\n                var rowid = getRowid($xetable, row);\n                if (lazy && row[hasChildField] && !treeExpandLazyLoadedMaps[rowid]) {\n                    tableMethods.clearTreeExpandLoaded(row).then(function () {\n                        return handleAsyncTreeExpandChilds(row);\n                    }).then(function () {\n                        if (transform) {\n                            handleVirtualTreeToList();\n                            return tablePrivateMethods.handleTableData();\n                        }\n                    }).then(function () {\n                        return tableMethods.recalculate();\n                    });\n                }\n                return nextTick();\n            },\n            reloadTreeChilds: function (row) {\n                if (process.env.NODE_ENV === 'development') {\n                    warnLog('vxe.error.delFunc', ['reloadTreeChilds', 'reloadTreeExpand']);\n                }\n                // 即将废弃\n                return tableMethods.reloadTreeExpand(row);\n            },\n            /**\n             * 切换/展开树节点\n             */\n            toggleTreeExpand: function (row) {\n                return tableMethods.setTreeExpand(row, !tableMethods.isTreeExpandByRow(row));\n            },\n            /**\n             * 设置所有树节点的展开与否\n             * @param {Boolean} expanded 是否展开\n             */\n            setAllTreeExpand: function (expanded) {\n                var tableFullData = internalData.tableFullData;\n                var treeOpts = computeTreeOpts.value;\n                var transform = treeOpts.transform, lazy = treeOpts.lazy;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var expandeds = [];\n                XEUtils.eachTree(tableFullData, function (row) {\n                    var rowChildren = row[childrenField];\n                    if (lazy || (rowChildren && rowChildren.length)) {\n                        expandeds.push(row);\n                    }\n                }, { children: childrenField });\n                return tableMethods.setTreeExpand(expandeds, expanded).then(function () {\n                    if (transform) {\n                        handleVirtualTreeToList();\n                        return tableMethods.recalculate();\n                    }\n                });\n            },\n            /**\n             * 设置展开树形节点，二个参数设置这一行展开与否\n             * 支持单行\n             * 支持多行\n             * @param {Array/Row} rows 行数据\n             * @param {Boolean} expanded 是否展开\n             */\n            setTreeExpand: function (rows, expanded) {\n                var treeOpts = computeTreeOpts.value;\n                var transform = treeOpts.transform;\n                if (rows) {\n                    if (!XEUtils.isArray(rows)) {\n                        rows = [rows];\n                    }\n                    if (rows.length) {\n                        // 如果为虚拟树\n                        if (transform) {\n                            return handleVirtualTreeExpand(rows, expanded);\n                        }\n                        else {\n                            return handleBaseTreeExpand(rows, expanded);\n                        }\n                    }\n                }\n                return nextTick();\n            },\n            /**\n             * 判断行是否为树形节点展开状态\n             * @param {Row} row 行对象\n             */\n            isTreeExpandByRow: function (row) {\n                var treeExpandedMaps = reactData.treeExpandedMaps;\n                return !!treeExpandedMaps[getRowid($xetable, row)];\n            },\n            /**\n             * 手动清空树形节点的展开状态，数据会恢复成未展开的状态\n             */\n            clearTreeExpand: function () {\n                var tableFullTreeData = internalData.tableFullTreeData;\n                var treeOpts = computeTreeOpts.value;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var transform = treeOpts.transform, reserve = treeOpts.reserve;\n                var expList = tableMethods.getTreeExpandRecords();\n                reactData.treeExpandedMaps = {};\n                if (reserve) {\n                    XEUtils.eachTree(tableFullTreeData, function (row) { return handleTreeExpandReserve(row, false); }, { children: childrenField });\n                }\n                return tablePrivateMethods.handleTableData().then(function () {\n                    if (transform) {\n                        handleVirtualTreeToList();\n                        return tablePrivateMethods.handleTableData();\n                    }\n                }).then(function () {\n                    if (expList.length) {\n                        return tableMethods.recalculate();\n                    }\n                });\n            },\n            clearTreeExpandReserve: function () {\n                internalData.treeExpandedReserveRowMap = {};\n                return nextTick();\n            },\n            /**\n             * 获取表格的滚动状态\n             */\n            getScroll: function () {\n                var scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad;\n                var tableBody = refTableBody.value;\n                var bodyElem = tableBody.$el;\n                return {\n                    virtualX: scrollXLoad,\n                    virtualY: scrollYLoad,\n                    scrollTop: bodyElem.scrollTop,\n                    scrollLeft: bodyElem.scrollLeft\n                };\n            },\n            /**\n             * 如果有滚动条，则滚动到对应的位置\n             * @param {Number} scrollLeft 左距离\n             * @param {Number} scrollTop 上距离\n             */\n            scrollTo: function (scrollLeft, scrollTop) {\n                var tableBody = refTableBody.value;\n                var tableFooter = refTableFooter.value;\n                var rightBody = refTableRightBody.value;\n                var tableBodyElem = tableBody ? tableBody.$el : null;\n                var rightBodyElem = rightBody ? rightBody.$el : null;\n                var tableFooterElem = tableFooter ? tableFooter.$el : null;\n                if (XEUtils.isNumber(scrollLeft)) {\n                    setScrollLeft(tableFooterElem || tableBodyElem, scrollLeft);\n                }\n                if (XEUtils.isNumber(scrollTop)) {\n                    setScrollTop(rightBodyElem || tableBodyElem, scrollTop);\n                }\n                if (reactData.scrollXLoad || reactData.scrollYLoad) {\n                    return new Promise(function (resolve) {\n                        setTimeout(function () {\n                            nextTick(function () {\n                                resolve();\n                            });\n                        }, 50);\n                    });\n                }\n                return nextTick();\n            },\n            /**\n             * 如果有滚动条，则滚动到对应的行\n             * @param {Row} row 行对象\n             * @param {ColumnInfo} fieldOrColumn 列配置\n             */\n            scrollToRow: function (row, fieldOrColumn) {\n                var rest = [];\n                if (row) {\n                    if (props.treeConfig) {\n                        rest.push(tablePrivateMethods.scrollToTreeRow(row));\n                    }\n                    else {\n                        rest.push(rowToVisible($xetable, row));\n                    }\n                }\n                if (fieldOrColumn) {\n                    rest.push(tableMethods.scrollToColumn(fieldOrColumn));\n                }\n                return Promise.all(rest);\n            },\n            /**\n             * 如果有滚动条，则滚动到对应的列\n             */\n            scrollToColumn: function (fieldOrColumn) {\n                var fullColumnIdData = internalData.fullColumnIdData;\n                var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                if (column && fullColumnIdData[column.id]) {\n                    return colToVisible($xetable, column);\n                }\n                return nextTick();\n            },\n            /**\n             * 手动清除滚动相关信息，还原到初始状态\n             */\n            clearScroll: function () {\n                var scrollXStore = internalData.scrollXStore, scrollYStore = internalData.scrollYStore;\n                var tableBody = refTableBody.value;\n                var tableFooter = refTableFooter.value;\n                var rightBody = refTableRightBody.value;\n                var tableBodyElem = tableBody ? tableBody.$el : null;\n                var rightBodyElem = rightBody ? rightBody.$el : null;\n                var tableFooterElem = tableFooter ? tableFooter.$el : null;\n                if (rightBodyElem) {\n                    restoreScrollListener(rightBodyElem);\n                    rightBodyElem.scrollTop = 0;\n                }\n                if (tableFooterElem) {\n                    tableFooterElem.scrollLeft = 0;\n                }\n                if (tableBodyElem) {\n                    restoreScrollListener(tableBodyElem);\n                    tableBodyElem.scrollTop = 0;\n                    tableBodyElem.scrollLeft = 0;\n                }\n                scrollXStore.startIndex = 0;\n                scrollYStore.startIndex = 0;\n                return nextTick();\n            },\n            /**\n             * 更新表尾合计\n             */\n            updateFooter: function () {\n                var showFooter = props.showFooter, footerMethod = props.footerMethod;\n                var visibleColumn = internalData.visibleColumn, afterFullData = internalData.afterFullData;\n                if (showFooter && footerMethod) {\n                    reactData.footerTableData = visibleColumn.length ? footerMethod({ columns: visibleColumn, data: afterFullData, $table: $xetable, $grid: $xegrid }) : [];\n                }\n                return nextTick();\n            },\n            /**\n             * 更新列状态 updateStatus({ row, column }, cellValue)\n             * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一列编辑状态\n             * 如果单元格配置了校验规则，则会进行校验\n             */\n            updateStatus: function (slotParams, cellValue) {\n                var customVal = !XEUtils.isUndefined(cellValue);\n                return nextTick().then(function () {\n                    var editRules = props.editRules;\n                    var validStore = reactData.validStore;\n                    var tableBody = refTableBody.value;\n                    if (slotParams && tableBody && editRules) {\n                        var row_1 = slotParams.row, column_3 = slotParams.column;\n                        var type = 'change';\n                        if ($xetable.hasCellRules) {\n                            if ($xetable.hasCellRules(type, row_1, column_3)) {\n                                var cell_1 = tablePrivateMethods.getCell(row_1, column_3);\n                                if (cell_1) {\n                                    return $xetable.validCellRules(type, row_1, column_3, cellValue)\n                                        .then(function () {\n                                        if (customVal && validStore.visible) {\n                                            setCellValue(row_1, column_3, cellValue);\n                                        }\n                                        $xetable.clearValidate(row_1, column_3);\n                                    })\n                                        .catch(function (_a) {\n                                        var rule = _a.rule;\n                                        if (customVal) {\n                                            setCellValue(row_1, column_3, cellValue);\n                                        }\n                                        $xetable.showValidTooltip({ rule: rule, row: row_1, column: column_3, cell: cell_1 });\n                                    });\n                                }\n                            }\n                        }\n                    }\n                });\n            },\n            /**\n             * 设置合并单元格\n             * @param {TableMergeConfig[]} merges { row: Row|number, column: ColumnInfo|number, rowspan: number, colspan: number }\n             */\n            setMergeCells: function (merges) {\n                if (props.spanMethod) {\n                    errLog('vxe.error.errConflicts', ['merge-cells', 'span-method']);\n                }\n                setMerges(merges, reactData.mergeList, internalData.afterFullData);\n                return nextTick().then(function () { return tableMethods.updateCellAreas(); });\n            },\n            /**\n             * 移除单元格合并\n             * @param {TableMergeConfig[]} merges 多个或数组 [{row:Row|number, col:ColumnInfo|number}]\n             */\n            removeMergeCells: function (merges) {\n                if (props.spanMethod) {\n                    errLog('vxe.error.errConflicts', ['merge-cells', 'span-method']);\n                }\n                var rest = removeMerges(merges, reactData.mergeList, internalData.afterFullData);\n                return nextTick().then(function () {\n                    tableMethods.updateCellAreas();\n                    return rest;\n                });\n            },\n            /**\n             * 获取所有被合并的单元格\n             */\n            getMergeCells: function () {\n                return reactData.mergeList.slice(0);\n            },\n            /**\n             * 清除所有单元格合并\n             */\n            clearMergeCells: function () {\n                reactData.mergeList = [];\n                return nextTick();\n            },\n            setMergeFooterItems: function (merges) {\n                if (props.footerSpanMethod) {\n                    errLog('vxe.error.errConflicts', ['merge-footer-items', 'footer-span-method']);\n                }\n                setMerges(merges, reactData.mergeFooterList);\n                return nextTick().then(function () { return tableMethods.updateCellAreas(); });\n            },\n            removeMergeFooterItems: function (merges) {\n                if (props.footerSpanMethod) {\n                    errLog('vxe.error.errConflicts', ['merge-footer-items', 'footer-span-method']);\n                }\n                var rest = removeMerges(merges, reactData.mergeFooterList);\n                return nextTick().then(function () {\n                    tableMethods.updateCellAreas();\n                    return rest;\n                });\n            },\n            /**\n             * 获取所有被合并的表尾\n             */\n            getMergeFooterItems: function () {\n                return reactData.mergeFooterList.slice(0);\n            },\n            /**\n             * 清除所有表尾合并\n             */\n            clearMergeFooterItems: function () {\n                reactData.mergeFooterList = [];\n                return nextTick();\n            },\n            updateCellAreas: function () {\n                var mouseConfig = props.mouseConfig;\n                var mouseOpts = computeMouseOpts.value;\n                if (mouseConfig && mouseOpts.area && $xetable.handleUpdateCellAreas) {\n                    return $xetable.handleUpdateCellAreas();\n                }\n                return nextTick();\n            },\n            focus: function () {\n                internalData.isActivated = true;\n                return nextTick();\n            },\n            blur: function () {\n                internalData.isActivated = false;\n                return nextTick();\n            },\n            /**\n             * 连接工具栏\n             * @param $toolbar\n             */\n            connect: function ($toolbar) {\n                if ($toolbar) {\n                    $xetoolbar = $toolbar;\n                    $xetoolbar.syncUpdate({ collectColumn: internalData.collectColumn, $table: $xetable });\n                }\n                else {\n                    errLog('vxe.error.barUnableLink');\n                }\n                return nextTick();\n            }\n        };\n        /**\n         * 全局按下事件处理\n         */\n        var handleGlobalMousedownEvent = function (evnt) {\n            var editStore = reactData.editStore, ctxMenuStore = reactData.ctxMenuStore, filterStore = reactData.filterStore;\n            var mouseConfig = props.mouseConfig, editRules = props.editRules;\n            var el = refElem.value;\n            var editOpts = computeEditOpts.value;\n            var validOpts = computeValidOpts.value;\n            var actived = editStore.actived;\n            var $validTooltip = refValidTooltip.value;\n            var tableFilter = refTableFilter.value;\n            var tableMenu = refTableMenu.value;\n            if (tableFilter) {\n                if (getEventTargetNode(evnt, el, 'vxe-cell--filter').flag) {\n                    // 如果点击了筛选按钮\n                }\n                else if (getEventTargetNode(evnt, tableFilter.$el).flag) {\n                    // 如果点击筛选容器\n                }\n                else {\n                    if (!getEventTargetNode(evnt, document.body, 'vxe-table--ignore-clear').flag) {\n                        tablePrivateMethods.preventEvent(evnt, 'event.clearFilter', filterStore.args, tableMethods.closeFilter);\n                    }\n                }\n            }\n            // 如果已激活了编辑状态\n            if (actived.row) {\n                if (!(editOpts.autoClear === false)) {\n                    // 如果是激活状态，点击了单元格之外\n                    var cell = actived.args.cell;\n                    if ((!cell || !getEventTargetNode(evnt, cell).flag)) {\n                        if ($validTooltip && getEventTargetNode(evnt, $validTooltip.$el).flag) {\n                            // 如果是激活状态，且点击了校验提示框\n                        }\n                        else if (!internalData._lastCallTime || internalData._lastCallTime + 50 < Date.now()) {\n                            // 如果是激活状态，点击了单元格之外\n                            if (!getEventTargetNode(evnt, document.body, 'vxe-table--ignore-clear').flag) {\n                                // 如果手动调用了激活单元格，避免触发源被移除后导致重复关闭\n                                tablePrivateMethods.preventEvent(evnt, 'event.clearActived', actived.args, function () {\n                                    var isClear;\n                                    if (editOpts.mode === 'row') {\n                                        var rowTargetNode = getEventTargetNode(evnt, el, 'vxe-body--row');\n                                        var rowNodeRest = rowTargetNode.flag ? tableMethods.getRowNode(rowTargetNode.targetElem) : null;\n                                        // row 方式，如果点击了不同行\n                                        isClear = rowNodeRest ? !$xetable.eqRow(rowNodeRest.item, actived.args.row) : false;\n                                    }\n                                    else {\n                                        // cell 方式，如果是非编辑列\n                                        isClear = !getEventTargetNode(evnt, el, 'col--edit').flag;\n                                    }\n                                    // 如果点击表头行，则清除激活状态\n                                    if (!isClear) {\n                                        isClear = getEventTargetNode(evnt, el, 'vxe-header--row').flag;\n                                    }\n                                    // 如果点击表尾行，则清除激活状态\n                                    if (!isClear) {\n                                        isClear = getEventTargetNode(evnt, el, 'vxe-footer--row').flag;\n                                    }\n                                    // 如果固定了高度且点击了行之外的空白处，则清除激活状态\n                                    if (!isClear && props.height && !reactData.overflowY) {\n                                        var bodyWrapperElem = evnt.target;\n                                        if (hasClass(bodyWrapperElem, 'vxe-table--body-wrapper')) {\n                                            isClear = evnt.offsetY < bodyWrapperElem.clientHeight;\n                                        }\n                                    }\n                                    if (isClear ||\n                                        // 如果点击了当前表格之外\n                                        !getEventTargetNode(evnt, el).flag) {\n                                        setTimeout(function () { return $xetable.clearEdit(evnt); });\n                                    }\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n            else if (mouseConfig) {\n                if (!getEventTargetNode(evnt, el).flag && !($xegrid && getEventTargetNode(evnt, $xegrid.getRefMaps().refElem.value).flag) && !(tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) && !($xetoolbar && getEventTargetNode(evnt, $xetoolbar.getRefMaps().refElem.value).flag)) {\n                    $xetable.clearSelected();\n                    if ($xetable.clearCellAreas) {\n                        if (!getEventTargetNode(evnt, document.body, 'vxe-table--ignore-areas-clear').flag) {\n                            tablePrivateMethods.preventEvent(evnt, 'event.clearAreas', {}, function () {\n                                $xetable.clearCellAreas();\n                                $xetable.clearCopyCellArea();\n                            });\n                        }\n                    }\n                }\n            }\n            // 如果配置了快捷菜单且，点击了其他地方则关闭\n            if ($xetable.closeMenu) {\n                if (ctxMenuStore.visible && tableMenu && !getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {\n                    $xetable.closeMenu();\n                }\n            }\n            var isActivated = getEventTargetNode(evnt, $xegrid ? $xegrid.getRefMaps().refElem.value : el).flag;\n            // 如果存在校验，点击了表格之外则清除\n            if (!isActivated && editRules && validOpts.autoClear) {\n                reactData.validErrorMaps = {};\n            }\n            // 最后激活的表格\n            internalData.isActivated = isActivated;\n        };\n        /**\n         * 窗口失焦事件处理\n         */\n        var handleGlobalBlurEvent = function () {\n            tableMethods.closeFilter();\n            if ($xetable.closeMenu) {\n                $xetable.closeMenu();\n            }\n        };\n        /**\n         * 全局滚动事件\n         */\n        var handleGlobalMousewheelEvent = function () {\n            tableMethods.closeTooltip();\n            if ($xetable.closeMenu) {\n                $xetable.closeMenu();\n            }\n        };\n        /**\n         * 表格键盘事件\n         */\n        var keydownEvent = function (evnt) {\n            var mouseConfig = props.mouseConfig, keyboardConfig = props.keyboardConfig;\n            var filterStore = reactData.filterStore, ctxMenuStore = reactData.ctxMenuStore, editStore = reactData.editStore;\n            var mouseOpts = computeMouseOpts.value;\n            var keyboardOpts = computeKeyboardOpts.value;\n            var actived = editStore.actived;\n            var isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);\n            if (isEsc) {\n                tablePrivateMethods.preventEvent(evnt, 'event.keydown', null, function () {\n                    tableMethods.dispatchEvent('keydown-start', {}, evnt);\n                    if (keyboardConfig && mouseConfig && mouseOpts.area && $xetable.handleKeyboardEvent) {\n                        $xetable.handleKeyboardEvent(evnt);\n                    }\n                    else if (actived.row || filterStore.visible || ctxMenuStore.visible) {\n                        evnt.stopPropagation();\n                        // 如果按下了 Esc 键，关闭快捷菜单、筛选\n                        if ($xetable.closeMenu) {\n                            $xetable.closeMenu();\n                        }\n                        tableMethods.closeFilter();\n                        if (keyboardConfig && keyboardOpts.isEsc) {\n                            // 如果是激活编辑状态，则取消编辑\n                            if (actived.row) {\n                                var params_1 = actived.args;\n                                $xetable.clearEdit(evnt);\n                                // 如果配置了选中功能，则为选中状态\n                                if (mouseOpts.selected) {\n                                    nextTick(function () { return $xetable.handleSelected(params_1, evnt); });\n                                }\n                            }\n                        }\n                    }\n                    tableMethods.dispatchEvent('keydown', {}, evnt);\n                    tableMethods.dispatchEvent('keydown-end', {}, evnt);\n                });\n            }\n        };\n        /**\n         * 全局键盘事件\n         */\n        var handleGlobalKeydownEvent = function (evnt) {\n            // 该行为只对当前激活的表格有效\n            if (internalData.isActivated) {\n                tablePrivateMethods.preventEvent(evnt, 'event.keydown', null, function () {\n                    var mouseConfig = props.mouseConfig, keyboardConfig = props.keyboardConfig, treeConfig = props.treeConfig, editConfig = props.editConfig, highlightCurrentRow = props.highlightCurrentRow;\n                    var ctxMenuStore = reactData.ctxMenuStore, editStore = reactData.editStore, currentRow = reactData.currentRow;\n                    var isMenu = computeIsMenu.value;\n                    var bodyMenu = computeBodyMenu.value;\n                    var keyboardOpts = computeKeyboardOpts.value;\n                    var mouseOpts = computeMouseOpts.value;\n                    var editOpts = computeEditOpts.value;\n                    var treeOpts = computeTreeOpts.value;\n                    var menuList = computeMenuList.value;\n                    var rowOpts = computeRowOpts.value;\n                    var selected = editStore.selected, actived = editStore.actived;\n                    var childrenField = treeOpts.children || treeOpts.childrenField;\n                    var keyCode = evnt.keyCode;\n                    var isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);\n                    var isBack = hasEventKey(evnt, EVENT_KEYS.BACKSPACE);\n                    var isTab = hasEventKey(evnt, EVENT_KEYS.TAB);\n                    var isEnter = hasEventKey(evnt, EVENT_KEYS.ENTER);\n                    var isSpacebar = hasEventKey(evnt, EVENT_KEYS.SPACEBAR);\n                    var isLeftArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_LEFT);\n                    var isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);\n                    var isRightArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_RIGHT);\n                    var isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);\n                    var isDel = hasEventKey(evnt, EVENT_KEYS.DELETE);\n                    var isF2 = hasEventKey(evnt, EVENT_KEYS.F2);\n                    var isContextMenu = hasEventKey(evnt, EVENT_KEYS.CONTEXT_MENU);\n                    var hasMetaKey = evnt.metaKey;\n                    var hasCtrlKey = evnt.ctrlKey;\n                    var hasShiftKey = evnt.shiftKey;\n                    var isAltKey = evnt.altKey;\n                    var operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;\n                    var operCtxMenu = isMenu && ctxMenuStore.visible && (isEnter || isSpacebar || operArrow);\n                    var isEditStatus = isEnableConf(editConfig) && actived.column && actived.row;\n                    var params;\n                    if (operCtxMenu) {\n                        // 如果配置了右键菜单; 支持方向键操作、回车\n                        evnt.preventDefault();\n                        if (ctxMenuStore.showChild && hasChildrenList(ctxMenuStore.selected)) {\n                            $xetable.moveCtxMenu(evnt, ctxMenuStore, 'selectChild', isLeftArrow, false, ctxMenuStore.selected.children);\n                        }\n                        else {\n                            $xetable.moveCtxMenu(evnt, ctxMenuStore, 'selected', isRightArrow, true, menuList);\n                        }\n                    }\n                    else if (keyboardConfig && mouseConfig && mouseOpts.area && $xetable.handleKeyboardEvent) {\n                        $xetable.handleKeyboardEvent(evnt);\n                    }\n                    else if (isEsc) {\n                        // 如果按下了 Esc 键，关闭快捷菜单、筛选\n                        if ($xetable.closeMenu) {\n                            $xetable.closeMenu();\n                        }\n                        tableMethods.closeFilter();\n                        if (keyboardConfig && keyboardOpts.isEsc) {\n                            // 如果是激活编辑状态，则取消编辑\n                            if (actived.row) {\n                                var params_2 = actived.args;\n                                $xetable.clearEdit(evnt);\n                                // 如果配置了选中功能，则为选中状态\n                                if (mouseOpts.selected) {\n                                    nextTick(function () { return $xetable.handleSelected(params_2, evnt); });\n                                }\n                            }\n                        }\n                    }\n                    else if (isSpacebar && keyboardConfig && keyboardOpts.isChecked && selected.row && selected.column && (selected.column.type === 'checkbox' || selected.column.type === 'radio')) {\n                        // 空格键支持选中复选框\n                        evnt.preventDefault();\n                        if (selected.column.type === 'checkbox') {\n                            tablePrivateMethods.handleToggleCheckRowEvent(evnt, selected.args);\n                        }\n                        else {\n                            tablePrivateMethods.triggerRadioRowEvent(evnt, selected.args);\n                        }\n                    }\n                    else if (isF2 && isEnableConf(editConfig)) {\n                        if (!isEditStatus) {\n                            // 如果按下了 F2 键\n                            if (selected.row && selected.column) {\n                                evnt.preventDefault();\n                                $xetable.handleActived(selected.args, evnt);\n                            }\n                        }\n                    }\n                    else if (isContextMenu) {\n                        // 如果按下上下文键\n                        internalData._keyCtx = selected.row && selected.column && bodyMenu.length;\n                        clearTimeout(keyCtxTimeout);\n                        keyCtxTimeout = setTimeout(function () {\n                            internalData._keyCtx = false;\n                        }, 1000);\n                    }\n                    else if (isEnter && !isAltKey && keyboardConfig && keyboardOpts.isEnter && (selected.row || actived.row || (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow))) {\n                        // 退出选中\n                        if (hasCtrlKey) {\n                            // 如果是激活编辑状态，则取消编辑\n                            if (actived.row) {\n                                params = actived.args;\n                                $xetable.clearEdit(evnt);\n                                // 如果配置了选中功能，则为选中状态\n                                if (mouseOpts.selected) {\n                                    nextTick(function () { return $xetable.handleSelected(params, evnt); });\n                                }\n                            }\n                        }\n                        else {\n                            // 如果是激活状态，退则出到上一行/下一行\n                            if (selected.row || actived.row) {\n                                var targetArgs = selected.row ? selected.args : actived.args;\n                                if (hasShiftKey) {\n                                    if (keyboardOpts.enterToTab) {\n                                        $xetable.moveTabSelected(targetArgs, hasShiftKey, evnt);\n                                    }\n                                    else {\n                                        $xetable.moveSelected(targetArgs, isLeftArrow, true, isRightArrow, false, evnt);\n                                    }\n                                }\n                                else {\n                                    if (keyboardOpts.enterToTab) {\n                                        $xetable.moveTabSelected(targetArgs, hasShiftKey, evnt);\n                                    }\n                                    else {\n                                        $xetable.moveSelected(targetArgs, isLeftArrow, false, isRightArrow, true, evnt);\n                                    }\n                                }\n                            }\n                            else if (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {\n                                // 如果是树形表格当前行回车移动到子节点\n                                var childrens = currentRow[childrenField];\n                                if (childrens && childrens.length) {\n                                    evnt.preventDefault();\n                                    var targetRow_1 = childrens[0];\n                                    params = {\n                                        $table: $xetable,\n                                        row: targetRow_1,\n                                        rowIndex: tableMethods.getRowIndex(targetRow_1),\n                                        $rowIndex: tableMethods.getVMRowIndex(targetRow_1)\n                                    };\n                                    tableMethods.setTreeExpand(currentRow, true)\n                                        .then(function () { return tableMethods.scrollToRow(targetRow_1); })\n                                        .then(function () { return tablePrivateMethods.triggerCurrentRowEvent(evnt, params); });\n                                }\n                            }\n                        }\n                    }\n                    else if (operArrow && keyboardConfig && keyboardOpts.isArrow) {\n                        if (!isEditStatus) {\n                            // 如果按下了方向键\n                            if (selected.row && selected.column) {\n                                $xetable.moveSelected(selected.args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt);\n                            }\n                            else if ((isUpArrow || isDwArrow) && (rowOpts.isCurrent || highlightCurrentRow)) {\n                                // 当前行按键上下移动\n                                $xetable.moveCurrentRow(isUpArrow, isDwArrow, evnt);\n                            }\n                        }\n                    }\n                    else if (isTab && keyboardConfig && keyboardOpts.isTab) {\n                        // 如果按下了 Tab 键切换\n                        if (selected.row || selected.column) {\n                            $xetable.moveTabSelected(selected.args, hasShiftKey, evnt);\n                        }\n                        else if (actived.row || actived.column) {\n                            $xetable.moveTabSelected(actived.args, hasShiftKey, evnt);\n                        }\n                    }\n                    else if (keyboardConfig && isEnableConf(editConfig) && (isDel || (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow ? isBack && keyboardOpts.isArrow : isBack))) {\n                        if (!isEditStatus) {\n                            var delMethod = keyboardOpts.delMethod, backMethod = keyboardOpts.backMethod;\n                            // 如果是删除键\n                            if (keyboardOpts.isDel && (selected.row || selected.column)) {\n                                if (delMethod) {\n                                    delMethod({\n                                        row: selected.row,\n                                        rowIndex: tableMethods.getRowIndex(selected.row),\n                                        column: selected.column,\n                                        columnIndex: tableMethods.getColumnIndex(selected.column),\n                                        $table: $xetable\n                                    });\n                                }\n                                else {\n                                    setCellValue(selected.row, selected.column, null);\n                                }\n                                if (isBack) {\n                                    if (backMethod) {\n                                        backMethod({\n                                            row: selected.row,\n                                            rowIndex: tableMethods.getRowIndex(selected.row),\n                                            column: selected.column,\n                                            columnIndex: tableMethods.getColumnIndex(selected.column),\n                                            $table: $xetable\n                                        });\n                                    }\n                                    else {\n                                        $xetable.handleActived(selected.args, evnt);\n                                    }\n                                }\n                                else if (isDel) {\n                                    // 如果按下 del 键，更新表尾数据\n                                    tableMethods.updateFooter();\n                                }\n                            }\n                            else if (isBack && keyboardOpts.isArrow && treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {\n                                // 如果树形表格回退键关闭当前行返回父节点\n                                var parentRow_1 = XEUtils.findTree(internalData.afterFullData, function (item) { return item === currentRow; }, { children: childrenField }).parent;\n                                if (parentRow_1) {\n                                    evnt.preventDefault();\n                                    params = {\n                                        $table: $xetable,\n                                        row: parentRow_1,\n                                        rowIndex: tableMethods.getRowIndex(parentRow_1),\n                                        $rowIndex: tableMethods.getVMRowIndex(parentRow_1)\n                                    };\n                                    tableMethods.setTreeExpand(parentRow_1, false)\n                                        .then(function () { return tableMethods.scrollToRow(parentRow_1); })\n                                        .then(function () { return tablePrivateMethods.triggerCurrentRowEvent(evnt, params); });\n                                }\n                            }\n                        }\n                    }\n                    else if (keyboardConfig && isEnableConf(editConfig) && keyboardOpts.isEdit && !hasCtrlKey && !hasMetaKey && (isSpacebar || (keyCode >= 48 && keyCode <= 57) || (keyCode >= 65 && keyCode <= 90) || (keyCode >= 96 && keyCode <= 111) || (keyCode >= 186 && keyCode <= 192) || (keyCode >= 219 && keyCode <= 222))) {\n                        var editMethod = keyboardOpts.editMethod;\n                        // 启用编辑后，空格键功能将失效\n                        // if (isSpacebar) {\n                        //   evnt.preventDefault()\n                        // }\n                        // 如果是按下非功能键之外允许直接编辑\n                        if (selected.column && selected.row && isEnableConf(selected.column.editRender)) {\n                            var beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;\n                            if (!beforeEditMethod || beforeEditMethod(__assign(__assign({}, selected.args), { $table: $xetable, $grid: $xegrid }))) {\n                                if (editMethod) {\n                                    editMethod({\n                                        row: selected.row,\n                                        rowIndex: tableMethods.getRowIndex(selected.row),\n                                        column: selected.column,\n                                        columnIndex: tableMethods.getColumnIndex(selected.column),\n                                        $table: $xetable,\n                                        $grid: $xegrid\n                                    });\n                                }\n                                else {\n                                    setCellValue(selected.row, selected.column, null);\n                                    $xetable.handleActived(selected.args, evnt);\n                                }\n                            }\n                        }\n                    }\n                    tableMethods.dispatchEvent('keydown', {}, evnt);\n                });\n            }\n        };\n        var handleGlobalPasteEvent = function (evnt) {\n            var keyboardConfig = props.keyboardConfig, mouseConfig = props.mouseConfig;\n            var editStore = reactData.editStore, filterStore = reactData.filterStore;\n            var isActivated = internalData.isActivated;\n            var mouseOpts = computeMouseOpts.value;\n            var keyboardOpts = computeKeyboardOpts.value;\n            var actived = editStore.actived;\n            if (isActivated && !filterStore.visible) {\n                if (!(actived.row || actived.column)) {\n                    if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handlePasteCellAreaEvent) {\n                        $xetable.handlePasteCellAreaEvent(evnt);\n                    }\n                }\n                tableMethods.dispatchEvent('paste', {}, evnt);\n            }\n        };\n        var handleGlobalCopyEvent = function (evnt) {\n            var keyboardConfig = props.keyboardConfig, mouseConfig = props.mouseConfig;\n            var editStore = reactData.editStore, filterStore = reactData.filterStore;\n            var isActivated = internalData.isActivated;\n            var mouseOpts = computeMouseOpts.value;\n            var keyboardOpts = computeKeyboardOpts.value;\n            var actived = editStore.actived;\n            if (isActivated && !filterStore.visible) {\n                if (!(actived.row || actived.column)) {\n                    if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handleCopyCellAreaEvent) {\n                        $xetable.handleCopyCellAreaEvent(evnt);\n                    }\n                }\n                tableMethods.dispatchEvent('copy', {}, evnt);\n            }\n        };\n        var handleGlobalCutEvent = function (evnt) {\n            var keyboardConfig = props.keyboardConfig, mouseConfig = props.mouseConfig;\n            var editStore = reactData.editStore, filterStore = reactData.filterStore;\n            var isActivated = internalData.isActivated;\n            var mouseOpts = computeMouseOpts.value;\n            var keyboardOpts = computeKeyboardOpts.value;\n            var actived = editStore.actived;\n            if (isActivated && !filterStore.visible) {\n                if (!(actived.row || actived.column)) {\n                    if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handleCutCellAreaEvent) {\n                        $xetable.handleCutCellAreaEvent(evnt);\n                    }\n                }\n                tableMethods.dispatchEvent('cut', {}, evnt);\n            }\n        };\n        var handleGlobalResizeEvent = function () {\n            if ($xetable.closeMenu) {\n                $xetable.closeMenu();\n            }\n            tableMethods.updateCellAreas();\n            tableMethods.recalculate(true);\n        };\n        var handleTargetEnterEvent = function (isClear) {\n            var $tooltip = refTooltip.value;\n            clearTimeout(internalData.tooltipTimeout);\n            if (isClear) {\n                tableMethods.closeTooltip();\n            }\n            else {\n                if ($tooltip) {\n                    $tooltip.setActived(true);\n                }\n            }\n        };\n        /**\n         * 处理显示 tooltip\n         * @param {Event} evnt 事件\n         * @param {ColumnInfo} column 列配置\n         * @param {Row} row 行对象\n         */\n        var handleTooltip = function (evnt, cell, overflowElem, tipElem, params) {\n            params.cell = cell;\n            var tooltipStore = reactData.tooltipStore;\n            var tooltipOpts = computeTooltipOpts.value;\n            var column = params.column, row = params.row;\n            var showAll = tooltipOpts.showAll, contentMethod = tooltipOpts.contentMethod;\n            var customContent = contentMethod ? contentMethod(params) : null;\n            var useCustom = contentMethod && !XEUtils.eqNull(customContent);\n            var content = useCustom ? customContent : XEUtils.toString(column.type === 'html' ? overflowElem.innerText : overflowElem.textContent).trim();\n            var isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;\n            if (content && (showAll || useCustom || isCellOverflow)) {\n                Object.assign(tooltipStore, {\n                    row: row,\n                    column: column,\n                    visible: true,\n                    currOpts: null\n                });\n                nextTick(function () {\n                    var $tooltip = refTooltip.value;\n                    if ($tooltip) {\n                        $tooltip.open(isCellOverflow ? overflowElem : (tipElem || overflowElem), formatText(content));\n                    }\n                });\n            }\n            return nextTick();\n        };\n        /**\n         * 内部方法\n         */\n        tablePrivateMethods = {\n            getSetupOptions: function () {\n                return GlobalConfig;\n            },\n            updateAfterDataIndex: updateAfterDataIndex,\n            callSlot: function (slotFunc, params) {\n                if (slotFunc) {\n                    if ($xegrid) {\n                        return $xegrid.callSlot(slotFunc, params);\n                    }\n                    if (XEUtils.isFunction(slotFunc)) {\n                        return getSlotVNs(slotFunc(params));\n                    }\n                }\n                return [];\n            },\n            /**\n             * 获取父容器元素\n             */\n            getParentElem: function () {\n                var el = refElem.value;\n                if ($xegrid) {\n                    var gridEl = $xegrid.getRefMaps().refElem.value;\n                    return gridEl ? gridEl.parentNode : null;\n                }\n                return el ? el.parentNode : null;\n            },\n            /**\n             * 获取父容器的高度\n             */\n            getParentHeight: function () {\n                var height = props.height;\n                var el = refElem.value;\n                if (el) {\n                    var parentElem = el.parentNode;\n                    var parentPaddingSize = height === 'auto' ? getPaddingTopBottomSize(parentElem) : 0;\n                    return Math.floor($xegrid ? $xegrid.getParentHeight() : XEUtils.toNumber(getComputedStyle(parentElem).height) - parentPaddingSize);\n                }\n                return 0;\n            },\n            /**\n             * 获取需要排除的高度\n             * 但渲染表格高度时，需要排除工具栏或分页等相关组件的高度\n             * 如果存在表尾合计滚动条，则需要排除滚动条高度\n             */\n            getExcludeHeight: function () {\n                return $xegrid ? $xegrid.getExcludeHeight() : 0;\n            },\n            /**\n             * 定义行数据中的列属性，如果不存在则定义\n             * @param {Row} records 行数据\n             */\n            defineField: function (records) {\n                var treeConfig = props.treeConfig;\n                var expandOpts = computeExpandOpts.value;\n                var treeOpts = computeTreeOpts.value;\n                var radioOpts = computeRadioOpts.value;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var rowkey = getRowkey($xetable);\n                if (!XEUtils.isArray(records)) {\n                    records = [records];\n                }\n                return records.map(function (record) {\n                    internalData.tableFullColumn.forEach(function (column) {\n                        var field = column.field, editRender = column.editRender;\n                        if (field && !XEUtils.has(record, field) && !record[field]) {\n                            var cellValue = null;\n                            if (editRender) {\n                                var defaultValue = editRender.defaultValue;\n                                if (XEUtils.isFunction(defaultValue)) {\n                                    cellValue = defaultValue({ column: column });\n                                }\n                                else if (!XEUtils.isUndefined(defaultValue)) {\n                                    cellValue = defaultValue;\n                                }\n                            }\n                            XEUtils.set(record, field, cellValue);\n                        }\n                    });\n                    var otherFields = [radioOpts.labelField, checkboxOpts.checkField, checkboxOpts.labelField, expandOpts.labelField];\n                    otherFields.forEach(function (key) {\n                        if (key && eqEmptyValue(XEUtils.get(record, key))) {\n                            XEUtils.set(record, key, null);\n                        }\n                    });\n                    if (treeConfig && treeOpts.lazy && XEUtils.isUndefined(record[childrenField])) {\n                        record[childrenField] = null;\n                    }\n                    // 必须有行数据的唯一主键，可以自行设置；也可以默认生成一个随机数\n                    if (eqEmptyValue(XEUtils.get(record, rowkey))) {\n                        XEUtils.set(record, rowkey, getRowUniqueId());\n                    }\n                    return record;\n                });\n            },\n            handleTableData: function (force) {\n                var scrollYLoad = reactData.scrollYLoad;\n                var scrollYStore = internalData.scrollYStore, fullDataRowIdData = internalData.fullDataRowIdData;\n                var fullList = internalData.afterFullData;\n                // 是否进行数据处理\n                if (force) {\n                    // 更新数据，处理筛选和排序\n                    updateAfterFullData();\n                    // 如果为虚拟树，将树结构拍平\n                    fullList = handleVirtualTreeToList();\n                }\n                var tableData = scrollYLoad ? fullList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullList.slice(0);\n                tableData.forEach(function (row, $index) {\n                    var rowid = getRowid($xetable, row);\n                    var rest = fullDataRowIdData[rowid];\n                    if (rest) {\n                        rest.$index = $index;\n                    }\n                });\n                reactData.tableData = tableData;\n                return nextTick();\n            },\n            /**\n             * 更新数据行的 Map\n             * 牺牲数据组装的耗时，用来换取使用过程中的流畅\n             */\n            cacheRowMap: function (isSource) {\n                var treeConfig = props.treeConfig;\n                var treeOpts = computeTreeOpts.value;\n                var fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData, tableFullData = internalData.tableFullData, tableFullTreeData = internalData.tableFullTreeData;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var hasChildField = treeOpts.hasChild || treeOpts.hasChildField;\n                var rowkey = getRowkey($xetable);\n                var isLazy = treeConfig && treeOpts.lazy;\n                var handleRow = function (row, index, items, path, parent, nodes) {\n                    var rowid = getRowid($xetable, row);\n                    var seq = treeConfig && path ? toTreePathSeq(path) : index + 1;\n                    var level = nodes ? nodes.length - 1 : 0;\n                    if (eqEmptyValue(rowid)) {\n                        rowid = getRowUniqueId();\n                        XEUtils.set(row, rowkey, rowid);\n                    }\n                    if (isLazy && row[hasChildField] && XEUtils.isUndefined(row[childrenField])) {\n                        row[childrenField] = null;\n                    }\n                    var rest = { row: row, rowid: rowid, seq: seq, index: treeConfig && parent ? -1 : index, _index: -1, $index: -1, items: items, parent: parent, level: level };\n                    if (isSource) {\n                        fullDataRowIdData[rowid] = rest;\n                    }\n                    fullAllDataRowIdData[rowid] = rest;\n                };\n                if (isSource) {\n                    fullDataRowIdData = internalData.fullDataRowIdData = {};\n                }\n                fullAllDataRowIdData = internalData.fullAllDataRowIdData = {};\n                if (treeConfig) {\n                    XEUtils.eachTree(tableFullTreeData, handleRow, { children: childrenField });\n                }\n                else {\n                    tableFullData.forEach(handleRow);\n                }\n            },\n            cacheSourceMap: function (fullData) {\n                var treeConfig = props.treeConfig;\n                var treeOpts = computeTreeOpts.value;\n                var sourceDataRowIdData = internalData.sourceDataRowIdData;\n                var sourceData = XEUtils.clone(fullData, true);\n                var rowkey = getRowkey($xetable);\n                sourceDataRowIdData = internalData.sourceDataRowIdData = {};\n                var handleSourceRow = function (row) {\n                    var rowid = getRowid($xetable, row);\n                    if (eqEmptyValue(rowid)) {\n                        rowid = getRowUniqueId();\n                        XEUtils.set(row, rowkey, rowid);\n                    }\n                    sourceDataRowIdData[rowid] = row;\n                };\n                // 源数据缓存\n                if (treeConfig) {\n                    var childrenField = treeOpts.children || treeOpts.childrenField;\n                    XEUtils.eachTree(sourceData, handleSourceRow, { children: treeOpts.transform ? treeOpts.mapChildrenField : childrenField });\n                }\n                else {\n                    sourceData.forEach(handleSourceRow);\n                }\n                internalData.tableSourceData = sourceData;\n            },\n            /**\n             * 指定列宽的列进行拆分\n             */\n            analyColumnWidth: function () {\n                var tableFullColumn = internalData.tableFullColumn;\n                var columnOpts = computeColumnOpts.value;\n                var defaultWidth = columnOpts.width, defaultMinWidth = columnOpts.minWidth;\n                var resizeList = [];\n                var pxList = [];\n                var pxMinList = [];\n                var scaleList = [];\n                var scaleMinList = [];\n                var autoList = [];\n                tableFullColumn.forEach(function (column) {\n                    if (defaultWidth && !column.width) {\n                        column.width = defaultWidth;\n                    }\n                    if (defaultMinWidth && !column.minWidth) {\n                        column.minWidth = defaultMinWidth;\n                    }\n                    if (column.visible) {\n                        if (column.resizeWidth) {\n                            resizeList.push(column);\n                        }\n                        else if (isPx(column.width)) {\n                            pxList.push(column);\n                        }\n                        else if (isScale(column.width)) {\n                            scaleList.push(column);\n                        }\n                        else if (isPx(column.minWidth)) {\n                            pxMinList.push(column);\n                        }\n                        else if (isScale(column.minWidth)) {\n                            scaleMinList.push(column);\n                        }\n                        else {\n                            autoList.push(column);\n                        }\n                    }\n                });\n                Object.assign(reactData.columnStore, { resizeList: resizeList, pxList: pxList, pxMinList: pxMinList, scaleList: scaleList, scaleMinList: scaleMinList, autoList: autoList });\n            },\n            saveCustomResizable: function (isReset) {\n                var id = props.id, customConfig = props.customConfig;\n                var customOpts = computeCustomOpts.value;\n                var collectColumn = internalData.collectColumn;\n                var storage = customOpts.storage;\n                var isResizable = storage === true || (storage && storage.resizable);\n                if (customConfig && isResizable) {\n                    var columnWidthStorageMap = getCustomStorageMap(resizableStorageKey);\n                    var columnWidthStorage_1;\n                    if (!id) {\n                        errLog('vxe.error.reqProp', ['id']);\n                        return;\n                    }\n                    if (!isReset) {\n                        columnWidthStorage_1 = XEUtils.isPlainObject(columnWidthStorageMap[id]) ? columnWidthStorageMap[id] : {};\n                        XEUtils.eachTree(collectColumn, function (column) {\n                            if (column.resizeWidth) {\n                                var colKey = column.getKey();\n                                if (colKey) {\n                                    columnWidthStorage_1[colKey] = column.renderWidth;\n                                }\n                            }\n                        });\n                    }\n                    columnWidthStorageMap[id] = XEUtils.isEmpty(columnWidthStorage_1) ? undefined : columnWidthStorage_1;\n                    localStorage.setItem(resizableStorageKey, XEUtils.toJSONString(columnWidthStorageMap));\n                }\n            },\n            saveCustomFixed: function () {\n                var id = props.id, customConfig = props.customConfig;\n                var collectColumn = internalData.collectColumn;\n                var customOpts = computeCustomOpts.value;\n                var storage = customOpts.storage;\n                var isCustomFixed = storage === true || (storage && storage.fixed);\n                if (customConfig && isCustomFixed) {\n                    var columnFixedStorageMap = getCustomStorageMap(fixedStorageKey);\n                    var colFixeds_1 = [];\n                    if (!id) {\n                        errLog('vxe.error.reqProp', ['id']);\n                        return;\n                    }\n                    XEUtils.eachTree(collectColumn, function (column) {\n                        if (column.fixed && column.fixed !== column.defaultFixed) {\n                            var colKey = column.getKey();\n                            if (colKey) {\n                                colFixeds_1.push(\"\".concat(colKey, \"|\").concat(column.fixed));\n                            }\n                        }\n                    });\n                    columnFixedStorageMap[id] = colFixeds_1.join(',') || undefined;\n                    localStorage.setItem(fixedStorageKey, XEUtils.toJSONString(columnFixedStorageMap));\n                }\n            },\n            saveCustomVisible: function () {\n                var id = props.id, customConfig = props.customConfig;\n                var collectColumn = internalData.collectColumn;\n                var customOpts = computeCustomOpts.value;\n                var checkMethod = customOpts.checkMethod, storage = customOpts.storage;\n                var isCustomVisible = storage === true || (storage && storage.visible);\n                if (customConfig && isCustomVisible) {\n                    var columnVisibleStorageMap = getCustomStorageMap(visibleStorageKey);\n                    var colHides_1 = [];\n                    var colShows_1 = [];\n                    if (!id) {\n                        errLog('vxe.error.reqProp', ['id']);\n                        return;\n                    }\n                    XEUtils.eachTree(collectColumn, function (column) {\n                        if (!checkMethod || checkMethod({ column: column })) {\n                            if (!column.visible && column.defaultVisible) {\n                                var colKey = column.getKey();\n                                if (colKey) {\n                                    colHides_1.push(colKey);\n                                }\n                            }\n                            else if (column.visible && !column.defaultVisible) {\n                                var colKey = column.getKey();\n                                if (colKey) {\n                                    colShows_1.push(colKey);\n                                }\n                            }\n                        }\n                    });\n                    columnVisibleStorageMap[id] = [colHides_1.join(',')].concat(colShows_1.length ? [colShows_1.join(',')] : []).join('|') || undefined;\n                    localStorage.setItem(visibleStorageKey, XEUtils.toJSONString(columnVisibleStorageMap));\n                }\n            },\n            handleCustom: function () {\n                tablePrivateMethods.saveCustomVisible();\n                tablePrivateMethods.analyColumnWidth();\n                return tableMethods.refreshColumn();\n            },\n            handleUpdateDataQueue: function () {\n                reactData.upDataFlag++;\n            },\n            handleRefreshColumnQueue: function () {\n                reactData.reColumnFlag++;\n            },\n            preventEvent: function (evnt, type, args, next, end) {\n                var evntList = VXETable.interceptor.get(type);\n                var rest;\n                if (!evntList.some(function (func) { return func(Object.assign({ $grid: $xegrid, $table: $xetable, $event: evnt }, args)) === false; })) {\n                    if (next) {\n                        rest = next();\n                    }\n                }\n                if (end) {\n                    end();\n                }\n                return rest;\n            },\n            checkSelectionStatus: function () {\n                var treeConfig = props.treeConfig;\n                var selectCheckboxMaps = reactData.selectCheckboxMaps, treeIndeterminateMaps = reactData.treeIndeterminateMaps;\n                var afterFullData = internalData.afterFullData;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var checkField = checkboxOpts.checkField, checkStrictly = checkboxOpts.checkStrictly, checkMethod = checkboxOpts.checkMethod;\n                var indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;\n                if (!checkStrictly) {\n                    var disableRows_1 = [];\n                    var checkRows_1 = [];\n                    var isAllResolve = false;\n                    var isAllSelected = false;\n                    var isIndeterminate = false;\n                    if (checkField) {\n                        isAllResolve = afterFullData.every(checkMethod\n                            ? function (row) {\n                                if (!checkMethod({ row: row })) {\n                                    disableRows_1.push(row);\n                                    return true;\n                                }\n                                if (XEUtils.get(row, checkField)) {\n                                    checkRows_1.push(row);\n                                    return true;\n                                }\n                                return false;\n                            }\n                            : function (row) { return XEUtils.get(row, checkField); });\n                        isAllSelected = isAllResolve && afterFullData.length !== disableRows_1.length;\n                        if (treeConfig) {\n                            if (indeterminateField) {\n                                isIndeterminate = !isAllSelected && afterFullData.some(function (row) { return XEUtils.get(row, checkField) || XEUtils.get(row, indeterminateField) || !!treeIndeterminateMaps[getRowid($xetable, row)]; });\n                            }\n                            else {\n                                isIndeterminate = !isAllSelected && afterFullData.some(function (row) { return XEUtils.get(row, checkField) || !!treeIndeterminateMaps[getRowid($xetable, row)]; });\n                            }\n                        }\n                        else {\n                            if (indeterminateField) {\n                                isIndeterminate = !isAllSelected && afterFullData.some(function (row) { return XEUtils.get(row, checkField) || XEUtils.get(row, indeterminateField); });\n                            }\n                            else {\n                                isIndeterminate = !isAllSelected && afterFullData.some(function (row) { return XEUtils.get(row, checkField); });\n                            }\n                        }\n                    }\n                    else {\n                        isAllResolve = afterFullData.every(checkMethod\n                            ? function (row) {\n                                if (!checkMethod({ row: row })) {\n                                    disableRows_1.push(row);\n                                    return true;\n                                }\n                                if (selectCheckboxMaps[getRowid($xetable, row)]) {\n                                    checkRows_1.push(row);\n                                    return true;\n                                }\n                                return false;\n                            }\n                            : function (row) { return selectCheckboxMaps[getRowid($xetable, row)]; });\n                        isAllSelected = isAllResolve && afterFullData.length !== disableRows_1.length;\n                        if (treeConfig) {\n                            isIndeterminate = !isAllSelected && afterFullData.some(function (row) {\n                                var itemRid = getRowid($xetable, row);\n                                return treeIndeterminateMaps[itemRid] || selectCheckboxMaps[itemRid];\n                            });\n                        }\n                        else {\n                            isIndeterminate = !isAllSelected && afterFullData.some(function (row) { return selectCheckboxMaps[getRowid($xetable, row)]; });\n                        }\n                    }\n                    reactData.isAllSelected = isAllSelected;\n                    reactData.isIndeterminate = isIndeterminate;\n                }\n            },\n            /**\n             * 多选，行选中事件\n             * value 选中true 不选false 半选-1\n             */\n            handleSelectRow: function (_a, value, isForce) {\n                var row = _a.row;\n                var treeConfig = props.treeConfig;\n                var selectCheckboxMaps = reactData.selectCheckboxMaps, treeIndeterminateMaps = reactData.treeIndeterminateMaps;\n                var selectRowMaps = __assign({}, selectCheckboxMaps);\n                var afterFullData = internalData.afterFullData;\n                var treeOpts = computeTreeOpts.value;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var checkField = checkboxOpts.checkField, checkStrictly = checkboxOpts.checkStrictly, checkMethod = checkboxOpts.checkMethod;\n                var indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;\n                var rowid = getRowid($xetable, row);\n                if (checkField) {\n                    if (treeConfig && !checkStrictly) {\n                        if (value === -1) {\n                            if (!treeIndeterminateMaps[rowid]) {\n                                if (indeterminateField) {\n                                    XEUtils.set(row, indeterminateField, true);\n                                }\n                                treeIndeterminateMaps[rowid] = row;\n                            }\n                            XEUtils.set(row, checkField, false);\n                        }\n                        else {\n                            // 更新子节点状态\n                            XEUtils.eachTree([row], function (item) {\n                                if ($xetable.eqRow(item, row) || (isForce || (!checkMethod || checkMethod({ row: item })))) {\n                                    XEUtils.set(item, checkField, value);\n                                    if (indeterminateField) {\n                                        XEUtils.set(row, indeterminateField, false);\n                                    }\n                                    delete treeIndeterminateMaps[getRowid($xetable, item)];\n                                    handleCheckboxReserveRow(row, value);\n                                }\n                            }, { children: childrenField });\n                        }\n                        // 如果存在父节点，更新父节点状态\n                        var matchObj = XEUtils.findTree(afterFullData, function (item) { return $xetable.eqRow(item, row); }, { children: childrenField });\n                        if (matchObj && matchObj.parent) {\n                            var parentStatus = void 0;\n                            var vItems_1 = [];\n                            var vItemMaps_1 = {};\n                            if (!isForce && checkMethod) {\n                                matchObj.items.forEach(function (item) {\n                                    if (checkMethod({ row: item })) {\n                                        var itemRid = getRowid($xetable, item);\n                                        vItemMaps_1[itemRid] = item;\n                                        vItems_1.push(item);\n                                    }\n                                });\n                            }\n                            else {\n                                matchObj.items.forEach(function (item) {\n                                    var itemRid = getRowid($xetable, item);\n                                    vItemMaps_1[itemRid] = item;\n                                    vItems_1.push(item);\n                                });\n                            }\n                            var indeterminatesItem = XEUtils.find(matchObj.items, function (item) { return !!treeIndeterminateMaps[getRowid($xetable, item)]; });\n                            if (indeterminatesItem) {\n                                parentStatus = -1;\n                            }\n                            else {\n                                var selectItems_1 = [];\n                                matchObj.items.forEach(function (item) {\n                                    if (XEUtils.get(item, checkField)) {\n                                        selectItems_1.push(item);\n                                    }\n                                });\n                                parentStatus = selectItems_1.filter(function (item) { return vItemMaps_1[getRowid($xetable, item)]; }).length === vItems_1.length ? true : (selectItems_1.length || value === -1 ? -1 : false);\n                            }\n                            reactData.selectCheckboxMaps = selectRowMaps;\n                            return tablePrivateMethods.handleSelectRow({ row: matchObj.parent }, parentStatus, isForce);\n                        }\n                    }\n                    else {\n                        if (isForce || (!checkMethod || checkMethod({ row: row }))) {\n                            XEUtils.set(row, checkField, value);\n                            handleCheckboxReserveRow(row, value);\n                        }\n                    }\n                }\n                else {\n                    if (treeConfig && !checkStrictly) {\n                        if (value === -1) {\n                            if (!treeIndeterminateMaps[rowid]) {\n                                if (indeterminateField) {\n                                    XEUtils.set(row, indeterminateField, true);\n                                }\n                                treeIndeterminateMaps[rowid] = row;\n                            }\n                            if (selectRowMaps[rowid]) {\n                                delete selectRowMaps[rowid];\n                            }\n                        }\n                        else {\n                            // 更新子节点状态\n                            XEUtils.eachTree([row], function (item) {\n                                var itemRid = getRowid($xetable, item);\n                                if ($xetable.eqRow(item, row) || (isForce || (!checkMethod || checkMethod({ row: item })))) {\n                                    if (value) {\n                                        selectRowMaps[itemRid] = item;\n                                    }\n                                    else {\n                                        if (selectRowMaps[itemRid]) {\n                                            delete selectRowMaps[itemRid];\n                                        }\n                                    }\n                                    if (indeterminateField) {\n                                        XEUtils.set(row, indeterminateField, false);\n                                    }\n                                    delete treeIndeterminateMaps[getRowid($xetable, item)];\n                                    handleCheckboxReserveRow(row, value);\n                                }\n                            }, { children: childrenField });\n                        }\n                        // 如果存在父节点，更新父节点状态\n                        var matchObj = XEUtils.findTree(afterFullData, function (item) { return $xetable.eqRow(item, row); }, { children: childrenField });\n                        if (matchObj && matchObj.parent) {\n                            var parentStatus = void 0;\n                            var vItems_2 = [];\n                            var vItemMaps_2 = {};\n                            if (!isForce && checkMethod) {\n                                matchObj.items.forEach(function (item) {\n                                    if (checkMethod({ row: item })) {\n                                        var itemRid = getRowid($xetable, item);\n                                        vItemMaps_2[itemRid] = item;\n                                        vItems_2.push(item);\n                                    }\n                                });\n                            }\n                            else {\n                                matchObj.items.forEach(function (item) {\n                                    var itemRid = getRowid($xetable, item);\n                                    vItemMaps_2[itemRid] = item;\n                                    vItems_2.push(item);\n                                });\n                            }\n                            var indeterminatesItem = XEUtils.find(matchObj.items, function (item) { return !!treeIndeterminateMaps[getRowid($xetable, item)]; });\n                            if (indeterminatesItem) {\n                                parentStatus = -1;\n                            }\n                            else {\n                                var selectItems_2 = [];\n                                matchObj.items.forEach(function (item) {\n                                    var itemRid = getRowid($xetable, item);\n                                    if (selectRowMaps[itemRid]) {\n                                        selectItems_2.push(item);\n                                    }\n                                });\n                                parentStatus = selectItems_2.filter(function (item) { return vItemMaps_2[getRowid($xetable, item)]; }).length === vItems_2.length ? true : (selectItems_2.length || value === -1 ? -1 : false);\n                            }\n                            reactData.selectCheckboxMaps = selectRowMaps;\n                            return tablePrivateMethods.handleSelectRow({ row: matchObj.parent }, parentStatus, isForce);\n                        }\n                    }\n                    else {\n                        if (isForce || (!checkMethod || checkMethod({ row: row }))) {\n                            if (value) {\n                                if (!selectRowMaps[rowid]) {\n                                    selectRowMaps[rowid] = row;\n                                }\n                            }\n                            else {\n                                if (selectRowMaps[rowid]) {\n                                    delete selectRowMaps[rowid];\n                                }\n                            }\n                            handleCheckboxReserveRow(row, value);\n                        }\n                    }\n                }\n                reactData.selectCheckboxMaps = selectRowMaps;\n                tablePrivateMethods.checkSelectionStatus();\n            },\n            triggerHeaderTitleEvent: function (evnt, iconParams, params) {\n                var tipContent = iconParams.content || iconParams.message;\n                if (tipContent) {\n                    var tooltipStore = reactData.tooltipStore;\n                    var content_1 = getFuncText(tipContent);\n                    handleTargetEnterEvent(true);\n                    tooltipStore.visible = true;\n                    tooltipStore.currOpts = __assign(__assign({}, params), { content: null });\n                    nextTick(function () {\n                        var $tooltip = refTooltip.value;\n                        if ($tooltip) {\n                            $tooltip.open(evnt.currentTarget, content_1);\n                        }\n                    });\n                }\n            },\n            /**\n             * 触发表头 tooltip 事件\n             */\n            triggerHeaderTooltipEvent: function (evnt, params) {\n                var tooltipStore = reactData.tooltipStore;\n                var column = params.column;\n                var titleElem = evnt.currentTarget;\n                handleTargetEnterEvent(true);\n                if (tooltipStore.column !== column || !tooltipStore.visible) {\n                    handleTooltip(evnt, titleElem, titleElem, null, params);\n                }\n            },\n            /**\n             * 触发单元格 tooltip 事件\n             */\n            triggerBodyTooltipEvent: function (evnt, params) {\n                var editConfig = props.editConfig;\n                var editStore = reactData.editStore;\n                var tooltipStore = reactData.tooltipStore;\n                var editOpts = computeEditOpts.value;\n                var actived = editStore.actived;\n                var row = params.row, column = params.column;\n                var cell = evnt.currentTarget;\n                handleTargetEnterEvent(tooltipStore.column !== column || tooltipStore.row !== row);\n                // 单元格处于编辑状态时不触发提示框\n                if (column.editRender && isEnableConf(editConfig)) {\n                    // 如果是行编辑模式\n                    if (editOpts.mode === 'row' && actived.row === row) {\n                        return;\n                    }\n                    // 如果是单元格编辑模式\n                    if (actived.row === row && actived.column === column) {\n                        return;\n                    }\n                }\n                if (tooltipStore.column !== column || tooltipStore.row !== row || !tooltipStore.visible) {\n                    var overflowElem = void 0;\n                    var tipElem = void 0;\n                    if (column.treeNode) {\n                        overflowElem = cell.querySelector('.vxe-tree-cell');\n                        if (column.type === 'html') {\n                            tipElem = cell.querySelector('.vxe-cell--html');\n                        }\n                    }\n                    else {\n                        tipElem = cell.querySelector(column.type === 'html' ? '.vxe-cell--html' : '.vxe-cell--label');\n                    }\n                    handleTooltip(evnt, cell, (overflowElem || cell.children[0]), tipElem, params);\n                }\n            },\n            /**\n             * 触发表尾 tooltip 事件\n             */\n            triggerFooterTooltipEvent: function (evnt, params) {\n                var column = params.column;\n                var tooltipStore = reactData.tooltipStore;\n                var cell = evnt.currentTarget;\n                handleTargetEnterEvent(tooltipStore.column !== column || !!tooltipStore.row);\n                if (tooltipStore.column !== column || !tooltipStore.visible) {\n                    handleTooltip(evnt, cell, cell.querySelector('.vxe-cell--item') || cell.children[0], null, params);\n                }\n            },\n            handleTargetLeaveEvent: function () {\n                var tooltipOpts = computeTooltipOpts.value;\n                var $tooltip = refTooltip.value;\n                if ($tooltip) {\n                    $tooltip.setActived(false);\n                }\n                if (tooltipOpts.enterable) {\n                    internalData.tooltipTimeout = setTimeout(function () {\n                        $tooltip = refTooltip.value;\n                        if ($tooltip && !$tooltip.isActived()) {\n                            tableMethods.closeTooltip();\n                        }\n                    }, tooltipOpts.leaveDelay);\n                }\n                else {\n                    tableMethods.closeTooltip();\n                }\n            },\n            triggerHeaderCellClickEvent: function (evnt, params) {\n                var _lastResizeTime = internalData._lastResizeTime;\n                var sortOpts = computeSortOpts.value;\n                var columnOpts = computeColumnOpts.value;\n                var column = params.column;\n                var cell = evnt.currentTarget;\n                var triggerResizable = _lastResizeTime && _lastResizeTime > Date.now() - 300;\n                var triggerSort = getEventTargetNode(evnt, cell, 'vxe-cell--sort').flag;\n                var triggerFilter = getEventTargetNode(evnt, cell, 'vxe-cell--filter').flag;\n                if (sortOpts.trigger === 'cell' && !(triggerResizable || triggerSort || triggerFilter)) {\n                    tablePrivateMethods.triggerSortEvent(evnt, column, getNextSortOrder(column));\n                }\n                tableMethods.dispatchEvent('header-cell-click', Object.assign({ triggerResizable: triggerResizable, triggerSort: triggerSort, triggerFilter: triggerFilter, cell: cell }, params), evnt);\n                if (columnOpts.isCurrent || props.highlightCurrentColumn) {\n                    tableMethods.setCurrentColumn(column);\n                }\n            },\n            triggerHeaderCellDblclickEvent: function (evnt, params) {\n                tableMethods.dispatchEvent('header-cell-dblclick', Object.assign({ cell: evnt.currentTarget }, params), evnt);\n            },\n            /**\n             * 列点击事件\n             * 如果是单击模式，则激活为编辑状态\n             * 如果是双击模式，则单击后选中状态\n             */\n            triggerCellClickEvent: function (evnt, params) {\n                var highlightCurrentRow = props.highlightCurrentRow, editConfig = props.editConfig;\n                var editStore = reactData.editStore;\n                var expandOpts = computeExpandOpts.value;\n                var editOpts = computeEditOpts.value;\n                var treeOpts = computeTreeOpts.value;\n                var radioOpts = computeRadioOpts.value;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var rowOpts = computeRowOpts.value;\n                var actived = editStore.actived;\n                var row = params.row, column = params.column;\n                var type = column.type, treeNode = column.treeNode;\n                var isRadioType = type === 'radio';\n                var isCheckboxType = type === 'checkbox';\n                var isExpandType = type === 'expand';\n                var cell = evnt.currentTarget;\n                var triggerRadio = isRadioType && getEventTargetNode(evnt, cell, 'vxe-cell--radio').flag;\n                var triggerCheckbox = isCheckboxType && getEventTargetNode(evnt, cell, 'vxe-cell--checkbox').flag;\n                var triggerTreeNode = treeNode && getEventTargetNode(evnt, cell, 'vxe-tree--btn-wrapper').flag;\n                var triggerExpandNode = isExpandType && getEventTargetNode(evnt, cell, 'vxe-table--expanded').flag;\n                params = Object.assign({ cell: cell, triggerRadio: triggerRadio, triggerCheckbox: triggerCheckbox, triggerTreeNode: triggerTreeNode, triggerExpandNode: triggerExpandNode }, params);\n                if (!triggerCheckbox && !triggerRadio) {\n                    // 如果是展开行\n                    if (!triggerExpandNode && (expandOpts.trigger === 'row' || (isExpandType && expandOpts.trigger === 'cell'))) {\n                        tablePrivateMethods.triggerRowExpandEvent(evnt, params);\n                    }\n                    // 如果是树形表格\n                    if ((treeOpts.trigger === 'row' || (treeNode && treeOpts.trigger === 'cell'))) {\n                        tablePrivateMethods.triggerTreeExpandEvent(evnt, params);\n                    }\n                }\n                // 如果点击了树节点\n                if (!triggerTreeNode) {\n                    if (!triggerExpandNode) {\n                        // 如果是高亮行\n                        if (rowOpts.isCurrent || highlightCurrentRow) {\n                            if (!triggerCheckbox && !triggerRadio) {\n                                tablePrivateMethods.triggerCurrentRowEvent(evnt, params);\n                            }\n                        }\n                        // 如果是单选框\n                        if (!triggerRadio && (radioOpts.trigger === 'row' || (isRadioType && radioOpts.trigger === 'cell'))) {\n                            tablePrivateMethods.triggerRadioRowEvent(evnt, params);\n                        }\n                        // 如果是复选框\n                        if (!triggerCheckbox && (checkboxOpts.trigger === 'row' || (isCheckboxType && checkboxOpts.trigger === 'cell'))) {\n                            tablePrivateMethods.handleToggleCheckRowEvent(evnt, params);\n                        }\n                    }\n                    // 如果设置了单元格选中功能，则不会使用点击事件去处理（只能支持双击模式）\n                    if (isEnableConf(editConfig)) {\n                        if (editOpts.trigger === 'manual') {\n                            if (actived.args && actived.row === row && column !== actived.column) {\n                                handleChangeCell(evnt, params);\n                            }\n                        }\n                        else if (!actived.args || row !== actived.row || column !== actived.column) {\n                            if (editOpts.trigger === 'click') {\n                                handleChangeCell(evnt, params);\n                            }\n                            else if (editOpts.trigger === 'dblclick') {\n                                if (editOpts.mode === 'row' && actived.row === row) {\n                                    handleChangeCell(evnt, params);\n                                }\n                            }\n                        }\n                    }\n                }\n                tableMethods.dispatchEvent('cell-click', params, evnt);\n            },\n            /**\n             * 列双击点击事件\n             * 如果是双击模式，则激活为编辑状态\n             */\n            triggerCellDblclickEvent: function (evnt, params) {\n                var editConfig = props.editConfig;\n                var editStore = reactData.editStore;\n                var editOpts = computeEditOpts.value;\n                var actived = editStore.actived;\n                var cell = evnt.currentTarget;\n                params = Object.assign({ cell: cell }, params);\n                if (isEnableConf(editConfig) && editOpts.trigger === 'dblclick') {\n                    if (!actived.args || evnt.currentTarget !== actived.args.cell) {\n                        if (editOpts.mode === 'row') {\n                            checkValidate('blur')\n                                .catch(function (e) { return e; })\n                                .then(function () {\n                                $xetable.handleActived(params, evnt)\n                                    .then(function () { return checkValidate('change'); })\n                                    .catch(function (e) { return e; });\n                            });\n                        }\n                        else if (editOpts.mode === 'cell') {\n                            $xetable.handleActived(params, evnt)\n                                .then(function () { return checkValidate('change'); })\n                                .catch(function (e) { return e; });\n                        }\n                    }\n                }\n                tableMethods.dispatchEvent('cell-dblclick', params, evnt);\n            },\n            handleToggleCheckRowEvent: function (evnt, params) {\n                var selectCheckboxMaps = reactData.selectCheckboxMaps;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var checkField = checkboxOpts.checkField;\n                var row = params.row;\n                var value = false;\n                if (checkField) {\n                    value = !XEUtils.get(row, checkField);\n                }\n                else {\n                    value = !selectCheckboxMaps[getRowid($xetable, row)];\n                }\n                if (evnt) {\n                    tablePrivateMethods.triggerCheckRowEvent(evnt, params, value);\n                }\n                else {\n                    tablePrivateMethods.handleSelectRow(params, value);\n                }\n            },\n            triggerCheckRowEvent: function (evnt, params, value) {\n                var checkboxOpts = computeCheckboxOpts.value;\n                var row = params.row;\n                var afterFullData = internalData.afterFullData;\n                var checkMethod = checkboxOpts.checkMethod;\n                if (checkboxOpts.isShiftKey && evnt.shiftKey && !props.treeConfig) {\n                    var checkboxRecords = tableMethods.getCheckboxRecords();\n                    if (checkboxRecords.length) {\n                        var firstRow = checkboxRecords[0];\n                        var _rowIndex = tableMethods.getVTRowIndex(row);\n                        var _firstRowIndex = tableMethods.getVTRowIndex(firstRow);\n                        if (_rowIndex !== _firstRowIndex) {\n                            tableMethods.setAllCheckboxRow(false);\n                            var rangeRows = _rowIndex < _firstRowIndex ? afterFullData.slice(_rowIndex, _firstRowIndex + 1) : afterFullData.slice(_firstRowIndex, _rowIndex + 1);\n                            handleCheckedCheckboxRow(rangeRows, true, false);\n                            tableMethods.dispatchEvent('checkbox-range-select', Object.assign({ rangeRecords: rangeRows }, params), evnt);\n                            return;\n                        }\n                    }\n                }\n                if (!checkMethod || checkMethod({ row: row })) {\n                    tablePrivateMethods.handleSelectRow(params, value);\n                    tableMethods.dispatchEvent('checkbox-change', Object.assign({\n                        records: tableMethods.getCheckboxRecords(),\n                        reserves: tableMethods.getCheckboxReserveRecords(),\n                        indeterminates: tableMethods.getCheckboxIndeterminateRecords(),\n                        checked: value\n                    }, params), evnt);\n                }\n            },\n            /**\n             * 多选，选中所有事件\n             */\n            triggerCheckAllEvent: function (evnt, value) {\n                handleCheckedAllCheckboxRow(value);\n                if (evnt) {\n                    tableMethods.dispatchEvent('checkbox-all', {\n                        records: tableMethods.getCheckboxRecords(),\n                        reserves: tableMethods.getCheckboxReserveRecords(),\n                        indeterminates: tableMethods.getCheckboxIndeterminateRecords(),\n                        checked: value\n                    }, evnt);\n                }\n            },\n            /**\n             * 单选，行选中事件\n             */\n            triggerRadioRowEvent: function (evnt, params) {\n                var oldValue = reactData.selectRadioRow;\n                var row = params.row;\n                var radioOpts = computeRadioOpts.value;\n                var newValue = row;\n                var isChange = oldValue !== newValue;\n                if (isChange) {\n                    handleCheckedRadioRow(newValue);\n                }\n                else if (!radioOpts.strict) {\n                    isChange = oldValue === newValue;\n                    if (isChange) {\n                        newValue = null;\n                        tableMethods.clearRadioRow();\n                    }\n                }\n                if (isChange) {\n                    tableMethods.dispatchEvent('radio-change', __assign({ oldValue: oldValue, newValue: newValue }, params), evnt);\n                }\n            },\n            triggerCurrentRowEvent: function (evnt, params) {\n                var oldValue = reactData.currentRow;\n                var newValue = params.row;\n                var isChange = oldValue !== newValue;\n                tableMethods.setCurrentRow(newValue);\n                if (isChange) {\n                    tableMethods.dispatchEvent('current-change', __assign({ oldValue: oldValue, newValue: newValue }, params), evnt);\n                }\n            },\n            /**\n             * 展开行事件\n             */\n            triggerRowExpandEvent: function (evnt, params) {\n                var rowExpandLazyLoadedMaps = reactData.rowExpandLazyLoadedMaps, column = reactData.expandColumn;\n                var expandOpts = computeExpandOpts.value;\n                var row = params.row;\n                var lazy = expandOpts.lazy;\n                var rowid = getRowid($xetable, row);\n                if (!lazy || !rowExpandLazyLoadedMaps[rowid]) {\n                    var expanded = !tableMethods.isExpandByRow(row);\n                    var columnIndex = tableMethods.getColumnIndex(column);\n                    var $columnIndex = tableMethods.getVMColumnIndex(column);\n                    tableMethods.setRowExpand(row, expanded);\n                    tableMethods.dispatchEvent('toggle-row-expand', {\n                        expanded: expanded,\n                        column: column,\n                        columnIndex: columnIndex,\n                        $columnIndex: $columnIndex,\n                        row: row,\n                        rowIndex: tableMethods.getRowIndex(row),\n                        $rowIndex: tableMethods.getVMRowIndex(row)\n                    }, evnt);\n                }\n            },\n            /**\n             * 展开树节点事件\n             */\n            triggerTreeExpandEvent: function (evnt, params) {\n                var treeExpandLazyLoadedMaps = reactData.treeExpandLazyLoadedMaps;\n                var treeOpts = computeTreeOpts.value;\n                var row = params.row, column = params.column;\n                var lazy = treeOpts.lazy;\n                var rowid = getRowid($xetable, row);\n                if (!lazy || !treeExpandLazyLoadedMaps[rowid]) {\n                    var expanded = !tableMethods.isTreeExpandByRow(row);\n                    var columnIndex = tableMethods.getColumnIndex(column);\n                    var $columnIndex = tableMethods.getVMColumnIndex(column);\n                    tableMethods.setTreeExpand(row, expanded);\n                    tableMethods.dispatchEvent('toggle-tree-expand', { expanded: expanded, column: column, columnIndex: columnIndex, $columnIndex: $columnIndex, row: row }, evnt);\n                }\n            },\n            /**\n             * 点击排序事件\n             */\n            triggerSortEvent: function (evnt, column, order) {\n                var mouseConfig = props.mouseConfig;\n                var sortOpts = computeSortOpts.value;\n                var mouseOpts = computeMouseOpts.value;\n                var field = column.field, sortable = column.sortable;\n                if (sortable) {\n                    if (!order || column.order === order) {\n                        tableMethods.clearSort(sortOpts.multiple ? column : null);\n                    }\n                    else {\n                        tableMethods.sort({ field: field, order: order });\n                    }\n                    var params = { $table: $xetable, $event: evnt, column: column, field: field, property: field, order: column.order, sortList: tableMethods.getSortColumns(), sortTime: column.sortTime };\n                    if (mouseConfig && mouseOpts.area && $xetable.handleSortEvent) {\n                        $xetable.handleSortEvent(evnt, params);\n                    }\n                    tableMethods.dispatchEvent('sort-change', params, evnt);\n                }\n            },\n            /**\n             * 横向 X 可视渲染事件处理\n             */\n            triggerScrollXEvent: function () {\n                loadScrollXData();\n            },\n            /**\n             * 纵向 Y 可视渲染事件处理\n             */\n            triggerScrollYEvent: function (evnt) {\n                var scrollYStore = internalData.scrollYStore;\n                var adaptive = scrollYStore.adaptive, offsetSize = scrollYStore.offsetSize, visibleSize = scrollYStore.visibleSize;\n                // webkit 浏览器使用最佳的渲染方式，且最高渲染量不能大于 40 条\n                if (isWebkit && adaptive && (offsetSize * 2 + visibleSize) <= 40) {\n                    loadScrollYData(evnt);\n                }\n                else {\n                    debounceScrollY(evnt);\n                }\n            },\n            /**\n             * 对于树形结构中，可以直接滚动到指定深层节点中\n             * 对于某些特定的场景可能会用到，比如定位到某一节点\n             * @param {Row} row 行对象\n             */\n            scrollToTreeRow: function (row) {\n                var treeConfig = props.treeConfig;\n                var tableFullData = internalData.tableFullData;\n                var rests = [];\n                if (treeConfig) {\n                    var treeOpts = computeTreeOpts.value;\n                    var childrenField = treeOpts.children || treeOpts.childrenField;\n                    var matchObj = XEUtils.findTree(tableFullData, function (item) { return $xetable.eqRow(item, row); }, { children: childrenField });\n                    if (matchObj) {\n                        var nodes_1 = matchObj.nodes;\n                        nodes_1.forEach(function (row, index) {\n                            if (index < nodes_1.length - 1 && !tableMethods.isTreeExpandByRow(row)) {\n                                rests.push(tableMethods.setTreeExpand(row, true));\n                            }\n                        });\n                    }\n                }\n                return Promise.all(rests).then(function () { return rowToVisible($xetable, row); });\n            },\n            updateScrollYStatus: updateScrollYStatus,\n            // 更新横向 X 可视渲染上下剩余空间大小\n            updateScrollXSpace: function () {\n                var isGroup = reactData.isGroup, scrollXLoad = reactData.scrollXLoad, scrollbarWidth = reactData.scrollbarWidth;\n                var visibleColumn = internalData.visibleColumn, scrollXStore = internalData.scrollXStore, elemStore = internalData.elemStore, tableWidth = internalData.tableWidth;\n                var tableHeader = refTableHeader.value;\n                var tableBody = refTableBody.value;\n                var tableFooter = refTableFooter.value;\n                var tableBodyElem = tableBody ? tableBody.$el : null;\n                if (tableBodyElem) {\n                    var tableHeaderElem = tableHeader ? tableHeader.$el : null;\n                    var tableFooterElem = tableFooter ? tableFooter.$el : null;\n                    var headerElem = tableHeaderElem ? tableHeaderElem.querySelector('.vxe-table--header') : null;\n                    var bodyElem = tableBodyElem.querySelector('.vxe-table--body');\n                    var footerElem = tableFooterElem ? tableFooterElem.querySelector('.vxe-table--footer') : null;\n                    var leftSpaceWidth = visibleColumn.slice(0, scrollXStore.startIndex).reduce(function (previous, column) { return previous + column.renderWidth; }, 0);\n                    var marginLeft = '';\n                    if (scrollXLoad) {\n                        marginLeft = \"\".concat(leftSpaceWidth, \"px\");\n                    }\n                    if (headerElem) {\n                        headerElem.style.marginLeft = isGroup ? '' : marginLeft;\n                    }\n                    bodyElem.style.marginLeft = marginLeft;\n                    if (footerElem) {\n                        footerElem.style.marginLeft = marginLeft;\n                    }\n                    var containerList = ['main'];\n                    containerList.forEach(function (name) {\n                        var layoutList = ['header', 'body', 'footer'];\n                        layoutList.forEach(function (layout) {\n                            var xSpaceRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-xSpace\")];\n                            var xSpaceElem = xSpaceRef ? xSpaceRef.value : null;\n                            if (xSpaceElem) {\n                                xSpaceElem.style.width = scrollXLoad ? \"\".concat(tableWidth + (layout === 'header' ? scrollbarWidth : 0), \"px\") : '';\n                            }\n                        });\n                    });\n                    nextTick(updateStyle);\n                }\n            },\n            // 更新纵向 Y 可视渲染上下剩余空间大小\n            updateScrollYSpace: function () {\n                var scrollYLoad = reactData.scrollYLoad;\n                var scrollYStore = internalData.scrollYStore, elemStore = internalData.elemStore, afterFullData = internalData.afterFullData;\n                var startIndex = scrollYStore.startIndex, rowHeight = scrollYStore.rowHeight;\n                var bodyHeight = afterFullData.length * rowHeight;\n                var topSpaceHeight = Math.max(0, startIndex * rowHeight);\n                var containerList = ['main', 'left', 'right'];\n                var marginTop = '';\n                var ySpaceHeight = '';\n                if (scrollYLoad) {\n                    marginTop = \"\".concat(topSpaceHeight, \"px\");\n                    ySpaceHeight = \"\".concat(bodyHeight, \"px\");\n                }\n                containerList.forEach(function (name) {\n                    var layoutList = ['header', 'body', 'footer'];\n                    var tableRef = elemStore[\"\".concat(name, \"-body-table\")];\n                    var tableElem = tableRef ? tableRef.value : null;\n                    if (tableElem) {\n                        tableElem.style.marginTop = marginTop;\n                    }\n                    layoutList.forEach(function (layout) {\n                        var ySpaceRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-ySpace\")];\n                        var ySpaceElem = ySpaceRef ? ySpaceRef.value : null;\n                        if (ySpaceElem) {\n                            ySpaceElem.style.height = ySpaceHeight;\n                        }\n                    });\n                });\n                nextTick(updateStyle);\n            },\n            updateScrollXData: function () {\n                // reactData.tableColumn = []\n                nextTick(function () {\n                    handleTableColumn();\n                    tablePrivateMethods.updateScrollXSpace();\n                });\n            },\n            updateScrollYData: function () {\n                // reactData.tableData = []\n                nextTick(function () {\n                    tablePrivateMethods.handleTableData();\n                    tablePrivateMethods.updateScrollYSpace();\n                });\n            },\n            /**\n             * 处理固定列的显示状态\n             */\n            checkScrolling: function () {\n                var leftContainerElem = refLeftContainer.value;\n                var rightContainerElem = refRightContainer.value;\n                var tableBody = refTableBody.value;\n                var bodyElem = tableBody ? tableBody.$el : null;\n                if (bodyElem) {\n                    if (leftContainerElem) {\n                        if (bodyElem.scrollLeft > 0) {\n                            addClass(leftContainerElem, 'scrolling--middle');\n                        }\n                        else {\n                            removeClass(leftContainerElem, 'scrolling--middle');\n                        }\n                    }\n                    if (rightContainerElem) {\n                        if (bodyElem.clientWidth < bodyElem.scrollWidth - Math.ceil(bodyElem.scrollLeft)) {\n                            addClass(rightContainerElem, 'scrolling--middle');\n                        }\n                        else {\n                            removeClass(rightContainerElem, 'scrolling--middle');\n                        }\n                    }\n                }\n            },\n            updateZindex: function () {\n                if (props.zIndex) {\n                    internalData.tZindex = props.zIndex;\n                }\n                else if (internalData.tZindex < getLastZIndex()) {\n                    internalData.tZindex = nextZIndex();\n                }\n            },\n            handleCheckedCheckboxRow: handleCheckedCheckboxRow,\n            /**\n             * 行 hover 事件\n             */\n            triggerHoverEvent: function (evnt, _a) {\n                var row = _a.row;\n                tablePrivateMethods.setHoverRow(row);\n            },\n            setHoverRow: function (row) {\n                var rowid = getRowid($xetable, row);\n                var el = refElem.value;\n                tablePrivateMethods.clearHoverRow();\n                if (el) {\n                    XEUtils.arrayEach(el.querySelectorAll(\"[rowid=\\\"\".concat(rowid, \"\\\"]\")), function (elem) { return addClass(elem, 'row--hover'); });\n                }\n                internalData.hoverRow = row;\n            },\n            clearHoverRow: function () {\n                var el = refElem.value;\n                if (el) {\n                    XEUtils.arrayEach(el.querySelectorAll('.vxe-body--row.row--hover'), function (elem) { return removeClass(elem, 'row--hover'); });\n                }\n                internalData.hoverRow = null;\n            },\n            getCell: function (row, column) {\n                var rowid = getRowid($xetable, row);\n                var tableBody = refTableBody.value;\n                var leftBody = refTableLeftBody.value;\n                var rightBody = refTableRightBody.value;\n                var bodyElem;\n                if (column) {\n                    if (column.fixed) {\n                        if (column.fixed === 'left') {\n                            if (leftBody) {\n                                bodyElem = leftBody.$el;\n                            }\n                        }\n                        else {\n                            if (rightBody) {\n                                bodyElem = rightBody.$el;\n                            }\n                        }\n                    }\n                    if (!bodyElem) {\n                        bodyElem = tableBody.$el;\n                    }\n                    if (bodyElem) {\n                        return bodyElem.querySelector(\".vxe-body--row[rowid=\\\"\".concat(rowid, \"\\\"] .\").concat(column.id));\n                    }\n                }\n                return null;\n            },\n            getCellLabel: function (row, column) {\n                var formatter = column.formatter;\n                var cellValue = getCellValue(row, column);\n                var cellLabel = cellValue;\n                if (formatter) {\n                    var formatData = void 0;\n                    var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                    var rowid = getRowid($xetable, row);\n                    var colid = column.id;\n                    var rest = fullAllDataRowIdData[rowid];\n                    if (rest) {\n                        formatData = rest.formatData;\n                        if (!formatData) {\n                            formatData = fullAllDataRowIdData[rowid].formatData = {};\n                        }\n                        if (rest && formatData[colid]) {\n                            if (formatData[colid].value === cellValue) {\n                                return formatData[colid].label;\n                            }\n                        }\n                    }\n                    var formatParams = { cellValue: cellValue, row: row, rowIndex: tableMethods.getRowIndex(row), column: column, columnIndex: tableMethods.getColumnIndex(column) };\n                    if (XEUtils.isString(formatter)) {\n                        var gFormatOpts = VXETable.formats.get(formatter);\n                        cellLabel = gFormatOpts && gFormatOpts.cellFormatMethod ? gFormatOpts.cellFormatMethod(formatParams) : '';\n                    }\n                    else if (XEUtils.isArray(formatter)) {\n                        var gFormatOpts = VXETable.formats.get(formatter[0]);\n                        cellLabel = gFormatOpts && gFormatOpts.cellFormatMethod ? gFormatOpts.cellFormatMethod.apply(gFormatOpts, __spreadArray([formatParams], formatter.slice(1), false)) : '';\n                    }\n                    else {\n                        cellLabel = formatter(formatParams);\n                    }\n                    if (formatData) {\n                        formatData[colid] = { value: cellValue, label: cellLabel };\n                    }\n                }\n                return cellLabel;\n            },\n            findRowIndexOf: function (list, row) {\n                return row ? XEUtils.findIndexOf(list, function (item) { return $xetable.eqRow(item, row); }) : -1;\n            },\n            eqRow: function (row1, row2) {\n                if (row1 && row2) {\n                    if (row1 === row2) {\n                        return true;\n                    }\n                    return getRowid($xetable, row1) === getRowid($xetable, row2);\n                }\n                return false;\n            }\n        };\n        // 检测对应模块是否安装\n        if (process.env.NODE_ENV === 'development') {\n            'openExport,openPrint,exportData,openImport,importData,saveFile,readFile,importByFile,print'.split(',').forEach(function (name) {\n                $xetable[name] = function () {\n                    errLog('vxe.error.reqModule', ['Export']);\n                };\n            });\n            'clearValidate,fullValidate,validate'.split(',').forEach(function (name) {\n                $xetable[name] = function () {\n                    errLog('vxe.error.reqModule', ['Validator']);\n                };\n            });\n        }\n        Object.assign($xetable, tableMethods, tablePrivateMethods);\n        /**\n         * 渲染浮固定列\n         * 分别渲染左边固定列和右边固定列\n         * 如果宽度足够情况下，则不需要渲染固定列\n         * @param {String} fixedType 固定列类型\n         */\n        var renderFixed = function (fixedType) {\n            var showHeader = props.showHeader, showFooter = props.showFooter;\n            var tableData = reactData.tableData, tableColumn = reactData.tableColumn, tableGroupColumn = reactData.tableGroupColumn, columnStore = reactData.columnStore, footerTableData = reactData.footerTableData;\n            var isFixedLeft = fixedType === 'left';\n            var fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;\n            return h('div', {\n                ref: isFixedLeft ? refLeftContainer : refRightContainer,\n                class: \"vxe-table--fixed-\".concat(fixedType, \"-wrapper\")\n            }, [\n                showHeader ? h(TableHeaderComponent, {\n                    ref: isFixedLeft ? refTableLeftHeader : refTableRightHeader,\n                    fixedType: fixedType,\n                    tableData: tableData,\n                    tableColumn: tableColumn,\n                    tableGroupColumn: tableGroupColumn,\n                    fixedColumn: fixedColumn\n                }) : createCommentVNode(),\n                h(TableBodyComponent, {\n                    ref: isFixedLeft ? refTableLeftBody : refTableRightBody,\n                    fixedType: fixedType,\n                    tableData: tableData,\n                    tableColumn: tableColumn,\n                    fixedColumn: fixedColumn\n                }),\n                showFooter ? h(TableFooterComponent, {\n                    ref: isFixedLeft ? refTableLeftFooter : refTableRightFooter,\n                    footerTableData: footerTableData,\n                    tableColumn: tableColumn,\n                    fixedColumn: fixedColumn,\n                    fixedType: fixedType\n                }) : createCommentVNode()\n            ]);\n        };\n        var renderEmptyContenet = function () {\n            var emptyOpts = computeEmptyOpts.value;\n            var params = { $table: $xetable };\n            if (slots.empty) {\n                return slots.empty(params);\n            }\n            else {\n                var compConf = emptyOpts.name ? VXETable.renderer.get(emptyOpts.name) : null;\n                var renderEmpty = compConf ? compConf.renderEmpty : null;\n                if (renderEmpty) {\n                    return getSlotVNs(renderEmpty(emptyOpts, params));\n                }\n            }\n            return getFuncText(props.emptyText) || GlobalConfig.i18n('vxe.table.emptyText');\n        };\n        function handleUupdateResize() {\n            var el = refElem.value;\n            if (el && el.clientWidth && el.clientHeight) {\n                tableMethods.recalculate();\n            }\n        }\n        var dataFlag = ref(0);\n        watch(function () { return props.data ? props.data.length : -1; }, function () {\n            dataFlag.value++;\n        });\n        watch(function () { return props.data; }, function () {\n            dataFlag.value++;\n        });\n        watch(dataFlag, function () {\n            var inited = internalData.inited, initStatus = internalData.initStatus;\n            loadTableData(props.data || []).then(function () {\n                var scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad, expandColumn = reactData.expandColumn;\n                internalData.inited = true;\n                internalData.initStatus = true;\n                if (!initStatus) {\n                    handleLoadDefaults();\n                }\n                if (!inited) {\n                    handleInitDefaults();\n                }\n                if (process.env.NODE_ENV === 'development') {\n                    // const checkboxOpts = computeCheckboxOpts.value\n                    // const checkboxColumn = internalData.tableFullColumn.find(column => column.type === 'checkbox')\n                    // if (checkboxColumn && internalData.tableFullData.length > 300 && !checkboxOpts.checkField) {\n                    //   warnLog('vxe.error.checkProp', ['checkbox-config.checkField'])\n                    // }\n                    if ((scrollXLoad || scrollYLoad) && expandColumn) {\n                        warnLog('vxe.error.scrollErrProp', ['column.type=expand']);\n                    }\n                }\n                tableMethods.recalculate();\n            });\n        });\n        var staticColumnFlag = ref(0);\n        watch(function () { return reactData.staticColumns.length; }, function () {\n            staticColumnFlag.value++;\n        });\n        watch(function () { return reactData.staticColumns; }, function () {\n            staticColumnFlag.value++;\n        });\n        watch(staticColumnFlag, function () {\n            handleColumn(reactData.staticColumns);\n        });\n        var tableColumnFlag = ref(0);\n        watch(function () { return reactData.tableColumn.length; }, function () {\n            tableColumnFlag.value++;\n        });\n        watch(function () { return reactData.tableColumn; }, function () {\n            tableColumnFlag.value++;\n        });\n        watch(tableColumnFlag, function () {\n            tablePrivateMethods.analyColumnWidth();\n        });\n        watch(function () { return reactData.upDataFlag; }, function () {\n            nextTick(function () {\n                tableMethods.updateData();\n            });\n        });\n        watch(function () { return reactData.reColumnFlag; }, function () {\n            nextTick(function () {\n                tableMethods.refreshColumn();\n            });\n        });\n        watch(function () { return props.showHeader; }, function () {\n            nextTick(function () {\n                tableMethods.recalculate(true).then(function () { return tableMethods.refreshScroll(); });\n            });\n        });\n        watch(function () { return props.showFooter; }, function () {\n            nextTick(function () {\n                tableMethods.recalculate(true).then(function () { return tableMethods.refreshScroll(); });\n            });\n        });\n        watch(function () { return props.height; }, function () {\n            nextTick(function () { return tableMethods.recalculate(true); });\n        });\n        watch(function () { return props.maxHeight; }, function () {\n            nextTick(function () { return tableMethods.recalculate(true); });\n        });\n        watch(function () { return props.syncResize; }, function (value) {\n            if (value) {\n                handleUupdateResize();\n                nextTick(function () {\n                    handleUupdateResize();\n                    setTimeout(function () { return handleUupdateResize(); });\n                });\n            }\n        });\n        var mergeCellFlag = ref(0);\n        watch(function () { return props.mergeCells ? props.mergeCells.length : -1; }, function () {\n            mergeCellFlag.value++;\n        });\n        watch(function () { return props.mergeCells; }, function () {\n            mergeCellFlag.value++;\n        });\n        watch(mergeCellFlag, function () {\n            tableMethods.clearMergeCells();\n            nextTick(function () {\n                if (props.mergeCells) {\n                    tableMethods.setMergeCells(props.mergeCells);\n                }\n            });\n        });\n        var mergeFooterItemFlag = ref(0);\n        watch(function () { return props.mergeFooterItems ? props.mergeFooterItems.length : -1; }, function () {\n            mergeFooterItemFlag.value++;\n        });\n        watch(function () { return props.mergeFooterItems; }, function () {\n            mergeFooterItemFlag.value++;\n        });\n        watch(mergeFooterItemFlag, function () {\n            tableMethods.clearMergeFooterItems();\n            nextTick(function () {\n                if (props.mergeFooterItems) {\n                    tableMethods.setMergeFooterItems(props.mergeFooterItems);\n                }\n            });\n        });\n        VXETable.hooks.forEach(function (options) {\n            var setupTable = options.setupTable;\n            if (setupTable) {\n                var hookRest = setupTable($xetable);\n                if (hookRest && XEUtils.isObject(hookRest)) {\n                    Object.assign($xetable, hookRest);\n                }\n            }\n        });\n        tablePrivateMethods.preventEvent(null, 'created', { $table: $xetable });\n        var resizeObserver;\n        onActivated(function () {\n            tableMethods.recalculate().then(function () { return tableMethods.refreshScroll(); });\n            tablePrivateMethods.preventEvent(null, 'activated', { $table: $xetable });\n        });\n        onDeactivated(function () {\n            internalData.isActivated = false;\n            tablePrivateMethods.preventEvent(null, 'deactivated', { $table: $xetable });\n        });\n        onMounted(function () {\n            nextTick(function () {\n                var data = props.data, treeConfig = props.treeConfig, showOverflow = props.showOverflow;\n                var scrollXStore = internalData.scrollXStore, scrollYStore = internalData.scrollYStore;\n                var sYOpts = computeSYOpts.value;\n                var editOpts = computeEditOpts.value;\n                var treeOpts = computeTreeOpts.value;\n                var radioOpts = computeRadioOpts.value;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var expandOpts = computeExpandOpts.value;\n                var rowOpts = computeRowOpts.value;\n                if (process.env.NODE_ENV === 'development') {\n                    // if (props.rowId) {\n                    //   warnLog('vxe.error.delProp', ['row-id', 'row-config.keyField'])\n                    // }\n                    // if (props.rowKey) {\n                    //   warnLog('vxe.error.delProp', ['row-id', 'row-config.useKey'])\n                    // }\n                    // if (props.columnKey) {\n                    //   warnLog('vxe.error.delProp', ['row-id', 'column-config.useKey'])\n                    // }\n                    if (!(props.rowId || rowOpts.keyField) && (checkboxOpts.reserve || checkboxOpts.checkRowKeys || radioOpts.reserve || radioOpts.checkRowKey || expandOpts.expandRowKeys || treeOpts.expandRowKeys)) {\n                        warnLog('vxe.error.reqProp', ['row-config.keyField']);\n                    }\n                    if (props.editConfig && (editOpts.showStatus || editOpts.showUpdateStatus || editOpts.showInsertStatus) && !props.keepSource) {\n                        warnLog('vxe.error.reqProp', ['keep-source']);\n                    }\n                    if (treeConfig && (treeOpts.showLine || treeOpts.line) && (!(props.rowKey || rowOpts.useKey) || !showOverflow)) {\n                        warnLog('vxe.error.reqProp', ['row-config.useKey | show-overflow']);\n                    }\n                    if (treeConfig && props.stripe) {\n                        warnLog('vxe.error.noTree', ['stripe']);\n                    }\n                    if (props.showFooter && !props.footerMethod) {\n                        warnLog('vxe.error.reqProp', ['footer-method']);\n                    }\n                    // if (props.highlightCurrentRow) {\n                    //   warnLog('vxe.error.delProp', ['highlight-current-row', 'row-config.isCurrent'])\n                    // }\n                    // if (props.highlightHoverRow) {\n                    //   warnLog('vxe.error.delProp', ['highlight-hover-row', 'row-config.isHover'])\n                    // }\n                    // if (props.highlightCurrentColumn) {\n                    //   warnLog('vxe.error.delProp', ['highlight-current-column', 'column-config.isCurrent'])\n                    // }\n                    // if (props.highlightHoverColumn) {\n                    //   warnLog('vxe.error.delProp', ['highlight-hover-column', 'column-config.isHover'])\n                    // }\n                    // 检查导入导出类型，如果自定义导入导出方法，则不校验类型\n                    var exportConfig = props.exportConfig, importConfig = props.importConfig;\n                    var exportOpts = computeExportOpts.value;\n                    var importOpts = computeImportOpts.value;\n                    if (importConfig && importOpts.types && !importOpts.importMethod && !XEUtils.includeArrays(VXETable.globalConfs.importTypes, importOpts.types)) {\n                        warnLog('vxe.error.errProp', [\"export-config.types=\".concat(importOpts.types.join(',')), importOpts.types.filter(function (type) { return XEUtils.includes(VXETable.globalConfs.importTypes, type); }).join(',') || VXETable.globalConfs.importTypes.join(',')]);\n                    }\n                    if (exportConfig && exportOpts.types && !exportOpts.exportMethod && !XEUtils.includeArrays(VXETable.globalConfs.exportTypes, exportOpts.types)) {\n                        warnLog('vxe.error.errProp', [\"export-config.types=\".concat(exportOpts.types.join(',')), exportOpts.types.filter(function (type) { return XEUtils.includes(VXETable.globalConfs.exportTypes, type); }).join(',') || VXETable.globalConfs.exportTypes.join(',')]);\n                    }\n                }\n                if (process.env.NODE_ENV === 'development') {\n                    var customOpts = computeCustomOpts.value;\n                    var mouseOpts = computeMouseOpts.value;\n                    var rowOpts_1 = computeRowOpts.value;\n                    if (!props.id && props.customConfig && (customOpts.storage === true || (customOpts.storage && customOpts.storage.resizable) || (customOpts.storage && customOpts.storage.visible))) {\n                        errLog('vxe.error.reqProp', ['id']);\n                    }\n                    if (props.treeConfig && checkboxOpts.range) {\n                        errLog('vxe.error.noTree', ['checkbox-config.range']);\n                    }\n                    if (rowOpts_1.height && !props.showOverflow) {\n                        warnLog('vxe.error.notProp', ['table.show-overflow']);\n                    }\n                    if (!$xetable.handleUpdateCellAreas) {\n                        if (props.clipConfig) {\n                            warnLog('vxe.error.notProp', ['clip-config']);\n                        }\n                        if (props.fnrConfig) {\n                            warnLog('vxe.error.notProp', ['fnr-config']);\n                        }\n                        if (mouseOpts.area) {\n                            errLog('vxe.error.notProp', ['mouse-config.area']);\n                            return;\n                        }\n                    }\n                    if (props.treeConfig && treeOpts.children) {\n                        warnLog('vxe.error.delProp', ['tree-config.children', 'tree-config.childrenField']);\n                    }\n                    if (props.treeConfig && treeOpts.line) {\n                        warnLog('vxe.error.delProp', ['tree-config.line', 'tree-config.showLine']);\n                    }\n                    if (mouseOpts.area && mouseOpts.selected) {\n                        warnLog('vxe.error.errConflicts', ['mouse-config.area', 'mouse-config.selected']);\n                    }\n                    if (mouseOpts.area && checkboxOpts.range) {\n                        warnLog('vxe.error.errConflicts', ['mouse-config.area', 'checkbox-config.range']);\n                    }\n                    if (props.treeConfig && mouseOpts.area) {\n                        errLog('vxe.error.noTree', ['mouse-config.area']);\n                    }\n                    if (props.editConfig && editOpts.activeMethod) {\n                        warnLog('vxe.error.delProp', ['edit-config.activeMethod', 'edit-config.beforeEditMethod']);\n                    }\n                    if (props.treeConfig && checkboxOpts.isShiftKey) {\n                        errLog('vxe.error.errConflicts', ['tree-config', 'checkbox-config.isShiftKey']);\n                    }\n                    if (checkboxOpts.halfField) {\n                        warnLog('vxe.error.delProp', ['checkbox-config.halfField', 'checkbox-config.indeterminateField']);\n                    }\n                }\n                // 检查是否有安装需要的模块\n                if (process.env.NODE_ENV === 'development') {\n                    if (props.editConfig && !$xetable.insert) {\n                        errLog('vxe.error.reqModule', ['Edit']);\n                    }\n                    if (props.editRules && !$xetable.validate) {\n                        errLog('vxe.error.reqModule', ['Validator']);\n                    }\n                    if ((checkboxOpts.range || props.keyboardConfig || props.mouseConfig) && !$xetable.triggerCellMousedownEvent) {\n                        errLog('vxe.error.reqModule', ['Keyboard']);\n                    }\n                    if ((props.printConfig || props.importConfig || props.exportConfig) && !$xetable.exportData) {\n                        errLog('vxe.error.reqModule', ['Export']);\n                    }\n                }\n                Object.assign(scrollYStore, {\n                    startIndex: 0,\n                    endIndex: 0,\n                    visibleSize: 0,\n                    adaptive: sYOpts.adaptive !== false\n                });\n                Object.assign(scrollXStore, {\n                    startIndex: 0,\n                    endIndex: 0,\n                    visibleSize: 0\n                });\n                loadTableData(data || []).then(function () {\n                    if (data && data.length) {\n                        internalData.inited = true;\n                        internalData.initStatus = true;\n                        handleLoadDefaults();\n                        handleInitDefaults();\n                    }\n                    updateStyle();\n                });\n                if (props.autoResize) {\n                    var resizeOpts = computeResizeleOpts.value;\n                    var refreshDelay = resizeOpts.refreshDelay;\n                    var el = refElem.value;\n                    var parentEl = tablePrivateMethods.getParentElem();\n                    var handleOptimizeResize_1 = refreshDelay ? XEUtils.throttle(function () { return tableMethods.recalculate(true); }, refreshDelay, { leading: true, trailing: true }) : null;\n                    resizeObserver = createResizeEvent(handleOptimizeResize_1 ? function () {\n                        if (props.autoResize) {\n                            requestAnimationFrame(handleOptimizeResize_1);\n                        }\n                    } : function () {\n                        if (props.autoResize) {\n                            tableMethods.recalculate(true);\n                        }\n                    });\n                    if (el) {\n                        resizeObserver.observe(el);\n                    }\n                    if (parentEl) {\n                        resizeObserver.observe(parentEl);\n                    }\n                }\n            });\n            GlobalEvent.on($xetable, 'paste', handleGlobalPasteEvent);\n            GlobalEvent.on($xetable, 'copy', handleGlobalCopyEvent);\n            GlobalEvent.on($xetable, 'cut', handleGlobalCutEvent);\n            GlobalEvent.on($xetable, 'mousedown', handleGlobalMousedownEvent);\n            GlobalEvent.on($xetable, 'blur', handleGlobalBlurEvent);\n            GlobalEvent.on($xetable, 'mousewheel', handleGlobalMousewheelEvent);\n            GlobalEvent.on($xetable, 'keydown', handleGlobalKeydownEvent);\n            GlobalEvent.on($xetable, 'resize', handleGlobalResizeEvent);\n            if ($xetable.handleGlobalContextmenuEvent) {\n                GlobalEvent.on($xetable, 'contextmenu', $xetable.handleGlobalContextmenuEvent);\n            }\n            tablePrivateMethods.preventEvent(null, 'mounted', { $table: $xetable });\n        });\n        onBeforeUnmount(function () {\n            if (resizeObserver) {\n                resizeObserver.disconnect();\n            }\n            tableMethods.closeFilter();\n            if ($xetable.closeMenu) {\n                $xetable.closeMenu();\n            }\n            tablePrivateMethods.preventEvent(null, 'beforeUnmount', { $table: $xetable });\n        });\n        onUnmounted(function () {\n            GlobalEvent.off($xetable, 'paste');\n            GlobalEvent.off($xetable, 'copy');\n            GlobalEvent.off($xetable, 'cut');\n            GlobalEvent.off($xetable, 'mousedown');\n            GlobalEvent.off($xetable, 'blur');\n            GlobalEvent.off($xetable, 'mousewheel');\n            GlobalEvent.off($xetable, 'keydown');\n            GlobalEvent.off($xetable, 'resize');\n            GlobalEvent.off($xetable, 'contextmenu');\n            tablePrivateMethods.preventEvent(null, 'unmounted', { $table: $xetable });\n        });\n        var renderVN = function () {\n            var _a;\n            var loading = props.loading, stripe = props.stripe, showHeader = props.showHeader, height = props.height, treeConfig = props.treeConfig, mouseConfig = props.mouseConfig, showFooter = props.showFooter, highlightCell = props.highlightCell, highlightHoverRow = props.highlightHoverRow, highlightHoverColumn = props.highlightHoverColumn, editConfig = props.editConfig, editRules = props.editRules;\n            var isGroup = reactData.isGroup, overflowX = reactData.overflowX, overflowY = reactData.overflowY, scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad, scrollbarHeight = reactData.scrollbarHeight, tableData = reactData.tableData, tableColumn = reactData.tableColumn, tableGroupColumn = reactData.tableGroupColumn, footerTableData = reactData.footerTableData, initStore = reactData.initStore, columnStore = reactData.columnStore, filterStore = reactData.filterStore;\n            var leftList = columnStore.leftList, rightList = columnStore.rightList;\n            var loadingSlot = slots.loading;\n            var tipConfig = computeTipConfig.value;\n            var validOpts = computeValidOpts.value;\n            var treeOpts = computeTreeOpts.value;\n            var rowOpts = computeRowOpts.value;\n            var columnOpts = computeColumnOpts.value;\n            var vSize = computeSize.value;\n            var tableBorder = computeTableBorder.value;\n            var mouseOpts = computeMouseOpts.value;\n            var validTipOpts = computeValidTipOpts.value;\n            var loadingOpts = computeLoadingOpts.value;\n            var isMenu = computeIsMenu.value;\n            return h('div', {\n                ref: refElem,\n                class: ['vxe-table', 'vxe-table--render-default', \"tid_\".concat(xID), \"border--\".concat(tableBorder), (_a = {},\n                        _a[\"size--\".concat(vSize)] = vSize,\n                        _a[\"vaild-msg--\".concat(validOpts.msgMode)] = !!editRules,\n                        _a['vxe-editable'] = !!editConfig,\n                        _a['old-cell-valid'] = editRules && GlobalConfig.cellVaildMode === 'obsolete',\n                        _a['cell--highlight'] = highlightCell,\n                        _a['cell--selected'] = mouseConfig && mouseOpts.selected,\n                        _a['cell--area'] = mouseConfig && mouseOpts.area,\n                        _a['row--highlight'] = rowOpts.isHover || highlightHoverRow,\n                        _a['column--highlight'] = columnOpts.isHover || highlightHoverColumn,\n                        _a['is--header'] = showHeader,\n                        _a['is--footer'] = showFooter,\n                        _a['is--group'] = isGroup,\n                        _a['is--tree-line'] = treeConfig && (treeOpts.showLine || treeOpts.line),\n                        _a['is--fixed-left'] = leftList.length,\n                        _a['is--fixed-right'] = rightList.length,\n                        _a['is--animat'] = !!props.animat,\n                        _a['is--round'] = props.round,\n                        _a['is--stripe'] = !treeConfig && stripe,\n                        _a['is--loading'] = loading,\n                        _a['is--empty'] = !loading && !tableData.length,\n                        _a['is--scroll-y'] = overflowY,\n                        _a['is--scroll-x'] = overflowX,\n                        _a['is--virtual-x'] = scrollXLoad,\n                        _a['is--virtual-y'] = scrollYLoad,\n                        _a)],\n                onKeydown: keydownEvent\n            }, [\n                /**\n                 * 隐藏列\n                 */\n                h('div', {\n                    class: 'vxe-table-slots'\n                }, slots.default ? slots.default({}) : []),\n                h('div', {\n                    class: 'vxe-table--render-wrapper'\n                }, [\n                    h('div', {\n                        class: 'vxe-table--main-wrapper'\n                    }, [\n                        /**\n                         * 表头\n                         */\n                        showHeader ? h(TableHeaderComponent, {\n                            ref: refTableHeader,\n                            tableData: tableData,\n                            tableColumn: tableColumn,\n                            tableGroupColumn: tableGroupColumn\n                        }) : createCommentVNode(),\n                        /**\n                         * 表体\n                         */\n                        h(TableBodyComponent, {\n                            ref: refTableBody,\n                            tableData: tableData,\n                            tableColumn: tableColumn\n                        }),\n                        /**\n                         * 表尾\n                         */\n                        showFooter ? h(TableFooterComponent, {\n                            ref: refTableFooter,\n                            footerTableData: footerTableData,\n                            tableColumn: tableColumn\n                        }) : createCommentVNode()\n                    ]),\n                    h('div', {\n                        class: 'vxe-table--fixed-wrapper'\n                    }, [\n                        /**\n                         * 左侧固定区域\n                         */\n                        leftList && leftList.length && overflowX ? renderFixed('left') : createCommentVNode(),\n                        /**\n                         * 右侧固定区域\n                         */\n                        rightList && rightList.length && overflowX ? renderFixed('right') : createCommentVNode()\n                    ])\n                ]),\n                /**\n                 * 空数据\n                 */\n                h('div', {\n                    ref: refEmptyPlaceholder,\n                    class: 'vxe-table--empty-placeholder'\n                }, [\n                    h('div', {\n                        class: 'vxe-table--empty-content'\n                    }, renderEmptyContenet())\n                ]),\n                /**\n                 * 边框线\n                 */\n                h('div', {\n                    class: 'vxe-table--border-line'\n                }),\n                /**\n                 * 列宽线\n                 */\n                h('div', {\n                    ref: refCellResizeBar,\n                    class: 'vxe-table--resizable-bar',\n                    style: overflowX ? {\n                        'padding-bottom': \"\".concat(scrollbarHeight, \"px\")\n                    } : null\n                }),\n                /**\n                 * 加载中\n                 */\n                h(VxeLoading, {\n                    class: 'vxe-table--loading',\n                    modelValue: loading,\n                    icon: loadingOpts.icon,\n                    text: loadingOpts.text\n                }, loadingSlot ? {\n                    default: function () { return loadingSlot({ $table: $xetable, $grid: $xegrid }); }\n                } : {}),\n                /**\n                 * 筛选\n                 */\n                initStore.filter ? h(resolveComponent('vxe-table-filter'), {\n                    ref: refTableFilter,\n                    filterStore: filterStore\n                }) : createCommentVNode(),\n                /**\n                 * 导入\n                 */\n                initStore.import && props.importConfig ? h(resolveComponent('vxe-import-panel'), {\n                    defaultOptions: reactData.importParams,\n                    storeData: reactData.importStore\n                }) : createCommentVNode(),\n                /**\n                 * 导出/导出\n                 */\n                initStore.export && (props.exportConfig || props.printConfig) ? h(resolveComponent('vxe-export-panel'), {\n                    defaultOptions: reactData.exportParams,\n                    storeData: reactData.exportStore\n                }) : createCommentVNode(),\n                /**\n                 * 快捷菜单\n                 */\n                isMenu ? h(resolveComponent('vxe-table-context-menu'), {\n                    ref: refTableMenu\n                }) : createCommentVNode(),\n                /**\n                 * 通用提示\n                 */\n                hasUseTooltip ? h(resolveComponent('vxe-tooltip'), {\n                    ref: refCommTooltip,\n                    isArrow: false,\n                    enterable: false\n                }) : createCommentVNode(),\n                /**\n                 * 工具提示\n                 */\n                hasUseTooltip ? h(resolveComponent('vxe-tooltip'), __assign({ ref: refTooltip }, tipConfig)) : createCommentVNode(),\n                /**\n                 * 校验提示\n                 */\n                hasUseTooltip && props.editRules && validOpts.showMessage && (validOpts.message === 'default' ? !height : validOpts.message === 'tooltip') ? h(resolveComponent('vxe-tooltip'), __assign({ ref: refValidTooltip, class: [{\n                            'old-cell-valid': editRules && GlobalConfig.cellVaildMode === 'obsolete'\n                        }, 'vxe-table--valid-error'] }, (validOpts.message === 'tooltip' || tableData.length === 1 ? validTipOpts : {}))) : createCommentVNode()\n            ]);\n        };\n        $xetable.renderVN = renderVN;\n        provide('xecolgroup', null);\n        provide('$xetable', $xetable);\n        return $xetable;\n    },\n    render: function () {\n        return this.renderVN();\n    }\n});\n",
      "start": 1714699767778,
      "end": 1714699767848,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1714699767848,
      "end": 1714699767848,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1714699767848,
      "end": 1714699767848,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1714699767848,
      "end": 1714699767848,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1714699767848,
      "end": 1714699767848,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1714699767848,
      "end": 1714699767848,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1714699767848,
      "end": 1714699767848,
      "order": "normal"
    },
    {
      "name": "vite-plugin-vconsole",
      "result": "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { defineComponent, getCurrentInstance, h, createCommentVNode, resolveComponent, reactive, ref, provide, inject, nextTick, onActivated, onDeactivated, onBeforeUnmount, onUnmounted, watch, computed, onMounted } from 'vue';\nimport XEUtils from 'xe-utils';\nimport { browse, isPx, isScale, hasClass, addClass, removeClass, getEventTargetNode, getPaddingTopBottomSize, setScrollTop, setScrollLeft, isNodeElement } from '../../tools/dom';\nimport { getLastZIndex, nextZIndex, hasChildrenList, getFuncText, isEnableConf, formatText, eqEmptyValue } from '../../tools/utils';\nimport { warnLog, errLog } from '../../tools/log';\nimport { createResizeEvent } from '../../tools/resize';\nimport { GlobalEvent, hasEventKey, EVENT_KEYS } from '../../tools/event';\nimport { useSize } from '../../hooks/size';\nimport { VXETable } from '../../v-x-e-table';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport Cell from './cell';\nimport TableBodyComponent from './body';\nimport TableHeaderComponent from '../../header';\nimport TableFooterComponent from '../../footer';\nimport tableProps from './props';\nimport tableEmits from './emits';\nimport VxeLoading from '../../loading/index';\nimport { getRowUniqueId, clearTableAllStatus, getRowkey, getRowid, rowToVisible, colToVisible, getCellValue, setCellValue, handleFieldOrColumn, toTreePathSeq, restoreScrollLocation, restoreScrollListener, getRootColumn } from './util';\nimport { getSlotVNs } from '../../tools/vn';\nvar isWebkit = browse['-webkit'] && !browse.edge;\nvar resizableStorageKey = 'VXE_TABLE_CUSTOM_COLUMN_WIDTH';\nvar visibleStorageKey = 'VXE_TABLE_CUSTOM_COLUMN_VISIBLE';\nvar fixedStorageKey = 'VXE_TABLE_CUSTOM_COLUMN_FIXED';\nvar orderStorageKey = 'VXE_TABLE_CUSTOM_COLUMN_ORDER';\nexport default defineComponent({\n    name: 'VxeTable',\n    props: tableProps,\n    emits: tableEmits,\n    setup: function (props, context) {\n        var slots = context.slots, emit = context.emit;\n        var hasUseTooltip = VXETable.tooltip;\n        var xID = XEUtils.uniqueId();\n        var computeSize = useSize(props);\n        var instance = getCurrentInstance();\n        var reactData = reactive({\n            // 低性能的静态列\n            staticColumns: [],\n            // 渲染的列分组\n            tableGroupColumn: [],\n            // 可视区渲染的列\n            tableColumn: [],\n            // 渲染中的数据\n            tableData: [],\n            // 是否启用了横向 X 可视渲染方式加载\n            scrollXLoad: false,\n            // 是否启用了纵向 Y 可视渲染方式加载\n            scrollYLoad: false,\n            // 是否存在纵向滚动条\n            overflowY: true,\n            // 是否存在横向滚动条\n            overflowX: false,\n            // 纵向滚动条的宽度\n            scrollbarWidth: 0,\n            // 横向滚动条的高度\n            scrollbarHeight: 0,\n            // 最后滚动时间戳\n            lastScrollTime: 0,\n            // 行高\n            rowHeight: 0,\n            // 表格父容器的高度\n            parentHeight: 0,\n            // 是否使用分组表头\n            isGroup: false,\n            isAllOverflow: false,\n            // 复选框属性，是否全选\n            isAllSelected: false,\n            // 复选框属性，有选中且非全选状态\n            isIndeterminate: false,\n            // 复选框属性，已选中的行集合\n            selectCheckboxMaps: {},\n            // 当前行\n            currentRow: null,\n            // 单选框属性，选中列\n            currentColumn: null,\n            // 单选框属性，选中行\n            selectRadioRow: null,\n            // 表尾合计数据\n            footerTableData: [],\n            // 展开列信息\n            expandColumn: null,\n            // 树节点列信息\n            treeNodeColumn: null,\n            hasFixedColumn: false,\n            // 已展开的行集合\n            rowExpandedMaps: {},\n            // 懒加载中的展开行的集合\n            rowExpandLazyLoadedMaps: {},\n            // 已展开树节点集合\n            treeExpandedMaps: {},\n            // 懒加载中的树节点的集合\n            treeExpandLazyLoadedMaps: {},\n            // 树节点不确定状态的集合\n            treeIndeterminateMaps: {},\n            // 合并单元格的对象集\n            mergeList: [],\n            // 合并表尾数据的对象集\n            mergeFooterList: [],\n            // 刷新列标识，当列筛选被改变时，触发表格刷新数据\n            upDataFlag: 0,\n            // 刷新列标识，当列的特定属性被改变时，触发表格刷新列\n            reColumnFlag: 0,\n            // 已标记的对象集\n            pendingRowMaps: {},\n            // 已标记的行\n            pendingRowList: [],\n            // 初始化标识\n            initStore: {\n                filter: false,\n                import: false,\n                export: false\n            },\n            // 当前选中的筛选列\n            filterStore: {\n                isAllSelected: false,\n                isIndeterminate: false,\n                style: null,\n                options: [],\n                column: null,\n                multiple: false,\n                visible: false,\n                maxHeight: null\n            },\n            // 存放列相关的信息\n            columnStore: {\n                leftList: [],\n                centerList: [],\n                rightList: [],\n                resizeList: [],\n                pxList: [],\n                pxMinList: [],\n                scaleList: [],\n                scaleMinList: [],\n                autoList: []\n            },\n            // 存放快捷菜单的信息\n            ctxMenuStore: {\n                selected: null,\n                visible: false,\n                showChild: false,\n                selectChild: null,\n                list: [],\n                style: null\n            },\n            // 存放可编辑相关信息\n            editStore: {\n                indexs: {\n                    columns: []\n                },\n                titles: {\n                    columns: []\n                },\n                // 选中源\n                selected: {\n                    row: null,\n                    column: null\n                },\n                // 已复制源\n                copyed: {\n                    cut: false,\n                    rows: [],\n                    columns: []\n                },\n                // 激活\n                actived: {\n                    row: null,\n                    column: null\n                },\n                insertMaps: {},\n                removeMaps: {}\n            },\n            // 存放 tooltip 相关信息\n            tooltipStore: {\n                row: null,\n                column: null,\n                content: null,\n                visible: false,\n                currOpts: null\n            },\n            // 存放数据校验相关信息\n            validStore: {\n                visible: false\n            },\n            validErrorMaps: {},\n            // 导入相关信息\n            importStore: {\n                inited: false,\n                file: null,\n                type: '',\n                modeList: [],\n                typeList: [],\n                filename: '',\n                visible: false\n            },\n            importParams: {\n                mode: '',\n                types: null,\n                message: true\n            },\n            // 导出相关信息\n            exportStore: {\n                inited: false,\n                name: '',\n                modeList: [],\n                typeList: [],\n                columns: [],\n                isPrint: false,\n                hasFooter: false,\n                hasMerge: false,\n                hasTree: false,\n                hasColgroup: false,\n                visible: false\n            },\n            exportParams: {\n                filename: '',\n                sheetName: '',\n                mode: '',\n                type: '',\n                isColgroup: false,\n                isMerge: false,\n                isAllExpand: false,\n                useStyle: false,\n                original: false,\n                message: true,\n                isHeader: false,\n                isFooter: false\n            },\n            scrollVMLoading: false,\n            _isResize: false\n        });\n        var internalData = {\n            tZindex: 0,\n            elemStore: {},\n            // 存放横向 X 虚拟滚动相关的信息\n            scrollXStore: {\n                offsetSize: 0,\n                visibleSize: 0,\n                startIndex: 0,\n                endIndex: 0\n            },\n            // 存放纵向 Y 虚拟滚动相关信息\n            scrollYStore: {\n                rowHeight: 0,\n                offsetSize: 0,\n                visibleSize: 0,\n                startIndex: 0,\n                endIndex: 0\n            },\n            // 表格宽度\n            tableWidth: 0,\n            // 表格高度\n            tableHeight: 0,\n            // 表头高度\n            headerHeight: 0,\n            // 表尾高度\n            footerHeight: 0,\n            customHeight: 0,\n            customMinHeight: 0,\n            customMaxHeight: 0,\n            // 当前 hover 行\n            hoverRow: null,\n            // 最后滚动位置\n            lastScrollLeft: 0,\n            lastScrollTop: 0,\n            // 单选框属性，已选中保留的行\n            radioReserveRow: null,\n            // 复选框属性，已选中保留的行集合\n            checkboxReserveRowMap: {},\n            // 行数据，已展开保留的行集合\n            rowExpandedReserveRowMap: {},\n            // 树结构数据，已展开保留的行集合\n            treeExpandedReserveRowMap: {},\n            // 树结构数据，不确定状态的集合\n            treeIndeterminateRowMaps: {},\n            // 列表完整数据、条件处理后\n            tableFullData: [],\n            afterFullData: [],\n            afterTreeFullData: [],\n            // 列表条件处理后数据集合\n            afterFullRowMaps: {},\n            // 树结构完整数据、条件处理后\n            tableFullTreeData: [],\n            tableSynchData: [],\n            tableSourceData: [],\n            // 收集的列配置（带分组）\n            collectColumn: [],\n            // 完整所有列（不带分组）\n            tableFullColumn: [],\n            // 渲染所有列\n            visibleColumn: [],\n            // 总的缓存数据集\n            fullAllDataRowIdData: {},\n            // 渲染中缓存数据\n            sourceDataRowIdData: {},\n            fullDataRowIdData: {},\n            fullColumnIdData: {},\n            fullColumnFieldData: {},\n            inited: false,\n            tooltipTimeout: null,\n            initStatus: false,\n            isActivated: false\n        };\n        var tableMethods = {};\n        var tablePrivateMethods = {};\n        var refElem = ref();\n        var refTooltip = ref();\n        var refCommTooltip = ref();\n        var refValidTooltip = ref();\n        var refTableFilter = ref();\n        var refTableMenu = ref();\n        var refTableHeader = ref();\n        var refTableBody = ref();\n        var refTableFooter = ref();\n        var refTableLeftHeader = ref();\n        var refTableLeftBody = ref();\n        var refTableLeftFooter = ref();\n        var refTableRightHeader = ref();\n        var refTableRightBody = ref();\n        var refTableRightFooter = ref();\n        var refLeftContainer = ref();\n        var refRightContainer = ref();\n        var refCellResizeBar = ref();\n        var refEmptyPlaceholder = ref();\n        var $xegrid = inject('$xegrid', null);\n        var $xetoolbar;\n        var computeValidOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.validConfig, props.validConfig);\n        });\n        var computeSXOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.scrollX, props.scrollX);\n        });\n        var computeSYOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.scrollY, props.scrollY);\n        });\n        var computeRowHeightMaps = computed(function () {\n            return {\n                default: 48,\n                medium: 44,\n                small: 40,\n                mini: 36\n            };\n        });\n        var computeColumnOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.columnConfig, props.columnConfig);\n        });\n        var computeRowOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.rowConfig, props.rowConfig);\n        });\n        var computeResizeleOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.resizeConfig, props.resizeConfig);\n        });\n        var computeResizableOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.resizableConfig, props.resizableConfig);\n        });\n        var computeSeqOpts = computed(function () {\n            return Object.assign({ startIndex: 0 }, GlobalConfig.table.seqConfig, props.seqConfig);\n        });\n        var computeRadioOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.radioConfig, props.radioConfig);\n        });\n        var computeCheckboxOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.checkboxConfig, props.checkboxConfig);\n        });\n        var computeTooltipOpts = ref();\n        computeTooltipOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.tooltip, GlobalConfig.table.tooltipConfig, props.tooltipConfig);\n        });\n        var computeTipConfig = computed(function () {\n            var tooltipStore = reactData.tooltipStore;\n            var tooltipOpts = computeTooltipOpts.value;\n            return __assign(__assign({}, tooltipOpts), tooltipStore.currOpts);\n        });\n        var computeValidTipOpts = computed(function () {\n            var tooltipOpts = computeTooltipOpts.value;\n            return Object.assign({ isArrow: false }, tooltipOpts);\n        });\n        var computeEditOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.editConfig, props.editConfig);\n        });\n        var computeSortOpts = computed(function () {\n            return Object.assign({ orders: ['asc', 'desc', null] }, GlobalConfig.table.sortConfig, props.sortConfig);\n        });\n        var computeFilterOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.filterConfig, props.filterConfig);\n        });\n        var computeMouseOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.mouseConfig, props.mouseConfig);\n        });\n        var computeAreaOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.areaConfig, props.areaConfig);\n        });\n        var computeKeyboardOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.keyboardConfig, props.keyboardConfig);\n        });\n        var computeClipOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.clipConfig, props.clipConfig);\n        });\n        var computeFNROpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.fnrConfig, props.fnrConfig);\n        });\n        var computeMenuOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.menuConfig, props.menuConfig);\n        });\n        var computeHeaderMenu = computed(function () {\n            var menuOpts = computeMenuOpts.value;\n            var headerOpts = menuOpts.header;\n            return headerOpts && headerOpts.options ? headerOpts.options : [];\n        });\n        var computeBodyMenu = computed(function () {\n            var menuOpts = computeMenuOpts.value;\n            var bodyOpts = menuOpts.body;\n            return bodyOpts && bodyOpts.options ? bodyOpts.options : [];\n        });\n        var computeFooterMenu = computed(function () {\n            var menuOpts = computeMenuOpts.value;\n            var footerOpts = menuOpts.footer;\n            return footerOpts && footerOpts.options ? footerOpts.options : [];\n        });\n        var computeIsMenu = computed(function () {\n            var menuOpts = computeMenuOpts.value;\n            var headerMenu = computeHeaderMenu.value;\n            var bodyMenu = computeBodyMenu.value;\n            var footerMenu = computeFooterMenu.value;\n            return !!(props.menuConfig && isEnableConf(menuOpts) && (headerMenu.length || bodyMenu.length || footerMenu.length));\n        });\n        var computeMenuList = computed(function () {\n            var ctxMenuStore = reactData.ctxMenuStore;\n            var rest = [];\n            ctxMenuStore.list.forEach(function (list) {\n                list.forEach(function (item) {\n                    rest.push(item);\n                });\n            });\n            return rest;\n        });\n        var computeExportOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.exportConfig, props.exportConfig);\n        });\n        var computeImportOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.importConfig, props.importConfig);\n        });\n        var computePrintOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.printConfig, props.printConfig);\n        });\n        var computeExpandOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.expandConfig, props.expandConfig);\n        });\n        var computeTreeOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.treeConfig, props.treeConfig);\n        });\n        var computeEmptyOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.emptyRender, props.emptyRender);\n        });\n        var computeLoadingOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.loadingConfig, props.loadingConfig);\n        });\n        var computeCellOffsetWidth = computed(function () {\n            return props.border ? Math.max(2, Math.ceil(reactData.scrollbarWidth / reactData.tableColumn.length)) : 1;\n        });\n        var computeCustomOpts = computed(function () {\n            return Object.assign({}, GlobalConfig.table.customConfig, props.customConfig);\n        });\n        var computeFixedColumnSize = computed(function () {\n            var tableFullColumn = internalData.tableFullColumn;\n            var fixedSize = 0;\n            tableFullColumn.forEach(function (column) {\n                if (column.fixed) {\n                    fixedSize++;\n                }\n            });\n            return fixedSize;\n        });\n        var computeIsMaxFixedColumn = computed(function () {\n            var fixedColumnSize = computeFixedColumnSize.value;\n            var columnOpts = computeColumnOpts.value;\n            var maxFixedSize = columnOpts.maxFixedSize;\n            if (maxFixedSize) {\n                return fixedColumnSize >= maxFixedSize;\n            }\n            return false;\n        });\n        var computeTableBorder = computed(function () {\n            var border = props.border;\n            if (border === true) {\n                return 'full';\n            }\n            if (border) {\n                return border;\n            }\n            return 'default';\n        });\n        var computeIsAllCheckboxDisabled = computed(function () {\n            var treeConfig = props.treeConfig;\n            var tableData = reactData.tableData;\n            var tableFullData = internalData.tableFullData;\n            var checkboxOpts = computeCheckboxOpts.value;\n            var strict = checkboxOpts.strict, checkMethod = checkboxOpts.checkMethod;\n            if (strict) {\n                if (tableData.length || tableFullData.length) {\n                    if (checkMethod) {\n                        if (treeConfig) {\n                            // 暂时不支持树形结构\n                        }\n                        // 如果所有行都被禁用\n                        return tableFullData.every(function (row) { return !checkMethod({ row: row }); });\n                    }\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        });\n        var refMaps = {\n            refElem: refElem,\n            refTooltip: refTooltip,\n            refValidTooltip: refValidTooltip,\n            refTableFilter: refTableFilter,\n            refTableMenu: refTableMenu,\n            refTableHeader: refTableHeader,\n            refTableBody: refTableBody,\n            refTableFooter: refTableFooter,\n            refTableLeftHeader: refTableLeftHeader,\n            refTableLeftBody: refTableLeftBody,\n            refTableLeftFooter: refTableLeftFooter,\n            refTableRightHeader: refTableRightHeader,\n            refTableRightBody: refTableRightBody,\n            refTableRightFooter: refTableRightFooter,\n            refLeftContainer: refLeftContainer,\n            refRightContainer: refRightContainer,\n            refCellResizeBar: refCellResizeBar\n        };\n        var computeMaps = {\n            computeSize: computeSize,\n            computeValidOpts: computeValidOpts,\n            computeSXOpts: computeSXOpts,\n            computeSYOpts: computeSYOpts,\n            computeColumnOpts: computeColumnOpts,\n            computeRowOpts: computeRowOpts,\n            computeResizeleOpts: computeResizeleOpts,\n            computeResizableOpts: computeResizableOpts,\n            computeSeqOpts: computeSeqOpts,\n            computeRadioOpts: computeRadioOpts,\n            computeCheckboxOpts: computeCheckboxOpts,\n            computeTooltipOpts: computeTooltipOpts,\n            computeEditOpts: computeEditOpts,\n            computeSortOpts: computeSortOpts,\n            computeFilterOpts: computeFilterOpts,\n            computeMouseOpts: computeMouseOpts,\n            computeAreaOpts: computeAreaOpts,\n            computeKeyboardOpts: computeKeyboardOpts,\n            computeClipOpts: computeClipOpts,\n            computeFNROpts: computeFNROpts,\n            computeHeaderMenu: computeHeaderMenu,\n            computeBodyMenu: computeBodyMenu,\n            computeFooterMenu: computeFooterMenu,\n            computeIsMenu: computeIsMenu,\n            computeMenuOpts: computeMenuOpts,\n            computeExportOpts: computeExportOpts,\n            computeImportOpts: computeImportOpts,\n            computePrintOpts: computePrintOpts,\n            computeExpandOpts: computeExpandOpts,\n            computeTreeOpts: computeTreeOpts,\n            computeEmptyOpts: computeEmptyOpts,\n            computeLoadingOpts: computeLoadingOpts,\n            computeCustomOpts: computeCustomOpts,\n            computeFixedColumnSize: computeFixedColumnSize,\n            computeIsMaxFixedColumn: computeIsMaxFixedColumn,\n            computeIsAllCheckboxDisabled: computeIsAllCheckboxDisabled\n        };\n        var $xetable = {\n            xID: xID,\n            props: props,\n            context: context,\n            instance: instance,\n            reactData: reactData,\n            internalData: internalData,\n            getRefMaps: function () { return refMaps; },\n            getComputeMaps: function () { return computeMaps; },\n            xegrid: $xegrid\n        };\n        var eqCellValue = function (row1, row2, field) {\n            var val1 = XEUtils.get(row1, field);\n            var val2 = XEUtils.get(row2, field);\n            if (eqEmptyValue(val1) && eqEmptyValue(val2)) {\n                return true;\n            }\n            if (XEUtils.isString(val1) || XEUtils.isNumber(val1)) {\n                return ('' + val1) === ('' + val2);\n            }\n            return XEUtils.isEqual(val1, val2);\n        };\n        var getNextSortOrder = function (column) {\n            var sortOpts = computeSortOpts.value;\n            var orders = sortOpts.orders;\n            var currOrder = column.order || null;\n            var oIndex = orders.indexOf(currOrder) + 1;\n            return orders[oIndex < orders.length ? oIndex : 0];\n        };\n        var getCustomStorageMap = function (key) {\n            var version = GlobalConfig.version;\n            var rest = XEUtils.toStringJSON(localStorage.getItem(key) || '');\n            return rest && rest._v === version ? rest : { _v: version };\n        };\n        var getRecoverRowMaps = function (keyMaps) {\n            var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n            var restKeys = {};\n            XEUtils.each(keyMaps, function (row, rowid) {\n                if (fullAllDataRowIdData[rowid]) {\n                    restKeys[rowid] = row;\n                }\n            });\n            return restKeys;\n        };\n        var handleReserveRow = function (reserveRowMap) {\n            var fullDataRowIdData = internalData.fullDataRowIdData;\n            var reserveList = [];\n            XEUtils.each(reserveRowMap, function (item, rowid) {\n                if (fullDataRowIdData[rowid] && $xetable.findRowIndexOf(reserveList, fullDataRowIdData[rowid].row) === -1) {\n                    reserveList.push(fullDataRowIdData[rowid].row);\n                }\n            });\n            return reserveList;\n        };\n        var computeVirtualX = function () {\n            var visibleColumn = internalData.visibleColumn;\n            var tableBody = refTableBody.value;\n            var tableBodyElem = tableBody ? tableBody.$el : null;\n            if (tableBodyElem) {\n                var scrollLeft = tableBodyElem.scrollLeft, clientWidth = tableBodyElem.clientWidth;\n                var endWidth = scrollLeft + clientWidth;\n                var toVisibleIndex = -1;\n                var cWidth = 0;\n                var visibleSize = 0;\n                for (var colIndex = 0, colLen = visibleColumn.length; colIndex < colLen; colIndex++) {\n                    cWidth += visibleColumn[colIndex].renderWidth;\n                    if (toVisibleIndex === -1 && scrollLeft < cWidth) {\n                        toVisibleIndex = colIndex;\n                    }\n                    if (toVisibleIndex >= 0) {\n                        visibleSize++;\n                        if (cWidth > endWidth) {\n                            break;\n                        }\n                    }\n                }\n                return { toVisibleIndex: Math.max(0, toVisibleIndex), visibleSize: Math.max(8, visibleSize) };\n            }\n            return { toVisibleIndex: 0, visibleSize: 8 };\n        };\n        var computeVirtualY = function () {\n            var tableHeader = refTableHeader.value;\n            var tableBody = refTableBody.value;\n            var tableBodyElem = tableBody ? tableBody.$el : null;\n            var vSize = computeSize.value;\n            var rowHeightMaps = computeRowHeightMaps.value;\n            if (tableBodyElem) {\n                var tableHeaderElem = tableHeader ? tableHeader.$el : null;\n                var rowHeight = 0;\n                var firstTrElem = void 0;\n                firstTrElem = tableBodyElem.querySelector('tr');\n                if (!firstTrElem && tableHeaderElem) {\n                    firstTrElem = tableHeaderElem.querySelector('tr');\n                }\n                if (firstTrElem) {\n                    rowHeight = firstTrElem.clientHeight;\n                }\n                if (!rowHeight) {\n                    rowHeight = rowHeightMaps[vSize || 'default'];\n                }\n                var visibleSize = Math.max(8, Math.ceil(tableBodyElem.clientHeight / rowHeight) + 2);\n                return { rowHeight: rowHeight, visibleSize: visibleSize };\n            }\n            return { rowHeight: 0, visibleSize: 8 };\n        };\n        var calculateMergerOffserIndex = function (list, offsetItem, type) {\n            for (var mcIndex = 0, len = list.length; mcIndex < len; mcIndex++) {\n                var mergeItem = list[mcIndex];\n                var startIndex = offsetItem.startIndex, endIndex = offsetItem.endIndex;\n                var mergeStartIndex = mergeItem[type];\n                var mergeSpanNumber = mergeItem[type + 'span'];\n                var mergeEndIndex = mergeStartIndex + mergeSpanNumber;\n                if (mergeStartIndex < startIndex && startIndex < mergeEndIndex) {\n                    offsetItem.startIndex = mergeStartIndex;\n                }\n                if (mergeStartIndex < endIndex && endIndex < mergeEndIndex) {\n                    offsetItem.endIndex = mergeEndIndex;\n                }\n                if (offsetItem.startIndex !== startIndex || offsetItem.endIndex !== endIndex) {\n                    mcIndex = -1;\n                }\n            }\n        };\n        var setMerges = function (merges, mList, rowList) {\n            if (merges) {\n                var treeConfig = props.treeConfig;\n                var visibleColumn_1 = internalData.visibleColumn;\n                if (!XEUtils.isArray(merges)) {\n                    merges = [merges];\n                }\n                if (treeConfig && merges.length) {\n                    errLog('vxe.error.noTree', ['merge-cells | merge-footer-items']);\n                }\n                merges.forEach(function (item) {\n                    var row = item.row, col = item.col, rowspan = item.rowspan, colspan = item.colspan;\n                    if (rowList && XEUtils.isNumber(row)) {\n                        row = rowList[row];\n                    }\n                    if (XEUtils.isNumber(col)) {\n                        col = visibleColumn_1[col];\n                    }\n                    if ((rowList ? row : XEUtils.isNumber(row)) && col && (rowspan || colspan)) {\n                        rowspan = XEUtils.toNumber(rowspan) || 1;\n                        colspan = XEUtils.toNumber(colspan) || 1;\n                        if (rowspan > 1 || colspan > 1) {\n                            var mcIndex = XEUtils.findIndexOf(mList, function (item) { return (item._row === row || getRowid($xetable, item._row) === getRowid($xetable, row)) && (item._col.id === col || item._col.id === col.id); });\n                            var mergeItem = mList[mcIndex];\n                            if (mergeItem) {\n                                mergeItem.rowspan = rowspan;\n                                mergeItem.colspan = colspan;\n                                mergeItem._rowspan = rowspan;\n                                mergeItem._colspan = colspan;\n                            }\n                            else {\n                                var mergeRowIndex = rowList ? $xetable.findRowIndexOf(rowList, row) : row;\n                                var mergeColIndex = tableMethods.getVTColumnIndex(col);\n                                mList.push({\n                                    row: mergeRowIndex,\n                                    col: mergeColIndex,\n                                    rowspan: rowspan,\n                                    colspan: colspan,\n                                    _row: row,\n                                    _col: col,\n                                    _rowspan: rowspan,\n                                    _colspan: colspan\n                                });\n                            }\n                        }\n                    }\n                });\n            }\n        };\n        var removeMerges = function (merges, mList, rowList) {\n            var rest = [];\n            if (merges) {\n                var treeConfig = props.treeConfig;\n                var visibleColumn_2 = internalData.visibleColumn;\n                if (!XEUtils.isArray(merges)) {\n                    merges = [merges];\n                }\n                if (treeConfig && merges.length) {\n                    errLog('vxe.error.noTree', ['merge-cells | merge-footer-items']);\n                }\n                merges.forEach(function (item) {\n                    var row = item.row, col = item.col;\n                    if (rowList && XEUtils.isNumber(row)) {\n                        row = rowList[row];\n                    }\n                    if (XEUtils.isNumber(col)) {\n                        col = visibleColumn_2[col];\n                    }\n                    var mcIndex = XEUtils.findIndexOf(mList, function (item) { return (item._row === row || getRowid($xetable, item._row) === getRowid($xetable, row)) && (item._col.id === col || item._col.id === col.id); });\n                    if (mcIndex > -1) {\n                        var rItems = mList.splice(mcIndex, 1);\n                        rest.push(rItems[0]);\n                    }\n                });\n            }\n            return rest;\n        };\n        var clearAllSort = function () {\n            var tableFullColumn = internalData.tableFullColumn;\n            tableFullColumn.forEach(function (column) {\n                column.order = null;\n            });\n        };\n        var calcHeight = function (key) {\n            var parentHeight = reactData.parentHeight;\n            var val = props[key];\n            var num = 0;\n            if (val) {\n                if (val === 'auto') {\n                    num = parentHeight;\n                }\n                else {\n                    var excludeHeight = $xetable.getExcludeHeight();\n                    if (isScale(val)) {\n                        num = Math.floor((XEUtils.toInteger(val) || 1) / 100 * parentHeight);\n                    }\n                    else {\n                        num = XEUtils.toNumber(val);\n                    }\n                    num = Math.max(40, num - excludeHeight);\n                }\n            }\n            return num;\n        };\n        /**\n         * 还原自定义列操作状态\n         */\n        var restoreCustomStorage = function () {\n            var id = props.id, customConfig = props.customConfig;\n            var collectColumn = internalData.collectColumn;\n            var customOpts = computeCustomOpts.value;\n            var storage = customOpts.storage;\n            var isCustomResizable = storage === true || (storage && storage.resizable);\n            var isCustomVisible = storage === true || (storage && storage.visible);\n            var isCustomFixed = storage === true || (storage && storage.fixed);\n            var isCustomOrder = storage === true || (storage && storage.order);\n            if (customConfig && (isCustomResizable || isCustomVisible || isCustomFixed || isCustomOrder)) {\n                var customMap_1 = {};\n                if (!id) {\n                    errLog('vxe.error.reqProp', ['id']);\n                    return;\n                }\n                // 自定义列宽\n                if (isCustomResizable) {\n                    var columnWidthStorage = getCustomStorageMap(resizableStorageKey)[id];\n                    if (columnWidthStorage) {\n                        XEUtils.each(columnWidthStorage, function (resizeWidth, colKey) {\n                            customMap_1[colKey] = { resizeWidth: resizeWidth };\n                        });\n                    }\n                }\n                // 自定义固定列\n                if (isCustomFixed) {\n                    var columnFixedStorage = getCustomStorageMap(fixedStorageKey)[id];\n                    if (columnFixedStorage) {\n                        var colFixeds = columnFixedStorage.split(',');\n                        colFixeds.forEach(function (fixConf) {\n                            var _a = fixConf.split('|'), colKey = _a[0], fixed = _a[1];\n                            if (customMap_1[colKey]) {\n                                customMap_1[colKey].fixed = fixed;\n                            }\n                            else {\n                                customMap_1[colKey] = { fixed: fixed };\n                            }\n                        });\n                    }\n                }\n                // 自定义顺序\n                if (isCustomOrder) {\n                    var columnOrderStorage = getCustomStorageMap(orderStorageKey)[id];\n                    if (columnOrderStorage) {\n                        // const colOrderSeqs = columnOrderStorage.split(',')\n                        // colOrderSeqs.forEach((orderConf: any) => {\n                        //   const [colKey, order] = orderConf.split('|')\n                        //   if (customMap[colKey]) {\n                        //     customMap[colKey].order = order\n                        //   } else {\n                        //     customMap[colKey] = { order }\n                        //   }\n                        // })\n                    }\n                }\n                // 自定义隐藏列\n                if (isCustomVisible) {\n                    var columnVisibleStorage = getCustomStorageMap(visibleStorageKey)[id];\n                    if (columnVisibleStorage) {\n                        var colVisibles = columnVisibleStorage.split('|');\n                        var colHides = colVisibles[0] ? colVisibles[0].split(',') : [];\n                        var colShows = colVisibles[1] ? colVisibles[1].split(',') : [];\n                        colHides.forEach(function (colKey) {\n                            if (customMap_1[colKey]) {\n                                customMap_1[colKey].visible = false;\n                            }\n                            else {\n                                customMap_1[colKey] = { visible: false };\n                            }\n                        });\n                        colShows.forEach(function (colKey) {\n                            if (customMap_1[colKey]) {\n                                customMap_1[colKey].visible = true;\n                            }\n                            else {\n                                customMap_1[colKey] = { visible: true };\n                            }\n                        });\n                    }\n                }\n                var keyMap_1 = {};\n                XEUtils.eachTree(collectColumn, function (column) {\n                    var colKey = column.getKey();\n                    if (colKey) {\n                        keyMap_1[colKey] = column;\n                    }\n                });\n                XEUtils.each(customMap_1, function (_a, colKey) {\n                    var visible = _a.visible, resizeWidth = _a.resizeWidth, fixed = _a.fixed, order = _a.order;\n                    var column = keyMap_1[colKey];\n                    if (column) {\n                        if (XEUtils.isNumber(resizeWidth)) {\n                            column.resizeWidth = resizeWidth;\n                        }\n                        if (XEUtils.isBoolean(visible)) {\n                            column.visible = visible;\n                        }\n                        if (fixed) {\n                            column.fixed = fixed;\n                        }\n                        if (order) {\n                            column.customOrder = order;\n                        }\n                    }\n                });\n            }\n        };\n        /**\n         * 更新数据列的 Map\n         * 牺牲数据组装的耗时，用来换取使用过程中的流畅\n         */\n        var cacheColumnMap = function () {\n            var tableFullColumn = internalData.tableFullColumn, collectColumn = internalData.collectColumn;\n            var fullColumnIdData = internalData.fullColumnIdData = {};\n            var fullColumnFieldData = internalData.fullColumnFieldData = {};\n            var mouseOpts = computeMouseOpts.value;\n            var columnOpts = computeColumnOpts.value;\n            var rowOpts = computeRowOpts.value;\n            var isGroup = collectColumn.some(hasChildrenList);\n            var isAllOverflow = !!props.showOverflow;\n            var expandColumn;\n            var treeNodeColumn;\n            var checkboxColumn;\n            var radioColumn;\n            var htmlColumn;\n            var hasFixed;\n            var handleFunc = function (column, index, items, path, parent) {\n                var colid = column.id, field = column.field, fixed = column.fixed, type = column.type, treeNode = column.treeNode;\n                var rest = { column: column, colid: colid, index: index, items: items, parent: parent };\n                if (field) {\n                    if (process.env.NODE_ENV === 'development') {\n                        if (fullColumnFieldData[field]) {\n                            warnLog('vxe.error.colRepet', ['field', field]);\n                        }\n                    }\n                    fullColumnFieldData[field] = rest;\n                }\n                if (!hasFixed && fixed) {\n                    hasFixed = fixed;\n                }\n                if (!htmlColumn && type === 'html') {\n                    htmlColumn = column;\n                }\n                if (treeNode) {\n                    if (process.env.NODE_ENV === 'development') {\n                        if (treeNodeColumn) {\n                            warnLog('vxe.error.colRepet', ['tree-node', treeNode]);\n                        }\n                    }\n                    if (!treeNodeColumn) {\n                        treeNodeColumn = column;\n                    }\n                }\n                else if (type === 'expand') {\n                    if (process.env.NODE_ENV === 'development') {\n                        if (expandColumn) {\n                            warnLog('vxe.error.colRepet', ['type', type]);\n                        }\n                    }\n                    if (!expandColumn) {\n                        expandColumn = column;\n                    }\n                }\n                if (process.env.NODE_ENV === 'development') {\n                    if (type === 'checkbox') {\n                        if (checkboxColumn) {\n                            warnLog('vxe.error.colRepet', ['type', type]);\n                        }\n                        if (!checkboxColumn) {\n                            checkboxColumn = column;\n                        }\n                    }\n                    else if (type === 'radio') {\n                        if (radioColumn) {\n                            warnLog('vxe.error.colRepet', ['type', type]);\n                        }\n                        if (!radioColumn) {\n                            radioColumn = column;\n                        }\n                    }\n                }\n                if (isAllOverflow && column.showOverflow === false) {\n                    isAllOverflow = false;\n                }\n                if (fullColumnIdData[colid]) {\n                    errLog('vxe.error.colRepet', ['colId', colid]);\n                }\n                fullColumnIdData[colid] = rest;\n            };\n            if (isGroup) {\n                XEUtils.eachTree(collectColumn, function (column, index, items, path, parent, nodes) {\n                    column.level = nodes.length;\n                    handleFunc(column, index, items, path, parent);\n                });\n            }\n            else {\n                tableFullColumn.forEach(handleFunc);\n            }\n            if (process.env.NODE_ENV === 'development') {\n                if (expandColumn && mouseOpts.area) {\n                    errLog('vxe.error.errConflicts', ['mouse-config.area', 'column.type=expand']);\n                }\n            }\n            if (process.env.NODE_ENV === 'development') {\n                if (htmlColumn) {\n                    if (!columnOpts.useKey) {\n                        errLog('vxe.error.reqProp', ['column-config.useKey', 'column.type=html']);\n                    }\n                    if (!rowOpts.useKey) {\n                        errLog('vxe.error.reqProp', ['row-config.useKey', 'column.type=html']);\n                    }\n                }\n            }\n            reactData.isGroup = isGroup;\n            reactData.treeNodeColumn = treeNodeColumn;\n            reactData.expandColumn = expandColumn;\n            reactData.isAllOverflow = isAllOverflow;\n        };\n        var updateHeight = function () {\n            internalData.customHeight = calcHeight('height');\n            internalData.customMinHeight = calcHeight('minHeight');\n            internalData.customMaxHeight = calcHeight('maxHeight');\n        };\n        /**\n         * 列宽算法\n         * 支持 px、%、固定 混合分配\n         * 支持动态列表调整分配\n         * 支持自动分配偏移量\n         */\n        var autoCellWidth = function () {\n            var tableHeader = refTableHeader.value;\n            var tableBody = refTableBody.value;\n            var tableFooter = refTableFooter.value;\n            var bodyElem = tableBody ? tableBody.$el : null;\n            var headerElem = tableHeader ? tableHeader.$el : null;\n            var footerElem = tableFooter ? tableFooter.$el : null;\n            if (!bodyElem) {\n                return;\n            }\n            var tableWidth = 0;\n            var minCellWidth = 40; // 列宽最少限制 40px\n            var bodyWidth = bodyElem.clientWidth - 1;\n            var remainWidth = bodyWidth;\n            var meanWidth = remainWidth / 100;\n            var fit = props.fit;\n            var columnStore = reactData.columnStore;\n            var resizeList = columnStore.resizeList, pxMinList = columnStore.pxMinList, pxList = columnStore.pxList, scaleList = columnStore.scaleList, scaleMinList = columnStore.scaleMinList, autoList = columnStore.autoList;\n            // 最小宽\n            pxMinList.forEach(function (column) {\n                var minWidth = XEUtils.toInteger(column.minWidth);\n                tableWidth += minWidth;\n                column.renderWidth = minWidth;\n            });\n            // 最小百分比\n            scaleMinList.forEach(function (column) {\n                var scaleWidth = Math.floor(XEUtils.toInteger(column.minWidth) * meanWidth);\n                tableWidth += scaleWidth;\n                column.renderWidth = scaleWidth;\n            });\n            // 固定百分比\n            scaleList.forEach(function (column) {\n                var scaleWidth = Math.floor(XEUtils.toInteger(column.width) * meanWidth);\n                tableWidth += scaleWidth;\n                column.renderWidth = scaleWidth;\n            });\n            // 固定宽\n            pxList.forEach(function (column) {\n                var width = XEUtils.toInteger(column.width);\n                tableWidth += width;\n                column.renderWidth = width;\n            });\n            // 调整了列宽\n            resizeList.forEach(function (column) {\n                var width = XEUtils.toInteger(column.resizeWidth);\n                tableWidth += width;\n                column.renderWidth = width;\n            });\n            remainWidth -= tableWidth;\n            meanWidth = remainWidth > 0 ? Math.floor(remainWidth / (scaleMinList.length + pxMinList.length + autoList.length)) : 0;\n            if (fit) {\n                if (remainWidth > 0) {\n                    scaleMinList.concat(pxMinList).forEach(function (column) {\n                        tableWidth += meanWidth;\n                        column.renderWidth += meanWidth;\n                    });\n                }\n            }\n            else {\n                meanWidth = minCellWidth;\n            }\n            // 自适应\n            autoList.forEach(function (column) {\n                var width = Math.max(meanWidth, minCellWidth);\n                column.renderWidth = width;\n                tableWidth += width;\n            });\n            if (fit) {\n                /**\n                 * 偏移量算法\n                 * 如果所有列足够放的情况下，从最后动态列开始分配\n                 */\n                var dynamicList = scaleList.concat(scaleMinList).concat(pxMinList).concat(autoList);\n                var dynamicSize = dynamicList.length - 1;\n                if (dynamicSize > 0) {\n                    var odiffer = bodyWidth - tableWidth;\n                    if (odiffer > 0) {\n                        while (odiffer > 0 && dynamicSize >= 0) {\n                            odiffer--;\n                            dynamicList[dynamicSize--].renderWidth++;\n                        }\n                        tableWidth = bodyWidth;\n                    }\n                }\n            }\n            var tableHeight = bodyElem.offsetHeight;\n            var overflowY = bodyElem.scrollHeight > bodyElem.clientHeight;\n            var scrollbarWidth = 0;\n            if (overflowY) {\n                scrollbarWidth = Math.max(bodyElem.offsetWidth - bodyElem.clientWidth, 0);\n            }\n            reactData.scrollbarWidth = scrollbarWidth;\n            reactData.overflowY = overflowY;\n            internalData.tableWidth = tableWidth;\n            internalData.tableHeight = tableHeight;\n            var headerHeight = 0;\n            if (headerElem) {\n                headerHeight = headerElem.clientHeight;\n                nextTick(function () {\n                    // 检测是否同步滚动\n                    if (headerElem && bodyElem && headerElem.scrollLeft !== bodyElem.scrollLeft) {\n                        headerElem.scrollLeft = bodyElem.scrollLeft;\n                    }\n                });\n            }\n            internalData.headerHeight = headerHeight;\n            var overflowX = false;\n            var footerHeight = 0;\n            var scrollbarHeight = 0;\n            if (footerElem) {\n                footerHeight = footerElem.offsetHeight;\n                overflowX = tableWidth > footerElem.clientWidth;\n                if (overflowX) {\n                    scrollbarHeight = Math.max(footerHeight - footerElem.clientHeight, 0);\n                }\n            }\n            else {\n                overflowX = tableWidth > bodyWidth;\n                if (overflowX) {\n                    scrollbarHeight = Math.max(tableHeight - bodyElem.clientHeight, 0);\n                }\n            }\n            internalData.footerHeight = footerHeight;\n            reactData.overflowX = overflowX;\n            reactData.scrollbarHeight = scrollbarHeight;\n            updateHeight();\n            reactData.parentHeight = Math.max(internalData.headerHeight + footerHeight + 20, tablePrivateMethods.getParentHeight());\n            if (overflowX) {\n                tablePrivateMethods.checkScrolling();\n            }\n        };\n        var getOrderField = function (column) {\n            var sortBy = column.sortBy, sortType = column.sortType;\n            return function (row) {\n                var cellValue;\n                if (sortBy) {\n                    cellValue = XEUtils.isFunction(sortBy) ? sortBy({ row: row, column: column }) : XEUtils.get(row, sortBy);\n                }\n                else {\n                    cellValue = tablePrivateMethods.getCellLabel(row, column);\n                }\n                if (!sortType || sortType === 'auto') {\n                    return isNaN(cellValue) ? cellValue : XEUtils.toNumber(cellValue);\n                }\n                else if (sortType === 'number') {\n                    return XEUtils.toNumber(cellValue);\n                }\n                else if (sortType === 'string') {\n                    return XEUtils.toValueString(cellValue);\n                }\n                return cellValue;\n            };\n        };\n        /**\n         * 预编译\n         * 对渲染中的数据提前解析序号及索引。牺牲提前编译耗时换取渲染中额外损耗，使运行时更加流畅\n         */\n        var updateAfterDataIndex = function () {\n            var treeConfig = props.treeConfig;\n            var afterFullData = internalData.afterFullData, fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n            var afterTreeFullData = internalData.afterTreeFullData;\n            var treeOpts = computeTreeOpts.value;\n            var childrenField = treeOpts.children || treeOpts.childrenField;\n            var fullMaps = {};\n            if (treeConfig) {\n                XEUtils.eachTree(afterTreeFullData, function (row, index, items, path) {\n                    var rowid = getRowid($xetable, row);\n                    var allrest = fullAllDataRowIdData[rowid];\n                    var seq = path.map(function (num, i) { return i % 2 === 0 ? (Number(num) + 1) : '.'; }).join('');\n                    if (allrest) {\n                        allrest.seq = seq;\n                        allrest._index = index;\n                    }\n                    else {\n                        var rest = { row: row, rowid: rowid, seq: seq, index: -1, $index: -1, _index: index, items: [], parent: null, level: 0 };\n                        fullAllDataRowIdData[rowid] = rest;\n                        fullDataRowIdData[rowid] = rest;\n                    }\n                    fullMaps[rowid] = row;\n                }, { children: treeOpts.transform ? treeOpts.mapChildrenField : childrenField });\n            }\n            else {\n                afterFullData.forEach(function (row, index) {\n                    var rowid = getRowid($xetable, row);\n                    var allrest = fullAllDataRowIdData[rowid];\n                    var seq = index + 1;\n                    if (allrest) {\n                        allrest.seq = seq;\n                        allrest._index = index;\n                    }\n                    else {\n                        var rest = { row: row, rowid: rowid, seq: seq, index: -1, $index: -1, _index: index, items: [], parent: null, level: 0 };\n                        fullAllDataRowIdData[rowid] = rest;\n                        fullDataRowIdData[rowid] = rest;\n                    }\n                    fullMaps[rowid] = row;\n                });\n            }\n            internalData.afterFullRowMaps = fullMaps;\n        };\n        /**\n         * 如果为虚拟树，将树结构拍平\n         * @returns\n         */\n        var handleVirtualTreeToList = function () {\n            var treeConfig = props.treeConfig;\n            var treeExpandedMaps = reactData.treeExpandedMaps;\n            var treeOpts = computeTreeOpts.value;\n            if (treeConfig && treeOpts.transform) {\n                var fullData_1 = [];\n                var expandMaps_1 = {};\n                XEUtils.eachTree(internalData.afterTreeFullData, function (row, index, items, path, parent) {\n                    var rowid = getRowid($xetable, row);\n                    var parentRowid = getRowid($xetable, parent);\n                    if (!parent || (expandMaps_1[parentRowid] && treeExpandedMaps[parentRowid])) {\n                        expandMaps_1[rowid] = 1;\n                        fullData_1.push(row);\n                    }\n                }, { children: treeOpts.mapChildrenField });\n                internalData.afterFullData = fullData_1;\n                updateScrollYStatus(fullData_1);\n                return fullData_1;\n            }\n            return internalData.afterFullData;\n        };\n        /**\n         * 获取处理后全量的表格数据\n         * 如果存在筛选条件，继续处理\n         */\n        var updateAfterFullData = function () {\n            var treeConfig = props.treeConfig;\n            var tableFullColumn = internalData.tableFullColumn, tableFullData = internalData.tableFullData, tableFullTreeData = internalData.tableFullTreeData;\n            var filterOpts = computeFilterOpts.value;\n            var sortOpts = computeSortOpts.value;\n            var treeOpts = computeTreeOpts.value;\n            var transform = treeOpts.transform;\n            var allRemoteFilter = filterOpts.remote, allFilterMethod = filterOpts.filterMethod;\n            var allRemoteSort = sortOpts.remote, allSortMethod = sortOpts.sortMethod, sortMultiple = sortOpts.multiple, chronological = sortOpts.chronological;\n            var tableData = [];\n            var tableTree = [];\n            // 处理列\n            if (!allRemoteFilter || !allRemoteSort) {\n                var filterColumns_1 = [];\n                var orderColumns_1 = [];\n                tableFullColumn.forEach(function (column) {\n                    var field = column.field, sortable = column.sortable, order = column.order, filters = column.filters;\n                    if (!allRemoteFilter && filters && filters.length) {\n                        var valueList_1 = [];\n                        var itemList_1 = [];\n                        filters.forEach(function (item) {\n                            if (item.checked) {\n                                itemList_1.push(item);\n                                valueList_1.push(item.value);\n                            }\n                        });\n                        if (itemList_1.length) {\n                            filterColumns_1.push({ column: column, valueList: valueList_1, itemList: itemList_1 });\n                        }\n                    }\n                    if (!allRemoteSort && sortable && order) {\n                        orderColumns_1.push({ column: column, field: field, property: field, order: order, sortTime: column.sortTime });\n                    }\n                });\n                if (sortMultiple && chronological && orderColumns_1.length > 1) {\n                    orderColumns_1 = XEUtils.orderBy(orderColumns_1, 'sortTime');\n                }\n                // 处理筛选\n                // 支持单列、多列、组合筛选\n                if (!allRemoteFilter && filterColumns_1.length) {\n                    var handleFilter = function (row) {\n                        return filterColumns_1.every(function (_a) {\n                            var column = _a.column, valueList = _a.valueList, itemList = _a.itemList;\n                            var filterMethod = column.filterMethod, filterRender = column.filterRender;\n                            var compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;\n                            var compFilterMethod = compConf ? compConf.filterMethod : null;\n                            var defaultFilterMethod = compConf ? compConf.defaultFilterMethod : null;\n                            var cellValue = getCellValue(row, column);\n                            if (filterMethod) {\n                                return itemList.some(function (item) { return filterMethod({ value: item.value, option: item, cellValue: cellValue, row: row, column: column, $table: $xetable }); });\n                            }\n                            else if (compFilterMethod) {\n                                return itemList.some(function (item) { return compFilterMethod({ value: item.value, option: item, cellValue: cellValue, row: row, column: column, $table: $xetable }); });\n                            }\n                            else if (allFilterMethod) {\n                                return allFilterMethod({ options: itemList, values: valueList, cellValue: cellValue, row: row, column: column });\n                            }\n                            else if (defaultFilterMethod) {\n                                return itemList.some(function (item) { return defaultFilterMethod({ value: item.value, option: item, cellValue: cellValue, row: row, column: column, $table: $xetable }); });\n                            }\n                            return valueList.indexOf(XEUtils.get(row, column.field)) > -1;\n                        });\n                    };\n                    if (treeConfig && transform) {\n                        // 筛选虚拟树\n                        tableTree = XEUtils.searchTree(tableFullTreeData, handleFilter, __assign(__assign({}, treeOpts), { original: true }));\n                        tableData = tableTree;\n                    }\n                    else {\n                        tableData = treeConfig ? tableFullTreeData.filter(handleFilter) : tableFullData.filter(handleFilter);\n                        tableTree = tableData;\n                    }\n                }\n                else {\n                    if (treeConfig && transform) {\n                        // 还原虚拟树\n                        tableTree = XEUtils.searchTree(tableFullTreeData, function () { return true; }, __assign(__assign({}, treeOpts), { original: true }));\n                        tableData = tableTree;\n                    }\n                    else {\n                        tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);\n                        tableTree = tableData;\n                    }\n                }\n                // 处理排序（不能用于树形结构）\n                // 支持单列、多列、组合排序\n                if (!allRemoteSort && orderColumns_1.length) {\n                    if (treeConfig && transform) {\n                        // 虚拟树和列表一样，只能排序根级节点\n                        if (allSortMethod) {\n                            var sortRests = allSortMethod({ data: tableTree, sortList: orderColumns_1, $table: $xetable });\n                            tableTree = XEUtils.isArray(sortRests) ? sortRests : tableTree;\n                        }\n                        else {\n                            tableTree = XEUtils.orderBy(tableTree, orderColumns_1.map(function (_a) {\n                                var column = _a.column, order = _a.order;\n                                return [getOrderField(column), order];\n                            }));\n                        }\n                        tableData = tableTree;\n                    }\n                    else {\n                        if (allSortMethod) {\n                            var sortRests = allSortMethod({ data: tableData, sortList: orderColumns_1, $table: $xetable });\n                            tableData = XEUtils.isArray(sortRests) ? sortRests : tableData;\n                        }\n                        else {\n                            tableData = XEUtils.orderBy(tableData, orderColumns_1.map(function (_a) {\n                                var column = _a.column, order = _a.order;\n                                return [getOrderField(column), order];\n                            }));\n                        }\n                        tableTree = tableData;\n                    }\n                }\n            }\n            else {\n                if (treeConfig && transform) {\n                    // 还原虚拟树\n                    tableTree = XEUtils.searchTree(tableFullTreeData, function () { return true; }, __assign(__assign({}, treeOpts), { original: true }));\n                    tableData = tableTree;\n                }\n                else {\n                    tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);\n                    tableTree = tableData;\n                }\n            }\n            internalData.afterFullData = tableData;\n            internalData.afterTreeFullData = tableTree;\n            updateAfterDataIndex();\n        };\n        var updateStyle = function () {\n            var border = props.border, showFooter = props.showFooter, allColumnOverflow = props.showOverflow, allColumnHeaderOverflow = props.showHeaderOverflow, allColumnFooterOverflow = props.showFooterOverflow, mouseConfig = props.mouseConfig, spanMethod = props.spanMethod, footerSpanMethod = props.footerSpanMethod, keyboardConfig = props.keyboardConfig;\n            var isGroup = reactData.isGroup, currentRow = reactData.currentRow, tableColumn = reactData.tableColumn, scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad, scrollbarWidth = reactData.scrollbarWidth, scrollbarHeight = reactData.scrollbarHeight, columnStore = reactData.columnStore, editStore = reactData.editStore, mergeList = reactData.mergeList, mergeFooterList = reactData.mergeFooterList, isAllOverflow = reactData.isAllOverflow;\n            var visibleColumn = internalData.visibleColumn, fullColumnIdData = internalData.fullColumnIdData, tableHeight = internalData.tableHeight, tableWidth = internalData.tableWidth, headerHeight = internalData.headerHeight, footerHeight = internalData.footerHeight, elemStore = internalData.elemStore, customHeight = internalData.customHeight, customMinHeight = internalData.customMinHeight, customMaxHeight = internalData.customMaxHeight;\n            var containerList = ['main', 'left', 'right'];\n            var emptyPlaceholderElem = refEmptyPlaceholder.value;\n            var cellOffsetWidth = computeCellOffsetWidth.value;\n            var mouseOpts = computeMouseOpts.value;\n            var keyboardOpts = computeKeyboardOpts.value;\n            var bodyWrapperRef = elemStore['main-body-wrapper'];\n            var bodyWrapperElem = bodyWrapperRef ? bodyWrapperRef.value : null;\n            if (emptyPlaceholderElem) {\n                emptyPlaceholderElem.style.top = \"\".concat(headerHeight, \"px\");\n                emptyPlaceholderElem.style.height = bodyWrapperElem ? \"\".concat(bodyWrapperElem.offsetHeight - scrollbarHeight, \"px\") : '';\n            }\n            if (customHeight > 0) {\n                if (showFooter) {\n                    customHeight += scrollbarHeight;\n                }\n            }\n            containerList.forEach(function (name, index) {\n                var fixedType = index > 0 ? name : '';\n                var layoutList = ['header', 'body', 'footer'];\n                var isFixedLeft = fixedType === 'left';\n                var fixedColumn = [];\n                var fixedWrapperElem;\n                if (fixedType) {\n                    fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;\n                    fixedWrapperElem = isFixedLeft ? refLeftContainer.value : refRightContainer.value;\n                }\n                layoutList.forEach(function (layout) {\n                    var wrapperRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-wrapper\")];\n                    var wrapperElem = wrapperRef ? wrapperRef.value : null;\n                    var tableRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-table\")];\n                    var tableElem = tableRef ? tableRef.value : null;\n                    if (layout === 'header') {\n                        // 表头体样式处理\n                        // 横向滚动渲染\n                        var tWidth = tableWidth;\n                        var renderColumnList = tableColumn;\n                        if (isGroup) {\n                            renderColumnList = visibleColumn;\n                        }\n                        else {\n                            // 如果是使用优化模式\n                            if (fixedType) {\n                                if (scrollXLoad || allColumnHeaderOverflow) {\n                                    renderColumnList = fixedColumn;\n                                }\n                            }\n                        }\n                        tWidth = renderColumnList.reduce(function (previous, column) { return previous + column.renderWidth; }, 0);\n                        if (tableElem) {\n                            tableElem.style.width = tWidth ? \"\".concat(tWidth + scrollbarWidth, \"px\") : '';\n                        }\n                        var repairRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-repair\")];\n                        var repairElem = repairRef ? repairRef.value : null;\n                        if (repairElem) {\n                            repairElem.style.width = \"\".concat(tableWidth, \"px\");\n                        }\n                        var listRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-list\")];\n                        var listElem = listRef ? listRef.value : null;\n                        if (isGroup && listElem) {\n                            XEUtils.arrayEach(listElem.querySelectorAll('.col--group'), function (thElem) {\n                                var colNode = tableMethods.getColumnNode(thElem);\n                                if (colNode) {\n                                    var column_1 = colNode.item;\n                                    var showHeaderOverflow = column_1.showHeaderOverflow;\n                                    var cellOverflow = XEUtils.isBoolean(showHeaderOverflow) ? showHeaderOverflow : allColumnHeaderOverflow;\n                                    var showEllipsis = cellOverflow === 'ellipsis';\n                                    var showTitle = cellOverflow === 'title';\n                                    var showTooltip = cellOverflow === true || cellOverflow === 'tooltip';\n                                    var hasEllipsis = showTitle || showTooltip || showEllipsis;\n                                    var childWidth_1 = 0;\n                                    var countChild_1 = 0;\n                                    if (hasEllipsis) {\n                                        XEUtils.eachTree(column_1.children, function (item) {\n                                            if (!item.children || !column_1.children.length) {\n                                                countChild_1++;\n                                            }\n                                            childWidth_1 += item.renderWidth;\n                                        }, { children: 'children' });\n                                    }\n                                    thElem.style.width = hasEllipsis ? \"\".concat(childWidth_1 - countChild_1 - (border ? 2 : 0), \"px\") : '';\n                                }\n                            });\n                        }\n                    }\n                    else if (layout === 'body') {\n                        var emptyBlockRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-emptyBlock\")];\n                        var emptyBlockElem = emptyBlockRef ? emptyBlockRef.value : null;\n                        if (isNodeElement(wrapperElem)) {\n                            var bodyMaxHeight = 0;\n                            var bodyMinHeight = customMinHeight - headerHeight - footerHeight;\n                            if (customMaxHeight) {\n                                bodyMaxHeight = customMaxHeight - headerHeight - footerHeight;\n                                // 如果是固定列\n                                if (fixedType) {\n                                    bodyMaxHeight -= (showFooter ? 0 : scrollbarHeight);\n                                }\n                                bodyMaxHeight = Math.max(bodyMinHeight, bodyMaxHeight);\n                                wrapperElem.style.maxHeight = \"\".concat(bodyMaxHeight, \"px\");\n                            }\n                            if (customHeight) {\n                                var bodyHeight = customHeight - headerHeight - footerHeight;\n                                // 如果是固定列\n                                if (fixedType) {\n                                    bodyHeight -= (showFooter ? 0 : scrollbarHeight);\n                                }\n                                if (bodyMaxHeight) {\n                                    bodyHeight = Math.min(bodyMaxHeight, bodyHeight);\n                                }\n                                wrapperElem.style.height = \"\".concat(Math.max(bodyMinHeight, bodyHeight), \"px\");\n                            }\n                            else {\n                                wrapperElem.style.height = '';\n                            }\n                            wrapperElem.style.minHeight = \"\".concat(bodyMinHeight, \"px\");\n                        }\n                        // 如果是固定列\n                        if (fixedWrapperElem) {\n                            if (isNodeElement(wrapperElem)) {\n                                wrapperElem.style.top = \"\".concat(headerHeight, \"px\");\n                            }\n                            fixedWrapperElem.style.height = \"\".concat((customHeight > 0 ? customHeight - headerHeight - footerHeight : tableHeight) + headerHeight + footerHeight - scrollbarHeight * (showFooter ? 2 : 1), \"px\");\n                            fixedWrapperElem.style.width = \"\".concat(fixedColumn.reduce(function (previous, column) { return previous + column.renderWidth; }, isFixedLeft ? 0 : scrollbarWidth), \"px\");\n                        }\n                        var tWidth = tableWidth;\n                        var renderColumnList = tableColumn;\n                        // 如果是使用优化模式\n                        if (fixedType) {\n                            // 如果存在展开行使用全量渲染\n                            if (!reactData.expandColumn && (scrollYLoad || (allColumnOverflow ? isAllOverflow : allColumnOverflow))) {\n                                if (!mergeList.length && !spanMethod && !(keyboardConfig && keyboardOpts.isMerge)) {\n                                    renderColumnList = fixedColumn;\n                                }\n                                else {\n                                    renderColumnList = visibleColumn;\n                                }\n                            }\n                            else {\n                                renderColumnList = visibleColumn;\n                            }\n                        }\n                        tWidth = renderColumnList.reduce(function (previous, column) { return previous + column.renderWidth; }, 0);\n                        if (tableElem) {\n                            tableElem.style.width = tWidth ? \"\".concat(tWidth, \"px\") : '';\n                            // 兼容性处理\n                            tableElem.style.paddingRight = scrollbarWidth && fixedType && (browse['-moz'] || browse.safari) ? \"\".concat(scrollbarWidth, \"px\") : '';\n                        }\n                        if (emptyBlockElem) {\n                            emptyBlockElem.style.width = tWidth ? \"\".concat(tWidth, \"px\") : '';\n                        }\n                    }\n                    else if (layout === 'footer') {\n                        var tWidth = tableWidth;\n                        var renderColumnList = tableColumn;\n                        // 如果是使用优化模式\n                        if (fixedType) {\n                            // 如果存在展开行使用全量渲染\n                            if (!reactData.expandColumn && (scrollXLoad || allColumnFooterOverflow)) {\n                                if (!mergeFooterList.length || !footerSpanMethod) {\n                                    renderColumnList = fixedColumn;\n                                }\n                                else {\n                                    renderColumnList = visibleColumn;\n                                }\n                            }\n                            else {\n                                renderColumnList = visibleColumn;\n                            }\n                        }\n                        tWidth = renderColumnList.reduce(function (previous, column) { return previous + column.renderWidth; }, 0);\n                        if (isNodeElement(wrapperElem)) {\n                            // 如果是固定列\n                            if (fixedWrapperElem) {\n                                wrapperElem.style.top = \"\".concat(customHeight > 0 ? customHeight - footerHeight : tableHeight + headerHeight, \"px\");\n                            }\n                            wrapperElem.style.marginTop = \"\".concat(-Math.max(1, scrollbarHeight), \"px\");\n                        }\n                        if (tableElem) {\n                            tableElem.style.width = tWidth ? \"\".concat(tWidth + scrollbarWidth, \"px\") : '';\n                        }\n                    }\n                    var colgroupRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-colgroup\")];\n                    var colgroupElem = colgroupRef ? colgroupRef.value : null;\n                    if (colgroupElem) {\n                        XEUtils.arrayEach(colgroupElem.children, function (colElem) {\n                            var colid = colElem.getAttribute('name');\n                            if (colid === 'col_gutter') {\n                                colElem.style.width = \"\".concat(scrollbarWidth, \"px\");\n                            }\n                            if (fullColumnIdData[colid]) {\n                                var column_2 = fullColumnIdData[colid].column;\n                                var showHeaderOverflow = column_2.showHeaderOverflow, showFooterOverflow = column_2.showFooterOverflow, showOverflow = column_2.showOverflow;\n                                var cellOverflow = void 0;\n                                colElem.style.width = \"\".concat(column_2.renderWidth, \"px\");\n                                if (layout === 'header') {\n                                    cellOverflow = XEUtils.isUndefined(showHeaderOverflow) || XEUtils.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;\n                                }\n                                else if (layout === 'footer') {\n                                    cellOverflow = XEUtils.isUndefined(showFooterOverflow) || XEUtils.isNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;\n                                }\n                                else {\n                                    cellOverflow = XEUtils.isUndefined(showOverflow) || XEUtils.isNull(showOverflow) ? allColumnOverflow : showOverflow;\n                                }\n                                var showEllipsis = cellOverflow === 'ellipsis';\n                                var showTitle = cellOverflow === 'title';\n                                var showTooltip = cellOverflow === true || cellOverflow === 'tooltip';\n                                var hasEllipsis_1 = showTitle || showTooltip || showEllipsis;\n                                var listRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-list\")];\n                                var listElem = listRef ? listRef.value : null;\n                                // 纵向虚拟滚动不支持动态行高\n                                if (scrollYLoad && !hasEllipsis_1) {\n                                    hasEllipsis_1 = true;\n                                }\n                                if (listElem) {\n                                    XEUtils.arrayEach(listElem.querySelectorAll(\".\".concat(column_2.id)), function (elem) {\n                                        var colspan = parseInt(elem.getAttribute('colspan') || 1);\n                                        var cellElem = elem.querySelector('.vxe-cell');\n                                        var colWidth = column_2.renderWidth;\n                                        if (cellElem) {\n                                            if (colspan > 1) {\n                                                var columnIndex = tableMethods.getColumnIndex(column_2);\n                                                for (var index_1 = 1; index_1 < colspan; index_1++) {\n                                                    var nextColumn = tableMethods.getColumns(columnIndex + index_1);\n                                                    if (nextColumn) {\n                                                        colWidth += nextColumn.renderWidth;\n                                                    }\n                                                }\n                                            }\n                                            cellElem.style.width = hasEllipsis_1 ? \"\".concat(colWidth - (cellOffsetWidth * colspan), \"px\") : '';\n                                        }\n                                    });\n                                }\n                            }\n                        });\n                    }\n                });\n            });\n            if (currentRow) {\n                tableMethods.setCurrentRow(currentRow);\n            }\n            if (mouseConfig && mouseOpts.selected && editStore.selected.row && editStore.selected.column) {\n                $xetable.addCellSelectedClass();\n            }\n            return nextTick();\n        };\n        var checkValidate = function (type) {\n            if ($xetable.triggerValidate) {\n                return $xetable.triggerValidate(type);\n            }\n            return nextTick();\n        };\n        /**\n         * 当单元格发生改变时\n         * 如果存在规则，则校验\n         */\n        var handleChangeCell = function (evnt, params) {\n            checkValidate('blur')\n                .catch(function (e) { return e; })\n                .then(function () {\n                $xetable.handleActived(params, evnt)\n                    .then(function () { return checkValidate('change'); })\n                    .catch(function (e) { return e; });\n            });\n        };\n        var handleDefaultSort = function () {\n            var sortConfig = props.sortConfig;\n            if (sortConfig) {\n                var sortOpts = computeSortOpts.value;\n                var defaultSort = sortOpts.defaultSort;\n                if (defaultSort) {\n                    if (!XEUtils.isArray(defaultSort)) {\n                        defaultSort = [defaultSort];\n                    }\n                    if (defaultSort.length) {\n                        (sortConfig.multiple ? defaultSort : defaultSort.slice(0, 1)).forEach(function (item, index) {\n                            var field = item.field, order = item.order;\n                            if (field && order) {\n                                var column = tableMethods.getColumnByField(field);\n                                if (column && column.sortable) {\n                                    column.order = order;\n                                    column.sortTime = Date.now() + index;\n                                }\n                            }\n                        });\n                        if (!sortOpts.remote) {\n                            tablePrivateMethods.handleTableData(true).then(updateStyle);\n                        }\n                    }\n                }\n            }\n        };\n        /**\n         * 处理默认勾选\n         */\n        var handleDefaultSelectionChecked = function () {\n            var checkboxConfig = props.checkboxConfig;\n            if (checkboxConfig) {\n                var fullDataRowIdData_1 = internalData.fullDataRowIdData;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var checkAll = checkboxOpts.checkAll, checkRowKeys = checkboxOpts.checkRowKeys;\n                if (checkAll) {\n                    handleCheckedAllCheckboxRow(true, true);\n                }\n                else if (checkRowKeys) {\n                    var defSelection_1 = [];\n                    checkRowKeys.forEach(function (rowid) {\n                        if (fullDataRowIdData_1[rowid]) {\n                            defSelection_1.push(fullDataRowIdData_1[rowid].row);\n                        }\n                    });\n                    handleCheckedCheckboxRow(defSelection_1, true, true);\n                }\n            }\n        };\n        /**\n         * 处理单选框默认勾选\n         */\n        var handleDefaultRadioChecked = function () {\n            var _a;\n            var radioConfig = props.radioConfig;\n            if (radioConfig) {\n                var fullDataRowIdData = internalData.fullDataRowIdData;\n                var radioOpts = computeRadioOpts.value;\n                var rowid = radioOpts.checkRowKey, reserve = radioOpts.reserve;\n                if (rowid) {\n                    if (fullDataRowIdData[rowid]) {\n                        handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);\n                    }\n                    if (reserve) {\n                        var rowkey = getRowkey($xetable);\n                        internalData.radioReserveRow = (_a = {}, _a[rowkey] = rowid, _a);\n                    }\n                }\n            }\n        };\n        /**\n         * 处理默认展开行\n         */\n        var handleDefaultRowExpand = function () {\n            var expandConfig = props.expandConfig;\n            if (expandConfig) {\n                var fullDataRowIdData_2 = internalData.fullDataRowIdData;\n                var expandOpts = computeExpandOpts.value;\n                var expandAll = expandOpts.expandAll, expandRowKeys = expandOpts.expandRowKeys;\n                if (expandAll) {\n                    tableMethods.setAllRowExpand(true);\n                }\n                else if (expandRowKeys) {\n                    var defExpandeds_1 = [];\n                    expandRowKeys.forEach(function (rowid) {\n                        if (fullDataRowIdData_2[rowid]) {\n                            defExpandeds_1.push(fullDataRowIdData_2[rowid].row);\n                        }\n                    });\n                    tableMethods.setRowExpand(defExpandeds_1, true);\n                }\n            }\n        };\n        var handleRadioReserveRow = function (row) {\n            var radioOpts = computeRadioOpts.value;\n            if (radioOpts.reserve) {\n                internalData.radioReserveRow = row;\n            }\n        };\n        var handleCheckboxReserveRow = function (row, checked) {\n            var checkboxReserveRowMap = internalData.checkboxReserveRowMap;\n            var checkboxOpts = computeCheckboxOpts.value;\n            if (checkboxOpts.reserve) {\n                var rowid = getRowid($xetable, row);\n                if (checked) {\n                    checkboxReserveRowMap[rowid] = row;\n                }\n                else if (checkboxReserveRowMap[rowid]) {\n                    delete checkboxReserveRowMap[rowid];\n                }\n            }\n        };\n        var handleCheckedRadioRow = function (row, isForce) {\n            var radioOpts = computeRadioOpts.value;\n            var checkMethod = radioOpts.checkMethod;\n            if (row && (isForce || (!checkMethod || checkMethod({ row: row })))) {\n                reactData.selectRadioRow = row;\n                handleRadioReserveRow(row);\n            }\n            return nextTick();\n        };\n        var handleCheckedCheckboxRow = function (rows, value, isForce) {\n            if (rows && !XEUtils.isArray(rows)) {\n                rows = [rows];\n            }\n            rows.forEach(function (row) { return tablePrivateMethods.handleSelectRow({ row: row }, !!value, isForce); });\n            return nextTick();\n        };\n        var handleCheckedAllCheckboxRow = function (value, isForce) {\n            var treeConfig = props.treeConfig;\n            var selectCheckboxMaps = reactData.selectCheckboxMaps;\n            var afterFullData = internalData.afterFullData, afterFullRowMaps = internalData.afterFullRowMaps, checkboxReserveRowMap = internalData.checkboxReserveRowMap;\n            var treeOpts = computeTreeOpts.value;\n            var childrenField = treeOpts.children || treeOpts.childrenField;\n            var checkboxOpts = computeCheckboxOpts.value;\n            var checkField = checkboxOpts.checkField, reserve = checkboxOpts.reserve, checkStrictly = checkboxOpts.checkStrictly, checkMethod = checkboxOpts.checkMethod;\n            var indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;\n            var selectRowMaps = {};\n            // 疑惑！\n            if (!treeConfig) {\n                XEUtils.each(selectCheckboxMaps, function (row, rowid) {\n                    if (!afterFullRowMaps[rowid]) {\n                        selectRowMaps[rowid] = row;\n                    }\n                });\n            }\n            // 疑惑！\n            if (checkStrictly) {\n                reactData.isAllSelected = value;\n            }\n            else {\n                /**\n                 * 绑定属性方式（高性能，有污染）\n                 * 必须在行数据存在对应的属性，否则将不响应\n                 */\n                if (checkField) {\n                    var checkValFn = function (row) {\n                        if (isForce || (!checkMethod || checkMethod({ row: row }))) {\n                            if (value) {\n                                selectRowMaps[getRowid($xetable, row)] = row;\n                            }\n                            XEUtils.set(row, checkField, value);\n                        }\n                        if (treeConfig && indeterminateField) {\n                            XEUtils.set(row, indeterminateField, false);\n                        }\n                    };\n                    // 如果存在选中方法\n                    // 如果方法成立，则更新值，否则忽略该数据\n                    if (treeConfig) {\n                        XEUtils.eachTree(afterFullData, checkValFn, { children: childrenField });\n                    }\n                    else {\n                        afterFullData.forEach(checkValFn);\n                    }\n                }\n                else {\n                    /**\n                     * 默认方式（低性能，无污染）\n                     * 无需任何属性，直接绑定\n                     */\n                    if (treeConfig) {\n                        if (value) {\n                            /**\n                             * 如果是树勾选\n                             * 如果方法成立，则添加到临时集合中\n                             */\n                            XEUtils.eachTree(afterFullData, function (row) {\n                                if (isForce || (!checkMethod || checkMethod({ row: row }))) {\n                                    selectRowMaps[getRowid($xetable, row)] = row;\n                                }\n                            }, { children: childrenField });\n                        }\n                        else {\n                            /**\n                             * 如果是树取消\n                             * 如果方法成立，则不添加到临时集合中\n                             */\n                            if (!isForce && checkMethod) {\n                                XEUtils.eachTree(afterFullData, function (row) {\n                                    var rowid = getRowid($xetable, row);\n                                    if (checkMethod({ row: row }) ? 0 : selectCheckboxMaps[rowid]) {\n                                        selectRowMaps[rowid] = row;\n                                    }\n                                }, { children: childrenField });\n                            }\n                        }\n                    }\n                    else {\n                        if (value) {\n                            /**\n                             * 如果是行勾选\n                             * 如果存在选中方法且成立或者本身已勾选，则添加到临时集合中\n                             * 如果不存在选中方法，则添加所有数据到临时集合中\n                             */\n                            if (!isForce && checkMethod) {\n                                afterFullData.forEach(function (row) {\n                                    var rowid = getRowid($xetable, row);\n                                    if (selectCheckboxMaps[rowid] || checkMethod({ row: row })) {\n                                        selectRowMaps[rowid] = row;\n                                    }\n                                });\n                            }\n                            else {\n                                afterFullData.forEach(function (row) {\n                                    selectRowMaps[getRowid($xetable, row)] = row;\n                                });\n                            }\n                        }\n                        else {\n                            /**\n                             * 如果是行取消\n                             * 如果方法成立，则不添加到临时集合中；如果方法不成立则判断当前是否已勾选，如果已被勾选则添加到新集合中\n                             * 如果不存在选中方法，无需处理，临时集合默认为空\n                             */\n                            if (!isForce && checkMethod) {\n                                afterFullData.forEach(function (row) {\n                                    var rowid = getRowid($xetable, row);\n                                    if (checkMethod({ row: row }) ? 0 : selectCheckboxMaps[rowid]) {\n                                        selectRowMaps[rowid] = row;\n                                    }\n                                });\n                            }\n                        }\n                    }\n                }\n                if (reserve) {\n                    if (value) {\n                        XEUtils.each(selectRowMaps, function (row, rowid) {\n                            checkboxReserveRowMap[rowid] = row;\n                        });\n                    }\n                    else {\n                        afterFullData.forEach(function (row) { return handleCheckboxReserveRow(row, false); });\n                    }\n                }\n                reactData.selectCheckboxMaps = checkField ? {} : selectRowMaps;\n            }\n            reactData.treeIndeterminateMaps = {};\n            internalData.treeIndeterminateRowMaps = {};\n            tablePrivateMethods.checkSelectionStatus();\n            return nextTick();\n        };\n        // 还原展开、选中等相关状态\n        var handleReserveStatus = function () {\n            var treeConfig = props.treeConfig;\n            var expandColumn = reactData.expandColumn, currentRow = reactData.currentRow, selectCheckboxMaps = reactData.selectCheckboxMaps, selectRadioRow = reactData.selectRadioRow, rowExpandedMaps = reactData.rowExpandedMaps, treeExpandedMaps = reactData.treeExpandedMaps;\n            var fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData, radioReserveRow = internalData.radioReserveRow;\n            var expandOpts = computeExpandOpts.value;\n            var treeOpts = computeTreeOpts.value;\n            var radioOpts = computeRadioOpts.value;\n            var checkboxOpts = computeCheckboxOpts.value;\n            // 单选框\n            if (selectRadioRow && !fullAllDataRowIdData[getRowid($xetable, selectRadioRow)]) {\n                reactData.selectRadioRow = null; // 刷新单选行状态\n            }\n            // 还原保留选中状态\n            if (radioOpts.reserve && radioReserveRow) {\n                var rowid = getRowid($xetable, radioReserveRow);\n                if (fullDataRowIdData[rowid]) {\n                    handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);\n                }\n            }\n            // 复选框\n            reactData.selectCheckboxMaps = getRecoverRowMaps(selectCheckboxMaps); // 刷新多选行状态\n            // 还原保留选中状态\n            if (checkboxOpts.reserve) {\n                handleCheckedCheckboxRow(handleReserveRow(internalData.checkboxReserveRowMap), true, true);\n            }\n            if (currentRow && !fullAllDataRowIdData[getRowid($xetable, currentRow)]) {\n                reactData.currentRow = null; // 刷新当前行状态\n            }\n            // 行展开\n            reactData.rowExpandedMaps = expandColumn ? getRecoverRowMaps(rowExpandedMaps) : {}; // 刷新行展开状态\n            // 还原保留状态\n            if (expandColumn && expandOpts.reserve) {\n                tableMethods.setRowExpand(handleReserveRow(internalData.rowExpandedReserveRowMap), true);\n            }\n            // 树展开\n            reactData.treeExpandedMaps = treeConfig ? getRecoverRowMaps(treeExpandedMaps) : {}; // 刷新树展开状态\n            if (treeConfig && treeOpts.reserve) {\n                tableMethods.setTreeExpand(handleReserveRow(internalData.treeExpandedReserveRowMap), true);\n            }\n        };\n        /**\n         * 处理默认展开树节点\n         */\n        var handleDefaultTreeExpand = function () {\n            var treeConfig = props.treeConfig;\n            if (treeConfig) {\n                var tableFullData_1 = internalData.tableFullData;\n                var treeOpts = computeTreeOpts.value;\n                var expandAll = treeOpts.expandAll, expandRowKeys = treeOpts.expandRowKeys;\n                var childrenField_1 = treeOpts.children || treeOpts.childrenField;\n                if (expandAll) {\n                    tableMethods.setAllTreeExpand(true);\n                }\n                else if (expandRowKeys) {\n                    var defExpandeds_2 = [];\n                    var rowkey_1 = getRowkey($xetable);\n                    expandRowKeys.forEach(function (rowid) {\n                        var matchObj = XEUtils.findTree(tableFullData_1, function (item) { return rowid === XEUtils.get(item, rowkey_1); }, { children: childrenField_1 });\n                        if (matchObj) {\n                            defExpandeds_2.push(matchObj.item);\n                        }\n                    });\n                    tableMethods.setTreeExpand(defExpandeds_2, true);\n                }\n            }\n        };\n        var handleAsyncTreeExpandChilds = function (row) {\n            var treeOpts = computeTreeOpts.value;\n            var checkboxOpts = computeCheckboxOpts.value;\n            var transform = treeOpts.transform, loadMethod = treeOpts.loadMethod;\n            var checkStrictly = checkboxOpts.checkStrictly;\n            return new Promise(function (resolve) {\n                if (loadMethod) {\n                    var treeExpandLazyLoadedMaps_1 = reactData.treeExpandLazyLoadedMaps;\n                    var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                    var rowid_1 = getRowid($xetable, row);\n                    var rest_1 = fullAllDataRowIdData[rowid_1];\n                    treeExpandLazyLoadedMaps_1[rowid_1] = row;\n                    loadMethod({ $table: $xetable, row: row }).then(function (childRecords) {\n                        rest_1.treeLoaded = true;\n                        if (treeExpandLazyLoadedMaps_1[rowid_1]) {\n                            delete treeExpandLazyLoadedMaps_1[rowid_1];\n                        }\n                        if (!XEUtils.isArray(childRecords)) {\n                            childRecords = [];\n                        }\n                        if (childRecords) {\n                            return tableMethods.loadTreeChildren(row, childRecords).then(function (childRows) {\n                                var treeExpandedMaps = reactData.treeExpandedMaps;\n                                if (childRows.length && !treeExpandedMaps[rowid_1]) {\n                                    treeExpandedMaps[rowid_1] = row;\n                                }\n                                // 如果当前节点已选中，则展开后子节点也被选中\n                                if (!checkStrictly && tableMethods.isCheckedByCheckboxRow(row)) {\n                                    handleCheckedCheckboxRow(childRows, true);\n                                }\n                                return nextTick().then(function () {\n                                    if (transform) {\n                                        return tablePrivateMethods.handleTableData();\n                                    }\n                                });\n                            });\n                        }\n                    }).catch(function () {\n                        var treeExpandLazyLoadedMaps = reactData.treeExpandLazyLoadedMaps;\n                        rest_1.treeLoaded = false;\n                        if (treeExpandLazyLoadedMaps[rowid_1]) {\n                            delete treeExpandLazyLoadedMaps[rowid_1];\n                        }\n                    }).finally(function () {\n                        nextTick().then(function () { return tableMethods.recalculate(); }).then(function () { return resolve(); });\n                    });\n                }\n                else {\n                    resolve();\n                }\n            });\n        };\n        var handleTreeExpandReserve = function (row, expanded) {\n            var treeExpandedReserveRowMap = internalData.treeExpandedReserveRowMap;\n            var treeOpts = computeTreeOpts.value;\n            if (treeOpts.reserve) {\n                var rowid = getRowid($xetable, row);\n                if (expanded) {\n                    treeExpandedReserveRowMap[rowid] = row;\n                }\n                else if (treeExpandedReserveRowMap[rowid]) {\n                    delete treeExpandedReserveRowMap[rowid];\n                }\n            }\n        };\n        var handleAsyncRowExpand = function (row) {\n            return new Promise(function (resolve) {\n                var expandOpts = computeExpandOpts.value;\n                var loadMethod = expandOpts.loadMethod;\n                if (loadMethod) {\n                    var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                    var rowExpandLazyLoadedMaps = reactData.rowExpandLazyLoadedMaps;\n                    var rowid_2 = getRowid($xetable, row);\n                    var rest_2 = fullAllDataRowIdData[rowid_2];\n                    rowExpandLazyLoadedMaps[rowid_2] = row;\n                    loadMethod({ $table: $xetable, row: row, rowIndex: tableMethods.getRowIndex(row), $rowIndex: tableMethods.getVMRowIndex(row) }).then(function () {\n                        var rowExpandedMaps = reactData.rowExpandedMaps;\n                        rest_2.expandLoaded = true;\n                        rowExpandedMaps[rowid_2] = row;\n                    }).catch(function () {\n                        rest_2.expandLoaded = false;\n                    }).finally(function () {\n                        var rowExpandLazyLoadedMaps = reactData.rowExpandLazyLoadedMaps;\n                        if (rowExpandLazyLoadedMaps[rowid_2]) {\n                            delete rowExpandLazyLoadedMaps[rowid_2];\n                        }\n                        nextTick().then(function () { return tableMethods.recalculate(); }).then(function () { return resolve(); });\n                    });\n                }\n                else {\n                    resolve();\n                }\n            });\n        };\n        var handleRowExpandReserve = function (row, expanded) {\n            var rowExpandedReserveRowMap = internalData.rowExpandedReserveRowMap;\n            var expandOpts = computeExpandOpts.value;\n            if (expandOpts.reserve) {\n                var rowid = getRowid($xetable, row);\n                if (expanded) {\n                    rowExpandedReserveRowMap[rowid] = row;\n                }\n                else if (rowExpandedReserveRowMap[rowid]) {\n                    delete rowExpandedReserveRowMap[rowid];\n                }\n            }\n        };\n        var handleDefaultMergeCells = function () {\n            var mergeCells = props.mergeCells;\n            if (mergeCells) {\n                tableMethods.setMergeCells(mergeCells);\n            }\n        };\n        var handleDefaultMergeFooterItems = function () {\n            var mergeFooterItems = props.mergeFooterItems;\n            if (mergeFooterItems) {\n                tableMethods.setMergeFooterItems(mergeFooterItems);\n            }\n        };\n        // 计算可视渲染相关数据\n        var computeScrollLoad = function () {\n            return nextTick().then(function () {\n                var scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad;\n                var scrollXStore = internalData.scrollXStore, scrollYStore = internalData.scrollYStore;\n                var sYOpts = computeSYOpts.value;\n                var sXOpts = computeSXOpts.value;\n                // 计算 X 逻辑\n                if (scrollXLoad) {\n                    var visibleXSize = computeVirtualX().visibleSize;\n                    var offsetXSize = sXOpts.oSize ? XEUtils.toNumber(sXOpts.oSize) : (browse.edge ? 5 : 0);\n                    scrollXStore.offsetSize = offsetXSize;\n                    scrollXStore.visibleSize = visibleXSize;\n                    scrollXStore.endIndex = Math.max(scrollXStore.startIndex + scrollXStore.visibleSize + offsetXSize, scrollXStore.endIndex);\n                    tablePrivateMethods.updateScrollXData();\n                }\n                else {\n                    tablePrivateMethods.updateScrollXSpace();\n                }\n                // 计算 Y 逻辑\n                var _a = computeVirtualY(), rowHeight = _a.rowHeight, visibleYSize = _a.visibleSize;\n                scrollYStore.rowHeight = rowHeight;\n                if (scrollYLoad) {\n                    var offsetYSize = sYOpts.oSize ? XEUtils.toNumber(sYOpts.oSize) : (browse.edge ? 10 : 0);\n                    scrollYStore.offsetSize = offsetYSize;\n                    scrollYStore.visibleSize = visibleYSize;\n                    scrollYStore.endIndex = Math.max(scrollYStore.startIndex + visibleYSize + offsetYSize, scrollYStore.endIndex);\n                    tablePrivateMethods.updateScrollYData();\n                }\n                else {\n                    tablePrivateMethods.updateScrollYSpace();\n                }\n                reactData.rowHeight = rowHeight;\n                nextTick(updateStyle);\n            });\n        };\n        /**\n         * 加载表格数据\n         * @param {Array} datas 数据\n         */\n        var loadTableData = function (datas) {\n            var keepSource = props.keepSource, treeConfig = props.treeConfig;\n            var editStore = reactData.editStore, oldScrollYLoad = reactData.scrollYLoad;\n            var scrollYStore = internalData.scrollYStore, scrollXStore = internalData.scrollXStore, lastScrollLeft = internalData.lastScrollLeft, lastScrollTop = internalData.lastScrollTop;\n            var treeOpts = computeTreeOpts.value;\n            var transform = treeOpts.transform;\n            var childrenField = treeOpts.children || treeOpts.childrenField;\n            var treeData = [];\n            var fullData = reactive(datas ? datas.slice(0) : []); // 转为响应式\n            if (treeConfig) {\n                if (transform) {\n                    // 树结构自动转换\n                    if (process.env.NODE_ENV === 'development') {\n                        if (!treeOpts.rowField) {\n                            errLog('vxe.error.reqProp', ['tree-config.rowField']);\n                        }\n                        if (!treeOpts.parentField) {\n                            errLog('vxe.error.reqProp', ['tree-config.parentField']);\n                        }\n                        if (!childrenField) {\n                            errLog('vxe.error.reqProp', ['tree-config.childrenField']);\n                        }\n                        if (!treeOpts.mapChildrenField) {\n                            errLog('vxe.error.reqProp', ['tree-config.mapChildrenField']);\n                        }\n                        if (childrenField === treeOpts.mapChildrenField) {\n                            errLog('vxe.error.errConflicts', ['tree-config.childrenField', 'tree-config.mapChildrenField']);\n                        }\n                        // fullData.forEach(row => {\n                        //   if (row[treeOpts.children] && row[treeOpts.children].length) {\n                        //     warnLog('vxe.error.errConflicts', ['tree-config.transform', `row.${treeOpts.children}`])\n                        //   }\n                        // })\n                    }\n                    treeData = XEUtils.toArrayTree(fullData, {\n                        key: treeOpts.rowField,\n                        parentKey: treeOpts.parentField,\n                        children: childrenField,\n                        mapChildren: treeOpts.mapChildrenField\n                    });\n                    fullData = treeData.slice(0);\n                }\n                else {\n                    treeData = fullData.slice(0);\n                }\n            }\n            scrollYStore.startIndex = 0;\n            scrollYStore.endIndex = 1;\n            scrollXStore.startIndex = 0;\n            scrollXStore.endIndex = 1;\n            reactData.scrollVMLoading = false;\n            editStore.insertMaps = {};\n            editStore.removeMaps = {};\n            var sYLoad = updateScrollYStatus(fullData);\n            reactData.scrollYLoad = sYLoad;\n            // 全量数据\n            internalData.tableFullData = fullData;\n            internalData.tableFullTreeData = treeData;\n            // 缓存数据\n            tablePrivateMethods.cacheRowMap(true);\n            // 原始数据\n            internalData.tableSynchData = datas;\n            // 克隆原数据，用于显示编辑状态，与编辑值做对比\n            if (keepSource) {\n                tablePrivateMethods.cacheSourceMap(fullData);\n            }\n            if (process.env.NODE_ENV === 'development') {\n                if (sYLoad) {\n                    if (!(props.height || props.maxHeight)) {\n                        errLog('vxe.error.reqProp', ['table.height | table.max-height | table.scroll-y={enabled: false}']);\n                    }\n                    if (!props.showOverflow) {\n                        warnLog('vxe.error.reqProp', ['table.show-overflow']);\n                    }\n                    if (props.spanMethod) {\n                        warnLog('vxe.error.scrollErrProp', ['table.span-method']);\n                    }\n                }\n            }\n            if ($xetable.clearCellAreas && props.mouseConfig) {\n                $xetable.clearCellAreas();\n                $xetable.clearCopyCellArea();\n            }\n            tableMethods.clearMergeCells();\n            tableMethods.clearMergeFooterItems();\n            tablePrivateMethods.handleTableData(true);\n            tableMethods.updateFooter();\n            return nextTick().then(function () {\n                updateHeight();\n                updateStyle();\n            }).then(function () {\n                computeScrollLoad();\n            }).then(function () {\n                // 是否启用了虚拟滚动\n                if (sYLoad) {\n                    scrollYStore.endIndex = scrollYStore.visibleSize;\n                }\n                handleReserveStatus();\n                tablePrivateMethods.checkSelectionStatus();\n                return new Promise(function (resolve) {\n                    nextTick()\n                        .then(function () { return tableMethods.recalculate(); })\n                        .then(function () {\n                        var targetScrollLeft = lastScrollLeft;\n                        var targetScrollTop = lastScrollTop;\n                        var sXOpts = computeSXOpts.value;\n                        var sYOpts = computeSYOpts.value;\n                        // 是否在更新数据之后自动滚动重置滚动条\n                        if (sXOpts.scrollToLeftOnChange) {\n                            targetScrollLeft = 0;\n                        }\n                        if (sYOpts.scrollToTopOnChange) {\n                            targetScrollTop = 0;\n                        }\n                        // 是否变更虚拟滚动\n                        if (oldScrollYLoad === sYLoad) {\n                            restoreScrollLocation($xetable, targetScrollLeft, targetScrollTop).then(resolve);\n                        }\n                        else {\n                            setTimeout(function () { return restoreScrollLocation($xetable, targetScrollLeft, targetScrollTop).then(resolve); });\n                        }\n                    });\n                });\n            });\n        };\n        /**\n         * 处理数据加载默认行为\n         * 默认执行一次，除非被重置\n         */\n        var handleLoadDefaults = function () {\n            handleDefaultSelectionChecked();\n            handleDefaultRadioChecked();\n            handleDefaultRowExpand();\n            handleDefaultTreeExpand();\n            handleDefaultMergeCells();\n            handleDefaultMergeFooterItems();\n            nextTick(function () { return setTimeout(function () { return tableMethods.recalculate(); }); });\n        };\n        /**\n         * 处理初始化的默认行为\n         * 只会执行一次\n         */\n        var handleInitDefaults = function () {\n            handleDefaultSort();\n        };\n        var handleTableColumn = function () {\n            var scrollXLoad = reactData.scrollXLoad;\n            var visibleColumn = internalData.visibleColumn, scrollXStore = internalData.scrollXStore, fullColumnIdData = internalData.fullColumnIdData;\n            var tableColumn = scrollXLoad ? visibleColumn.slice(scrollXStore.startIndex, scrollXStore.endIndex) : visibleColumn.slice(0);\n            tableColumn.forEach(function (column, $index) {\n                var colid = column.id;\n                var rest = fullColumnIdData[colid];\n                if (rest) {\n                    rest.$index = $index;\n                }\n            });\n            reactData.tableColumn = tableColumn;\n        };\n        var loadScrollXData = function () {\n            var mergeList = reactData.mergeList, mergeFooterList = reactData.mergeFooterList;\n            var scrollXStore = internalData.scrollXStore;\n            var startIndex = scrollXStore.startIndex, endIndex = scrollXStore.endIndex, offsetSize = scrollXStore.offsetSize;\n            var _a = computeVirtualX(), toVisibleIndex = _a.toVisibleIndex, visibleSize = _a.visibleSize;\n            var offsetItem = {\n                startIndex: Math.max(0, toVisibleIndex - 1 - offsetSize),\n                endIndex: toVisibleIndex + visibleSize + offsetSize\n            };\n            calculateMergerOffserIndex(mergeList.concat(mergeFooterList), offsetItem, 'col');\n            var offsetStartIndex = offsetItem.startIndex, offsetEndIndex = offsetItem.endIndex;\n            if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {\n                if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {\n                    scrollXStore.startIndex = offsetStartIndex;\n                    scrollXStore.endIndex = offsetEndIndex;\n                    tablePrivateMethods.updateScrollXData();\n                }\n            }\n            tableMethods.closeTooltip();\n        };\n        // 获取所有的列，排除分组\n        var getColumnList = function (columns) {\n            var result = [];\n            columns.forEach(function (column) {\n                result.push.apply(result, (column.children && column.children.length ? getColumnList(column.children) : [column]));\n            });\n            return result;\n        };\n        var parseColumns = function () {\n            var leftList = [];\n            var centerList = [];\n            var rightList = [];\n            var isGroup = reactData.isGroup, columnStore = reactData.columnStore;\n            var sXOpts = computeSXOpts.value;\n            var collectColumn = internalData.collectColumn, tableFullColumn = internalData.tableFullColumn, scrollXStore = internalData.scrollXStore, fullColumnIdData = internalData.fullColumnIdData;\n            // 如果是分组表头，如果子列全部被隐藏，则根列也隐藏\n            if (isGroup) {\n                var leftGroupList_1 = [];\n                var centerGroupList_1 = [];\n                var rightGroupList_1 = [];\n                XEUtils.eachTree(collectColumn, function (column, index, items, path, parent) {\n                    var isColGroup = hasChildrenList(column);\n                    // 如果是分组，必须按组设置固定列，不允许给子列设置固定\n                    if (parent && parent.fixed) {\n                        column.fixed = parent.fixed;\n                    }\n                    if (parent && column.fixed !== parent.fixed) {\n                        errLog('vxe.error.groupFixed');\n                    }\n                    if (isColGroup) {\n                        column.visible = !!XEUtils.findTree(column.children, function (subColumn) { return hasChildrenList(subColumn) ? false : subColumn.visible; });\n                    }\n                    else if (column.visible) {\n                        if (column.fixed === 'left') {\n                            leftList.push(column);\n                        }\n                        else if (column.fixed === 'right') {\n                            rightList.push(column);\n                        }\n                        else {\n                            centerList.push(column);\n                        }\n                    }\n                });\n                collectColumn.forEach(function (column) {\n                    if (column.visible) {\n                        if (column.fixed === 'left') {\n                            leftGroupList_1.push(column);\n                        }\n                        else if (column.fixed === 'right') {\n                            rightGroupList_1.push(column);\n                        }\n                        else {\n                            centerGroupList_1.push(column);\n                        }\n                    }\n                });\n                reactData.tableGroupColumn = leftGroupList_1.concat(centerGroupList_1).concat(rightGroupList_1);\n            }\n            else {\n                // 重新分配列\n                tableFullColumn.forEach(function (column) {\n                    if (column.visible) {\n                        if (column.fixed === 'left') {\n                            leftList.push(column);\n                        }\n                        else if (column.fixed === 'right') {\n                            rightList.push(column);\n                        }\n                        else {\n                            centerList.push(column);\n                        }\n                    }\n                });\n            }\n            var visibleColumn = leftList.concat(centerList).concat(rightList);\n            // 如果gt为0，则总是启用\n            var scrollXLoad = !!sXOpts.enabled && sXOpts.gt > -1 && (sXOpts.gt === 0 || sXOpts.gt < tableFullColumn.length);\n            reactData.hasFixedColumn = leftList.length > 0 || rightList.length > 0;\n            Object.assign(columnStore, { leftList: leftList, centerList: centerList, rightList: rightList });\n            if (scrollXLoad) {\n                if (process.env.NODE_ENV === 'development') {\n                    // if (props.showHeader && !props.showHeaderOverflow) {\n                    //   warnLog('vxe.error.reqProp', ['show-header-overflow'])\n                    // }\n                    // if (props.showFooter && !props.showFooterOverflow) {\n                    //   warnLog('vxe.error.reqProp', ['show-footer-overflow'])\n                    // }\n                    if (props.spanMethod) {\n                        warnLog('vxe.error.scrollErrProp', ['span-method']);\n                    }\n                    if (props.footerSpanMethod) {\n                        warnLog('vxe.error.scrollErrProp', ['footer-span-method']);\n                    }\n                }\n                var visibleSize = computeVirtualX().visibleSize;\n                scrollXStore.startIndex = 0;\n                scrollXStore.endIndex = visibleSize;\n                scrollXStore.visibleSize = visibleSize;\n            }\n            // 如果列被显示/隐藏，则清除合并状态\n            // 如果列被设置为固定，则清除合并状态\n            if (visibleColumn.length !== internalData.visibleColumn.length || !internalData.visibleColumn.every(function (column, index) { return column === visibleColumn[index]; })) {\n                tableMethods.clearMergeCells();\n                tableMethods.clearMergeFooterItems();\n            }\n            reactData.scrollXLoad = scrollXLoad;\n            visibleColumn.forEach(function (column, index) {\n                var colid = column.id;\n                var rest = fullColumnIdData[colid];\n                if (rest) {\n                    rest._index = index;\n                }\n            });\n            internalData.visibleColumn = visibleColumn;\n            handleTableColumn();\n            return tableMethods.updateFooter().then(function () {\n                return tableMethods.recalculate();\n            }).then(function () {\n                tableMethods.updateCellAreas();\n                return tableMethods.recalculate();\n            });\n        };\n        var handleColumn = function (collectColumn) {\n            internalData.collectColumn = collectColumn;\n            var tableFullColumn = getColumnList(collectColumn);\n            internalData.tableFullColumn = tableFullColumn;\n            cacheColumnMap();\n            restoreCustomStorage();\n            parseColumns().then(function () {\n                if (reactData.scrollXLoad) {\n                    loadScrollXData();\n                }\n            });\n            tableMethods.clearMergeCells();\n            tableMethods.clearMergeFooterItems();\n            tablePrivateMethods.handleTableData(true);\n            if (process.env.NODE_ENV === 'development') {\n                if ((reactData.scrollXLoad || reactData.scrollYLoad) && reactData.expandColumn) {\n                    warnLog('vxe.error.scrollErrProp', ['column.type=expand']);\n                }\n            }\n            return nextTick().then(function () {\n                if ($xetoolbar) {\n                    $xetoolbar.syncUpdate({ collectColumn: collectColumn, $table: $xetable });\n                }\n                return tableMethods.recalculate();\n            });\n        };\n        var updateScrollYStatus = function (fullData) {\n            var treeConfig = props.treeConfig;\n            var sYOpts = computeSYOpts.value;\n            var treeOpts = computeTreeOpts.value;\n            var transform = treeOpts.transform;\n            var allList = fullData || internalData.tableFullData;\n            // 如果gt为0，则总是启用\n            var scrollYLoad = (transform || !treeConfig) && !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt < allList.length);\n            reactData.scrollYLoad = scrollYLoad;\n            return scrollYLoad;\n        };\n        /**\n         * 展开与收起树节点\n         * @param rows\n         * @param expanded\n         * @returns\n         */\n        var handleBaseTreeExpand = function (rows, expanded) {\n            var treeExpandedMaps = reactData.treeExpandedMaps, treeExpandLazyLoadedMaps = reactData.treeExpandLazyLoadedMaps, treeNodeColumn = reactData.treeNodeColumn;\n            var treeTempExpandedMaps = __assign({}, treeExpandedMaps);\n            var fullAllDataRowIdData = internalData.fullAllDataRowIdData, tableFullData = internalData.tableFullData;\n            var treeOpts = computeTreeOpts.value;\n            var reserve = treeOpts.reserve, lazy = treeOpts.lazy, accordion = treeOpts.accordion, toggleMethod = treeOpts.toggleMethod;\n            var childrenField = treeOpts.children || treeOpts.childrenField;\n            var hasChildField = treeOpts.hasChild || treeOpts.hasChildField;\n            var result = [];\n            var columnIndex = tableMethods.getColumnIndex(treeNodeColumn);\n            var $columnIndex = tableMethods.getVMColumnIndex(treeNodeColumn);\n            var validRows = toggleMethod ? rows.filter(function (row) { return toggleMethod({ $table: $xetable, expanded: expanded, column: treeNodeColumn, columnIndex: columnIndex, $columnIndex: $columnIndex, row: row }); }) : rows;\n            if (accordion) {\n                validRows = validRows.length ? [validRows[validRows.length - 1]] : [];\n                // 同一级只能展开一个\n                var matchObj = XEUtils.findTree(tableFullData, function (item) { return item === validRows[0]; }, { children: childrenField });\n                if (matchObj) {\n                    matchObj.items.forEach(function (item) {\n                        var rowid = getRowid($xetable, item);\n                        if (treeTempExpandedMaps[rowid]) {\n                            delete treeTempExpandedMaps[rowid];\n                        }\n                    });\n                }\n            }\n            if (expanded) {\n                validRows.forEach(function (row) {\n                    var rowid = getRowid($xetable, row);\n                    if (!treeTempExpandedMaps[rowid]) {\n                        var rest = fullAllDataRowIdData[rowid];\n                        var isLoad = lazy && row[hasChildField] && !rest.treeLoaded && !treeExpandLazyLoadedMaps[rowid];\n                        // 是否使用懒加载\n                        if (isLoad) {\n                            result.push(handleAsyncTreeExpandChilds(row));\n                        }\n                        else {\n                            if (row[childrenField] && row[childrenField].length) {\n                                treeTempExpandedMaps[rowid] = row;\n                            }\n                        }\n                    }\n                });\n            }\n            else {\n                validRows.forEach(function (item) {\n                    var rowid = getRowid($xetable, item);\n                    if (treeTempExpandedMaps[rowid]) {\n                        delete treeTempExpandedMaps[rowid];\n                    }\n                });\n            }\n            if (reserve) {\n                validRows.forEach(function (row) { return handleTreeExpandReserve(row, expanded); });\n            }\n            reactData.treeExpandedMaps = treeTempExpandedMaps;\n            return Promise.all(result).then(function () {\n                return tableMethods.recalculate();\n            });\n        };\n        /**\n         * 虚拟树的展开与收起\n         * @param rows\n         * @param expanded\n         * @returns\n         */\n        var handleVirtualTreeExpand = function (rows, expanded) {\n            return handleBaseTreeExpand(rows, expanded).then(function () {\n                handleVirtualTreeToList();\n                return tablePrivateMethods.handleTableData();\n            }).then(function () {\n                return tableMethods.recalculate();\n            });\n        };\n        /**\n         * 纵向 Y 可视渲染处理\n         */\n        var loadScrollYData = function (evnt) {\n            var mergeList = reactData.mergeList;\n            var scrollYStore = internalData.scrollYStore;\n            var startIndex = scrollYStore.startIndex, endIndex = scrollYStore.endIndex, visibleSize = scrollYStore.visibleSize, offsetSize = scrollYStore.offsetSize, rowHeight = scrollYStore.rowHeight;\n            var scrollBodyElem = (evnt.currentTarget || evnt.target);\n            var scrollTop = scrollBodyElem.scrollTop;\n            var toVisibleIndex = Math.floor(scrollTop / rowHeight);\n            var offsetItem = {\n                startIndex: Math.max(0, toVisibleIndex - 1 - offsetSize),\n                endIndex: toVisibleIndex + visibleSize + offsetSize\n            };\n            calculateMergerOffserIndex(mergeList, offsetItem, 'row');\n            var offsetStartIndex = offsetItem.startIndex, offsetEndIndex = offsetItem.endIndex;\n            if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {\n                if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {\n                    scrollYStore.startIndex = offsetStartIndex;\n                    scrollYStore.endIndex = offsetEndIndex;\n                    tablePrivateMethods.updateScrollYData();\n                }\n            }\n        };\n        var createGetRowCacheProp = function (prop) {\n            return function (row) {\n                var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                if (row) {\n                    var rowid = getRowid($xetable, row);\n                    var rest = fullAllDataRowIdData[rowid];\n                    if (rest) {\n                        return rest[prop];\n                    }\n                }\n                return -1;\n            };\n        };\n        var createGetColumnCacheProp = function (prop) {\n            return function (column) {\n                var fullColumnIdData = internalData.fullColumnIdData;\n                if (column) {\n                    var rest = fullColumnIdData[column.id];\n                    if (rest) {\n                        return rest[prop];\n                    }\n                }\n                return -1;\n            };\n        };\n        var debounceScrollY = XEUtils.debounce(function (evnt) {\n            loadScrollYData(evnt);\n        }, 20, { leading: false, trailing: true });\n        var keyCtxTimeout;\n        tableMethods = {\n            dispatchEvent: function (type, params, evnt) {\n                emit(type, Object.assign({ $table: $xetable, $grid: $xegrid, $event: evnt }, params));\n            },\n            /**\n             * 重置表格的一切数据状态\n             */\n            clearAll: function () {\n                return clearTableAllStatus($xetable);\n            },\n            /**\n             * 同步 data 数据（即将废弃）\n             * 如果用了该方法，那么组件将不再记录增删改的状态，只能自行实现对应逻辑\n             * 对于某些特殊的场景，比如深层树节点元素发生变动时可能会用到\n             */\n            syncData: function () {\n                warnLog('vxe.error.delFunc', ['syncData', 'getData']);\n                return nextTick().then(function () {\n                    reactData.tableData = [];\n                    emit('update:data', internalData.tableFullData);\n                    return nextTick();\n                });\n            },\n            /**\n             * 手动处理数据，用于手动排序与筛选\n             * 对于手动更改了排序、筛选...等条件后需要重新处理数据时可能会用到\n             */\n            updateData: function () {\n                var scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad;\n                return tablePrivateMethods.handleTableData(true).then(function () {\n                    tableMethods.updateFooter();\n                    if (scrollXLoad || scrollYLoad) {\n                        if (scrollXLoad) {\n                            tablePrivateMethods.updateScrollXSpace();\n                        }\n                        if (scrollYLoad) {\n                            tablePrivateMethods.updateScrollYSpace();\n                        }\n                        return tableMethods.refreshScroll();\n                    }\n                }).then(function () {\n                    tableMethods.updateCellAreas();\n                    return tableMethods.recalculate(true);\n                }).then(function () {\n                    // 存在滚动行为未结束情况\n                    setTimeout(function () { return $xetable.recalculate(); }, 50);\n                });\n            },\n            /**\n             * 重新加载数据，不会清空表格状态\n             * @param {Array} datas 数据\n             */\n            loadData: function (datas) {\n                var inited = internalData.inited, initStatus = internalData.initStatus;\n                return loadTableData(datas).then(function () {\n                    internalData.inited = true;\n                    internalData.initStatus = true;\n                    if (!initStatus) {\n                        handleLoadDefaults();\n                    }\n                    if (!inited) {\n                        handleInitDefaults();\n                    }\n                    return tableMethods.recalculate();\n                });\n            },\n            /**\n             * 重新加载数据，会清空表格状态\n             * @param {Array} datas 数据\n             */\n            reloadData: function (datas) {\n                var inited = internalData.inited;\n                return tableMethods.clearAll()\n                    .then(function () {\n                    internalData.inited = true;\n                    internalData.initStatus = true;\n                    return loadTableData(datas);\n                })\n                    .then(function () {\n                    handleLoadDefaults();\n                    if (!inited) {\n                        handleInitDefaults();\n                    }\n                    return tableMethods.recalculate();\n                });\n            },\n            /**\n             * 局部加载行数据并恢复到初始状态\n             * 对于行数据需要局部更改的场景中可能会用到\n             * @param {Row} row 行对象\n             * @param {Object} record 新数据\n             * @param {String} field 字段名\n             */\n            reloadRow: function (row, record, field) {\n                var keepSource = props.keepSource;\n                var tableData = reactData.tableData;\n                var tableSourceData = internalData.tableSourceData;\n                if (keepSource) {\n                    var rowIndex = tableMethods.getRowIndex(row);\n                    var oRow = tableSourceData[rowIndex];\n                    if (oRow && row) {\n                        if (field) {\n                            var newValue = XEUtils.get(record || row, field);\n                            XEUtils.set(row, field, newValue);\n                            XEUtils.set(oRow, field, newValue);\n                        }\n                        else {\n                            var newRecord = XEUtils.clone(__assign({}, record), true);\n                            XEUtils.destructuring(oRow, Object.assign(row, newRecord));\n                        }\n                    }\n                    reactData.tableData = tableData.slice(0);\n                }\n                else {\n                    if (process.env.NODE_ENV === 'development') {\n                        warnLog('vxe.error.reqProp', ['keep-source']);\n                    }\n                }\n                return nextTick();\n            },\n            /**\n             * 用于树结构，给行数据加载子节点\n             */\n            loadTreeChildren: function (row, childRecords) {\n                var keepSource = props.keepSource;\n                var tableSourceData = internalData.tableSourceData, fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData, sourceDataRowIdData = internalData.sourceDataRowIdData;\n                var treeOpts = computeTreeOpts.value;\n                var transform = treeOpts.transform, mapChildrenField = treeOpts.mapChildrenField;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var parentRest = fullAllDataRowIdData[getRowid($xetable, row)];\n                var parentLevel = parentRest ? parentRest.level : 0;\n                return tableMethods.createData(childRecords).then(function (rows) {\n                    if (keepSource) {\n                        var rowid_3 = getRowid($xetable, row);\n                        var matchObj = XEUtils.findTree(tableSourceData, function (item) { return rowid_3 === getRowid($xetable, item); }, { children: childrenField });\n                        if (matchObj) {\n                            matchObj.item[childrenField] = XEUtils.clone(rows, true);\n                        }\n                        rows.forEach(function (childRow) {\n                            var rowid = getRowid($xetable, childRow);\n                            sourceDataRowIdData[rowid] = XEUtils.clone(childRow, true);\n                        });\n                    }\n                    XEUtils.eachTree(rows, function (childRow, index, items, path, parent, nodes) {\n                        var rowid = getRowid($xetable, childRow);\n                        var parentRow = parent || parentRest.row;\n                        var rest = { row: childRow, rowid: rowid, seq: -1, index: index, _index: -1, $index: -1, items: items, parent: parentRow, level: parentLevel + nodes.length };\n                        fullDataRowIdData[rowid] = rest;\n                        fullAllDataRowIdData[rowid] = rest;\n                    }, { children: childrenField });\n                    row[childrenField] = rows;\n                    if (transform) {\n                        row[mapChildrenField] = rows;\n                    }\n                    updateAfterDataIndex();\n                    return rows;\n                });\n            },\n            /**\n             * 加载列配置\n             * 对于表格列需要重载、局部递增场景下可能会用到\n             * @param {ColumnInfo} columns 列配置\n             */\n            loadColumn: function (columns) {\n                var collectColumn = XEUtils.mapTree(columns, function (column) { return reactive(Cell.createColumn($xetable, column)); });\n                return handleColumn(collectColumn);\n            },\n            /**\n             * 加载列配置并恢复到初始状态\n             * 对于表格列需要重载、局部递增场景下可能会用到\n             * @param {ColumnInfo} columns 列配置\n             */\n            reloadColumn: function (columns) {\n                return tableMethods.clearAll().then(function () {\n                    return tableMethods.loadColumn(columns);\n                });\n            },\n            /**\n             * 根据 tr 元素获取对应的 row 信息\n             * @param {Element} tr 元素\n             */\n            getRowNode: function (tr) {\n                if (tr) {\n                    var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                    var rowid = tr.getAttribute('rowid');\n                    if (rowid) {\n                        var rest = fullAllDataRowIdData[rowid];\n                        if (rest) {\n                            return { rowid: rest.rowid, item: rest.row, index: rest.index, items: rest.items, parent: rest.parent };\n                        }\n                    }\n                }\n                return null;\n            },\n            /**\n             * 根据 th/td 元素获取对应的 column 信息\n             * @param {Element} cell 元素\n             */\n            getColumnNode: function (cell) {\n                if (cell) {\n                    var fullColumnIdData = internalData.fullColumnIdData;\n                    var colid = cell.getAttribute('colid');\n                    if (colid) {\n                        var rest = fullColumnIdData[colid];\n                        if (rest) {\n                            return { colid: rest.colid, item: rest.column, index: rest.index, items: rest.items, parent: rest.parent };\n                        }\n                    }\n                }\n                return null;\n            },\n            /**\n             * 根据 row 获取序号\n             * @param {Row} row 行对象\n             */\n            getRowSeq: createGetRowCacheProp('seq'),\n            /**\n             * 根据 row 获取相对于 data 中的索引\n             * @param {Row} row 行对象\n             */\n            getRowIndex: createGetRowCacheProp('index'),\n            /**\n             * 根据 row 获取相对于当前数据中的索引\n             * @param {Row} row 行对象\n             */\n            getVTRowIndex: createGetRowCacheProp('_index'),\n            /**\n             * 根据 row 获取渲染中的虚拟索引\n             * @param {Row} row 行对象\n             */\n            getVMRowIndex: createGetRowCacheProp('$index'),\n            /**\n             * 根据 column 获取相对于 columns 中的索引\n             * @param {ColumnInfo} column 列配置\n             */\n            getColumnIndex: createGetColumnCacheProp('index'),\n            /**\n             * 根据 column 获取相对于当前表格列中的索引\n             * @param {ColumnInfo} column 列配置\n             */\n            getVTColumnIndex: createGetColumnCacheProp('_index'),\n            /**\n             * 根据 column 获取渲染中的虚拟索引\n             * @param {ColumnInfo} column 列配置\n             */\n            getVMColumnIndex: createGetColumnCacheProp('$index'),\n            /**\n             * 创建 data 对象\n             * 对于某些特殊场景可能会用到，会自动对数据的字段名进行检测，如果不存在就自动定义\n             * @param {Array} records 新数据\n             */\n            createData: function (records) {\n                return nextTick().then(function () {\n                    return reactive(tablePrivateMethods.defineField(records));\n                });\n            },\n            /**\n             * 创建 Row|Rows 对象\n             * 对于某些特殊场景需要对数据进行手动插入时可能会用到\n             * @param {Array/Object} records 新数据\n             */\n            createRow: function (records) {\n                var isArr = XEUtils.isArray(records);\n                if (!isArr) {\n                    records = [records || {}];\n                }\n                return tableMethods.createData(records).then(function (rows) { return isArr ? rows : rows[0]; });\n            },\n            /**\n             * 还原数据\n             * 如果不传任何参数，则还原整个表格\n             * 如果传 row 则还原一行\n             * 如果传 rows 则还原多行\n             * 如果还额外传了 field 则还原指定的单元格数据\n             */\n            revertData: function (rows, field) {\n                var keepSource = props.keepSource;\n                var tableSourceData = internalData.tableSourceData, sourceDataRowIdData = internalData.sourceDataRowIdData;\n                if (!keepSource) {\n                    if (process.env.NODE_ENV === 'development') {\n                        warnLog('vxe.error.reqProp', ['keep-source']);\n                    }\n                    return nextTick();\n                }\n                var targetRows = rows;\n                if (rows) {\n                    if (!XEUtils.isArray(rows)) {\n                        targetRows = [rows];\n                    }\n                }\n                else {\n                    targetRows = XEUtils.toArray($xetable.getUpdateRecords());\n                }\n                if (targetRows.length) {\n                    targetRows.forEach(function (row) {\n                        if (!tableMethods.isInsertByRow(row)) {\n                            var rowid = getRowid($xetable, row);\n                            var oRow = sourceDataRowIdData[rowid];\n                            if (oRow && row) {\n                                if (field) {\n                                    XEUtils.set(row, field, XEUtils.clone(XEUtils.get(oRow, field), true));\n                                }\n                                else {\n                                    XEUtils.destructuring(row, XEUtils.clone(oRow, true));\n                                }\n                            }\n                        }\n                    });\n                }\n                if (rows) {\n                    return nextTick();\n                }\n                return tableMethods.reloadData(tableSourceData);\n            },\n            /**\n             * 清空单元格内容\n             * 如果不创参数，则清空整个表格内容\n             * 如果传 row 则清空一行内容\n             * 如果传 rows 则清空多行内容\n             * 如果还额外传了 field 则清空指定单元格内容\n             * @param {Array/Row} rows 行数据\n             * @param {String} field 字段名\n             */\n            clearData: function (rows, field) {\n                var tableFullData = internalData.tableFullData, visibleColumn = internalData.visibleColumn;\n                if (!arguments.length) {\n                    rows = tableFullData;\n                }\n                else if (rows && !XEUtils.isArray(rows)) {\n                    rows = [rows];\n                }\n                if (field) {\n                    rows.forEach(function (row) { return XEUtils.set(row, field, null); });\n                }\n                else {\n                    rows.forEach(function (row) {\n                        visibleColumn.forEach(function (column) {\n                            if (column.field) {\n                                setCellValue(row, column, null);\n                            }\n                        });\n                    });\n                }\n                return nextTick();\n            },\n            /**\n             * 检查是否为临时行数据\n             * @param {Row} row 行对象\n             */\n            isInsertByRow: function (row) {\n                var editStore = reactData.editStore;\n                var rowid = getRowid($xetable, row);\n                return editStore.insertMaps[rowid];\n            },\n            /**\n             * 删除所有新增的临时数据\n             * @returns\n             */\n            removeInsertRow: function () {\n                var editStore = reactData.editStore;\n                editStore.insertMaps = {};\n                return $xetable.remove($xetable.getInsertRecords());\n            },\n            /**\n             * 检查行或列数据是否发生改变\n             * @param {Row} row 行对象\n             * @param {String} field 字段名\n             */\n            isUpdateByRow: function (row, field) {\n                var keepSource = props.keepSource;\n                var tableFullColumn = internalData.tableFullColumn, fullDataRowIdData = internalData.fullDataRowIdData, sourceDataRowIdData = internalData.sourceDataRowIdData;\n                if (keepSource) {\n                    var rowid = getRowid($xetable, row);\n                    // 新增的数据不需要检测\n                    if (!fullDataRowIdData[rowid]) {\n                        return false;\n                    }\n                    var oRow = sourceDataRowIdData[rowid];\n                    if (oRow) {\n                        if (arguments.length > 1) {\n                            return !eqCellValue(oRow, row, field);\n                        }\n                        for (var index = 0, len = tableFullColumn.length; index < len; index++) {\n                            var property = tableFullColumn[index].field;\n                            if (property && !eqCellValue(oRow, row, property)) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n                return false;\n            },\n            /**\n             * 获取表格的可视列，也可以指定索引获取列\n             * @param {Number} columnIndex 索引\n             */\n            getColumns: function (columnIndex) {\n                var columns = internalData.visibleColumn;\n                return XEUtils.isUndefined(columnIndex) ? columns.slice(0) : columns[columnIndex];\n            },\n            /**\n             * 根据列的唯一主键获取列\n             * @param {String} colid 列主键\n             */\n            getColumnById: function (colid) {\n                var fullColumnIdData = internalData.fullColumnIdData;\n                return fullColumnIdData[colid] ? fullColumnIdData[colid].column : null;\n            },\n            /**\n             * 根据列的字段名获取列\n             * @param {String} field 字段名\n             */\n            getColumnByField: function (field) {\n                var fullColumnFieldData = internalData.fullColumnFieldData;\n                return fullColumnFieldData[field] ? fullColumnFieldData[field].column : null;\n            },\n            /**\n             * 获取当前表格的列\n             * 收集到的全量列、全量表头列、处理条件之后的全量表头列、当前渲染中的表头列\n             */\n            getTableColumn: function () {\n                return {\n                    collectColumn: internalData.collectColumn.slice(0),\n                    fullColumn: internalData.tableFullColumn.slice(0),\n                    visibleColumn: internalData.visibleColumn.slice(0),\n                    tableColumn: reactData.tableColumn.slice(0)\n                };\n            },\n            /**\n             * 获取数据，和 data 的行为一致，也可以指定索引获取数据\n             */\n            getData: function (rowIndex) {\n                var tableSynchData = props.data || internalData.tableSynchData;\n                return XEUtils.isUndefined(rowIndex) ? tableSynchData.slice(0) : tableSynchData[rowIndex];\n            },\n            /**\n             * 用于多选行，获取已选中的数据\n             */\n            getCheckboxRecords: function (isFull) {\n                var treeConfig = props.treeConfig;\n                var tableFullData = internalData.tableFullData, afterFullData = internalData.afterFullData, afterTreeFullData = internalData.afterTreeFullData, tableFullTreeData = internalData.tableFullTreeData, fullDataRowIdData = internalData.fullDataRowIdData, afterFullRowMaps = internalData.afterFullRowMaps;\n                var treeOpts = computeTreeOpts.value;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var transform = treeOpts.transform, mapChildrenField = treeOpts.mapChildrenField;\n                var checkField = checkboxOpts.checkField;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var rowList = [];\n                var currTableData = isFull ? (transform ? tableFullTreeData : tableFullData) : (transform ? afterTreeFullData : afterFullData);\n                if (checkField) {\n                    if (treeConfig) {\n                        rowList = XEUtils.filterTree(currTableData, function (row) { return XEUtils.get(row, checkField); }, { children: transform ? mapChildrenField : childrenField });\n                    }\n                    else {\n                        rowList = currTableData.filter(function (row) { return XEUtils.get(row, checkField); });\n                    }\n                }\n                else {\n                    var selectCheckboxMaps = reactData.selectCheckboxMaps;\n                    XEUtils.each(selectCheckboxMaps, function (row, rowid) {\n                        if (isFull ? fullDataRowIdData[rowid] : afterFullRowMaps[rowid]) {\n                            rowList.push(row);\n                        }\n                    });\n                }\n                return rowList;\n            },\n            /**\n             * 只对 tree-config 有效，获取行的父级\n             */\n            getParentRow: function (rowOrRowid) {\n                var treeConfig = props.treeConfig;\n                var fullDataRowIdData = internalData.fullDataRowIdData;\n                if (rowOrRowid && treeConfig) {\n                    var rowid = void 0;\n                    if (XEUtils.isString(rowOrRowid)) {\n                        rowid = rowOrRowid;\n                    }\n                    else {\n                        rowid = getRowid($xetable, rowOrRowid);\n                    }\n                    if (rowid) {\n                        var rest = fullDataRowIdData[rowid];\n                        return rest ? rest.parent : null;\n                    }\n                }\n                return null;\n            },\n            /**\n             * 根据行的唯一主键获取行\n             * @param {String/Number} rowid 行主键\n             */\n            getRowById: function (cellValue) {\n                var fullDataRowIdData = internalData.fullDataRowIdData;\n                var rowid = XEUtils.eqNull(cellValue) ? '' : encodeURIComponent(cellValue);\n                return fullDataRowIdData[rowid] ? fullDataRowIdData[rowid].row : null;\n            },\n            /**\n             * 根据行获取行的唯一主键\n             * @param {Row} row 行对象\n             */\n            getRowid: function (row) {\n                return getRowid($xetable, row);\n            },\n            /**\n             * 获取处理后的表格数据\n             * 如果存在筛选条件，继续处理\n             * 如果存在排序，继续处理\n             */\n            getTableData: function () {\n                var tableData = reactData.tableData, footerTableData = reactData.footerTableData;\n                var tableFullData = internalData.tableFullData, afterFullData = internalData.afterFullData, tableFullTreeData = internalData.tableFullTreeData;\n                return {\n                    fullData: props.treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0),\n                    visibleData: afterFullData.slice(0),\n                    tableData: tableData.slice(0),\n                    footerData: footerTableData.slice(0)\n                };\n            },\n            /**\n             * 设置为固定列\n             */\n            setColumnFixed: function (fieldOrColumn, fixed) {\n                var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                var targetColumn = getRootColumn($xetable, column);\n                var isMaxFixedColumn = computeIsMaxFixedColumn.value;\n                var columnOpts = computeColumnOpts.value;\n                var maxFixedSize = columnOpts.maxFixedSize;\n                if (targetColumn && targetColumn.fixed !== fixed) {\n                    // 是否超过最大固定列数量\n                    if (!targetColumn.fixed && isMaxFixedColumn) {\n                        if (VXETable.modal) {\n                            VXETable.modal.message({\n                                status: 'error',\n                                content: GlobalConfig.i18n('vxe.table.maxFixedCol', [maxFixedSize])\n                            });\n                        }\n                        return nextTick();\n                    }\n                    XEUtils.eachTree([targetColumn], function (column) {\n                        column.fixed = fixed;\n                    });\n                    tablePrivateMethods.saveCustomFixed();\n                    return tableMethods.refreshColumn();\n                }\n                return nextTick();\n            },\n            /**\n             * 取消指定固定列\n             */\n            clearColumnFixed: function (fieldOrColumn) {\n                var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                var targetColumn = getRootColumn($xetable, column);\n                if (targetColumn && targetColumn.fixed) {\n                    XEUtils.eachTree([targetColumn], function (column) {\n                        column.fixed = null;\n                    });\n                    tablePrivateMethods.saveCustomFixed();\n                    return tableMethods.refreshColumn();\n                }\n                return nextTick();\n            },\n            /**\n             * 隐藏指定列\n             */\n            hideColumn: function (fieldOrColumn) {\n                var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                if (column && column.visible) {\n                    column.visible = false;\n                    return tablePrivateMethods.handleCustom();\n                }\n                return nextTick();\n            },\n            /**\n             * 显示指定列\n             */\n            showColumn: function (fieldOrColumn) {\n                var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                if (column && !column.visible) {\n                    column.visible = true;\n                    return tablePrivateMethods.handleCustom();\n                }\n                return nextTick();\n            },\n            setColumnWidth: function (fieldOrColumn, width) {\n                var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                if (column) {\n                    var colWidth = XEUtils.toInteger(width);\n                    var rdWidth = colWidth;\n                    if (isScale(width)) {\n                        var tableBody = refTableBody.value;\n                        var bodyElem = tableBody ? tableBody.$el : null;\n                        var bodyWidth = bodyElem ? bodyElem.clientWidth - 1 : 0;\n                        rdWidth = Math.floor(colWidth * bodyWidth);\n                    }\n                    column.renderWidth = rdWidth;\n                }\n                return nextTick();\n            },\n            getColumnWidth: function (fieldOrColumn) {\n                var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                if (column) {\n                    return column.renderWidth;\n                }\n                return 0;\n            },\n            /**\n             * 手动重置列的显示隐藏、列宽拖动的状态、固定列、排序列；\n             * 如果为 true 则重置所有状态\n             * 如果已关联工具栏，则会同步更新\n             */\n            resetColumn: function (options) {\n                var collectColumn = internalData.collectColumn;\n                var customOpts = computeCustomOpts.value;\n                var checkMethod = customOpts.checkMethod;\n                var opts = Object.assign({\n                    visible: true,\n                    resizable: options === true,\n                    fixed: options === true\n                }, options);\n                XEUtils.eachTree(collectColumn, function (column) {\n                    if (opts.resizable) {\n                        column.resizeWidth = 0;\n                    }\n                    if (opts.fixed) {\n                        column.fixed = column.defaultFixed;\n                    }\n                    if (!checkMethod || checkMethod({ column: column })) {\n                        column.visible = column.defaultVisible;\n                    }\n                });\n                if (opts.resizable) {\n                    tablePrivateMethods.saveCustomResizable(true);\n                }\n                if (opts.fixed) {\n                    tablePrivateMethods.saveCustomFixed();\n                }\n                return tablePrivateMethods.handleCustom();\n            },\n            /**\n             * 刷新列信息\n             * 将固定的列左边、右边分别靠边\n             */\n            refreshColumn: function () {\n                return parseColumns().then(function () {\n                    return tableMethods.refreshScroll();\n                }).then(function () {\n                    return tableMethods.recalculate();\n                });\n            },\n            /**\n             * 刷新滚动操作，手动同步滚动相关位置（对于某些特殊的操作，比如滚动条错位、固定列不同步）\n             */\n            refreshScroll: function () {\n                var lastScrollLeft = internalData.lastScrollLeft, lastScrollTop = internalData.lastScrollTop;\n                var tableBody = refTableBody.value;\n                var tableFooter = refTableFooter.value;\n                var leftBody = refTableLeftBody.value;\n                var rightBody = refTableRightBody.value;\n                var tableBodyElem = tableBody ? tableBody.$el : null;\n                var leftBodyElem = leftBody ? leftBody.$el : null;\n                var rightBodyElem = rightBody ? rightBody.$el : null;\n                var tableFooterElem = tableFooter ? tableFooter.$el : null;\n                return new Promise(function (resolve) {\n                    // 还原滚动条位置\n                    if (lastScrollLeft || lastScrollTop) {\n                        return restoreScrollLocation($xetable, lastScrollLeft, lastScrollTop).then().then(function () {\n                            // 存在滚动行为未结束情况\n                            setTimeout(resolve, 30);\n                        });\n                    }\n                    // 重置\n                    setScrollTop(tableBodyElem, lastScrollTop);\n                    setScrollTop(leftBodyElem, lastScrollTop);\n                    setScrollTop(rightBodyElem, lastScrollTop);\n                    setScrollLeft(tableFooterElem, lastScrollLeft);\n                    // 存在滚动行为未结束情况\n                    setTimeout(resolve, 30);\n                });\n            },\n            /**\n             * 计算单元格列宽，动态分配可用剩余空间\n             * 支持 width=? width=?px width=?% min-width=? min-width=?px min-width=?%\n             */\n            recalculate: function (refull) {\n                autoCellWidth();\n                if (refull === true) {\n                    // 初始化时需要在列计算之后再执行优化运算，达到最优显示效果\n                    return computeScrollLoad().then(function () {\n                        autoCellWidth();\n                        return computeScrollLoad();\n                    });\n                }\n                return computeScrollLoad();\n            },\n            openTooltip: function (target, content) {\n                var $commTip = refCommTooltip.value;\n                if ($commTip) {\n                    return $commTip.open(target, content);\n                }\n                return nextTick();\n            },\n            /**\n             * 关闭 tooltip\n             */\n            closeTooltip: function () {\n                var tooltipStore = reactData.tooltipStore;\n                var $tooltip = refTooltip.value;\n                var $commTip = refCommTooltip.value;\n                if (tooltipStore.visible) {\n                    Object.assign(tooltipStore, {\n                        row: null,\n                        column: null,\n                        content: null,\n                        visible: false\n                    });\n                    if ($tooltip) {\n                        $tooltip.close();\n                    }\n                }\n                if ($commTip) {\n                    $commTip.close();\n                }\n                return nextTick();\n            },\n            /**\n             * 判断列头复选框是否被选中\n             */\n            isAllCheckboxChecked: function () {\n                return reactData.isAllSelected;\n            },\n            /**\n             * 判断列头复选框是否被半选\n             */\n            isAllCheckboxIndeterminate: function () {\n                return !reactData.isAllSelected && reactData.isIndeterminate;\n            },\n            /**\n             * 获取复选框半选状态的行数据\n             */\n            getCheckboxIndeterminateRecords: function (isFull) {\n                var treeConfig = props.treeConfig;\n                var fullDataRowIdData = internalData.fullDataRowIdData;\n                var treeIndeterminateMaps = reactData.treeIndeterminateMaps;\n                if (treeConfig) {\n                    var fullRest_1 = [];\n                    var defRest_1 = [];\n                    XEUtils.each(treeIndeterminateMaps, function (item, rowid) {\n                        if (item) {\n                            fullRest_1.push(item);\n                            if (fullDataRowIdData[rowid]) {\n                                defRest_1.push(item);\n                            }\n                        }\n                    });\n                    if (isFull) {\n                        return fullRest_1;\n                    }\n                    return defRest_1;\n                }\n                return [];\n            },\n            /**\n             * 用于多选行，设置行为选中状态，第二个参数为选中与否\n             * @param {Array/Row} rows 行数据\n             * @param {Boolean} value 是否选中\n             */\n            setCheckboxRow: function (rows, value) {\n                return handleCheckedCheckboxRow(rows, value, true);\n            },\n            isCheckedByCheckboxRow: function (row) {\n                var selectCheckboxMaps = reactData.selectCheckboxMaps;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var checkField = checkboxOpts.checkField;\n                if (checkField) {\n                    return XEUtils.get(row, checkField);\n                }\n                return !!selectCheckboxMaps[getRowid($xetable, row)];\n            },\n            isIndeterminateByCheckboxRow: function (row) {\n                var treeIndeterminateMaps = reactData.treeIndeterminateMaps;\n                return !!treeIndeterminateMaps[getRowid($xetable, row)] && !tableMethods.isCheckedByCheckboxRow(row);\n            },\n            /**\n             * 多选，切换某一行的选中状态\n             */\n            toggleCheckboxRow: function (row) {\n                var selectCheckboxMaps = reactData.selectCheckboxMaps;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var checkField = checkboxOpts.checkField;\n                var value = checkField ? !XEUtils.get(row, checkField) : !selectCheckboxMaps[getRowid($xetable, row)];\n                tablePrivateMethods.handleSelectRow({ row: row }, value, true);\n                return nextTick();\n            },\n            /**\n             * 用于多选行，设置所有行的选中状态\n             * @param {Boolean} value 是否选中\n             */\n            setAllCheckboxRow: function (value) {\n                return handleCheckedAllCheckboxRow(value, true);\n            },\n            /**\n             * 获取单选框保留选中的行\n             */\n            getRadioReserveRecord: function (isFull) {\n                var treeConfig = props.treeConfig;\n                var fullDataRowIdData = internalData.fullDataRowIdData, radioReserveRow = internalData.radioReserveRow, afterFullData = internalData.afterFullData;\n                var radioOpts = computeRadioOpts.value;\n                var treeOpts = computeTreeOpts.value;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                if (radioOpts.reserve && radioReserveRow) {\n                    var rowid_4 = getRowid($xetable, radioReserveRow);\n                    if (isFull) {\n                        if (!fullDataRowIdData[rowid_4]) {\n                            return radioReserveRow;\n                        }\n                    }\n                    else {\n                        var rowkey_2 = getRowkey($xetable);\n                        if (treeConfig) {\n                            var matchObj = XEUtils.findTree(afterFullData, function (row) { return rowid_4 === XEUtils.get(row, rowkey_2); }, { children: childrenField });\n                            if (matchObj) {\n                                return radioReserveRow;\n                            }\n                        }\n                        else {\n                            if (!afterFullData.some(function (row) { return rowid_4 === XEUtils.get(row, rowkey_2); })) {\n                                return radioReserveRow;\n                            }\n                        }\n                    }\n                }\n                return null;\n            },\n            clearRadioReserve: function () {\n                internalData.radioReserveRow = null;\n                return nextTick();\n            },\n            /**\n             * 获取复选框保留选中的行\n             */\n            getCheckboxReserveRecords: function (isFull) {\n                var treeConfig = props.treeConfig;\n                var afterFullData = internalData.afterFullData, fullDataRowIdData = internalData.fullDataRowIdData, checkboxReserveRowMap = internalData.checkboxReserveRowMap;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var treeOpts = computeTreeOpts.value;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var reserveSelection = [];\n                if (checkboxOpts.reserve) {\n                    var afterFullIdMaps_1 = {};\n                    if (treeConfig) {\n                        XEUtils.eachTree(afterFullData, function (row) {\n                            afterFullIdMaps_1[getRowid($xetable, row)] = 1;\n                        }, { children: childrenField });\n                    }\n                    else {\n                        afterFullData.forEach(function (row) {\n                            afterFullIdMaps_1[getRowid($xetable, row)] = 1;\n                        });\n                    }\n                    XEUtils.each(checkboxReserveRowMap, function (oldRow, oldRowid) {\n                        if (oldRow) {\n                            if (isFull) {\n                                if (!fullDataRowIdData[oldRowid]) {\n                                    reserveSelection.push(oldRow);\n                                }\n                            }\n                            else {\n                                if (!afterFullIdMaps_1[oldRowid]) {\n                                    reserveSelection.push(oldRow);\n                                }\n                            }\n                        }\n                    });\n                }\n                return reserveSelection;\n            },\n            clearCheckboxReserve: function () {\n                internalData.checkboxReserveRowMap = {};\n                return nextTick();\n            },\n            /**\n             * 多选，切换所有行的选中状态\n             */\n            toggleAllCheckboxRow: function () {\n                tablePrivateMethods.triggerCheckAllEvent(null, !reactData.isAllSelected);\n                return nextTick();\n            },\n            /**\n             * 用于多选行，手动清空用户的选择\n             * 清空行为不管是否被禁用还是保留记录，都将彻底清空选中状态\n             */\n            clearCheckboxRow: function () {\n                var treeConfig = props.treeConfig;\n                var tableFullData = internalData.tableFullData;\n                var treeOpts = computeTreeOpts.value;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var checkField = checkboxOpts.checkField, reserve = checkboxOpts.reserve;\n                var indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;\n                if (checkField) {\n                    var handleClearChecked = function (item) {\n                        if (treeConfig && indeterminateField) {\n                            XEUtils.set(item, indeterminateField, false);\n                        }\n                        XEUtils.set(item, checkField, false);\n                    };\n                    if (treeConfig) {\n                        XEUtils.eachTree(tableFullData, handleClearChecked, { children: childrenField });\n                    }\n                    else {\n                        tableFullData.forEach(handleClearChecked);\n                    }\n                }\n                if (reserve) {\n                    tableFullData.forEach(function (row) { return handleCheckboxReserveRow(row, false); });\n                }\n                reactData.isAllSelected = false;\n                reactData.isIndeterminate = false;\n                reactData.selectCheckboxMaps = {};\n                reactData.treeIndeterminateMaps = {};\n                return nextTick();\n            },\n            /**\n             * 用于当前行，设置某一行为高亮状态\n             * @param {Row} row 行对象\n             */\n            setCurrentRow: function (row) {\n                var rowOpts = computeRowOpts.value;\n                var el = refElem.value;\n                tableMethods.clearCurrentRow();\n                // tableMethods.clearCurrentColumn()\n                reactData.currentRow = row;\n                if (rowOpts.isCurrent || props.highlightCurrentRow) {\n                    if (el) {\n                        XEUtils.arrayEach(el.querySelectorAll(\"[rowid=\\\"\".concat(getRowid($xetable, row), \"\\\"]\")), function (elem) { return addClass(elem, 'row--current'); });\n                    }\n                }\n                return nextTick();\n            },\n            isCheckedByRadioRow: function (row) {\n                return $xetable.eqRow(reactData.selectRadioRow, row);\n            },\n            /**\n             * 用于单选行，设置某一行为选中状态\n             * @param {Row} row 行对象\n             */\n            setRadioRow: function (row) {\n                return handleCheckedRadioRow(row, true);\n            },\n            /**\n             * 用于当前行，手动清空当前高亮的状态\n             */\n            clearCurrentRow: function () {\n                var el = refElem.value;\n                reactData.currentRow = null;\n                internalData.hoverRow = null;\n                if (el) {\n                    XEUtils.arrayEach(el.querySelectorAll('.row--current'), function (elem) { return removeClass(elem, 'row--current'); });\n                }\n                return nextTick();\n            },\n            /**\n             * 用于单选行，手动清空用户的选择\n             */\n            clearRadioRow: function () {\n                reactData.selectRadioRow = null;\n                return nextTick();\n            },\n            /**\n             * 用于当前行，获取当前行的数据\n             */\n            getCurrentRecord: function () {\n                var rowOpts = computeRowOpts.value;\n                return rowOpts.isCurrent || props.highlightCurrentRow ? reactData.currentRow : null;\n            },\n            /**\n             * 用于单选行，获取当已选中的数据\n             */\n            getRadioRecord: function (isFull) {\n                var fullDataRowIdData = internalData.fullDataRowIdData, afterFullRowMaps = internalData.afterFullRowMaps;\n                var selectRadioRow = reactData.selectRadioRow;\n                if (selectRadioRow) {\n                    var rowid = getRowid($xetable, selectRadioRow);\n                    if (isFull) {\n                        if (!fullDataRowIdData[rowid]) {\n                            return selectRadioRow;\n                        }\n                    }\n                    else {\n                        if (afterFullRowMaps[rowid]) {\n                            return selectRadioRow;\n                        }\n                    }\n                }\n                return null;\n            },\n            getCurrentColumn: function () {\n                var columnOpts = computeColumnOpts.value;\n                return columnOpts.isCurrent || props.highlightCurrentColumn ? reactData.currentColumn : null;\n            },\n            /**\n             * 用于当前列，设置某列行为高亮状态\n             */\n            setCurrentColumn: function (fieldOrColumn) {\n                var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                if (column) {\n                    // tableMethods.clearCurrentRow()\n                    tableMethods.clearCurrentColumn();\n                    reactData.currentColumn = column;\n                }\n                return nextTick();\n            },\n            /**\n             * 用于当前列，手动清空当前高亮的状态\n             */\n            clearCurrentColumn: function () {\n                reactData.currentColumn = null;\n                return nextTick();\n            },\n            setPendingRow: function (rows, status) {\n                var pendingMaps = __assign({}, reactData.pendingRowMaps);\n                var pendingList = __spreadArray([], reactData.pendingRowList, true);\n                if (rows && !XEUtils.isArray(rows)) {\n                    rows = [rows];\n                }\n                if (status) {\n                    rows.forEach(function (row) {\n                        var rowid = getRowid($xetable, row);\n                        if (rowid && !pendingMaps[rowid]) {\n                            pendingList.push(row);\n                            pendingMaps[rowid] = row;\n                        }\n                    });\n                }\n                else {\n                    rows.forEach(function (row) {\n                        var rowid = getRowid($xetable, row);\n                        if (rowid && pendingMaps[rowid]) {\n                            var pendingIndex = $xetable.findRowIndexOf(pendingList, row);\n                            if (pendingIndex > -1) {\n                                pendingList.splice(pendingIndex, 1);\n                            }\n                            delete pendingMaps[rowid];\n                        }\n                    });\n                }\n                reactData.pendingRowMaps = pendingMaps;\n                reactData.pendingRowList = pendingList;\n                return nextTick();\n            },\n            togglePendingRow: function (rows) {\n                var pendingMaps = __assign({}, reactData.pendingRowMaps);\n                var pendingList = __spreadArray([], reactData.pendingRowList, true);\n                if (rows && !XEUtils.isArray(rows)) {\n                    rows = [rows];\n                }\n                rows.forEach(function (row) {\n                    var rowid = getRowid($xetable, row);\n                    if (rowid) {\n                        if (pendingMaps[rowid]) {\n                            var pendingIndex = $xetable.findRowIndexOf(pendingList, row);\n                            if (pendingIndex > -1) {\n                                pendingList.splice(pendingIndex, 1);\n                            }\n                            delete pendingMaps[rowid];\n                        }\n                        else {\n                            pendingList.push(row);\n                            pendingMaps[rowid] = row;\n                        }\n                    }\n                });\n                reactData.pendingRowMaps = pendingMaps;\n                reactData.pendingRowList = pendingList;\n                return nextTick();\n            },\n            hasPendingByRow: function (row) {\n                var pendingRowMaps = reactData.pendingRowMaps;\n                var rowid = getRowid($xetable, row);\n                return !!pendingRowMaps[rowid];\n            },\n            getPendingRecords: function () {\n                var pendingRowList = reactData.pendingRowList;\n                return pendingRowList.slice(0);\n            },\n            clearPendingRow: function () {\n                reactData.pendingRowMaps = {};\n                reactData.pendingRowList = [];\n                return nextTick();\n            },\n            sort: function (sortConfs, sortOrder) {\n                var sortOpts = computeSortOpts.value;\n                var multiple = sortOpts.multiple, remote = sortOpts.remote, orders = sortOpts.orders;\n                if (sortConfs) {\n                    if (XEUtils.isString(sortConfs)) {\n                        sortConfs = [\n                            { field: sortConfs, order: sortOrder }\n                        ];\n                    }\n                }\n                if (!XEUtils.isArray(sortConfs)) {\n                    sortConfs = [sortConfs];\n                }\n                if (sortConfs.length) {\n                    if (!multiple) {\n                        clearAllSort();\n                    }\n                    (multiple ? sortConfs : [sortConfs[0]]).forEach(function (confs, index) {\n                        var field = confs.field, order = confs.order;\n                        var column = field;\n                        if (XEUtils.isString(field)) {\n                            column = tableMethods.getColumnByField(field);\n                        }\n                        if (column && column.sortable) {\n                            if (orders.indexOf(order) === -1) {\n                                order = getNextSortOrder(column);\n                            }\n                            if (column.order !== order) {\n                                column.order = order;\n                            }\n                            column.sortTime = Date.now() + index;\n                        }\n                    });\n                    // 如果是服务端排序，则跳过本地排序处理\n                    if (!remote) {\n                        tablePrivateMethods.handleTableData(true);\n                    }\n                    return nextTick().then(function () {\n                        tableMethods.updateCellAreas();\n                        return updateStyle();\n                    });\n                }\n                return nextTick();\n            },\n            /**\n             * 清空指定列的排序条件\n             * 如果为空则清空所有列的排序条件\n             * @param {String} fieldOrColumn 列或字段名\n             */\n            clearSort: function (fieldOrColumn) {\n                var sortOpts = computeSortOpts.value;\n                if (fieldOrColumn) {\n                    var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                    if (column) {\n                        column.order = null;\n                    }\n                }\n                else {\n                    clearAllSort();\n                }\n                if (!sortOpts.remote) {\n                    tablePrivateMethods.handleTableData(true);\n                }\n                return nextTick().then(updateStyle);\n            },\n            isSort: function (fieldOrColumn) {\n                if (fieldOrColumn) {\n                    var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                    return column ? column.sortable && !!column.order : false;\n                }\n                return tableMethods.getSortColumns().length > 0;\n            },\n            getSortColumns: function () {\n                var sortOpts = computeSortOpts.value;\n                var multiple = sortOpts.multiple, chronological = sortOpts.chronological;\n                var sortList = [];\n                var tableFullColumn = internalData.tableFullColumn;\n                tableFullColumn.forEach(function (column) {\n                    var field = column.field, order = column.order;\n                    if (column.sortable && order) {\n                        sortList.push({ column: column, field: field, property: field, order: order, sortTime: column.sortTime });\n                    }\n                });\n                if (multiple && chronological && sortList.length > 1) {\n                    return XEUtils.orderBy(sortList, 'sortTime');\n                }\n                return sortList;\n            },\n            /**\n             * 关闭筛选\n             * @param {Event} evnt 事件\n             */\n            closeFilter: function () {\n                var filterStore = reactData.filterStore;\n                var column = filterStore.column, visible = filterStore.visible;\n                Object.assign(filterStore, {\n                    isAllSelected: false,\n                    isIndeterminate: false,\n                    options: [],\n                    visible: false\n                });\n                if (visible) {\n                    $xetable.dispatchEvent('filter-visible', { column: column, property: column.field, field: column.field, filterList: $xetable.getCheckedFilters(), visible: false }, null);\n                }\n                return nextTick();\n            },\n            /**\n             * 判断指定列是否为筛选状态，如果为空则判断所有列\n             * @param {String} fieldOrColumn 字段名\n             */\n            isActiveFilterByColumn: function (fieldOrColumn) {\n                var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                if (column) {\n                    return column.filters && column.filters.some(function (option) { return option.checked; });\n                }\n                return $xetable.getCheckedFilters().length > 0;\n            },\n            isFilter: function (fieldOrColumn) {\n                return tableMethods.isActiveFilterByColumn(fieldOrColumn);\n            },\n            /**\n             * 判断展开行是否懒加载完成\n             * @param {Row} row 行对象\n             */\n            isRowExpandLoaded: function (row) {\n                var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                var rest = fullAllDataRowIdData[getRowid($xetable, row)];\n                return rest && !!rest.expandLoaded;\n            },\n            clearRowExpandLoaded: function (row) {\n                var rowExpandLazyLoadedMaps = reactData.rowExpandLazyLoadedMaps;\n                var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                var expandOpts = computeExpandOpts.value;\n                var lazy = expandOpts.lazy;\n                var rowid = getRowid($xetable, row);\n                var rest = fullAllDataRowIdData[rowid];\n                if (lazy && rest) {\n                    rest.expandLoaded = false;\n                    delete rowExpandLazyLoadedMaps[rowid];\n                }\n                return nextTick();\n            },\n            /**\n             * 重新懒加载展开行，并展开内容\n             * @param {Row} row 行对象\n             */\n            reloadRowExpand: function (row) {\n                var rowExpandLazyLoadedMaps = reactData.rowExpandLazyLoadedMaps;\n                var expandOpts = computeExpandOpts.value;\n                var lazy = expandOpts.lazy;\n                var rowid = getRowid($xetable, row);\n                if (lazy && !rowExpandLazyLoadedMaps[rowid]) {\n                    tableMethods.clearRowExpandLoaded(row)\n                        .then(function () { return handleAsyncRowExpand(row); });\n                }\n                return nextTick();\n            },\n            reloadExpandContent: function (row) {\n                if (process.env.NODE_ENV === 'development') {\n                    warnLog('vxe.error.delFunc', ['reloadExpandContent', 'reloadRowExpand']);\n                }\n                // 即将废弃\n                return tableMethods.reloadRowExpand(row);\n            },\n            /**\n             * 切换展开行\n             */\n            toggleRowExpand: function (row) {\n                return tableMethods.setRowExpand(row, !tableMethods.isRowExpandByRow(row));\n            },\n            /**\n             * 设置所有行的展开与否\n             * @param {Boolean} expanded 是否展开\n             */\n            setAllRowExpand: function (expanded) {\n                var treeOpts = computeTreeOpts.value;\n                var tableFullData = internalData.tableFullData, tableFullTreeData = internalData.tableFullTreeData;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var expandedRows = [];\n                if (props.treeConfig) {\n                    XEUtils.eachTree(tableFullTreeData, function (row) {\n                        expandedRows.push(row);\n                    }, { children: childrenField });\n                }\n                else {\n                    expandedRows = tableFullData;\n                }\n                return tableMethods.setRowExpand(expandedRows, expanded);\n            },\n            /**\n             * 设置展开行，二个参数设置这一行展开与否\n             * 支持单行\n             * 支持多行\n             * @param {Array/Row} rows 行数据\n             * @param {Boolean} expanded 是否展开\n             */\n            setRowExpand: function (rows, expanded) {\n                var rowExpandedMaps = reactData.rowExpandedMaps, rowExpandLazyLoadedMaps = reactData.rowExpandLazyLoadedMaps, column = reactData.expandColumn;\n                var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                var rExpandedMaps = __assign({}, rowExpandedMaps);\n                var expandOpts = computeExpandOpts.value;\n                var reserve = expandOpts.reserve, lazy = expandOpts.lazy, accordion = expandOpts.accordion, toggleMethod = expandOpts.toggleMethod;\n                var lazyRests = [];\n                var columnIndex = tableMethods.getColumnIndex(column);\n                var $columnIndex = tableMethods.getVMColumnIndex(column);\n                if (rows) {\n                    if (!XEUtils.isArray(rows)) {\n                        rows = [rows];\n                    }\n                    if (accordion) {\n                        // 只能同时展开一个\n                        rExpandedMaps = {};\n                        rows = rows.slice(rows.length - 1, rows.length);\n                    }\n                    var validRows = toggleMethod ? rows.filter(function (row) { return toggleMethod({ $table: $xetable, expanded: expanded, column: column, columnIndex: columnIndex, $columnIndex: $columnIndex, row: row, rowIndex: tableMethods.getRowIndex(row), $rowIndex: tableMethods.getVMRowIndex(row) }); }) : rows;\n                    if (expanded) {\n                        validRows.forEach(function (row) {\n                            var rowid = getRowid($xetable, row);\n                            if (!rExpandedMaps[rowid]) {\n                                var rest = fullAllDataRowIdData[rowid];\n                                var isLoad = lazy && !rest.expandLoaded && !rowExpandLazyLoadedMaps[rowid];\n                                if (isLoad) {\n                                    lazyRests.push(handleAsyncRowExpand(row));\n                                }\n                                else {\n                                    rExpandedMaps[rowid] = row;\n                                }\n                            }\n                        });\n                    }\n                    else {\n                        validRows.forEach(function (item) {\n                            var rowid = getRowid($xetable, item);\n                            if (rExpandedMaps[rowid]) {\n                                delete rExpandedMaps[rowid];\n                            }\n                        });\n                    }\n                    if (reserve) {\n                        validRows.forEach(function (row) { return handleRowExpandReserve(row, expanded); });\n                    }\n                }\n                reactData.rowExpandedMaps = rExpandedMaps;\n                return Promise.all(lazyRests).then(function () { return tableMethods.recalculate(); });\n            },\n            /**\n             * 判断行是否为展开状态\n             * @param {Row} row 行对象\n             */\n            isRowExpandByRow: function (row) {\n                var rowExpandedMaps = reactData.rowExpandedMaps;\n                var rowid = getRowid($xetable, row);\n                return !!rowExpandedMaps[rowid];\n            },\n            isExpandByRow: function (row) {\n                // if (process.env.NODE_ENV === 'development') {\n                //   warnLog('vxe.error.delFunc', ['isExpandByRow', 'isRowExpandByRow'])\n                // }\n                return tableMethods.isRowExpandByRow(row);\n            },\n            /**\n             * 手动清空展开行状态，数据会恢复成未展开的状态\n             */\n            clearRowExpand: function () {\n                var tableFullData = internalData.tableFullData;\n                var expandOpts = computeExpandOpts.value;\n                var reserve = expandOpts.reserve;\n                var expList = tableMethods.getRowExpandRecords();\n                reactData.rowExpandedMaps = {};\n                if (reserve) {\n                    tableFullData.forEach(function (row) { return handleRowExpandReserve(row, false); });\n                }\n                return nextTick().then(function () {\n                    if (expList.length) {\n                        tableMethods.recalculate();\n                    }\n                });\n            },\n            clearRowExpandReserve: function () {\n                internalData.rowExpandedReserveRowMap = {};\n                return nextTick();\n            },\n            getRowExpandRecords: function () {\n                var rest = [];\n                XEUtils.each(reactData.rowExpandedMaps, function (item) {\n                    if (item) {\n                        rest.push(item);\n                    }\n                });\n                return rest;\n            },\n            getTreeExpandRecords: function () {\n                var rest = [];\n                XEUtils.each(reactData.treeExpandedMaps, function (item) {\n                    if (item) {\n                        rest.push(item);\n                    }\n                });\n                return rest;\n            },\n            /**\n             * 判断树节点是否懒加载完成\n             * @param {Row} row 行对象\n             */\n            isTreeExpandLoaded: function (row) {\n                var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                var rest = fullAllDataRowIdData[getRowid($xetable, row)];\n                return rest && !!rest.treeLoaded;\n            },\n            clearTreeExpandLoaded: function (row) {\n                var treeExpandedMaps = reactData.treeExpandedMaps;\n                var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                var treeOpts = computeTreeOpts.value;\n                var transform = treeOpts.transform, lazy = treeOpts.lazy;\n                var rowid = getRowid($xetable, row);\n                var rest = fullAllDataRowIdData[rowid];\n                if (lazy && rest) {\n                    rest.treeLoaded = false;\n                    if (treeExpandedMaps[rowid]) {\n                        delete treeExpandedMaps[rowid];\n                    }\n                }\n                if (transform) {\n                    handleVirtualTreeToList();\n                    return tablePrivateMethods.handleTableData();\n                }\n                return nextTick();\n            },\n            /**\n             * 重新懒加载树节点，并展开该节点\n             * @param {Row} row 行对象\n             */\n            reloadTreeExpand: function (row) {\n                var treeExpandLazyLoadedMaps = reactData.treeExpandLazyLoadedMaps;\n                var treeOpts = computeTreeOpts.value;\n                var hasChildField = treeOpts.hasChild || treeOpts.hasChildField;\n                var transform = treeOpts.transform, lazy = treeOpts.lazy;\n                var rowid = getRowid($xetable, row);\n                if (lazy && row[hasChildField] && !treeExpandLazyLoadedMaps[rowid]) {\n                    tableMethods.clearTreeExpandLoaded(row).then(function () {\n                        return handleAsyncTreeExpandChilds(row);\n                    }).then(function () {\n                        if (transform) {\n                            handleVirtualTreeToList();\n                            return tablePrivateMethods.handleTableData();\n                        }\n                    }).then(function () {\n                        return tableMethods.recalculate();\n                    });\n                }\n                return nextTick();\n            },\n            reloadTreeChilds: function (row) {\n                if (process.env.NODE_ENV === 'development') {\n                    warnLog('vxe.error.delFunc', ['reloadTreeChilds', 'reloadTreeExpand']);\n                }\n                // 即将废弃\n                return tableMethods.reloadTreeExpand(row);\n            },\n            /**\n             * 切换/展开树节点\n             */\n            toggleTreeExpand: function (row) {\n                return tableMethods.setTreeExpand(row, !tableMethods.isTreeExpandByRow(row));\n            },\n            /**\n             * 设置所有树节点的展开与否\n             * @param {Boolean} expanded 是否展开\n             */\n            setAllTreeExpand: function (expanded) {\n                var tableFullData = internalData.tableFullData;\n                var treeOpts = computeTreeOpts.value;\n                var transform = treeOpts.transform, lazy = treeOpts.lazy;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var expandeds = [];\n                XEUtils.eachTree(tableFullData, function (row) {\n                    var rowChildren = row[childrenField];\n                    if (lazy || (rowChildren && rowChildren.length)) {\n                        expandeds.push(row);\n                    }\n                }, { children: childrenField });\n                return tableMethods.setTreeExpand(expandeds, expanded).then(function () {\n                    if (transform) {\n                        handleVirtualTreeToList();\n                        return tableMethods.recalculate();\n                    }\n                });\n            },\n            /**\n             * 设置展开树形节点，二个参数设置这一行展开与否\n             * 支持单行\n             * 支持多行\n             * @param {Array/Row} rows 行数据\n             * @param {Boolean} expanded 是否展开\n             */\n            setTreeExpand: function (rows, expanded) {\n                var treeOpts = computeTreeOpts.value;\n                var transform = treeOpts.transform;\n                if (rows) {\n                    if (!XEUtils.isArray(rows)) {\n                        rows = [rows];\n                    }\n                    if (rows.length) {\n                        // 如果为虚拟树\n                        if (transform) {\n                            return handleVirtualTreeExpand(rows, expanded);\n                        }\n                        else {\n                            return handleBaseTreeExpand(rows, expanded);\n                        }\n                    }\n                }\n                return nextTick();\n            },\n            /**\n             * 判断行是否为树形节点展开状态\n             * @param {Row} row 行对象\n             */\n            isTreeExpandByRow: function (row) {\n                var treeExpandedMaps = reactData.treeExpandedMaps;\n                return !!treeExpandedMaps[getRowid($xetable, row)];\n            },\n            /**\n             * 手动清空树形节点的展开状态，数据会恢复成未展开的状态\n             */\n            clearTreeExpand: function () {\n                var tableFullTreeData = internalData.tableFullTreeData;\n                var treeOpts = computeTreeOpts.value;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var transform = treeOpts.transform, reserve = treeOpts.reserve;\n                var expList = tableMethods.getTreeExpandRecords();\n                reactData.treeExpandedMaps = {};\n                if (reserve) {\n                    XEUtils.eachTree(tableFullTreeData, function (row) { return handleTreeExpandReserve(row, false); }, { children: childrenField });\n                }\n                return tablePrivateMethods.handleTableData().then(function () {\n                    if (transform) {\n                        handleVirtualTreeToList();\n                        return tablePrivateMethods.handleTableData();\n                    }\n                }).then(function () {\n                    if (expList.length) {\n                        return tableMethods.recalculate();\n                    }\n                });\n            },\n            clearTreeExpandReserve: function () {\n                internalData.treeExpandedReserveRowMap = {};\n                return nextTick();\n            },\n            /**\n             * 获取表格的滚动状态\n             */\n            getScroll: function () {\n                var scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad;\n                var tableBody = refTableBody.value;\n                var bodyElem = tableBody.$el;\n                return {\n                    virtualX: scrollXLoad,\n                    virtualY: scrollYLoad,\n                    scrollTop: bodyElem.scrollTop,\n                    scrollLeft: bodyElem.scrollLeft\n                };\n            },\n            /**\n             * 如果有滚动条，则滚动到对应的位置\n             * @param {Number} scrollLeft 左距离\n             * @param {Number} scrollTop 上距离\n             */\n            scrollTo: function (scrollLeft, scrollTop) {\n                var tableBody = refTableBody.value;\n                var tableFooter = refTableFooter.value;\n                var rightBody = refTableRightBody.value;\n                var tableBodyElem = tableBody ? tableBody.$el : null;\n                var rightBodyElem = rightBody ? rightBody.$el : null;\n                var tableFooterElem = tableFooter ? tableFooter.$el : null;\n                if (XEUtils.isNumber(scrollLeft)) {\n                    setScrollLeft(tableFooterElem || tableBodyElem, scrollLeft);\n                }\n                if (XEUtils.isNumber(scrollTop)) {\n                    setScrollTop(rightBodyElem || tableBodyElem, scrollTop);\n                }\n                if (reactData.scrollXLoad || reactData.scrollYLoad) {\n                    return new Promise(function (resolve) {\n                        setTimeout(function () {\n                            nextTick(function () {\n                                resolve();\n                            });\n                        }, 50);\n                    });\n                }\n                return nextTick();\n            },\n            /**\n             * 如果有滚动条，则滚动到对应的行\n             * @param {Row} row 行对象\n             * @param {ColumnInfo} fieldOrColumn 列配置\n             */\n            scrollToRow: function (row, fieldOrColumn) {\n                var rest = [];\n                if (row) {\n                    if (props.treeConfig) {\n                        rest.push(tablePrivateMethods.scrollToTreeRow(row));\n                    }\n                    else {\n                        rest.push(rowToVisible($xetable, row));\n                    }\n                }\n                if (fieldOrColumn) {\n                    rest.push(tableMethods.scrollToColumn(fieldOrColumn));\n                }\n                return Promise.all(rest);\n            },\n            /**\n             * 如果有滚动条，则滚动到对应的列\n             */\n            scrollToColumn: function (fieldOrColumn) {\n                var fullColumnIdData = internalData.fullColumnIdData;\n                var column = handleFieldOrColumn($xetable, fieldOrColumn);\n                if (column && fullColumnIdData[column.id]) {\n                    return colToVisible($xetable, column);\n                }\n                return nextTick();\n            },\n            /**\n             * 手动清除滚动相关信息，还原到初始状态\n             */\n            clearScroll: function () {\n                var scrollXStore = internalData.scrollXStore, scrollYStore = internalData.scrollYStore;\n                var tableBody = refTableBody.value;\n                var tableFooter = refTableFooter.value;\n                var rightBody = refTableRightBody.value;\n                var tableBodyElem = tableBody ? tableBody.$el : null;\n                var rightBodyElem = rightBody ? rightBody.$el : null;\n                var tableFooterElem = tableFooter ? tableFooter.$el : null;\n                if (rightBodyElem) {\n                    restoreScrollListener(rightBodyElem);\n                    rightBodyElem.scrollTop = 0;\n                }\n                if (tableFooterElem) {\n                    tableFooterElem.scrollLeft = 0;\n                }\n                if (tableBodyElem) {\n                    restoreScrollListener(tableBodyElem);\n                    tableBodyElem.scrollTop = 0;\n                    tableBodyElem.scrollLeft = 0;\n                }\n                scrollXStore.startIndex = 0;\n                scrollYStore.startIndex = 0;\n                return nextTick();\n            },\n            /**\n             * 更新表尾合计\n             */\n            updateFooter: function () {\n                var showFooter = props.showFooter, footerMethod = props.footerMethod;\n                var visibleColumn = internalData.visibleColumn, afterFullData = internalData.afterFullData;\n                if (showFooter && footerMethod) {\n                    reactData.footerTableData = visibleColumn.length ? footerMethod({ columns: visibleColumn, data: afterFullData, $table: $xetable, $grid: $xegrid }) : [];\n                }\n                return nextTick();\n            },\n            /**\n             * 更新列状态 updateStatus({ row, column }, cellValue)\n             * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一列编辑状态\n             * 如果单元格配置了校验规则，则会进行校验\n             */\n            updateStatus: function (slotParams, cellValue) {\n                var customVal = !XEUtils.isUndefined(cellValue);\n                return nextTick().then(function () {\n                    var editRules = props.editRules;\n                    var validStore = reactData.validStore;\n                    var tableBody = refTableBody.value;\n                    if (slotParams && tableBody && editRules) {\n                        var row_1 = slotParams.row, column_3 = slotParams.column;\n                        var type = 'change';\n                        if ($xetable.hasCellRules) {\n                            if ($xetable.hasCellRules(type, row_1, column_3)) {\n                                var cell_1 = tablePrivateMethods.getCell(row_1, column_3);\n                                if (cell_1) {\n                                    return $xetable.validCellRules(type, row_1, column_3, cellValue)\n                                        .then(function () {\n                                        if (customVal && validStore.visible) {\n                                            setCellValue(row_1, column_3, cellValue);\n                                        }\n                                        $xetable.clearValidate(row_1, column_3);\n                                    })\n                                        .catch(function (_a) {\n                                        var rule = _a.rule;\n                                        if (customVal) {\n                                            setCellValue(row_1, column_3, cellValue);\n                                        }\n                                        $xetable.showValidTooltip({ rule: rule, row: row_1, column: column_3, cell: cell_1 });\n                                    });\n                                }\n                            }\n                        }\n                    }\n                });\n            },\n            /**\n             * 设置合并单元格\n             * @param {TableMergeConfig[]} merges { row: Row|number, column: ColumnInfo|number, rowspan: number, colspan: number }\n             */\n            setMergeCells: function (merges) {\n                if (props.spanMethod) {\n                    errLog('vxe.error.errConflicts', ['merge-cells', 'span-method']);\n                }\n                setMerges(merges, reactData.mergeList, internalData.afterFullData);\n                return nextTick().then(function () { return tableMethods.updateCellAreas(); });\n            },\n            /**\n             * 移除单元格合并\n             * @param {TableMergeConfig[]} merges 多个或数组 [{row:Row|number, col:ColumnInfo|number}]\n             */\n            removeMergeCells: function (merges) {\n                if (props.spanMethod) {\n                    errLog('vxe.error.errConflicts', ['merge-cells', 'span-method']);\n                }\n                var rest = removeMerges(merges, reactData.mergeList, internalData.afterFullData);\n                return nextTick().then(function () {\n                    tableMethods.updateCellAreas();\n                    return rest;\n                });\n            },\n            /**\n             * 获取所有被合并的单元格\n             */\n            getMergeCells: function () {\n                return reactData.mergeList.slice(0);\n            },\n            /**\n             * 清除所有单元格合并\n             */\n            clearMergeCells: function () {\n                reactData.mergeList = [];\n                return nextTick();\n            },\n            setMergeFooterItems: function (merges) {\n                if (props.footerSpanMethod) {\n                    errLog('vxe.error.errConflicts', ['merge-footer-items', 'footer-span-method']);\n                }\n                setMerges(merges, reactData.mergeFooterList);\n                return nextTick().then(function () { return tableMethods.updateCellAreas(); });\n            },\n            removeMergeFooterItems: function (merges) {\n                if (props.footerSpanMethod) {\n                    errLog('vxe.error.errConflicts', ['merge-footer-items', 'footer-span-method']);\n                }\n                var rest = removeMerges(merges, reactData.mergeFooterList);\n                return nextTick().then(function () {\n                    tableMethods.updateCellAreas();\n                    return rest;\n                });\n            },\n            /**\n             * 获取所有被合并的表尾\n             */\n            getMergeFooterItems: function () {\n                return reactData.mergeFooterList.slice(0);\n            },\n            /**\n             * 清除所有表尾合并\n             */\n            clearMergeFooterItems: function () {\n                reactData.mergeFooterList = [];\n                return nextTick();\n            },\n            updateCellAreas: function () {\n                var mouseConfig = props.mouseConfig;\n                var mouseOpts = computeMouseOpts.value;\n                if (mouseConfig && mouseOpts.area && $xetable.handleUpdateCellAreas) {\n                    return $xetable.handleUpdateCellAreas();\n                }\n                return nextTick();\n            },\n            focus: function () {\n                internalData.isActivated = true;\n                return nextTick();\n            },\n            blur: function () {\n                internalData.isActivated = false;\n                return nextTick();\n            },\n            /**\n             * 连接工具栏\n             * @param $toolbar\n             */\n            connect: function ($toolbar) {\n                if ($toolbar) {\n                    $xetoolbar = $toolbar;\n                    $xetoolbar.syncUpdate({ collectColumn: internalData.collectColumn, $table: $xetable });\n                }\n                else {\n                    errLog('vxe.error.barUnableLink');\n                }\n                return nextTick();\n            }\n        };\n        /**\n         * 全局按下事件处理\n         */\n        var handleGlobalMousedownEvent = function (evnt) {\n            var editStore = reactData.editStore, ctxMenuStore = reactData.ctxMenuStore, filterStore = reactData.filterStore;\n            var mouseConfig = props.mouseConfig, editRules = props.editRules;\n            var el = refElem.value;\n            var editOpts = computeEditOpts.value;\n            var validOpts = computeValidOpts.value;\n            var actived = editStore.actived;\n            var $validTooltip = refValidTooltip.value;\n            var tableFilter = refTableFilter.value;\n            var tableMenu = refTableMenu.value;\n            if (tableFilter) {\n                if (getEventTargetNode(evnt, el, 'vxe-cell--filter').flag) {\n                    // 如果点击了筛选按钮\n                }\n                else if (getEventTargetNode(evnt, tableFilter.$el).flag) {\n                    // 如果点击筛选容器\n                }\n                else {\n                    if (!getEventTargetNode(evnt, document.body, 'vxe-table--ignore-clear').flag) {\n                        tablePrivateMethods.preventEvent(evnt, 'event.clearFilter', filterStore.args, tableMethods.closeFilter);\n                    }\n                }\n            }\n            // 如果已激活了编辑状态\n            if (actived.row) {\n                if (!(editOpts.autoClear === false)) {\n                    // 如果是激活状态，点击了单元格之外\n                    var cell = actived.args.cell;\n                    if ((!cell || !getEventTargetNode(evnt, cell).flag)) {\n                        if ($validTooltip && getEventTargetNode(evnt, $validTooltip.$el).flag) {\n                            // 如果是激活状态，且点击了校验提示框\n                        }\n                        else if (!internalData._lastCallTime || internalData._lastCallTime + 50 < Date.now()) {\n                            // 如果是激活状态，点击了单元格之外\n                            if (!getEventTargetNode(evnt, document.body, 'vxe-table--ignore-clear').flag) {\n                                // 如果手动调用了激活单元格，避免触发源被移除后导致重复关闭\n                                tablePrivateMethods.preventEvent(evnt, 'event.clearActived', actived.args, function () {\n                                    var isClear;\n                                    if (editOpts.mode === 'row') {\n                                        var rowTargetNode = getEventTargetNode(evnt, el, 'vxe-body--row');\n                                        var rowNodeRest = rowTargetNode.flag ? tableMethods.getRowNode(rowTargetNode.targetElem) : null;\n                                        // row 方式，如果点击了不同行\n                                        isClear = rowNodeRest ? !$xetable.eqRow(rowNodeRest.item, actived.args.row) : false;\n                                    }\n                                    else {\n                                        // cell 方式，如果是非编辑列\n                                        isClear = !getEventTargetNode(evnt, el, 'col--edit').flag;\n                                    }\n                                    // 如果点击表头行，则清除激活状态\n                                    if (!isClear) {\n                                        isClear = getEventTargetNode(evnt, el, 'vxe-header--row').flag;\n                                    }\n                                    // 如果点击表尾行，则清除激活状态\n                                    if (!isClear) {\n                                        isClear = getEventTargetNode(evnt, el, 'vxe-footer--row').flag;\n                                    }\n                                    // 如果固定了高度且点击了行之外的空白处，则清除激活状态\n                                    if (!isClear && props.height && !reactData.overflowY) {\n                                        var bodyWrapperElem = evnt.target;\n                                        if (hasClass(bodyWrapperElem, 'vxe-table--body-wrapper')) {\n                                            isClear = evnt.offsetY < bodyWrapperElem.clientHeight;\n                                        }\n                                    }\n                                    if (isClear ||\n                                        // 如果点击了当前表格之外\n                                        !getEventTargetNode(evnt, el).flag) {\n                                        setTimeout(function () { return $xetable.clearEdit(evnt); });\n                                    }\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n            else if (mouseConfig) {\n                if (!getEventTargetNode(evnt, el).flag && !($xegrid && getEventTargetNode(evnt, $xegrid.getRefMaps().refElem.value).flag) && !(tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) && !($xetoolbar && getEventTargetNode(evnt, $xetoolbar.getRefMaps().refElem.value).flag)) {\n                    $xetable.clearSelected();\n                    if ($xetable.clearCellAreas) {\n                        if (!getEventTargetNode(evnt, document.body, 'vxe-table--ignore-areas-clear').flag) {\n                            tablePrivateMethods.preventEvent(evnt, 'event.clearAreas', {}, function () {\n                                $xetable.clearCellAreas();\n                                $xetable.clearCopyCellArea();\n                            });\n                        }\n                    }\n                }\n            }\n            // 如果配置了快捷菜单且，点击了其他地方则关闭\n            if ($xetable.closeMenu) {\n                if (ctxMenuStore.visible && tableMenu && !getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {\n                    $xetable.closeMenu();\n                }\n            }\n            var isActivated = getEventTargetNode(evnt, $xegrid ? $xegrid.getRefMaps().refElem.value : el).flag;\n            // 如果存在校验，点击了表格之外则清除\n            if (!isActivated && editRules && validOpts.autoClear) {\n                reactData.validErrorMaps = {};\n            }\n            // 最后激活的表格\n            internalData.isActivated = isActivated;\n        };\n        /**\n         * 窗口失焦事件处理\n         */\n        var handleGlobalBlurEvent = function () {\n            tableMethods.closeFilter();\n            if ($xetable.closeMenu) {\n                $xetable.closeMenu();\n            }\n        };\n        /**\n         * 全局滚动事件\n         */\n        var handleGlobalMousewheelEvent = function () {\n            tableMethods.closeTooltip();\n            if ($xetable.closeMenu) {\n                $xetable.closeMenu();\n            }\n        };\n        /**\n         * 表格键盘事件\n         */\n        var keydownEvent = function (evnt) {\n            var mouseConfig = props.mouseConfig, keyboardConfig = props.keyboardConfig;\n            var filterStore = reactData.filterStore, ctxMenuStore = reactData.ctxMenuStore, editStore = reactData.editStore;\n            var mouseOpts = computeMouseOpts.value;\n            var keyboardOpts = computeKeyboardOpts.value;\n            var actived = editStore.actived;\n            var isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);\n            if (isEsc) {\n                tablePrivateMethods.preventEvent(evnt, 'event.keydown', null, function () {\n                    tableMethods.dispatchEvent('keydown-start', {}, evnt);\n                    if (keyboardConfig && mouseConfig && mouseOpts.area && $xetable.handleKeyboardEvent) {\n                        $xetable.handleKeyboardEvent(evnt);\n                    }\n                    else if (actived.row || filterStore.visible || ctxMenuStore.visible) {\n                        evnt.stopPropagation();\n                        // 如果按下了 Esc 键，关闭快捷菜单、筛选\n                        if ($xetable.closeMenu) {\n                            $xetable.closeMenu();\n                        }\n                        tableMethods.closeFilter();\n                        if (keyboardConfig && keyboardOpts.isEsc) {\n                            // 如果是激活编辑状态，则取消编辑\n                            if (actived.row) {\n                                var params_1 = actived.args;\n                                $xetable.clearEdit(evnt);\n                                // 如果配置了选中功能，则为选中状态\n                                if (mouseOpts.selected) {\n                                    nextTick(function () { return $xetable.handleSelected(params_1, evnt); });\n                                }\n                            }\n                        }\n                    }\n                    tableMethods.dispatchEvent('keydown', {}, evnt);\n                    tableMethods.dispatchEvent('keydown-end', {}, evnt);\n                });\n            }\n        };\n        /**\n         * 全局键盘事件\n         */\n        var handleGlobalKeydownEvent = function (evnt) {\n            // 该行为只对当前激活的表格有效\n            if (internalData.isActivated) {\n                tablePrivateMethods.preventEvent(evnt, 'event.keydown', null, function () {\n                    var mouseConfig = props.mouseConfig, keyboardConfig = props.keyboardConfig, treeConfig = props.treeConfig, editConfig = props.editConfig, highlightCurrentRow = props.highlightCurrentRow;\n                    var ctxMenuStore = reactData.ctxMenuStore, editStore = reactData.editStore, currentRow = reactData.currentRow;\n                    var isMenu = computeIsMenu.value;\n                    var bodyMenu = computeBodyMenu.value;\n                    var keyboardOpts = computeKeyboardOpts.value;\n                    var mouseOpts = computeMouseOpts.value;\n                    var editOpts = computeEditOpts.value;\n                    var treeOpts = computeTreeOpts.value;\n                    var menuList = computeMenuList.value;\n                    var rowOpts = computeRowOpts.value;\n                    var selected = editStore.selected, actived = editStore.actived;\n                    var childrenField = treeOpts.children || treeOpts.childrenField;\n                    var keyCode = evnt.keyCode;\n                    var isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);\n                    var isBack = hasEventKey(evnt, EVENT_KEYS.BACKSPACE);\n                    var isTab = hasEventKey(evnt, EVENT_KEYS.TAB);\n                    var isEnter = hasEventKey(evnt, EVENT_KEYS.ENTER);\n                    var isSpacebar = hasEventKey(evnt, EVENT_KEYS.SPACEBAR);\n                    var isLeftArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_LEFT);\n                    var isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);\n                    var isRightArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_RIGHT);\n                    var isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);\n                    var isDel = hasEventKey(evnt, EVENT_KEYS.DELETE);\n                    var isF2 = hasEventKey(evnt, EVENT_KEYS.F2);\n                    var isContextMenu = hasEventKey(evnt, EVENT_KEYS.CONTEXT_MENU);\n                    var hasMetaKey = evnt.metaKey;\n                    var hasCtrlKey = evnt.ctrlKey;\n                    var hasShiftKey = evnt.shiftKey;\n                    var isAltKey = evnt.altKey;\n                    var operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;\n                    var operCtxMenu = isMenu && ctxMenuStore.visible && (isEnter || isSpacebar || operArrow);\n                    var isEditStatus = isEnableConf(editConfig) && actived.column && actived.row;\n                    var params;\n                    if (operCtxMenu) {\n                        // 如果配置了右键菜单; 支持方向键操作、回车\n                        evnt.preventDefault();\n                        if (ctxMenuStore.showChild && hasChildrenList(ctxMenuStore.selected)) {\n                            $xetable.moveCtxMenu(evnt, ctxMenuStore, 'selectChild', isLeftArrow, false, ctxMenuStore.selected.children);\n                        }\n                        else {\n                            $xetable.moveCtxMenu(evnt, ctxMenuStore, 'selected', isRightArrow, true, menuList);\n                        }\n                    }\n                    else if (keyboardConfig && mouseConfig && mouseOpts.area && $xetable.handleKeyboardEvent) {\n                        $xetable.handleKeyboardEvent(evnt);\n                    }\n                    else if (isEsc) {\n                        // 如果按下了 Esc 键，关闭快捷菜单、筛选\n                        if ($xetable.closeMenu) {\n                            $xetable.closeMenu();\n                        }\n                        tableMethods.closeFilter();\n                        if (keyboardConfig && keyboardOpts.isEsc) {\n                            // 如果是激活编辑状态，则取消编辑\n                            if (actived.row) {\n                                var params_2 = actived.args;\n                                $xetable.clearEdit(evnt);\n                                // 如果配置了选中功能，则为选中状态\n                                if (mouseOpts.selected) {\n                                    nextTick(function () { return $xetable.handleSelected(params_2, evnt); });\n                                }\n                            }\n                        }\n                    }\n                    else if (isSpacebar && keyboardConfig && keyboardOpts.isChecked && selected.row && selected.column && (selected.column.type === 'checkbox' || selected.column.type === 'radio')) {\n                        // 空格键支持选中复选框\n                        evnt.preventDefault();\n                        if (selected.column.type === 'checkbox') {\n                            tablePrivateMethods.handleToggleCheckRowEvent(evnt, selected.args);\n                        }\n                        else {\n                            tablePrivateMethods.triggerRadioRowEvent(evnt, selected.args);\n                        }\n                    }\n                    else if (isF2 && isEnableConf(editConfig)) {\n                        if (!isEditStatus) {\n                            // 如果按下了 F2 键\n                            if (selected.row && selected.column) {\n                                evnt.preventDefault();\n                                $xetable.handleActived(selected.args, evnt);\n                            }\n                        }\n                    }\n                    else if (isContextMenu) {\n                        // 如果按下上下文键\n                        internalData._keyCtx = selected.row && selected.column && bodyMenu.length;\n                        clearTimeout(keyCtxTimeout);\n                        keyCtxTimeout = setTimeout(function () {\n                            internalData._keyCtx = false;\n                        }, 1000);\n                    }\n                    else if (isEnter && !isAltKey && keyboardConfig && keyboardOpts.isEnter && (selected.row || actived.row || (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow))) {\n                        // 退出选中\n                        if (hasCtrlKey) {\n                            // 如果是激活编辑状态，则取消编辑\n                            if (actived.row) {\n                                params = actived.args;\n                                $xetable.clearEdit(evnt);\n                                // 如果配置了选中功能，则为选中状态\n                                if (mouseOpts.selected) {\n                                    nextTick(function () { return $xetable.handleSelected(params, evnt); });\n                                }\n                            }\n                        }\n                        else {\n                            // 如果是激活状态，退则出到上一行/下一行\n                            if (selected.row || actived.row) {\n                                var targetArgs = selected.row ? selected.args : actived.args;\n                                if (hasShiftKey) {\n                                    if (keyboardOpts.enterToTab) {\n                                        $xetable.moveTabSelected(targetArgs, hasShiftKey, evnt);\n                                    }\n                                    else {\n                                        $xetable.moveSelected(targetArgs, isLeftArrow, true, isRightArrow, false, evnt);\n                                    }\n                                }\n                                else {\n                                    if (keyboardOpts.enterToTab) {\n                                        $xetable.moveTabSelected(targetArgs, hasShiftKey, evnt);\n                                    }\n                                    else {\n                                        $xetable.moveSelected(targetArgs, isLeftArrow, false, isRightArrow, true, evnt);\n                                    }\n                                }\n                            }\n                            else if (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {\n                                // 如果是树形表格当前行回车移动到子节点\n                                var childrens = currentRow[childrenField];\n                                if (childrens && childrens.length) {\n                                    evnt.preventDefault();\n                                    var targetRow_1 = childrens[0];\n                                    params = {\n                                        $table: $xetable,\n                                        row: targetRow_1,\n                                        rowIndex: tableMethods.getRowIndex(targetRow_1),\n                                        $rowIndex: tableMethods.getVMRowIndex(targetRow_1)\n                                    };\n                                    tableMethods.setTreeExpand(currentRow, true)\n                                        .then(function () { return tableMethods.scrollToRow(targetRow_1); })\n                                        .then(function () { return tablePrivateMethods.triggerCurrentRowEvent(evnt, params); });\n                                }\n                            }\n                        }\n                    }\n                    else if (operArrow && keyboardConfig && keyboardOpts.isArrow) {\n                        if (!isEditStatus) {\n                            // 如果按下了方向键\n                            if (selected.row && selected.column) {\n                                $xetable.moveSelected(selected.args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt);\n                            }\n                            else if ((isUpArrow || isDwArrow) && (rowOpts.isCurrent || highlightCurrentRow)) {\n                                // 当前行按键上下移动\n                                $xetable.moveCurrentRow(isUpArrow, isDwArrow, evnt);\n                            }\n                        }\n                    }\n                    else if (isTab && keyboardConfig && keyboardOpts.isTab) {\n                        // 如果按下了 Tab 键切换\n                        if (selected.row || selected.column) {\n                            $xetable.moveTabSelected(selected.args, hasShiftKey, evnt);\n                        }\n                        else if (actived.row || actived.column) {\n                            $xetable.moveTabSelected(actived.args, hasShiftKey, evnt);\n                        }\n                    }\n                    else if (keyboardConfig && isEnableConf(editConfig) && (isDel || (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow ? isBack && keyboardOpts.isArrow : isBack))) {\n                        if (!isEditStatus) {\n                            var delMethod = keyboardOpts.delMethod, backMethod = keyboardOpts.backMethod;\n                            // 如果是删除键\n                            if (keyboardOpts.isDel && (selected.row || selected.column)) {\n                                if (delMethod) {\n                                    delMethod({\n                                        row: selected.row,\n                                        rowIndex: tableMethods.getRowIndex(selected.row),\n                                        column: selected.column,\n                                        columnIndex: tableMethods.getColumnIndex(selected.column),\n                                        $table: $xetable\n                                    });\n                                }\n                                else {\n                                    setCellValue(selected.row, selected.column, null);\n                                }\n                                if (isBack) {\n                                    if (backMethod) {\n                                        backMethod({\n                                            row: selected.row,\n                                            rowIndex: tableMethods.getRowIndex(selected.row),\n                                            column: selected.column,\n                                            columnIndex: tableMethods.getColumnIndex(selected.column),\n                                            $table: $xetable\n                                        });\n                                    }\n                                    else {\n                                        $xetable.handleActived(selected.args, evnt);\n                                    }\n                                }\n                                else if (isDel) {\n                                    // 如果按下 del 键，更新表尾数据\n                                    tableMethods.updateFooter();\n                                }\n                            }\n                            else if (isBack && keyboardOpts.isArrow && treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {\n                                // 如果树形表格回退键关闭当前行返回父节点\n                                var parentRow_1 = XEUtils.findTree(internalData.afterFullData, function (item) { return item === currentRow; }, { children: childrenField }).parent;\n                                if (parentRow_1) {\n                                    evnt.preventDefault();\n                                    params = {\n                                        $table: $xetable,\n                                        row: parentRow_1,\n                                        rowIndex: tableMethods.getRowIndex(parentRow_1),\n                                        $rowIndex: tableMethods.getVMRowIndex(parentRow_1)\n                                    };\n                                    tableMethods.setTreeExpand(parentRow_1, false)\n                                        .then(function () { return tableMethods.scrollToRow(parentRow_1); })\n                                        .then(function () { return tablePrivateMethods.triggerCurrentRowEvent(evnt, params); });\n                                }\n                            }\n                        }\n                    }\n                    else if (keyboardConfig && isEnableConf(editConfig) && keyboardOpts.isEdit && !hasCtrlKey && !hasMetaKey && (isSpacebar || (keyCode >= 48 && keyCode <= 57) || (keyCode >= 65 && keyCode <= 90) || (keyCode >= 96 && keyCode <= 111) || (keyCode >= 186 && keyCode <= 192) || (keyCode >= 219 && keyCode <= 222))) {\n                        var editMethod = keyboardOpts.editMethod;\n                        // 启用编辑后，空格键功能将失效\n                        // if (isSpacebar) {\n                        //   evnt.preventDefault()\n                        // }\n                        // 如果是按下非功能键之外允许直接编辑\n                        if (selected.column && selected.row && isEnableConf(selected.column.editRender)) {\n                            var beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;\n                            if (!beforeEditMethod || beforeEditMethod(__assign(__assign({}, selected.args), { $table: $xetable, $grid: $xegrid }))) {\n                                if (editMethod) {\n                                    editMethod({\n                                        row: selected.row,\n                                        rowIndex: tableMethods.getRowIndex(selected.row),\n                                        column: selected.column,\n                                        columnIndex: tableMethods.getColumnIndex(selected.column),\n                                        $table: $xetable,\n                                        $grid: $xegrid\n                                    });\n                                }\n                                else {\n                                    setCellValue(selected.row, selected.column, null);\n                                    $xetable.handleActived(selected.args, evnt);\n                                }\n                            }\n                        }\n                    }\n                    tableMethods.dispatchEvent('keydown', {}, evnt);\n                });\n            }\n        };\n        var handleGlobalPasteEvent = function (evnt) {\n            var keyboardConfig = props.keyboardConfig, mouseConfig = props.mouseConfig;\n            var editStore = reactData.editStore, filterStore = reactData.filterStore;\n            var isActivated = internalData.isActivated;\n            var mouseOpts = computeMouseOpts.value;\n            var keyboardOpts = computeKeyboardOpts.value;\n            var actived = editStore.actived;\n            if (isActivated && !filterStore.visible) {\n                if (!(actived.row || actived.column)) {\n                    if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handlePasteCellAreaEvent) {\n                        $xetable.handlePasteCellAreaEvent(evnt);\n                    }\n                }\n                tableMethods.dispatchEvent('paste', {}, evnt);\n            }\n        };\n        var handleGlobalCopyEvent = function (evnt) {\n            var keyboardConfig = props.keyboardConfig, mouseConfig = props.mouseConfig;\n            var editStore = reactData.editStore, filterStore = reactData.filterStore;\n            var isActivated = internalData.isActivated;\n            var mouseOpts = computeMouseOpts.value;\n            var keyboardOpts = computeKeyboardOpts.value;\n            var actived = editStore.actived;\n            if (isActivated && !filterStore.visible) {\n                if (!(actived.row || actived.column)) {\n                    if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handleCopyCellAreaEvent) {\n                        $xetable.handleCopyCellAreaEvent(evnt);\n                    }\n                }\n                tableMethods.dispatchEvent('copy', {}, evnt);\n            }\n        };\n        var handleGlobalCutEvent = function (evnt) {\n            var keyboardConfig = props.keyboardConfig, mouseConfig = props.mouseConfig;\n            var editStore = reactData.editStore, filterStore = reactData.filterStore;\n            var isActivated = internalData.isActivated;\n            var mouseOpts = computeMouseOpts.value;\n            var keyboardOpts = computeKeyboardOpts.value;\n            var actived = editStore.actived;\n            if (isActivated && !filterStore.visible) {\n                if (!(actived.row || actived.column)) {\n                    if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handleCutCellAreaEvent) {\n                        $xetable.handleCutCellAreaEvent(evnt);\n                    }\n                }\n                tableMethods.dispatchEvent('cut', {}, evnt);\n            }\n        };\n        var handleGlobalResizeEvent = function () {\n            if ($xetable.closeMenu) {\n                $xetable.closeMenu();\n            }\n            tableMethods.updateCellAreas();\n            tableMethods.recalculate(true);\n        };\n        var handleTargetEnterEvent = function (isClear) {\n            var $tooltip = refTooltip.value;\n            clearTimeout(internalData.tooltipTimeout);\n            if (isClear) {\n                tableMethods.closeTooltip();\n            }\n            else {\n                if ($tooltip) {\n                    $tooltip.setActived(true);\n                }\n            }\n        };\n        /**\n         * 处理显示 tooltip\n         * @param {Event} evnt 事件\n         * @param {ColumnInfo} column 列配置\n         * @param {Row} row 行对象\n         */\n        var handleTooltip = function (evnt, cell, overflowElem, tipElem, params) {\n            params.cell = cell;\n            var tooltipStore = reactData.tooltipStore;\n            var tooltipOpts = computeTooltipOpts.value;\n            var column = params.column, row = params.row;\n            var showAll = tooltipOpts.showAll, contentMethod = tooltipOpts.contentMethod;\n            var customContent = contentMethod ? contentMethod(params) : null;\n            var useCustom = contentMethod && !XEUtils.eqNull(customContent);\n            var content = useCustom ? customContent : XEUtils.toString(column.type === 'html' ? overflowElem.innerText : overflowElem.textContent).trim();\n            var isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;\n            if (content && (showAll || useCustom || isCellOverflow)) {\n                Object.assign(tooltipStore, {\n                    row: row,\n                    column: column,\n                    visible: true,\n                    currOpts: null\n                });\n                nextTick(function () {\n                    var $tooltip = refTooltip.value;\n                    if ($tooltip) {\n                        $tooltip.open(isCellOverflow ? overflowElem : (tipElem || overflowElem), formatText(content));\n                    }\n                });\n            }\n            return nextTick();\n        };\n        /**\n         * 内部方法\n         */\n        tablePrivateMethods = {\n            getSetupOptions: function () {\n                return GlobalConfig;\n            },\n            updateAfterDataIndex: updateAfterDataIndex,\n            callSlot: function (slotFunc, params) {\n                if (slotFunc) {\n                    if ($xegrid) {\n                        return $xegrid.callSlot(slotFunc, params);\n                    }\n                    if (XEUtils.isFunction(slotFunc)) {\n                        return getSlotVNs(slotFunc(params));\n                    }\n                }\n                return [];\n            },\n            /**\n             * 获取父容器元素\n             */\n            getParentElem: function () {\n                var el = refElem.value;\n                if ($xegrid) {\n                    var gridEl = $xegrid.getRefMaps().refElem.value;\n                    return gridEl ? gridEl.parentNode : null;\n                }\n                return el ? el.parentNode : null;\n            },\n            /**\n             * 获取父容器的高度\n             */\n            getParentHeight: function () {\n                var height = props.height;\n                var el = refElem.value;\n                if (el) {\n                    var parentElem = el.parentNode;\n                    var parentPaddingSize = height === 'auto' ? getPaddingTopBottomSize(parentElem) : 0;\n                    return Math.floor($xegrid ? $xegrid.getParentHeight() : XEUtils.toNumber(getComputedStyle(parentElem).height) - parentPaddingSize);\n                }\n                return 0;\n            },\n            /**\n             * 获取需要排除的高度\n             * 但渲染表格高度时，需要排除工具栏或分页等相关组件的高度\n             * 如果存在表尾合计滚动条，则需要排除滚动条高度\n             */\n            getExcludeHeight: function () {\n                return $xegrid ? $xegrid.getExcludeHeight() : 0;\n            },\n            /**\n             * 定义行数据中的列属性，如果不存在则定义\n             * @param {Row} records 行数据\n             */\n            defineField: function (records) {\n                var treeConfig = props.treeConfig;\n                var expandOpts = computeExpandOpts.value;\n                var treeOpts = computeTreeOpts.value;\n                var radioOpts = computeRadioOpts.value;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var rowkey = getRowkey($xetable);\n                if (!XEUtils.isArray(records)) {\n                    records = [records];\n                }\n                return records.map(function (record) {\n                    internalData.tableFullColumn.forEach(function (column) {\n                        var field = column.field, editRender = column.editRender;\n                        if (field && !XEUtils.has(record, field) && !record[field]) {\n                            var cellValue = null;\n                            if (editRender) {\n                                var defaultValue = editRender.defaultValue;\n                                if (XEUtils.isFunction(defaultValue)) {\n                                    cellValue = defaultValue({ column: column });\n                                }\n                                else if (!XEUtils.isUndefined(defaultValue)) {\n                                    cellValue = defaultValue;\n                                }\n                            }\n                            XEUtils.set(record, field, cellValue);\n                        }\n                    });\n                    var otherFields = [radioOpts.labelField, checkboxOpts.checkField, checkboxOpts.labelField, expandOpts.labelField];\n                    otherFields.forEach(function (key) {\n                        if (key && eqEmptyValue(XEUtils.get(record, key))) {\n                            XEUtils.set(record, key, null);\n                        }\n                    });\n                    if (treeConfig && treeOpts.lazy && XEUtils.isUndefined(record[childrenField])) {\n                        record[childrenField] = null;\n                    }\n                    // 必须有行数据的唯一主键，可以自行设置；也可以默认生成一个随机数\n                    if (eqEmptyValue(XEUtils.get(record, rowkey))) {\n                        XEUtils.set(record, rowkey, getRowUniqueId());\n                    }\n                    return record;\n                });\n            },\n            handleTableData: function (force) {\n                var scrollYLoad = reactData.scrollYLoad;\n                var scrollYStore = internalData.scrollYStore, fullDataRowIdData = internalData.fullDataRowIdData;\n                var fullList = internalData.afterFullData;\n                // 是否进行数据处理\n                if (force) {\n                    // 更新数据，处理筛选和排序\n                    updateAfterFullData();\n                    // 如果为虚拟树，将树结构拍平\n                    fullList = handleVirtualTreeToList();\n                }\n                var tableData = scrollYLoad ? fullList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullList.slice(0);\n                tableData.forEach(function (row, $index) {\n                    var rowid = getRowid($xetable, row);\n                    var rest = fullDataRowIdData[rowid];\n                    if (rest) {\n                        rest.$index = $index;\n                    }\n                });\n                reactData.tableData = tableData;\n                return nextTick();\n            },\n            /**\n             * 更新数据行的 Map\n             * 牺牲数据组装的耗时，用来换取使用过程中的流畅\n             */\n            cacheRowMap: function (isSource) {\n                var treeConfig = props.treeConfig;\n                var treeOpts = computeTreeOpts.value;\n                var fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData, tableFullData = internalData.tableFullData, tableFullTreeData = internalData.tableFullTreeData;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var hasChildField = treeOpts.hasChild || treeOpts.hasChildField;\n                var rowkey = getRowkey($xetable);\n                var isLazy = treeConfig && treeOpts.lazy;\n                var handleRow = function (row, index, items, path, parent, nodes) {\n                    var rowid = getRowid($xetable, row);\n                    var seq = treeConfig && path ? toTreePathSeq(path) : index + 1;\n                    var level = nodes ? nodes.length - 1 : 0;\n                    if (eqEmptyValue(rowid)) {\n                        rowid = getRowUniqueId();\n                        XEUtils.set(row, rowkey, rowid);\n                    }\n                    if (isLazy && row[hasChildField] && XEUtils.isUndefined(row[childrenField])) {\n                        row[childrenField] = null;\n                    }\n                    var rest = { row: row, rowid: rowid, seq: seq, index: treeConfig && parent ? -1 : index, _index: -1, $index: -1, items: items, parent: parent, level: level };\n                    if (isSource) {\n                        fullDataRowIdData[rowid] = rest;\n                    }\n                    fullAllDataRowIdData[rowid] = rest;\n                };\n                if (isSource) {\n                    fullDataRowIdData = internalData.fullDataRowIdData = {};\n                }\n                fullAllDataRowIdData = internalData.fullAllDataRowIdData = {};\n                if (treeConfig) {\n                    XEUtils.eachTree(tableFullTreeData, handleRow, { children: childrenField });\n                }\n                else {\n                    tableFullData.forEach(handleRow);\n                }\n            },\n            cacheSourceMap: function (fullData) {\n                var treeConfig = props.treeConfig;\n                var treeOpts = computeTreeOpts.value;\n                var sourceDataRowIdData = internalData.sourceDataRowIdData;\n                var sourceData = XEUtils.clone(fullData, true);\n                var rowkey = getRowkey($xetable);\n                sourceDataRowIdData = internalData.sourceDataRowIdData = {};\n                var handleSourceRow = function (row) {\n                    var rowid = getRowid($xetable, row);\n                    if (eqEmptyValue(rowid)) {\n                        rowid = getRowUniqueId();\n                        XEUtils.set(row, rowkey, rowid);\n                    }\n                    sourceDataRowIdData[rowid] = row;\n                };\n                // 源数据缓存\n                if (treeConfig) {\n                    var childrenField = treeOpts.children || treeOpts.childrenField;\n                    XEUtils.eachTree(sourceData, handleSourceRow, { children: treeOpts.transform ? treeOpts.mapChildrenField : childrenField });\n                }\n                else {\n                    sourceData.forEach(handleSourceRow);\n                }\n                internalData.tableSourceData = sourceData;\n            },\n            /**\n             * 指定列宽的列进行拆分\n             */\n            analyColumnWidth: function () {\n                var tableFullColumn = internalData.tableFullColumn;\n                var columnOpts = computeColumnOpts.value;\n                var defaultWidth = columnOpts.width, defaultMinWidth = columnOpts.minWidth;\n                var resizeList = [];\n                var pxList = [];\n                var pxMinList = [];\n                var scaleList = [];\n                var scaleMinList = [];\n                var autoList = [];\n                tableFullColumn.forEach(function (column) {\n                    if (defaultWidth && !column.width) {\n                        column.width = defaultWidth;\n                    }\n                    if (defaultMinWidth && !column.minWidth) {\n                        column.minWidth = defaultMinWidth;\n                    }\n                    if (column.visible) {\n                        if (column.resizeWidth) {\n                            resizeList.push(column);\n                        }\n                        else if (isPx(column.width)) {\n                            pxList.push(column);\n                        }\n                        else if (isScale(column.width)) {\n                            scaleList.push(column);\n                        }\n                        else if (isPx(column.minWidth)) {\n                            pxMinList.push(column);\n                        }\n                        else if (isScale(column.minWidth)) {\n                            scaleMinList.push(column);\n                        }\n                        else {\n                            autoList.push(column);\n                        }\n                    }\n                });\n                Object.assign(reactData.columnStore, { resizeList: resizeList, pxList: pxList, pxMinList: pxMinList, scaleList: scaleList, scaleMinList: scaleMinList, autoList: autoList });\n            },\n            saveCustomResizable: function (isReset) {\n                var id = props.id, customConfig = props.customConfig;\n                var customOpts = computeCustomOpts.value;\n                var collectColumn = internalData.collectColumn;\n                var storage = customOpts.storage;\n                var isResizable = storage === true || (storage && storage.resizable);\n                if (customConfig && isResizable) {\n                    var columnWidthStorageMap = getCustomStorageMap(resizableStorageKey);\n                    var columnWidthStorage_1;\n                    if (!id) {\n                        errLog('vxe.error.reqProp', ['id']);\n                        return;\n                    }\n                    if (!isReset) {\n                        columnWidthStorage_1 = XEUtils.isPlainObject(columnWidthStorageMap[id]) ? columnWidthStorageMap[id] : {};\n                        XEUtils.eachTree(collectColumn, function (column) {\n                            if (column.resizeWidth) {\n                                var colKey = column.getKey();\n                                if (colKey) {\n                                    columnWidthStorage_1[colKey] = column.renderWidth;\n                                }\n                            }\n                        });\n                    }\n                    columnWidthStorageMap[id] = XEUtils.isEmpty(columnWidthStorage_1) ? undefined : columnWidthStorage_1;\n                    localStorage.setItem(resizableStorageKey, XEUtils.toJSONString(columnWidthStorageMap));\n                }\n            },\n            saveCustomFixed: function () {\n                var id = props.id, customConfig = props.customConfig;\n                var collectColumn = internalData.collectColumn;\n                var customOpts = computeCustomOpts.value;\n                var storage = customOpts.storage;\n                var isCustomFixed = storage === true || (storage && storage.fixed);\n                if (customConfig && isCustomFixed) {\n                    var columnFixedStorageMap = getCustomStorageMap(fixedStorageKey);\n                    var colFixeds_1 = [];\n                    if (!id) {\n                        errLog('vxe.error.reqProp', ['id']);\n                        return;\n                    }\n                    XEUtils.eachTree(collectColumn, function (column) {\n                        if (column.fixed && column.fixed !== column.defaultFixed) {\n                            var colKey = column.getKey();\n                            if (colKey) {\n                                colFixeds_1.push(\"\".concat(colKey, \"|\").concat(column.fixed));\n                            }\n                        }\n                    });\n                    columnFixedStorageMap[id] = colFixeds_1.join(',') || undefined;\n                    localStorage.setItem(fixedStorageKey, XEUtils.toJSONString(columnFixedStorageMap));\n                }\n            },\n            saveCustomVisible: function () {\n                var id = props.id, customConfig = props.customConfig;\n                var collectColumn = internalData.collectColumn;\n                var customOpts = computeCustomOpts.value;\n                var checkMethod = customOpts.checkMethod, storage = customOpts.storage;\n                var isCustomVisible = storage === true || (storage && storage.visible);\n                if (customConfig && isCustomVisible) {\n                    var columnVisibleStorageMap = getCustomStorageMap(visibleStorageKey);\n                    var colHides_1 = [];\n                    var colShows_1 = [];\n                    if (!id) {\n                        errLog('vxe.error.reqProp', ['id']);\n                        return;\n                    }\n                    XEUtils.eachTree(collectColumn, function (column) {\n                        if (!checkMethod || checkMethod({ column: column })) {\n                            if (!column.visible && column.defaultVisible) {\n                                var colKey = column.getKey();\n                                if (colKey) {\n                                    colHides_1.push(colKey);\n                                }\n                            }\n                            else if (column.visible && !column.defaultVisible) {\n                                var colKey = column.getKey();\n                                if (colKey) {\n                                    colShows_1.push(colKey);\n                                }\n                            }\n                        }\n                    });\n                    columnVisibleStorageMap[id] = [colHides_1.join(',')].concat(colShows_1.length ? [colShows_1.join(',')] : []).join('|') || undefined;\n                    localStorage.setItem(visibleStorageKey, XEUtils.toJSONString(columnVisibleStorageMap));\n                }\n            },\n            handleCustom: function () {\n                tablePrivateMethods.saveCustomVisible();\n                tablePrivateMethods.analyColumnWidth();\n                return tableMethods.refreshColumn();\n            },\n            handleUpdateDataQueue: function () {\n                reactData.upDataFlag++;\n            },\n            handleRefreshColumnQueue: function () {\n                reactData.reColumnFlag++;\n            },\n            preventEvent: function (evnt, type, args, next, end) {\n                var evntList = VXETable.interceptor.get(type);\n                var rest;\n                if (!evntList.some(function (func) { return func(Object.assign({ $grid: $xegrid, $table: $xetable, $event: evnt }, args)) === false; })) {\n                    if (next) {\n                        rest = next();\n                    }\n                }\n                if (end) {\n                    end();\n                }\n                return rest;\n            },\n            checkSelectionStatus: function () {\n                var treeConfig = props.treeConfig;\n                var selectCheckboxMaps = reactData.selectCheckboxMaps, treeIndeterminateMaps = reactData.treeIndeterminateMaps;\n                var afterFullData = internalData.afterFullData;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var checkField = checkboxOpts.checkField, checkStrictly = checkboxOpts.checkStrictly, checkMethod = checkboxOpts.checkMethod;\n                var indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;\n                if (!checkStrictly) {\n                    var disableRows_1 = [];\n                    var checkRows_1 = [];\n                    var isAllResolve = false;\n                    var isAllSelected = false;\n                    var isIndeterminate = false;\n                    if (checkField) {\n                        isAllResolve = afterFullData.every(checkMethod\n                            ? function (row) {\n                                if (!checkMethod({ row: row })) {\n                                    disableRows_1.push(row);\n                                    return true;\n                                }\n                                if (XEUtils.get(row, checkField)) {\n                                    checkRows_1.push(row);\n                                    return true;\n                                }\n                                return false;\n                            }\n                            : function (row) { return XEUtils.get(row, checkField); });\n                        isAllSelected = isAllResolve && afterFullData.length !== disableRows_1.length;\n                        if (treeConfig) {\n                            if (indeterminateField) {\n                                isIndeterminate = !isAllSelected && afterFullData.some(function (row) { return XEUtils.get(row, checkField) || XEUtils.get(row, indeterminateField) || !!treeIndeterminateMaps[getRowid($xetable, row)]; });\n                            }\n                            else {\n                                isIndeterminate = !isAllSelected && afterFullData.some(function (row) { return XEUtils.get(row, checkField) || !!treeIndeterminateMaps[getRowid($xetable, row)]; });\n                            }\n                        }\n                        else {\n                            if (indeterminateField) {\n                                isIndeterminate = !isAllSelected && afterFullData.some(function (row) { return XEUtils.get(row, checkField) || XEUtils.get(row, indeterminateField); });\n                            }\n                            else {\n                                isIndeterminate = !isAllSelected && afterFullData.some(function (row) { return XEUtils.get(row, checkField); });\n                            }\n                        }\n                    }\n                    else {\n                        isAllResolve = afterFullData.every(checkMethod\n                            ? function (row) {\n                                if (!checkMethod({ row: row })) {\n                                    disableRows_1.push(row);\n                                    return true;\n                                }\n                                if (selectCheckboxMaps[getRowid($xetable, row)]) {\n                                    checkRows_1.push(row);\n                                    return true;\n                                }\n                                return false;\n                            }\n                            : function (row) { return selectCheckboxMaps[getRowid($xetable, row)]; });\n                        isAllSelected = isAllResolve && afterFullData.length !== disableRows_1.length;\n                        if (treeConfig) {\n                            isIndeterminate = !isAllSelected && afterFullData.some(function (row) {\n                                var itemRid = getRowid($xetable, row);\n                                return treeIndeterminateMaps[itemRid] || selectCheckboxMaps[itemRid];\n                            });\n                        }\n                        else {\n                            isIndeterminate = !isAllSelected && afterFullData.some(function (row) { return selectCheckboxMaps[getRowid($xetable, row)]; });\n                        }\n                    }\n                    reactData.isAllSelected = isAllSelected;\n                    reactData.isIndeterminate = isIndeterminate;\n                }\n            },\n            /**\n             * 多选，行选中事件\n             * value 选中true 不选false 半选-1\n             */\n            handleSelectRow: function (_a, value, isForce) {\n                var row = _a.row;\n                var treeConfig = props.treeConfig;\n                var selectCheckboxMaps = reactData.selectCheckboxMaps, treeIndeterminateMaps = reactData.treeIndeterminateMaps;\n                var selectRowMaps = __assign({}, selectCheckboxMaps);\n                var afterFullData = internalData.afterFullData;\n                var treeOpts = computeTreeOpts.value;\n                var childrenField = treeOpts.children || treeOpts.childrenField;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var checkField = checkboxOpts.checkField, checkStrictly = checkboxOpts.checkStrictly, checkMethod = checkboxOpts.checkMethod;\n                var indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;\n                var rowid = getRowid($xetable, row);\n                if (checkField) {\n                    if (treeConfig && !checkStrictly) {\n                        if (value === -1) {\n                            if (!treeIndeterminateMaps[rowid]) {\n                                if (indeterminateField) {\n                                    XEUtils.set(row, indeterminateField, true);\n                                }\n                                treeIndeterminateMaps[rowid] = row;\n                            }\n                            XEUtils.set(row, checkField, false);\n                        }\n                        else {\n                            // 更新子节点状态\n                            XEUtils.eachTree([row], function (item) {\n                                if ($xetable.eqRow(item, row) || (isForce || (!checkMethod || checkMethod({ row: item })))) {\n                                    XEUtils.set(item, checkField, value);\n                                    if (indeterminateField) {\n                                        XEUtils.set(row, indeterminateField, false);\n                                    }\n                                    delete treeIndeterminateMaps[getRowid($xetable, item)];\n                                    handleCheckboxReserveRow(row, value);\n                                }\n                            }, { children: childrenField });\n                        }\n                        // 如果存在父节点，更新父节点状态\n                        var matchObj = XEUtils.findTree(afterFullData, function (item) { return $xetable.eqRow(item, row); }, { children: childrenField });\n                        if (matchObj && matchObj.parent) {\n                            var parentStatus = void 0;\n                            var vItems_1 = [];\n                            var vItemMaps_1 = {};\n                            if (!isForce && checkMethod) {\n                                matchObj.items.forEach(function (item) {\n                                    if (checkMethod({ row: item })) {\n                                        var itemRid = getRowid($xetable, item);\n                                        vItemMaps_1[itemRid] = item;\n                                        vItems_1.push(item);\n                                    }\n                                });\n                            }\n                            else {\n                                matchObj.items.forEach(function (item) {\n                                    var itemRid = getRowid($xetable, item);\n                                    vItemMaps_1[itemRid] = item;\n                                    vItems_1.push(item);\n                                });\n                            }\n                            var indeterminatesItem = XEUtils.find(matchObj.items, function (item) { return !!treeIndeterminateMaps[getRowid($xetable, item)]; });\n                            if (indeterminatesItem) {\n                                parentStatus = -1;\n                            }\n                            else {\n                                var selectItems_1 = [];\n                                matchObj.items.forEach(function (item) {\n                                    if (XEUtils.get(item, checkField)) {\n                                        selectItems_1.push(item);\n                                    }\n                                });\n                                parentStatus = selectItems_1.filter(function (item) { return vItemMaps_1[getRowid($xetable, item)]; }).length === vItems_1.length ? true : (selectItems_1.length || value === -1 ? -1 : false);\n                            }\n                            reactData.selectCheckboxMaps = selectRowMaps;\n                            return tablePrivateMethods.handleSelectRow({ row: matchObj.parent }, parentStatus, isForce);\n                        }\n                    }\n                    else {\n                        if (isForce || (!checkMethod || checkMethod({ row: row }))) {\n                            XEUtils.set(row, checkField, value);\n                            handleCheckboxReserveRow(row, value);\n                        }\n                    }\n                }\n                else {\n                    if (treeConfig && !checkStrictly) {\n                        if (value === -1) {\n                            if (!treeIndeterminateMaps[rowid]) {\n                                if (indeterminateField) {\n                                    XEUtils.set(row, indeterminateField, true);\n                                }\n                                treeIndeterminateMaps[rowid] = row;\n                            }\n                            if (selectRowMaps[rowid]) {\n                                delete selectRowMaps[rowid];\n                            }\n                        }\n                        else {\n                            // 更新子节点状态\n                            XEUtils.eachTree([row], function (item) {\n                                var itemRid = getRowid($xetable, item);\n                                if ($xetable.eqRow(item, row) || (isForce || (!checkMethod || checkMethod({ row: item })))) {\n                                    if (value) {\n                                        selectRowMaps[itemRid] = item;\n                                    }\n                                    else {\n                                        if (selectRowMaps[itemRid]) {\n                                            delete selectRowMaps[itemRid];\n                                        }\n                                    }\n                                    if (indeterminateField) {\n                                        XEUtils.set(row, indeterminateField, false);\n                                    }\n                                    delete treeIndeterminateMaps[getRowid($xetable, item)];\n                                    handleCheckboxReserveRow(row, value);\n                                }\n                            }, { children: childrenField });\n                        }\n                        // 如果存在父节点，更新父节点状态\n                        var matchObj = XEUtils.findTree(afterFullData, function (item) { return $xetable.eqRow(item, row); }, { children: childrenField });\n                        if (matchObj && matchObj.parent) {\n                            var parentStatus = void 0;\n                            var vItems_2 = [];\n                            var vItemMaps_2 = {};\n                            if (!isForce && checkMethod) {\n                                matchObj.items.forEach(function (item) {\n                                    if (checkMethod({ row: item })) {\n                                        var itemRid = getRowid($xetable, item);\n                                        vItemMaps_2[itemRid] = item;\n                                        vItems_2.push(item);\n                                    }\n                                });\n                            }\n                            else {\n                                matchObj.items.forEach(function (item) {\n                                    var itemRid = getRowid($xetable, item);\n                                    vItemMaps_2[itemRid] = item;\n                                    vItems_2.push(item);\n                                });\n                            }\n                            var indeterminatesItem = XEUtils.find(matchObj.items, function (item) { return !!treeIndeterminateMaps[getRowid($xetable, item)]; });\n                            if (indeterminatesItem) {\n                                parentStatus = -1;\n                            }\n                            else {\n                                var selectItems_2 = [];\n                                matchObj.items.forEach(function (item) {\n                                    var itemRid = getRowid($xetable, item);\n                                    if (selectRowMaps[itemRid]) {\n                                        selectItems_2.push(item);\n                                    }\n                                });\n                                parentStatus = selectItems_2.filter(function (item) { return vItemMaps_2[getRowid($xetable, item)]; }).length === vItems_2.length ? true : (selectItems_2.length || value === -1 ? -1 : false);\n                            }\n                            reactData.selectCheckboxMaps = selectRowMaps;\n                            return tablePrivateMethods.handleSelectRow({ row: matchObj.parent }, parentStatus, isForce);\n                        }\n                    }\n                    else {\n                        if (isForce || (!checkMethod || checkMethod({ row: row }))) {\n                            if (value) {\n                                if (!selectRowMaps[rowid]) {\n                                    selectRowMaps[rowid] = row;\n                                }\n                            }\n                            else {\n                                if (selectRowMaps[rowid]) {\n                                    delete selectRowMaps[rowid];\n                                }\n                            }\n                            handleCheckboxReserveRow(row, value);\n                        }\n                    }\n                }\n                reactData.selectCheckboxMaps = selectRowMaps;\n                tablePrivateMethods.checkSelectionStatus();\n            },\n            triggerHeaderTitleEvent: function (evnt, iconParams, params) {\n                var tipContent = iconParams.content || iconParams.message;\n                if (tipContent) {\n                    var tooltipStore = reactData.tooltipStore;\n                    var content_1 = getFuncText(tipContent);\n                    handleTargetEnterEvent(true);\n                    tooltipStore.visible = true;\n                    tooltipStore.currOpts = __assign(__assign({}, params), { content: null });\n                    nextTick(function () {\n                        var $tooltip = refTooltip.value;\n                        if ($tooltip) {\n                            $tooltip.open(evnt.currentTarget, content_1);\n                        }\n                    });\n                }\n            },\n            /**\n             * 触发表头 tooltip 事件\n             */\n            triggerHeaderTooltipEvent: function (evnt, params) {\n                var tooltipStore = reactData.tooltipStore;\n                var column = params.column;\n                var titleElem = evnt.currentTarget;\n                handleTargetEnterEvent(true);\n                if (tooltipStore.column !== column || !tooltipStore.visible) {\n                    handleTooltip(evnt, titleElem, titleElem, null, params);\n                }\n            },\n            /**\n             * 触发单元格 tooltip 事件\n             */\n            triggerBodyTooltipEvent: function (evnt, params) {\n                var editConfig = props.editConfig;\n                var editStore = reactData.editStore;\n                var tooltipStore = reactData.tooltipStore;\n                var editOpts = computeEditOpts.value;\n                var actived = editStore.actived;\n                var row = params.row, column = params.column;\n                var cell = evnt.currentTarget;\n                handleTargetEnterEvent(tooltipStore.column !== column || tooltipStore.row !== row);\n                // 单元格处于编辑状态时不触发提示框\n                if (column.editRender && isEnableConf(editConfig)) {\n                    // 如果是行编辑模式\n                    if (editOpts.mode === 'row' && actived.row === row) {\n                        return;\n                    }\n                    // 如果是单元格编辑模式\n                    if (actived.row === row && actived.column === column) {\n                        return;\n                    }\n                }\n                if (tooltipStore.column !== column || tooltipStore.row !== row || !tooltipStore.visible) {\n                    var overflowElem = void 0;\n                    var tipElem = void 0;\n                    if (column.treeNode) {\n                        overflowElem = cell.querySelector('.vxe-tree-cell');\n                        if (column.type === 'html') {\n                            tipElem = cell.querySelector('.vxe-cell--html');\n                        }\n                    }\n                    else {\n                        tipElem = cell.querySelector(column.type === 'html' ? '.vxe-cell--html' : '.vxe-cell--label');\n                    }\n                    handleTooltip(evnt, cell, (overflowElem || cell.children[0]), tipElem, params);\n                }\n            },\n            /**\n             * 触发表尾 tooltip 事件\n             */\n            triggerFooterTooltipEvent: function (evnt, params) {\n                var column = params.column;\n                var tooltipStore = reactData.tooltipStore;\n                var cell = evnt.currentTarget;\n                handleTargetEnterEvent(tooltipStore.column !== column || !!tooltipStore.row);\n                if (tooltipStore.column !== column || !tooltipStore.visible) {\n                    handleTooltip(evnt, cell, cell.querySelector('.vxe-cell--item') || cell.children[0], null, params);\n                }\n            },\n            handleTargetLeaveEvent: function () {\n                var tooltipOpts = computeTooltipOpts.value;\n                var $tooltip = refTooltip.value;\n                if ($tooltip) {\n                    $tooltip.setActived(false);\n                }\n                if (tooltipOpts.enterable) {\n                    internalData.tooltipTimeout = setTimeout(function () {\n                        $tooltip = refTooltip.value;\n                        if ($tooltip && !$tooltip.isActived()) {\n                            tableMethods.closeTooltip();\n                        }\n                    }, tooltipOpts.leaveDelay);\n                }\n                else {\n                    tableMethods.closeTooltip();\n                }\n            },\n            triggerHeaderCellClickEvent: function (evnt, params) {\n                var _lastResizeTime = internalData._lastResizeTime;\n                var sortOpts = computeSortOpts.value;\n                var columnOpts = computeColumnOpts.value;\n                var column = params.column;\n                var cell = evnt.currentTarget;\n                var triggerResizable = _lastResizeTime && _lastResizeTime > Date.now() - 300;\n                var triggerSort = getEventTargetNode(evnt, cell, 'vxe-cell--sort').flag;\n                var triggerFilter = getEventTargetNode(evnt, cell, 'vxe-cell--filter').flag;\n                if (sortOpts.trigger === 'cell' && !(triggerResizable || triggerSort || triggerFilter)) {\n                    tablePrivateMethods.triggerSortEvent(evnt, column, getNextSortOrder(column));\n                }\n                tableMethods.dispatchEvent('header-cell-click', Object.assign({ triggerResizable: triggerResizable, triggerSort: triggerSort, triggerFilter: triggerFilter, cell: cell }, params), evnt);\n                if (columnOpts.isCurrent || props.highlightCurrentColumn) {\n                    tableMethods.setCurrentColumn(column);\n                }\n            },\n            triggerHeaderCellDblclickEvent: function (evnt, params) {\n                tableMethods.dispatchEvent('header-cell-dblclick', Object.assign({ cell: evnt.currentTarget }, params), evnt);\n            },\n            /**\n             * 列点击事件\n             * 如果是单击模式，则激活为编辑状态\n             * 如果是双击模式，则单击后选中状态\n             */\n            triggerCellClickEvent: function (evnt, params) {\n                var highlightCurrentRow = props.highlightCurrentRow, editConfig = props.editConfig;\n                var editStore = reactData.editStore;\n                var expandOpts = computeExpandOpts.value;\n                var editOpts = computeEditOpts.value;\n                var treeOpts = computeTreeOpts.value;\n                var radioOpts = computeRadioOpts.value;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var rowOpts = computeRowOpts.value;\n                var actived = editStore.actived;\n                var row = params.row, column = params.column;\n                var type = column.type, treeNode = column.treeNode;\n                var isRadioType = type === 'radio';\n                var isCheckboxType = type === 'checkbox';\n                var isExpandType = type === 'expand';\n                var cell = evnt.currentTarget;\n                var triggerRadio = isRadioType && getEventTargetNode(evnt, cell, 'vxe-cell--radio').flag;\n                var triggerCheckbox = isCheckboxType && getEventTargetNode(evnt, cell, 'vxe-cell--checkbox').flag;\n                var triggerTreeNode = treeNode && getEventTargetNode(evnt, cell, 'vxe-tree--btn-wrapper').flag;\n                var triggerExpandNode = isExpandType && getEventTargetNode(evnt, cell, 'vxe-table--expanded').flag;\n                params = Object.assign({ cell: cell, triggerRadio: triggerRadio, triggerCheckbox: triggerCheckbox, triggerTreeNode: triggerTreeNode, triggerExpandNode: triggerExpandNode }, params);\n                if (!triggerCheckbox && !triggerRadio) {\n                    // 如果是展开行\n                    if (!triggerExpandNode && (expandOpts.trigger === 'row' || (isExpandType && expandOpts.trigger === 'cell'))) {\n                        tablePrivateMethods.triggerRowExpandEvent(evnt, params);\n                    }\n                    // 如果是树形表格\n                    if ((treeOpts.trigger === 'row' || (treeNode && treeOpts.trigger === 'cell'))) {\n                        tablePrivateMethods.triggerTreeExpandEvent(evnt, params);\n                    }\n                }\n                // 如果点击了树节点\n                if (!triggerTreeNode) {\n                    if (!triggerExpandNode) {\n                        // 如果是高亮行\n                        if (rowOpts.isCurrent || highlightCurrentRow) {\n                            if (!triggerCheckbox && !triggerRadio) {\n                                tablePrivateMethods.triggerCurrentRowEvent(evnt, params);\n                            }\n                        }\n                        // 如果是单选框\n                        if (!triggerRadio && (radioOpts.trigger === 'row' || (isRadioType && radioOpts.trigger === 'cell'))) {\n                            tablePrivateMethods.triggerRadioRowEvent(evnt, params);\n                        }\n                        // 如果是复选框\n                        if (!triggerCheckbox && (checkboxOpts.trigger === 'row' || (isCheckboxType && checkboxOpts.trigger === 'cell'))) {\n                            tablePrivateMethods.handleToggleCheckRowEvent(evnt, params);\n                        }\n                    }\n                    // 如果设置了单元格选中功能，则不会使用点击事件去处理（只能支持双击模式）\n                    if (isEnableConf(editConfig)) {\n                        if (editOpts.trigger === 'manual') {\n                            if (actived.args && actived.row === row && column !== actived.column) {\n                                handleChangeCell(evnt, params);\n                            }\n                        }\n                        else if (!actived.args || row !== actived.row || column !== actived.column) {\n                            if (editOpts.trigger === 'click') {\n                                handleChangeCell(evnt, params);\n                            }\n                            else if (editOpts.trigger === 'dblclick') {\n                                if (editOpts.mode === 'row' && actived.row === row) {\n                                    handleChangeCell(evnt, params);\n                                }\n                            }\n                        }\n                    }\n                }\n                tableMethods.dispatchEvent('cell-click', params, evnt);\n            },\n            /**\n             * 列双击点击事件\n             * 如果是双击模式，则激活为编辑状态\n             */\n            triggerCellDblclickEvent: function (evnt, params) {\n                var editConfig = props.editConfig;\n                var editStore = reactData.editStore;\n                var editOpts = computeEditOpts.value;\n                var actived = editStore.actived;\n                var cell = evnt.currentTarget;\n                params = Object.assign({ cell: cell }, params);\n                if (isEnableConf(editConfig) && editOpts.trigger === 'dblclick') {\n                    if (!actived.args || evnt.currentTarget !== actived.args.cell) {\n                        if (editOpts.mode === 'row') {\n                            checkValidate('blur')\n                                .catch(function (e) { return e; })\n                                .then(function () {\n                                $xetable.handleActived(params, evnt)\n                                    .then(function () { return checkValidate('change'); })\n                                    .catch(function (e) { return e; });\n                            });\n                        }\n                        else if (editOpts.mode === 'cell') {\n                            $xetable.handleActived(params, evnt)\n                                .then(function () { return checkValidate('change'); })\n                                .catch(function (e) { return e; });\n                        }\n                    }\n                }\n                tableMethods.dispatchEvent('cell-dblclick', params, evnt);\n            },\n            handleToggleCheckRowEvent: function (evnt, params) {\n                var selectCheckboxMaps = reactData.selectCheckboxMaps;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var checkField = checkboxOpts.checkField;\n                var row = params.row;\n                var value = false;\n                if (checkField) {\n                    value = !XEUtils.get(row, checkField);\n                }\n                else {\n                    value = !selectCheckboxMaps[getRowid($xetable, row)];\n                }\n                if (evnt) {\n                    tablePrivateMethods.triggerCheckRowEvent(evnt, params, value);\n                }\n                else {\n                    tablePrivateMethods.handleSelectRow(params, value);\n                }\n            },\n            triggerCheckRowEvent: function (evnt, params, value) {\n                var checkboxOpts = computeCheckboxOpts.value;\n                var row = params.row;\n                var afterFullData = internalData.afterFullData;\n                var checkMethod = checkboxOpts.checkMethod;\n                if (checkboxOpts.isShiftKey && evnt.shiftKey && !props.treeConfig) {\n                    var checkboxRecords = tableMethods.getCheckboxRecords();\n                    if (checkboxRecords.length) {\n                        var firstRow = checkboxRecords[0];\n                        var _rowIndex = tableMethods.getVTRowIndex(row);\n                        var _firstRowIndex = tableMethods.getVTRowIndex(firstRow);\n                        if (_rowIndex !== _firstRowIndex) {\n                            tableMethods.setAllCheckboxRow(false);\n                            var rangeRows = _rowIndex < _firstRowIndex ? afterFullData.slice(_rowIndex, _firstRowIndex + 1) : afterFullData.slice(_firstRowIndex, _rowIndex + 1);\n                            handleCheckedCheckboxRow(rangeRows, true, false);\n                            tableMethods.dispatchEvent('checkbox-range-select', Object.assign({ rangeRecords: rangeRows }, params), evnt);\n                            return;\n                        }\n                    }\n                }\n                if (!checkMethod || checkMethod({ row: row })) {\n                    tablePrivateMethods.handleSelectRow(params, value);\n                    tableMethods.dispatchEvent('checkbox-change', Object.assign({\n                        records: tableMethods.getCheckboxRecords(),\n                        reserves: tableMethods.getCheckboxReserveRecords(),\n                        indeterminates: tableMethods.getCheckboxIndeterminateRecords(),\n                        checked: value\n                    }, params), evnt);\n                }\n            },\n            /**\n             * 多选，选中所有事件\n             */\n            triggerCheckAllEvent: function (evnt, value) {\n                handleCheckedAllCheckboxRow(value);\n                if (evnt) {\n                    tableMethods.dispatchEvent('checkbox-all', {\n                        records: tableMethods.getCheckboxRecords(),\n                        reserves: tableMethods.getCheckboxReserveRecords(),\n                        indeterminates: tableMethods.getCheckboxIndeterminateRecords(),\n                        checked: value\n                    }, evnt);\n                }\n            },\n            /**\n             * 单选，行选中事件\n             */\n            triggerRadioRowEvent: function (evnt, params) {\n                var oldValue = reactData.selectRadioRow;\n                var row = params.row;\n                var radioOpts = computeRadioOpts.value;\n                var newValue = row;\n                var isChange = oldValue !== newValue;\n                if (isChange) {\n                    handleCheckedRadioRow(newValue);\n                }\n                else if (!radioOpts.strict) {\n                    isChange = oldValue === newValue;\n                    if (isChange) {\n                        newValue = null;\n                        tableMethods.clearRadioRow();\n                    }\n                }\n                if (isChange) {\n                    tableMethods.dispatchEvent('radio-change', __assign({ oldValue: oldValue, newValue: newValue }, params), evnt);\n                }\n            },\n            triggerCurrentRowEvent: function (evnt, params) {\n                var oldValue = reactData.currentRow;\n                var newValue = params.row;\n                var isChange = oldValue !== newValue;\n                tableMethods.setCurrentRow(newValue);\n                if (isChange) {\n                    tableMethods.dispatchEvent('current-change', __assign({ oldValue: oldValue, newValue: newValue }, params), evnt);\n                }\n            },\n            /**\n             * 展开行事件\n             */\n            triggerRowExpandEvent: function (evnt, params) {\n                var rowExpandLazyLoadedMaps = reactData.rowExpandLazyLoadedMaps, column = reactData.expandColumn;\n                var expandOpts = computeExpandOpts.value;\n                var row = params.row;\n                var lazy = expandOpts.lazy;\n                var rowid = getRowid($xetable, row);\n                if (!lazy || !rowExpandLazyLoadedMaps[rowid]) {\n                    var expanded = !tableMethods.isExpandByRow(row);\n                    var columnIndex = tableMethods.getColumnIndex(column);\n                    var $columnIndex = tableMethods.getVMColumnIndex(column);\n                    tableMethods.setRowExpand(row, expanded);\n                    tableMethods.dispatchEvent('toggle-row-expand', {\n                        expanded: expanded,\n                        column: column,\n                        columnIndex: columnIndex,\n                        $columnIndex: $columnIndex,\n                        row: row,\n                        rowIndex: tableMethods.getRowIndex(row),\n                        $rowIndex: tableMethods.getVMRowIndex(row)\n                    }, evnt);\n                }\n            },\n            /**\n             * 展开树节点事件\n             */\n            triggerTreeExpandEvent: function (evnt, params) {\n                var treeExpandLazyLoadedMaps = reactData.treeExpandLazyLoadedMaps;\n                var treeOpts = computeTreeOpts.value;\n                var row = params.row, column = params.column;\n                var lazy = treeOpts.lazy;\n                var rowid = getRowid($xetable, row);\n                if (!lazy || !treeExpandLazyLoadedMaps[rowid]) {\n                    var expanded = !tableMethods.isTreeExpandByRow(row);\n                    var columnIndex = tableMethods.getColumnIndex(column);\n                    var $columnIndex = tableMethods.getVMColumnIndex(column);\n                    tableMethods.setTreeExpand(row, expanded);\n                    tableMethods.dispatchEvent('toggle-tree-expand', { expanded: expanded, column: column, columnIndex: columnIndex, $columnIndex: $columnIndex, row: row }, evnt);\n                }\n            },\n            /**\n             * 点击排序事件\n             */\n            triggerSortEvent: function (evnt, column, order) {\n                var mouseConfig = props.mouseConfig;\n                var sortOpts = computeSortOpts.value;\n                var mouseOpts = computeMouseOpts.value;\n                var field = column.field, sortable = column.sortable;\n                if (sortable) {\n                    if (!order || column.order === order) {\n                        tableMethods.clearSort(sortOpts.multiple ? column : null);\n                    }\n                    else {\n                        tableMethods.sort({ field: field, order: order });\n                    }\n                    var params = { $table: $xetable, $event: evnt, column: column, field: field, property: field, order: column.order, sortList: tableMethods.getSortColumns(), sortTime: column.sortTime };\n                    if (mouseConfig && mouseOpts.area && $xetable.handleSortEvent) {\n                        $xetable.handleSortEvent(evnt, params);\n                    }\n                    tableMethods.dispatchEvent('sort-change', params, evnt);\n                }\n            },\n            /**\n             * 横向 X 可视渲染事件处理\n             */\n            triggerScrollXEvent: function () {\n                loadScrollXData();\n            },\n            /**\n             * 纵向 Y 可视渲染事件处理\n             */\n            triggerScrollYEvent: function (evnt) {\n                var scrollYStore = internalData.scrollYStore;\n                var adaptive = scrollYStore.adaptive, offsetSize = scrollYStore.offsetSize, visibleSize = scrollYStore.visibleSize;\n                // webkit 浏览器使用最佳的渲染方式，且最高渲染量不能大于 40 条\n                if (isWebkit && adaptive && (offsetSize * 2 + visibleSize) <= 40) {\n                    loadScrollYData(evnt);\n                }\n                else {\n                    debounceScrollY(evnt);\n                }\n            },\n            /**\n             * 对于树形结构中，可以直接滚动到指定深层节点中\n             * 对于某些特定的场景可能会用到，比如定位到某一节点\n             * @param {Row} row 行对象\n             */\n            scrollToTreeRow: function (row) {\n                var treeConfig = props.treeConfig;\n                var tableFullData = internalData.tableFullData;\n                var rests = [];\n                if (treeConfig) {\n                    var treeOpts = computeTreeOpts.value;\n                    var childrenField = treeOpts.children || treeOpts.childrenField;\n                    var matchObj = XEUtils.findTree(tableFullData, function (item) { return $xetable.eqRow(item, row); }, { children: childrenField });\n                    if (matchObj) {\n                        var nodes_1 = matchObj.nodes;\n                        nodes_1.forEach(function (row, index) {\n                            if (index < nodes_1.length - 1 && !tableMethods.isTreeExpandByRow(row)) {\n                                rests.push(tableMethods.setTreeExpand(row, true));\n                            }\n                        });\n                    }\n                }\n                return Promise.all(rests).then(function () { return rowToVisible($xetable, row); });\n            },\n            updateScrollYStatus: updateScrollYStatus,\n            // 更新横向 X 可视渲染上下剩余空间大小\n            updateScrollXSpace: function () {\n                var isGroup = reactData.isGroup, scrollXLoad = reactData.scrollXLoad, scrollbarWidth = reactData.scrollbarWidth;\n                var visibleColumn = internalData.visibleColumn, scrollXStore = internalData.scrollXStore, elemStore = internalData.elemStore, tableWidth = internalData.tableWidth;\n                var tableHeader = refTableHeader.value;\n                var tableBody = refTableBody.value;\n                var tableFooter = refTableFooter.value;\n                var tableBodyElem = tableBody ? tableBody.$el : null;\n                if (tableBodyElem) {\n                    var tableHeaderElem = tableHeader ? tableHeader.$el : null;\n                    var tableFooterElem = tableFooter ? tableFooter.$el : null;\n                    var headerElem = tableHeaderElem ? tableHeaderElem.querySelector('.vxe-table--header') : null;\n                    var bodyElem = tableBodyElem.querySelector('.vxe-table--body');\n                    var footerElem = tableFooterElem ? tableFooterElem.querySelector('.vxe-table--footer') : null;\n                    var leftSpaceWidth = visibleColumn.slice(0, scrollXStore.startIndex).reduce(function (previous, column) { return previous + column.renderWidth; }, 0);\n                    var marginLeft = '';\n                    if (scrollXLoad) {\n                        marginLeft = \"\".concat(leftSpaceWidth, \"px\");\n                    }\n                    if (headerElem) {\n                        headerElem.style.marginLeft = isGroup ? '' : marginLeft;\n                    }\n                    bodyElem.style.marginLeft = marginLeft;\n                    if (footerElem) {\n                        footerElem.style.marginLeft = marginLeft;\n                    }\n                    var containerList = ['main'];\n                    containerList.forEach(function (name) {\n                        var layoutList = ['header', 'body', 'footer'];\n                        layoutList.forEach(function (layout) {\n                            var xSpaceRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-xSpace\")];\n                            var xSpaceElem = xSpaceRef ? xSpaceRef.value : null;\n                            if (xSpaceElem) {\n                                xSpaceElem.style.width = scrollXLoad ? \"\".concat(tableWidth + (layout === 'header' ? scrollbarWidth : 0), \"px\") : '';\n                            }\n                        });\n                    });\n                    nextTick(updateStyle);\n                }\n            },\n            // 更新纵向 Y 可视渲染上下剩余空间大小\n            updateScrollYSpace: function () {\n                var scrollYLoad = reactData.scrollYLoad;\n                var scrollYStore = internalData.scrollYStore, elemStore = internalData.elemStore, afterFullData = internalData.afterFullData;\n                var startIndex = scrollYStore.startIndex, rowHeight = scrollYStore.rowHeight;\n                var bodyHeight = afterFullData.length * rowHeight;\n                var topSpaceHeight = Math.max(0, startIndex * rowHeight);\n                var containerList = ['main', 'left', 'right'];\n                var marginTop = '';\n                var ySpaceHeight = '';\n                if (scrollYLoad) {\n                    marginTop = \"\".concat(topSpaceHeight, \"px\");\n                    ySpaceHeight = \"\".concat(bodyHeight, \"px\");\n                }\n                containerList.forEach(function (name) {\n                    var layoutList = ['header', 'body', 'footer'];\n                    var tableRef = elemStore[\"\".concat(name, \"-body-table\")];\n                    var tableElem = tableRef ? tableRef.value : null;\n                    if (tableElem) {\n                        tableElem.style.marginTop = marginTop;\n                    }\n                    layoutList.forEach(function (layout) {\n                        var ySpaceRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-ySpace\")];\n                        var ySpaceElem = ySpaceRef ? ySpaceRef.value : null;\n                        if (ySpaceElem) {\n                            ySpaceElem.style.height = ySpaceHeight;\n                        }\n                    });\n                });\n                nextTick(updateStyle);\n            },\n            updateScrollXData: function () {\n                // reactData.tableColumn = []\n                nextTick(function () {\n                    handleTableColumn();\n                    tablePrivateMethods.updateScrollXSpace();\n                });\n            },\n            updateScrollYData: function () {\n                // reactData.tableData = []\n                nextTick(function () {\n                    tablePrivateMethods.handleTableData();\n                    tablePrivateMethods.updateScrollYSpace();\n                });\n            },\n            /**\n             * 处理固定列的显示状态\n             */\n            checkScrolling: function () {\n                var leftContainerElem = refLeftContainer.value;\n                var rightContainerElem = refRightContainer.value;\n                var tableBody = refTableBody.value;\n                var bodyElem = tableBody ? tableBody.$el : null;\n                if (bodyElem) {\n                    if (leftContainerElem) {\n                        if (bodyElem.scrollLeft > 0) {\n                            addClass(leftContainerElem, 'scrolling--middle');\n                        }\n                        else {\n                            removeClass(leftContainerElem, 'scrolling--middle');\n                        }\n                    }\n                    if (rightContainerElem) {\n                        if (bodyElem.clientWidth < bodyElem.scrollWidth - Math.ceil(bodyElem.scrollLeft)) {\n                            addClass(rightContainerElem, 'scrolling--middle');\n                        }\n                        else {\n                            removeClass(rightContainerElem, 'scrolling--middle');\n                        }\n                    }\n                }\n            },\n            updateZindex: function () {\n                if (props.zIndex) {\n                    internalData.tZindex = props.zIndex;\n                }\n                else if (internalData.tZindex < getLastZIndex()) {\n                    internalData.tZindex = nextZIndex();\n                }\n            },\n            handleCheckedCheckboxRow: handleCheckedCheckboxRow,\n            /**\n             * 行 hover 事件\n             */\n            triggerHoverEvent: function (evnt, _a) {\n                var row = _a.row;\n                tablePrivateMethods.setHoverRow(row);\n            },\n            setHoverRow: function (row) {\n                var rowid = getRowid($xetable, row);\n                var el = refElem.value;\n                tablePrivateMethods.clearHoverRow();\n                if (el) {\n                    XEUtils.arrayEach(el.querySelectorAll(\"[rowid=\\\"\".concat(rowid, \"\\\"]\")), function (elem) { return addClass(elem, 'row--hover'); });\n                }\n                internalData.hoverRow = row;\n            },\n            clearHoverRow: function () {\n                var el = refElem.value;\n                if (el) {\n                    XEUtils.arrayEach(el.querySelectorAll('.vxe-body--row.row--hover'), function (elem) { return removeClass(elem, 'row--hover'); });\n                }\n                internalData.hoverRow = null;\n            },\n            getCell: function (row, column) {\n                var rowid = getRowid($xetable, row);\n                var tableBody = refTableBody.value;\n                var leftBody = refTableLeftBody.value;\n                var rightBody = refTableRightBody.value;\n                var bodyElem;\n                if (column) {\n                    if (column.fixed) {\n                        if (column.fixed === 'left') {\n                            if (leftBody) {\n                                bodyElem = leftBody.$el;\n                            }\n                        }\n                        else {\n                            if (rightBody) {\n                                bodyElem = rightBody.$el;\n                            }\n                        }\n                    }\n                    if (!bodyElem) {\n                        bodyElem = tableBody.$el;\n                    }\n                    if (bodyElem) {\n                        return bodyElem.querySelector(\".vxe-body--row[rowid=\\\"\".concat(rowid, \"\\\"] .\").concat(column.id));\n                    }\n                }\n                return null;\n            },\n            getCellLabel: function (row, column) {\n                var formatter = column.formatter;\n                var cellValue = getCellValue(row, column);\n                var cellLabel = cellValue;\n                if (formatter) {\n                    var formatData = void 0;\n                    var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n                    var rowid = getRowid($xetable, row);\n                    var colid = column.id;\n                    var rest = fullAllDataRowIdData[rowid];\n                    if (rest) {\n                        formatData = rest.formatData;\n                        if (!formatData) {\n                            formatData = fullAllDataRowIdData[rowid].formatData = {};\n                        }\n                        if (rest && formatData[colid]) {\n                            if (formatData[colid].value === cellValue) {\n                                return formatData[colid].label;\n                            }\n                        }\n                    }\n                    var formatParams = { cellValue: cellValue, row: row, rowIndex: tableMethods.getRowIndex(row), column: column, columnIndex: tableMethods.getColumnIndex(column) };\n                    if (XEUtils.isString(formatter)) {\n                        var gFormatOpts = VXETable.formats.get(formatter);\n                        cellLabel = gFormatOpts && gFormatOpts.cellFormatMethod ? gFormatOpts.cellFormatMethod(formatParams) : '';\n                    }\n                    else if (XEUtils.isArray(formatter)) {\n                        var gFormatOpts = VXETable.formats.get(formatter[0]);\n                        cellLabel = gFormatOpts && gFormatOpts.cellFormatMethod ? gFormatOpts.cellFormatMethod.apply(gFormatOpts, __spreadArray([formatParams], formatter.slice(1), false)) : '';\n                    }\n                    else {\n                        cellLabel = formatter(formatParams);\n                    }\n                    if (formatData) {\n                        formatData[colid] = { value: cellValue, label: cellLabel };\n                    }\n                }\n                return cellLabel;\n            },\n            findRowIndexOf: function (list, row) {\n                return row ? XEUtils.findIndexOf(list, function (item) { return $xetable.eqRow(item, row); }) : -1;\n            },\n            eqRow: function (row1, row2) {\n                if (row1 && row2) {\n                    if (row1 === row2) {\n                        return true;\n                    }\n                    return getRowid($xetable, row1) === getRowid($xetable, row2);\n                }\n                return false;\n            }\n        };\n        // 检测对应模块是否安装\n        if (process.env.NODE_ENV === 'development') {\n            'openExport,openPrint,exportData,openImport,importData,saveFile,readFile,importByFile,print'.split(',').forEach(function (name) {\n                $xetable[name] = function () {\n                    errLog('vxe.error.reqModule', ['Export']);\n                };\n            });\n            'clearValidate,fullValidate,validate'.split(',').forEach(function (name) {\n                $xetable[name] = function () {\n                    errLog('vxe.error.reqModule', ['Validator']);\n                };\n            });\n        }\n        Object.assign($xetable, tableMethods, tablePrivateMethods);\n        /**\n         * 渲染浮固定列\n         * 分别渲染左边固定列和右边固定列\n         * 如果宽度足够情况下，则不需要渲染固定列\n         * @param {String} fixedType 固定列类型\n         */\n        var renderFixed = function (fixedType) {\n            var showHeader = props.showHeader, showFooter = props.showFooter;\n            var tableData = reactData.tableData, tableColumn = reactData.tableColumn, tableGroupColumn = reactData.tableGroupColumn, columnStore = reactData.columnStore, footerTableData = reactData.footerTableData;\n            var isFixedLeft = fixedType === 'left';\n            var fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;\n            return h('div', {\n                ref: isFixedLeft ? refLeftContainer : refRightContainer,\n                class: \"vxe-table--fixed-\".concat(fixedType, \"-wrapper\")\n            }, [\n                showHeader ? h(TableHeaderComponent, {\n                    ref: isFixedLeft ? refTableLeftHeader : refTableRightHeader,\n                    fixedType: fixedType,\n                    tableData: tableData,\n                    tableColumn: tableColumn,\n                    tableGroupColumn: tableGroupColumn,\n                    fixedColumn: fixedColumn\n                }) : createCommentVNode(),\n                h(TableBodyComponent, {\n                    ref: isFixedLeft ? refTableLeftBody : refTableRightBody,\n                    fixedType: fixedType,\n                    tableData: tableData,\n                    tableColumn: tableColumn,\n                    fixedColumn: fixedColumn\n                }),\n                showFooter ? h(TableFooterComponent, {\n                    ref: isFixedLeft ? refTableLeftFooter : refTableRightFooter,\n                    footerTableData: footerTableData,\n                    tableColumn: tableColumn,\n                    fixedColumn: fixedColumn,\n                    fixedType: fixedType\n                }) : createCommentVNode()\n            ]);\n        };\n        var renderEmptyContenet = function () {\n            var emptyOpts = computeEmptyOpts.value;\n            var params = { $table: $xetable };\n            if (slots.empty) {\n                return slots.empty(params);\n            }\n            else {\n                var compConf = emptyOpts.name ? VXETable.renderer.get(emptyOpts.name) : null;\n                var renderEmpty = compConf ? compConf.renderEmpty : null;\n                if (renderEmpty) {\n                    return getSlotVNs(renderEmpty(emptyOpts, params));\n                }\n            }\n            return getFuncText(props.emptyText) || GlobalConfig.i18n('vxe.table.emptyText');\n        };\n        function handleUupdateResize() {\n            var el = refElem.value;\n            if (el && el.clientWidth && el.clientHeight) {\n                tableMethods.recalculate();\n            }\n        }\n        var dataFlag = ref(0);\n        watch(function () { return props.data ? props.data.length : -1; }, function () {\n            dataFlag.value++;\n        });\n        watch(function () { return props.data; }, function () {\n            dataFlag.value++;\n        });\n        watch(dataFlag, function () {\n            var inited = internalData.inited, initStatus = internalData.initStatus;\n            loadTableData(props.data || []).then(function () {\n                var scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad, expandColumn = reactData.expandColumn;\n                internalData.inited = true;\n                internalData.initStatus = true;\n                if (!initStatus) {\n                    handleLoadDefaults();\n                }\n                if (!inited) {\n                    handleInitDefaults();\n                }\n                if (process.env.NODE_ENV === 'development') {\n                    // const checkboxOpts = computeCheckboxOpts.value\n                    // const checkboxColumn = internalData.tableFullColumn.find(column => column.type === 'checkbox')\n                    // if (checkboxColumn && internalData.tableFullData.length > 300 && !checkboxOpts.checkField) {\n                    //   warnLog('vxe.error.checkProp', ['checkbox-config.checkField'])\n                    // }\n                    if ((scrollXLoad || scrollYLoad) && expandColumn) {\n                        warnLog('vxe.error.scrollErrProp', ['column.type=expand']);\n                    }\n                }\n                tableMethods.recalculate();\n            });\n        });\n        var staticColumnFlag = ref(0);\n        watch(function () { return reactData.staticColumns.length; }, function () {\n            staticColumnFlag.value++;\n        });\n        watch(function () { return reactData.staticColumns; }, function () {\n            staticColumnFlag.value++;\n        });\n        watch(staticColumnFlag, function () {\n            handleColumn(reactData.staticColumns);\n        });\n        var tableColumnFlag = ref(0);\n        watch(function () { return reactData.tableColumn.length; }, function () {\n            tableColumnFlag.value++;\n        });\n        watch(function () { return reactData.tableColumn; }, function () {\n            tableColumnFlag.value++;\n        });\n        watch(tableColumnFlag, function () {\n            tablePrivateMethods.analyColumnWidth();\n        });\n        watch(function () { return reactData.upDataFlag; }, function () {\n            nextTick(function () {\n                tableMethods.updateData();\n            });\n        });\n        watch(function () { return reactData.reColumnFlag; }, function () {\n            nextTick(function () {\n                tableMethods.refreshColumn();\n            });\n        });\n        watch(function () { return props.showHeader; }, function () {\n            nextTick(function () {\n                tableMethods.recalculate(true).then(function () { return tableMethods.refreshScroll(); });\n            });\n        });\n        watch(function () { return props.showFooter; }, function () {\n            nextTick(function () {\n                tableMethods.recalculate(true).then(function () { return tableMethods.refreshScroll(); });\n            });\n        });\n        watch(function () { return props.height; }, function () {\n            nextTick(function () { return tableMethods.recalculate(true); });\n        });\n        watch(function () { return props.maxHeight; }, function () {\n            nextTick(function () { return tableMethods.recalculate(true); });\n        });\n        watch(function () { return props.syncResize; }, function (value) {\n            if (value) {\n                handleUupdateResize();\n                nextTick(function () {\n                    handleUupdateResize();\n                    setTimeout(function () { return handleUupdateResize(); });\n                });\n            }\n        });\n        var mergeCellFlag = ref(0);\n        watch(function () { return props.mergeCells ? props.mergeCells.length : -1; }, function () {\n            mergeCellFlag.value++;\n        });\n        watch(function () { return props.mergeCells; }, function () {\n            mergeCellFlag.value++;\n        });\n        watch(mergeCellFlag, function () {\n            tableMethods.clearMergeCells();\n            nextTick(function () {\n                if (props.mergeCells) {\n                    tableMethods.setMergeCells(props.mergeCells);\n                }\n            });\n        });\n        var mergeFooterItemFlag = ref(0);\n        watch(function () { return props.mergeFooterItems ? props.mergeFooterItems.length : -1; }, function () {\n            mergeFooterItemFlag.value++;\n        });\n        watch(function () { return props.mergeFooterItems; }, function () {\n            mergeFooterItemFlag.value++;\n        });\n        watch(mergeFooterItemFlag, function () {\n            tableMethods.clearMergeFooterItems();\n            nextTick(function () {\n                if (props.mergeFooterItems) {\n                    tableMethods.setMergeFooterItems(props.mergeFooterItems);\n                }\n            });\n        });\n        VXETable.hooks.forEach(function (options) {\n            var setupTable = options.setupTable;\n            if (setupTable) {\n                var hookRest = setupTable($xetable);\n                if (hookRest && XEUtils.isObject(hookRest)) {\n                    Object.assign($xetable, hookRest);\n                }\n            }\n        });\n        tablePrivateMethods.preventEvent(null, 'created', { $table: $xetable });\n        var resizeObserver;\n        onActivated(function () {\n            tableMethods.recalculate().then(function () { return tableMethods.refreshScroll(); });\n            tablePrivateMethods.preventEvent(null, 'activated', { $table: $xetable });\n        });\n        onDeactivated(function () {\n            internalData.isActivated = false;\n            tablePrivateMethods.preventEvent(null, 'deactivated', { $table: $xetable });\n        });\n        onMounted(function () {\n            nextTick(function () {\n                var data = props.data, treeConfig = props.treeConfig, showOverflow = props.showOverflow;\n                var scrollXStore = internalData.scrollXStore, scrollYStore = internalData.scrollYStore;\n                var sYOpts = computeSYOpts.value;\n                var editOpts = computeEditOpts.value;\n                var treeOpts = computeTreeOpts.value;\n                var radioOpts = computeRadioOpts.value;\n                var checkboxOpts = computeCheckboxOpts.value;\n                var expandOpts = computeExpandOpts.value;\n                var rowOpts = computeRowOpts.value;\n                if (process.env.NODE_ENV === 'development') {\n                    // if (props.rowId) {\n                    //   warnLog('vxe.error.delProp', ['row-id', 'row-config.keyField'])\n                    // }\n                    // if (props.rowKey) {\n                    //   warnLog('vxe.error.delProp', ['row-id', 'row-config.useKey'])\n                    // }\n                    // if (props.columnKey) {\n                    //   warnLog('vxe.error.delProp', ['row-id', 'column-config.useKey'])\n                    // }\n                    if (!(props.rowId || rowOpts.keyField) && (checkboxOpts.reserve || checkboxOpts.checkRowKeys || radioOpts.reserve || radioOpts.checkRowKey || expandOpts.expandRowKeys || treeOpts.expandRowKeys)) {\n                        warnLog('vxe.error.reqProp', ['row-config.keyField']);\n                    }\n                    if (props.editConfig && (editOpts.showStatus || editOpts.showUpdateStatus || editOpts.showInsertStatus) && !props.keepSource) {\n                        warnLog('vxe.error.reqProp', ['keep-source']);\n                    }\n                    if (treeConfig && (treeOpts.showLine || treeOpts.line) && (!(props.rowKey || rowOpts.useKey) || !showOverflow)) {\n                        warnLog('vxe.error.reqProp', ['row-config.useKey | show-overflow']);\n                    }\n                    if (treeConfig && props.stripe) {\n                        warnLog('vxe.error.noTree', ['stripe']);\n                    }\n                    if (props.showFooter && !props.footerMethod) {\n                        warnLog('vxe.error.reqProp', ['footer-method']);\n                    }\n                    // if (props.highlightCurrentRow) {\n                    //   warnLog('vxe.error.delProp', ['highlight-current-row', 'row-config.isCurrent'])\n                    // }\n                    // if (props.highlightHoverRow) {\n                    //   warnLog('vxe.error.delProp', ['highlight-hover-row', 'row-config.isHover'])\n                    // }\n                    // if (props.highlightCurrentColumn) {\n                    //   warnLog('vxe.error.delProp', ['highlight-current-column', 'column-config.isCurrent'])\n                    // }\n                    // if (props.highlightHoverColumn) {\n                    //   warnLog('vxe.error.delProp', ['highlight-hover-column', 'column-config.isHover'])\n                    // }\n                    // 检查导入导出类型，如果自定义导入导出方法，则不校验类型\n                    var exportConfig = props.exportConfig, importConfig = props.importConfig;\n                    var exportOpts = computeExportOpts.value;\n                    var importOpts = computeImportOpts.value;\n                    if (importConfig && importOpts.types && !importOpts.importMethod && !XEUtils.includeArrays(VXETable.globalConfs.importTypes, importOpts.types)) {\n                        warnLog('vxe.error.errProp', [\"export-config.types=\".concat(importOpts.types.join(',')), importOpts.types.filter(function (type) { return XEUtils.includes(VXETable.globalConfs.importTypes, type); }).join(',') || VXETable.globalConfs.importTypes.join(',')]);\n                    }\n                    if (exportConfig && exportOpts.types && !exportOpts.exportMethod && !XEUtils.includeArrays(VXETable.globalConfs.exportTypes, exportOpts.types)) {\n                        warnLog('vxe.error.errProp', [\"export-config.types=\".concat(exportOpts.types.join(',')), exportOpts.types.filter(function (type) { return XEUtils.includes(VXETable.globalConfs.exportTypes, type); }).join(',') || VXETable.globalConfs.exportTypes.join(',')]);\n                    }\n                }\n                if (process.env.NODE_ENV === 'development') {\n                    var customOpts = computeCustomOpts.value;\n                    var mouseOpts = computeMouseOpts.value;\n                    var rowOpts_1 = computeRowOpts.value;\n                    if (!props.id && props.customConfig && (customOpts.storage === true || (customOpts.storage && customOpts.storage.resizable) || (customOpts.storage && customOpts.storage.visible))) {\n                        errLog('vxe.error.reqProp', ['id']);\n                    }\n                    if (props.treeConfig && checkboxOpts.range) {\n                        errLog('vxe.error.noTree', ['checkbox-config.range']);\n                    }\n                    if (rowOpts_1.height && !props.showOverflow) {\n                        warnLog('vxe.error.notProp', ['table.show-overflow']);\n                    }\n                    if (!$xetable.handleUpdateCellAreas) {\n                        if (props.clipConfig) {\n                            warnLog('vxe.error.notProp', ['clip-config']);\n                        }\n                        if (props.fnrConfig) {\n                            warnLog('vxe.error.notProp', ['fnr-config']);\n                        }\n                        if (mouseOpts.area) {\n                            errLog('vxe.error.notProp', ['mouse-config.area']);\n                            return;\n                        }\n                    }\n                    if (props.treeConfig && treeOpts.children) {\n                        warnLog('vxe.error.delProp', ['tree-config.children', 'tree-config.childrenField']);\n                    }\n                    if (props.treeConfig && treeOpts.line) {\n                        warnLog('vxe.error.delProp', ['tree-config.line', 'tree-config.showLine']);\n                    }\n                    if (mouseOpts.area && mouseOpts.selected) {\n                        warnLog('vxe.error.errConflicts', ['mouse-config.area', 'mouse-config.selected']);\n                    }\n                    if (mouseOpts.area && checkboxOpts.range) {\n                        warnLog('vxe.error.errConflicts', ['mouse-config.area', 'checkbox-config.range']);\n                    }\n                    if (props.treeConfig && mouseOpts.area) {\n                        errLog('vxe.error.noTree', ['mouse-config.area']);\n                    }\n                    if (props.editConfig && editOpts.activeMethod) {\n                        warnLog('vxe.error.delProp', ['edit-config.activeMethod', 'edit-config.beforeEditMethod']);\n                    }\n                    if (props.treeConfig && checkboxOpts.isShiftKey) {\n                        errLog('vxe.error.errConflicts', ['tree-config', 'checkbox-config.isShiftKey']);\n                    }\n                    if (checkboxOpts.halfField) {\n                        warnLog('vxe.error.delProp', ['checkbox-config.halfField', 'checkbox-config.indeterminateField']);\n                    }\n                }\n                // 检查是否有安装需要的模块\n                if (process.env.NODE_ENV === 'development') {\n                    if (props.editConfig && !$xetable.insert) {\n                        errLog('vxe.error.reqModule', ['Edit']);\n                    }\n                    if (props.editRules && !$xetable.validate) {\n                        errLog('vxe.error.reqModule', ['Validator']);\n                    }\n                    if ((checkboxOpts.range || props.keyboardConfig || props.mouseConfig) && !$xetable.triggerCellMousedownEvent) {\n                        errLog('vxe.error.reqModule', ['Keyboard']);\n                    }\n                    if ((props.printConfig || props.importConfig || props.exportConfig) && !$xetable.exportData) {\n                        errLog('vxe.error.reqModule', ['Export']);\n                    }\n                }\n                Object.assign(scrollYStore, {\n                    startIndex: 0,\n                    endIndex: 0,\n                    visibleSize: 0,\n                    adaptive: sYOpts.adaptive !== false\n                });\n                Object.assign(scrollXStore, {\n                    startIndex: 0,\n                    endIndex: 0,\n                    visibleSize: 0\n                });\n                loadTableData(data || []).then(function () {\n                    if (data && data.length) {\n                        internalData.inited = true;\n                        internalData.initStatus = true;\n                        handleLoadDefaults();\n                        handleInitDefaults();\n                    }\n                    updateStyle();\n                });\n                if (props.autoResize) {\n                    var resizeOpts = computeResizeleOpts.value;\n                    var refreshDelay = resizeOpts.refreshDelay;\n                    var el = refElem.value;\n                    var parentEl = tablePrivateMethods.getParentElem();\n                    var handleOptimizeResize_1 = refreshDelay ? XEUtils.throttle(function () { return tableMethods.recalculate(true); }, refreshDelay, { leading: true, trailing: true }) : null;\n                    resizeObserver = createResizeEvent(handleOptimizeResize_1 ? function () {\n                        if (props.autoResize) {\n                            requestAnimationFrame(handleOptimizeResize_1);\n                        }\n                    } : function () {\n                        if (props.autoResize) {\n                            tableMethods.recalculate(true);\n                        }\n                    });\n                    if (el) {\n                        resizeObserver.observe(el);\n                    }\n                    if (parentEl) {\n                        resizeObserver.observe(parentEl);\n                    }\n                }\n            });\n            GlobalEvent.on($xetable, 'paste', handleGlobalPasteEvent);\n            GlobalEvent.on($xetable, 'copy', handleGlobalCopyEvent);\n            GlobalEvent.on($xetable, 'cut', handleGlobalCutEvent);\n            GlobalEvent.on($xetable, 'mousedown', handleGlobalMousedownEvent);\n            GlobalEvent.on($xetable, 'blur', handleGlobalBlurEvent);\n            GlobalEvent.on($xetable, 'mousewheel', handleGlobalMousewheelEvent);\n            GlobalEvent.on($xetable, 'keydown', handleGlobalKeydownEvent);\n            GlobalEvent.on($xetable, 'resize', handleGlobalResizeEvent);\n            if ($xetable.handleGlobalContextmenuEvent) {\n                GlobalEvent.on($xetable, 'contextmenu', $xetable.handleGlobalContextmenuEvent);\n            }\n            tablePrivateMethods.preventEvent(null, 'mounted', { $table: $xetable });\n        });\n        onBeforeUnmount(function () {\n            if (resizeObserver) {\n                resizeObserver.disconnect();\n            }\n            tableMethods.closeFilter();\n            if ($xetable.closeMenu) {\n                $xetable.closeMenu();\n            }\n            tablePrivateMethods.preventEvent(null, 'beforeUnmount', { $table: $xetable });\n        });\n        onUnmounted(function () {\n            GlobalEvent.off($xetable, 'paste');\n            GlobalEvent.off($xetable, 'copy');\n            GlobalEvent.off($xetable, 'cut');\n            GlobalEvent.off($xetable, 'mousedown');\n            GlobalEvent.off($xetable, 'blur');\n            GlobalEvent.off($xetable, 'mousewheel');\n            GlobalEvent.off($xetable, 'keydown');\n            GlobalEvent.off($xetable, 'resize');\n            GlobalEvent.off($xetable, 'contextmenu');\n            tablePrivateMethods.preventEvent(null, 'unmounted', { $table: $xetable });\n        });\n        var renderVN = function () {\n            var _a;\n            var loading = props.loading, stripe = props.stripe, showHeader = props.showHeader, height = props.height, treeConfig = props.treeConfig, mouseConfig = props.mouseConfig, showFooter = props.showFooter, highlightCell = props.highlightCell, highlightHoverRow = props.highlightHoverRow, highlightHoverColumn = props.highlightHoverColumn, editConfig = props.editConfig, editRules = props.editRules;\n            var isGroup = reactData.isGroup, overflowX = reactData.overflowX, overflowY = reactData.overflowY, scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad, scrollbarHeight = reactData.scrollbarHeight, tableData = reactData.tableData, tableColumn = reactData.tableColumn, tableGroupColumn = reactData.tableGroupColumn, footerTableData = reactData.footerTableData, initStore = reactData.initStore, columnStore = reactData.columnStore, filterStore = reactData.filterStore;\n            var leftList = columnStore.leftList, rightList = columnStore.rightList;\n            var loadingSlot = slots.loading;\n            var tipConfig = computeTipConfig.value;\n            var validOpts = computeValidOpts.value;\n            var treeOpts = computeTreeOpts.value;\n            var rowOpts = computeRowOpts.value;\n            var columnOpts = computeColumnOpts.value;\n            var vSize = computeSize.value;\n            var tableBorder = computeTableBorder.value;\n            var mouseOpts = computeMouseOpts.value;\n            var validTipOpts = computeValidTipOpts.value;\n            var loadingOpts = computeLoadingOpts.value;\n            var isMenu = computeIsMenu.value;\n            return h('div', {\n                ref: refElem,\n                class: ['vxe-table', 'vxe-table--render-default', \"tid_\".concat(xID), \"border--\".concat(tableBorder), (_a = {},\n                        _a[\"size--\".concat(vSize)] = vSize,\n                        _a[\"vaild-msg--\".concat(validOpts.msgMode)] = !!editRules,\n                        _a['vxe-editable'] = !!editConfig,\n                        _a['old-cell-valid'] = editRules && GlobalConfig.cellVaildMode === 'obsolete',\n                        _a['cell--highlight'] = highlightCell,\n                        _a['cell--selected'] = mouseConfig && mouseOpts.selected,\n                        _a['cell--area'] = mouseConfig && mouseOpts.area,\n                        _a['row--highlight'] = rowOpts.isHover || highlightHoverRow,\n                        _a['column--highlight'] = columnOpts.isHover || highlightHoverColumn,\n                        _a['is--header'] = showHeader,\n                        _a['is--footer'] = showFooter,\n                        _a['is--group'] = isGroup,\n                        _a['is--tree-line'] = treeConfig && (treeOpts.showLine || treeOpts.line),\n                        _a['is--fixed-left'] = leftList.length,\n                        _a['is--fixed-right'] = rightList.length,\n                        _a['is--animat'] = !!props.animat,\n                        _a['is--round'] = props.round,\n                        _a['is--stripe'] = !treeConfig && stripe,\n                        _a['is--loading'] = loading,\n                        _a['is--empty'] = !loading && !tableData.length,\n                        _a['is--scroll-y'] = overflowY,\n                        _a['is--scroll-x'] = overflowX,\n                        _a['is--virtual-x'] = scrollXLoad,\n                        _a['is--virtual-y'] = scrollYLoad,\n                        _a)],\n                onKeydown: keydownEvent\n            }, [\n                /**\n                 * 隐藏列\n                 */\n                h('div', {\n                    class: 'vxe-table-slots'\n                }, slots.default ? slots.default({}) : []),\n                h('div', {\n                    class: 'vxe-table--render-wrapper'\n                }, [\n                    h('div', {\n                        class: 'vxe-table--main-wrapper'\n                    }, [\n                        /**\n                         * 表头\n                         */\n                        showHeader ? h(TableHeaderComponent, {\n                            ref: refTableHeader,\n                            tableData: tableData,\n                            tableColumn: tableColumn,\n                            tableGroupColumn: tableGroupColumn\n                        }) : createCommentVNode(),\n                        /**\n                         * 表体\n                         */\n                        h(TableBodyComponent, {\n                            ref: refTableBody,\n                            tableData: tableData,\n                            tableColumn: tableColumn\n                        }),\n                        /**\n                         * 表尾\n                         */\n                        showFooter ? h(TableFooterComponent, {\n                            ref: refTableFooter,\n                            footerTableData: footerTableData,\n                            tableColumn: tableColumn\n                        }) : createCommentVNode()\n                    ]),\n                    h('div', {\n                        class: 'vxe-table--fixed-wrapper'\n                    }, [\n                        /**\n                         * 左侧固定区域\n                         */\n                        leftList && leftList.length && overflowX ? renderFixed('left') : createCommentVNode(),\n                        /**\n                         * 右侧固定区域\n                         */\n                        rightList && rightList.length && overflowX ? renderFixed('right') : createCommentVNode()\n                    ])\n                ]),\n                /**\n                 * 空数据\n                 */\n                h('div', {\n                    ref: refEmptyPlaceholder,\n                    class: 'vxe-table--empty-placeholder'\n                }, [\n                    h('div', {\n                        class: 'vxe-table--empty-content'\n                    }, renderEmptyContenet())\n                ]),\n                /**\n                 * 边框线\n                 */\n                h('div', {\n                    class: 'vxe-table--border-line'\n                }),\n                /**\n                 * 列宽线\n                 */\n                h('div', {\n                    ref: refCellResizeBar,\n                    class: 'vxe-table--resizable-bar',\n                    style: overflowX ? {\n                        'padding-bottom': \"\".concat(scrollbarHeight, \"px\")\n                    } : null\n                }),\n                /**\n                 * 加载中\n                 */\n                h(VxeLoading, {\n                    class: 'vxe-table--loading',\n                    modelValue: loading,\n                    icon: loadingOpts.icon,\n                    text: loadingOpts.text\n                }, loadingSlot ? {\n                    default: function () { return loadingSlot({ $table: $xetable, $grid: $xegrid }); }\n                } : {}),\n                /**\n                 * 筛选\n                 */\n                initStore.filter ? h(resolveComponent('vxe-table-filter'), {\n                    ref: refTableFilter,\n                    filterStore: filterStore\n                }) : createCommentVNode(),\n                /**\n                 * 导入\n                 */\n                initStore.import && props.importConfig ? h(resolveComponent('vxe-import-panel'), {\n                    defaultOptions: reactData.importParams,\n                    storeData: reactData.importStore\n                }) : createCommentVNode(),\n                /**\n                 * 导出/导出\n                 */\n                initStore.export && (props.exportConfig || props.printConfig) ? h(resolveComponent('vxe-export-panel'), {\n                    defaultOptions: reactData.exportParams,\n                    storeData: reactData.exportStore\n                }) : createCommentVNode(),\n                /**\n                 * 快捷菜单\n                 */\n                isMenu ? h(resolveComponent('vxe-table-context-menu'), {\n                    ref: refTableMenu\n                }) : createCommentVNode(),\n                /**\n                 * 通用提示\n                 */\n                hasUseTooltip ? h(resolveComponent('vxe-tooltip'), {\n                    ref: refCommTooltip,\n                    isArrow: false,\n                    enterable: false\n                }) : createCommentVNode(),\n                /**\n                 * 工具提示\n                 */\n                hasUseTooltip ? h(resolveComponent('vxe-tooltip'), __assign({ ref: refTooltip }, tipConfig)) : createCommentVNode(),\n                /**\n                 * 校验提示\n                 */\n                hasUseTooltip && props.editRules && validOpts.showMessage && (validOpts.message === 'default' ? !height : validOpts.message === 'tooltip') ? h(resolveComponent('vxe-tooltip'), __assign({ ref: refValidTooltip, class: [{\n                            'old-cell-valid': editRules && GlobalConfig.cellVaildMode === 'obsolete'\n                        }, 'vxe-table--valid-error'] }, (validOpts.message === 'tooltip' || tableData.length === 1 ? validTipOpts : {}))) : createCommentVNode()\n            ]);\n        };\n        $xetable.renderVN = renderVN;\n        provide('xecolgroup', null);\n        provide('$xetable', $xetable);\n        return $xetable;\n    },\n    render: function () {\n        return this.renderVN();\n    }\n});\n",
      "start": 1714699767848,
      "end": 1714699767848,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "esbuild",
      "start": 1714699767848,
      "end": 1714699767848,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "var __assign = function() {\n  __assign = Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s)\n        if (Object.prototype.hasOwnProperty.call(s, p))\n          t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __spreadArray = function(to, from, pack) {\n  if (pack || arguments.length === 2)\n    for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n        if (!ar)\n          ar = Array.prototype.slice.call(from, 0, i);\n        ar[i] = from[i];\n      }\n    }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { defineComponent, getCurrentInstance, h, createCommentVNode, resolveComponent, reactive, ref, provide, inject, nextTick, onActivated, onDeactivated, onBeforeUnmount, onUnmounted, watch, computed, onMounted } from \"vue\";\nimport XEUtils from \"xe-utils\";\nimport { browse, isPx, isScale, hasClass, addClass, removeClass, getEventTargetNode, getPaddingTopBottomSize, setScrollTop, setScrollLeft, isNodeElement } from \"../../tools/dom\";\nimport { getLastZIndex, nextZIndex, hasChildrenList, getFuncText, isEnableConf, formatText, eqEmptyValue } from \"../../tools/utils\";\nimport { warnLog, errLog } from \"../../tools/log\";\nimport { createResizeEvent } from \"../../tools/resize\";\nimport { GlobalEvent, hasEventKey, EVENT_KEYS } from \"../../tools/event\";\nimport { useSize } from \"../../hooks/size\";\nimport { VXETable } from \"../../v-x-e-table\";\nimport GlobalConfig from \"../../v-x-e-table/src/conf\";\nimport Cell from \"./cell\";\nimport TableBodyComponent from \"./body\";\nimport TableHeaderComponent from \"../../header\";\nimport TableFooterComponent from \"../../footer\";\nimport tableProps from \"./props\";\nimport tableEmits from \"./emits\";\nimport VxeLoading from \"../../loading/index\";\nimport { getRowUniqueId, clearTableAllStatus, getRowkey, getRowid, rowToVisible, colToVisible, getCellValue, setCellValue, handleFieldOrColumn, toTreePathSeq, restoreScrollLocation, restoreScrollListener, getRootColumn } from \"./util\";\nimport { getSlotVNs } from \"../../tools/vn\";\nvar isWebkit = browse[\"-webkit\"] && !browse.edge;\nvar resizableStorageKey = \"VXE_TABLE_CUSTOM_COLUMN_WIDTH\";\nvar visibleStorageKey = \"VXE_TABLE_CUSTOM_COLUMN_VISIBLE\";\nvar fixedStorageKey = \"VXE_TABLE_CUSTOM_COLUMN_FIXED\";\nvar orderStorageKey = \"VXE_TABLE_CUSTOM_COLUMN_ORDER\";\nexport default defineComponent({\n  name: \"VxeTable\",\n  props: tableProps,\n  emits: tableEmits,\n  setup: function(props, context) {\n    var slots = context.slots, emit = context.emit;\n    var hasUseTooltip = VXETable.tooltip;\n    var xID = XEUtils.uniqueId();\n    var computeSize = useSize(props);\n    var instance = getCurrentInstance();\n    var reactData = reactive({\n      // 低性能的静态列\n      staticColumns: [],\n      // 渲染的列分组\n      tableGroupColumn: [],\n      // 可视区渲染的列\n      tableColumn: [],\n      // 渲染中的数据\n      tableData: [],\n      // 是否启用了横向 X 可视渲染方式加载\n      scrollXLoad: false,\n      // 是否启用了纵向 Y 可视渲染方式加载\n      scrollYLoad: false,\n      // 是否存在纵向滚动条\n      overflowY: true,\n      // 是否存在横向滚动条\n      overflowX: false,\n      // 纵向滚动条的宽度\n      scrollbarWidth: 0,\n      // 横向滚动条的高度\n      scrollbarHeight: 0,\n      // 最后滚动时间戳\n      lastScrollTime: 0,\n      // 行高\n      rowHeight: 0,\n      // 表格父容器的高度\n      parentHeight: 0,\n      // 是否使用分组表头\n      isGroup: false,\n      isAllOverflow: false,\n      // 复选框属性，是否全选\n      isAllSelected: false,\n      // 复选框属性，有选中且非全选状态\n      isIndeterminate: false,\n      // 复选框属性，已选中的行集合\n      selectCheckboxMaps: {},\n      // 当前行\n      currentRow: null,\n      // 单选框属性，选中列\n      currentColumn: null,\n      // 单选框属性，选中行\n      selectRadioRow: null,\n      // 表尾合计数据\n      footerTableData: [],\n      // 展开列信息\n      expandColumn: null,\n      // 树节点列信息\n      treeNodeColumn: null,\n      hasFixedColumn: false,\n      // 已展开的行集合\n      rowExpandedMaps: {},\n      // 懒加载中的展开行的集合\n      rowExpandLazyLoadedMaps: {},\n      // 已展开树节点集合\n      treeExpandedMaps: {},\n      // 懒加载中的树节点的集合\n      treeExpandLazyLoadedMaps: {},\n      // 树节点不确定状态的集合\n      treeIndeterminateMaps: {},\n      // 合并单元格的对象集\n      mergeList: [],\n      // 合并表尾数据的对象集\n      mergeFooterList: [],\n      // 刷新列标识，当列筛选被改变时，触发表格刷新数据\n      upDataFlag: 0,\n      // 刷新列标识，当列的特定属性被改变时，触发表格刷新列\n      reColumnFlag: 0,\n      // 已标记的对象集\n      pendingRowMaps: {},\n      // 已标记的行\n      pendingRowList: [],\n      // 初始化标识\n      initStore: {\n        filter: false,\n        import: false,\n        export: false\n      },\n      // 当前选中的筛选列\n      filterStore: {\n        isAllSelected: false,\n        isIndeterminate: false,\n        style: null,\n        options: [],\n        column: null,\n        multiple: false,\n        visible: false,\n        maxHeight: null\n      },\n      // 存放列相关的信息\n      columnStore: {\n        leftList: [],\n        centerList: [],\n        rightList: [],\n        resizeList: [],\n        pxList: [],\n        pxMinList: [],\n        scaleList: [],\n        scaleMinList: [],\n        autoList: []\n      },\n      // 存放快捷菜单的信息\n      ctxMenuStore: {\n        selected: null,\n        visible: false,\n        showChild: false,\n        selectChild: null,\n        list: [],\n        style: null\n      },\n      // 存放可编辑相关信息\n      editStore: {\n        indexs: {\n          columns: []\n        },\n        titles: {\n          columns: []\n        },\n        // 选中源\n        selected: {\n          row: null,\n          column: null\n        },\n        // 已复制源\n        copyed: {\n          cut: false,\n          rows: [],\n          columns: []\n        },\n        // 激活\n        actived: {\n          row: null,\n          column: null\n        },\n        insertMaps: {},\n        removeMaps: {}\n      },\n      // 存放 tooltip 相关信息\n      tooltipStore: {\n        row: null,\n        column: null,\n        content: null,\n        visible: false,\n        currOpts: null\n      },\n      // 存放数据校验相关信息\n      validStore: {\n        visible: false\n      },\n      validErrorMaps: {},\n      // 导入相关信息\n      importStore: {\n        inited: false,\n        file: null,\n        type: \"\",\n        modeList: [],\n        typeList: [],\n        filename: \"\",\n        visible: false\n      },\n      importParams: {\n        mode: \"\",\n        types: null,\n        message: true\n      },\n      // 导出相关信息\n      exportStore: {\n        inited: false,\n        name: \"\",\n        modeList: [],\n        typeList: [],\n        columns: [],\n        isPrint: false,\n        hasFooter: false,\n        hasMerge: false,\n        hasTree: false,\n        hasColgroup: false,\n        visible: false\n      },\n      exportParams: {\n        filename: \"\",\n        sheetName: \"\",\n        mode: \"\",\n        type: \"\",\n        isColgroup: false,\n        isMerge: false,\n        isAllExpand: false,\n        useStyle: false,\n        original: false,\n        message: true,\n        isHeader: false,\n        isFooter: false\n      },\n      scrollVMLoading: false,\n      _isResize: false\n    });\n    var internalData = {\n      tZindex: 0,\n      elemStore: {},\n      // 存放横向 X 虚拟滚动相关的信息\n      scrollXStore: {\n        offsetSize: 0,\n        visibleSize: 0,\n        startIndex: 0,\n        endIndex: 0\n      },\n      // 存放纵向 Y 虚拟滚动相关信息\n      scrollYStore: {\n        rowHeight: 0,\n        offsetSize: 0,\n        visibleSize: 0,\n        startIndex: 0,\n        endIndex: 0\n      },\n      // 表格宽度\n      tableWidth: 0,\n      // 表格高度\n      tableHeight: 0,\n      // 表头高度\n      headerHeight: 0,\n      // 表尾高度\n      footerHeight: 0,\n      customHeight: 0,\n      customMinHeight: 0,\n      customMaxHeight: 0,\n      // 当前 hover 行\n      hoverRow: null,\n      // 最后滚动位置\n      lastScrollLeft: 0,\n      lastScrollTop: 0,\n      // 单选框属性，已选中保留的行\n      radioReserveRow: null,\n      // 复选框属性，已选中保留的行集合\n      checkboxReserveRowMap: {},\n      // 行数据，已展开保留的行集合\n      rowExpandedReserveRowMap: {},\n      // 树结构数据，已展开保留的行集合\n      treeExpandedReserveRowMap: {},\n      // 树结构数据，不确定状态的集合\n      treeIndeterminateRowMaps: {},\n      // 列表完整数据、条件处理后\n      tableFullData: [],\n      afterFullData: [],\n      afterTreeFullData: [],\n      // 列表条件处理后数据集合\n      afterFullRowMaps: {},\n      // 树结构完整数据、条件处理后\n      tableFullTreeData: [],\n      tableSynchData: [],\n      tableSourceData: [],\n      // 收集的列配置（带分组）\n      collectColumn: [],\n      // 完整所有列（不带分组）\n      tableFullColumn: [],\n      // 渲染所有列\n      visibleColumn: [],\n      // 总的缓存数据集\n      fullAllDataRowIdData: {},\n      // 渲染中缓存数据\n      sourceDataRowIdData: {},\n      fullDataRowIdData: {},\n      fullColumnIdData: {},\n      fullColumnFieldData: {},\n      inited: false,\n      tooltipTimeout: null,\n      initStatus: false,\n      isActivated: false\n    };\n    var tableMethods = {};\n    var tablePrivateMethods = {};\n    var refElem = ref();\n    var refTooltip = ref();\n    var refCommTooltip = ref();\n    var refValidTooltip = ref();\n    var refTableFilter = ref();\n    var refTableMenu = ref();\n    var refTableHeader = ref();\n    var refTableBody = ref();\n    var refTableFooter = ref();\n    var refTableLeftHeader = ref();\n    var refTableLeftBody = ref();\n    var refTableLeftFooter = ref();\n    var refTableRightHeader = ref();\n    var refTableRightBody = ref();\n    var refTableRightFooter = ref();\n    var refLeftContainer = ref();\n    var refRightContainer = ref();\n    var refCellResizeBar = ref();\n    var refEmptyPlaceholder = ref();\n    var $xegrid = inject(\"$xegrid\", null);\n    var $xetoolbar;\n    var computeValidOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.validConfig, props.validConfig);\n    });\n    var computeSXOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.scrollX, props.scrollX);\n    });\n    var computeSYOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.scrollY, props.scrollY);\n    });\n    var computeRowHeightMaps = computed(function() {\n      return {\n        default: 48,\n        medium: 44,\n        small: 40,\n        mini: 36\n      };\n    });\n    var computeColumnOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.columnConfig, props.columnConfig);\n    });\n    var computeRowOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.rowConfig, props.rowConfig);\n    });\n    var computeResizeleOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.resizeConfig, props.resizeConfig);\n    });\n    var computeResizableOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.resizableConfig, props.resizableConfig);\n    });\n    var computeSeqOpts = computed(function() {\n      return Object.assign({ startIndex: 0 }, GlobalConfig.table.seqConfig, props.seqConfig);\n    });\n    var computeRadioOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.radioConfig, props.radioConfig);\n    });\n    var computeCheckboxOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.checkboxConfig, props.checkboxConfig);\n    });\n    var computeTooltipOpts = ref();\n    computeTooltipOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.tooltip, GlobalConfig.table.tooltipConfig, props.tooltipConfig);\n    });\n    var computeTipConfig = computed(function() {\n      var tooltipStore = reactData.tooltipStore;\n      var tooltipOpts = computeTooltipOpts.value;\n      return __assign(__assign({}, tooltipOpts), tooltipStore.currOpts);\n    });\n    var computeValidTipOpts = computed(function() {\n      var tooltipOpts = computeTooltipOpts.value;\n      return Object.assign({ isArrow: false }, tooltipOpts);\n    });\n    var computeEditOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.editConfig, props.editConfig);\n    });\n    var computeSortOpts = computed(function() {\n      return Object.assign({ orders: [\"asc\", \"desc\", null] }, GlobalConfig.table.sortConfig, props.sortConfig);\n    });\n    var computeFilterOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.filterConfig, props.filterConfig);\n    });\n    var computeMouseOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.mouseConfig, props.mouseConfig);\n    });\n    var computeAreaOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.areaConfig, props.areaConfig);\n    });\n    var computeKeyboardOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.keyboardConfig, props.keyboardConfig);\n    });\n    var computeClipOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.clipConfig, props.clipConfig);\n    });\n    var computeFNROpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.fnrConfig, props.fnrConfig);\n    });\n    var computeMenuOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.menuConfig, props.menuConfig);\n    });\n    var computeHeaderMenu = computed(function() {\n      var menuOpts = computeMenuOpts.value;\n      var headerOpts = menuOpts.header;\n      return headerOpts && headerOpts.options ? headerOpts.options : [];\n    });\n    var computeBodyMenu = computed(function() {\n      var menuOpts = computeMenuOpts.value;\n      var bodyOpts = menuOpts.body;\n      return bodyOpts && bodyOpts.options ? bodyOpts.options : [];\n    });\n    var computeFooterMenu = computed(function() {\n      var menuOpts = computeMenuOpts.value;\n      var footerOpts = menuOpts.footer;\n      return footerOpts && footerOpts.options ? footerOpts.options : [];\n    });\n    var computeIsMenu = computed(function() {\n      var menuOpts = computeMenuOpts.value;\n      var headerMenu = computeHeaderMenu.value;\n      var bodyMenu = computeBodyMenu.value;\n      var footerMenu = computeFooterMenu.value;\n      return !!(props.menuConfig && isEnableConf(menuOpts) && (headerMenu.length || bodyMenu.length || footerMenu.length));\n    });\n    var computeMenuList = computed(function() {\n      var ctxMenuStore = reactData.ctxMenuStore;\n      var rest = [];\n      ctxMenuStore.list.forEach(function(list) {\n        list.forEach(function(item) {\n          rest.push(item);\n        });\n      });\n      return rest;\n    });\n    var computeExportOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.exportConfig, props.exportConfig);\n    });\n    var computeImportOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.importConfig, props.importConfig);\n    });\n    var computePrintOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.printConfig, props.printConfig);\n    });\n    var computeExpandOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.expandConfig, props.expandConfig);\n    });\n    var computeTreeOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.treeConfig, props.treeConfig);\n    });\n    var computeEmptyOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.emptyRender, props.emptyRender);\n    });\n    var computeLoadingOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.loadingConfig, props.loadingConfig);\n    });\n    var computeCellOffsetWidth = computed(function() {\n      return props.border ? Math.max(2, Math.ceil(reactData.scrollbarWidth / reactData.tableColumn.length)) : 1;\n    });\n    var computeCustomOpts = computed(function() {\n      return Object.assign({}, GlobalConfig.table.customConfig, props.customConfig);\n    });\n    var computeFixedColumnSize = computed(function() {\n      var tableFullColumn = internalData.tableFullColumn;\n      var fixedSize = 0;\n      tableFullColumn.forEach(function(column) {\n        if (column.fixed) {\n          fixedSize++;\n        }\n      });\n      return fixedSize;\n    });\n    var computeIsMaxFixedColumn = computed(function() {\n      var fixedColumnSize = computeFixedColumnSize.value;\n      var columnOpts = computeColumnOpts.value;\n      var maxFixedSize = columnOpts.maxFixedSize;\n      if (maxFixedSize) {\n        return fixedColumnSize >= maxFixedSize;\n      }\n      return false;\n    });\n    var computeTableBorder = computed(function() {\n      var border = props.border;\n      if (border === true) {\n        return \"full\";\n      }\n      if (border) {\n        return border;\n      }\n      return \"default\";\n    });\n    var computeIsAllCheckboxDisabled = computed(function() {\n      var treeConfig = props.treeConfig;\n      var tableData = reactData.tableData;\n      var tableFullData = internalData.tableFullData;\n      var checkboxOpts = computeCheckboxOpts.value;\n      var strict = checkboxOpts.strict, checkMethod = checkboxOpts.checkMethod;\n      if (strict) {\n        if (tableData.length || tableFullData.length) {\n          if (checkMethod) {\n            if (treeConfig) {\n            }\n            return tableFullData.every(function(row) {\n              return !checkMethod({ row });\n            });\n          }\n          return false;\n        }\n        return true;\n      }\n      return false;\n    });\n    var refMaps = {\n      refElem,\n      refTooltip,\n      refValidTooltip,\n      refTableFilter,\n      refTableMenu,\n      refTableHeader,\n      refTableBody,\n      refTableFooter,\n      refTableLeftHeader,\n      refTableLeftBody,\n      refTableLeftFooter,\n      refTableRightHeader,\n      refTableRightBody,\n      refTableRightFooter,\n      refLeftContainer,\n      refRightContainer,\n      refCellResizeBar\n    };\n    var computeMaps = {\n      computeSize,\n      computeValidOpts,\n      computeSXOpts,\n      computeSYOpts,\n      computeColumnOpts,\n      computeRowOpts,\n      computeResizeleOpts,\n      computeResizableOpts,\n      computeSeqOpts,\n      computeRadioOpts,\n      computeCheckboxOpts,\n      computeTooltipOpts,\n      computeEditOpts,\n      computeSortOpts,\n      computeFilterOpts,\n      computeMouseOpts,\n      computeAreaOpts,\n      computeKeyboardOpts,\n      computeClipOpts,\n      computeFNROpts,\n      computeHeaderMenu,\n      computeBodyMenu,\n      computeFooterMenu,\n      computeIsMenu,\n      computeMenuOpts,\n      computeExportOpts,\n      computeImportOpts,\n      computePrintOpts,\n      computeExpandOpts,\n      computeTreeOpts,\n      computeEmptyOpts,\n      computeLoadingOpts,\n      computeCustomOpts,\n      computeFixedColumnSize,\n      computeIsMaxFixedColumn,\n      computeIsAllCheckboxDisabled\n    };\n    var $xetable = {\n      xID,\n      props,\n      context,\n      instance,\n      reactData,\n      internalData,\n      getRefMaps: function() {\n        return refMaps;\n      },\n      getComputeMaps: function() {\n        return computeMaps;\n      },\n      xegrid: $xegrid\n    };\n    var eqCellValue = function(row1, row2, field) {\n      var val1 = XEUtils.get(row1, field);\n      var val2 = XEUtils.get(row2, field);\n      if (eqEmptyValue(val1) && eqEmptyValue(val2)) {\n        return true;\n      }\n      if (XEUtils.isString(val1) || XEUtils.isNumber(val1)) {\n        return \"\" + val1 === \"\" + val2;\n      }\n      return XEUtils.isEqual(val1, val2);\n    };\n    var getNextSortOrder = function(column) {\n      var sortOpts = computeSortOpts.value;\n      var orders = sortOpts.orders;\n      var currOrder = column.order || null;\n      var oIndex = orders.indexOf(currOrder) + 1;\n      return orders[oIndex < orders.length ? oIndex : 0];\n    };\n    var getCustomStorageMap = function(key) {\n      var version = GlobalConfig.version;\n      var rest = XEUtils.toStringJSON(localStorage.getItem(key) || \"\");\n      return rest && rest._v === version ? rest : { _v: version };\n    };\n    var getRecoverRowMaps = function(keyMaps) {\n      var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n      var restKeys = {};\n      XEUtils.each(keyMaps, function(row, rowid) {\n        if (fullAllDataRowIdData[rowid]) {\n          restKeys[rowid] = row;\n        }\n      });\n      return restKeys;\n    };\n    var handleReserveRow = function(reserveRowMap) {\n      var fullDataRowIdData = internalData.fullDataRowIdData;\n      var reserveList = [];\n      XEUtils.each(reserveRowMap, function(item, rowid) {\n        if (fullDataRowIdData[rowid] && $xetable.findRowIndexOf(reserveList, fullDataRowIdData[rowid].row) === -1) {\n          reserveList.push(fullDataRowIdData[rowid].row);\n        }\n      });\n      return reserveList;\n    };\n    var computeVirtualX = function() {\n      var visibleColumn = internalData.visibleColumn;\n      var tableBody = refTableBody.value;\n      var tableBodyElem = tableBody ? tableBody.$el : null;\n      if (tableBodyElem) {\n        var scrollLeft = tableBodyElem.scrollLeft, clientWidth = tableBodyElem.clientWidth;\n        var endWidth = scrollLeft + clientWidth;\n        var toVisibleIndex = -1;\n        var cWidth = 0;\n        var visibleSize = 0;\n        for (var colIndex = 0, colLen = visibleColumn.length; colIndex < colLen; colIndex++) {\n          cWidth += visibleColumn[colIndex].renderWidth;\n          if (toVisibleIndex === -1 && scrollLeft < cWidth) {\n            toVisibleIndex = colIndex;\n          }\n          if (toVisibleIndex >= 0) {\n            visibleSize++;\n            if (cWidth > endWidth) {\n              break;\n            }\n          }\n        }\n        return { toVisibleIndex: Math.max(0, toVisibleIndex), visibleSize: Math.max(8, visibleSize) };\n      }\n      return { toVisibleIndex: 0, visibleSize: 8 };\n    };\n    var computeVirtualY = function() {\n      var tableHeader = refTableHeader.value;\n      var tableBody = refTableBody.value;\n      var tableBodyElem = tableBody ? tableBody.$el : null;\n      var vSize = computeSize.value;\n      var rowHeightMaps = computeRowHeightMaps.value;\n      if (tableBodyElem) {\n        var tableHeaderElem = tableHeader ? tableHeader.$el : null;\n        var rowHeight = 0;\n        var firstTrElem = void 0;\n        firstTrElem = tableBodyElem.querySelector(\"tr\");\n        if (!firstTrElem && tableHeaderElem) {\n          firstTrElem = tableHeaderElem.querySelector(\"tr\");\n        }\n        if (firstTrElem) {\n          rowHeight = firstTrElem.clientHeight;\n        }\n        if (!rowHeight) {\n          rowHeight = rowHeightMaps[vSize || \"default\"];\n        }\n        var visibleSize = Math.max(8, Math.ceil(tableBodyElem.clientHeight / rowHeight) + 2);\n        return { rowHeight, visibleSize };\n      }\n      return { rowHeight: 0, visibleSize: 8 };\n    };\n    var calculateMergerOffserIndex = function(list, offsetItem, type) {\n      for (var mcIndex = 0, len = list.length; mcIndex < len; mcIndex++) {\n        var mergeItem = list[mcIndex];\n        var startIndex = offsetItem.startIndex, endIndex = offsetItem.endIndex;\n        var mergeStartIndex = mergeItem[type];\n        var mergeSpanNumber = mergeItem[type + \"span\"];\n        var mergeEndIndex = mergeStartIndex + mergeSpanNumber;\n        if (mergeStartIndex < startIndex && startIndex < mergeEndIndex) {\n          offsetItem.startIndex = mergeStartIndex;\n        }\n        if (mergeStartIndex < endIndex && endIndex < mergeEndIndex) {\n          offsetItem.endIndex = mergeEndIndex;\n        }\n        if (offsetItem.startIndex !== startIndex || offsetItem.endIndex !== endIndex) {\n          mcIndex = -1;\n        }\n      }\n    };\n    var setMerges = function(merges, mList, rowList) {\n      if (merges) {\n        var treeConfig = props.treeConfig;\n        var visibleColumn_1 = internalData.visibleColumn;\n        if (!XEUtils.isArray(merges)) {\n          merges = [merges];\n        }\n        if (treeConfig && merges.length) {\n          errLog(\"vxe.error.noTree\", [\"merge-cells | merge-footer-items\"]);\n        }\n        merges.forEach(function(item) {\n          var row = item.row, col = item.col, rowspan = item.rowspan, colspan = item.colspan;\n          if (rowList && XEUtils.isNumber(row)) {\n            row = rowList[row];\n          }\n          if (XEUtils.isNumber(col)) {\n            col = visibleColumn_1[col];\n          }\n          if ((rowList ? row : XEUtils.isNumber(row)) && col && (rowspan || colspan)) {\n            rowspan = XEUtils.toNumber(rowspan) || 1;\n            colspan = XEUtils.toNumber(colspan) || 1;\n            if (rowspan > 1 || colspan > 1) {\n              var mcIndex = XEUtils.findIndexOf(mList, function(item2) {\n                return (item2._row === row || getRowid($xetable, item2._row) === getRowid($xetable, row)) && (item2._col.id === col || item2._col.id === col.id);\n              });\n              var mergeItem = mList[mcIndex];\n              if (mergeItem) {\n                mergeItem.rowspan = rowspan;\n                mergeItem.colspan = colspan;\n                mergeItem._rowspan = rowspan;\n                mergeItem._colspan = colspan;\n              } else {\n                var mergeRowIndex = rowList ? $xetable.findRowIndexOf(rowList, row) : row;\n                var mergeColIndex = tableMethods.getVTColumnIndex(col);\n                mList.push({\n                  row: mergeRowIndex,\n                  col: mergeColIndex,\n                  rowspan,\n                  colspan,\n                  _row: row,\n                  _col: col,\n                  _rowspan: rowspan,\n                  _colspan: colspan\n                });\n              }\n            }\n          }\n        });\n      }\n    };\n    var removeMerges = function(merges, mList, rowList) {\n      var rest = [];\n      if (merges) {\n        var treeConfig = props.treeConfig;\n        var visibleColumn_2 = internalData.visibleColumn;\n        if (!XEUtils.isArray(merges)) {\n          merges = [merges];\n        }\n        if (treeConfig && merges.length) {\n          errLog(\"vxe.error.noTree\", [\"merge-cells | merge-footer-items\"]);\n        }\n        merges.forEach(function(item) {\n          var row = item.row, col = item.col;\n          if (rowList && XEUtils.isNumber(row)) {\n            row = rowList[row];\n          }\n          if (XEUtils.isNumber(col)) {\n            col = visibleColumn_2[col];\n          }\n          var mcIndex = XEUtils.findIndexOf(mList, function(item2) {\n            return (item2._row === row || getRowid($xetable, item2._row) === getRowid($xetable, row)) && (item2._col.id === col || item2._col.id === col.id);\n          });\n          if (mcIndex > -1) {\n            var rItems = mList.splice(mcIndex, 1);\n            rest.push(rItems[0]);\n          }\n        });\n      }\n      return rest;\n    };\n    var clearAllSort = function() {\n      var tableFullColumn = internalData.tableFullColumn;\n      tableFullColumn.forEach(function(column) {\n        column.order = null;\n      });\n    };\n    var calcHeight = function(key) {\n      var parentHeight = reactData.parentHeight;\n      var val = props[key];\n      var num = 0;\n      if (val) {\n        if (val === \"auto\") {\n          num = parentHeight;\n        } else {\n          var excludeHeight = $xetable.getExcludeHeight();\n          if (isScale(val)) {\n            num = Math.floor((XEUtils.toInteger(val) || 1) / 100 * parentHeight);\n          } else {\n            num = XEUtils.toNumber(val);\n          }\n          num = Math.max(40, num - excludeHeight);\n        }\n      }\n      return num;\n    };\n    var restoreCustomStorage = function() {\n      var id = props.id, customConfig = props.customConfig;\n      var collectColumn = internalData.collectColumn;\n      var customOpts = computeCustomOpts.value;\n      var storage = customOpts.storage;\n      var isCustomResizable = storage === true || storage && storage.resizable;\n      var isCustomVisible = storage === true || storage && storage.visible;\n      var isCustomFixed = storage === true || storage && storage.fixed;\n      var isCustomOrder = storage === true || storage && storage.order;\n      if (customConfig && (isCustomResizable || isCustomVisible || isCustomFixed || isCustomOrder)) {\n        var customMap_1 = {};\n        if (!id) {\n          errLog(\"vxe.error.reqProp\", [\"id\"]);\n          return;\n        }\n        if (isCustomResizable) {\n          var columnWidthStorage = getCustomStorageMap(resizableStorageKey)[id];\n          if (columnWidthStorage) {\n            XEUtils.each(columnWidthStorage, function(resizeWidth, colKey) {\n              customMap_1[colKey] = { resizeWidth };\n            });\n          }\n        }\n        if (isCustomFixed) {\n          var columnFixedStorage = getCustomStorageMap(fixedStorageKey)[id];\n          if (columnFixedStorage) {\n            var colFixeds = columnFixedStorage.split(\",\");\n            colFixeds.forEach(function(fixConf) {\n              var _a = fixConf.split(\"|\"), colKey = _a[0], fixed = _a[1];\n              if (customMap_1[colKey]) {\n                customMap_1[colKey].fixed = fixed;\n              } else {\n                customMap_1[colKey] = { fixed };\n              }\n            });\n          }\n        }\n        if (isCustomOrder) {\n          var columnOrderStorage = getCustomStorageMap(orderStorageKey)[id];\n          if (columnOrderStorage) {\n          }\n        }\n        if (isCustomVisible) {\n          var columnVisibleStorage = getCustomStorageMap(visibleStorageKey)[id];\n          if (columnVisibleStorage) {\n            var colVisibles = columnVisibleStorage.split(\"|\");\n            var colHides = colVisibles[0] ? colVisibles[0].split(\",\") : [];\n            var colShows = colVisibles[1] ? colVisibles[1].split(\",\") : [];\n            colHides.forEach(function(colKey) {\n              if (customMap_1[colKey]) {\n                customMap_1[colKey].visible = false;\n              } else {\n                customMap_1[colKey] = { visible: false };\n              }\n            });\n            colShows.forEach(function(colKey) {\n              if (customMap_1[colKey]) {\n                customMap_1[colKey].visible = true;\n              } else {\n                customMap_1[colKey] = { visible: true };\n              }\n            });\n          }\n        }\n        var keyMap_1 = {};\n        XEUtils.eachTree(collectColumn, function(column) {\n          var colKey = column.getKey();\n          if (colKey) {\n            keyMap_1[colKey] = column;\n          }\n        });\n        XEUtils.each(customMap_1, function(_a, colKey) {\n          var visible = _a.visible, resizeWidth = _a.resizeWidth, fixed = _a.fixed, order = _a.order;\n          var column = keyMap_1[colKey];\n          if (column) {\n            if (XEUtils.isNumber(resizeWidth)) {\n              column.resizeWidth = resizeWidth;\n            }\n            if (XEUtils.isBoolean(visible)) {\n              column.visible = visible;\n            }\n            if (fixed) {\n              column.fixed = fixed;\n            }\n            if (order) {\n              column.customOrder = order;\n            }\n          }\n        });\n      }\n    };\n    var cacheColumnMap = function() {\n      var tableFullColumn = internalData.tableFullColumn, collectColumn = internalData.collectColumn;\n      var fullColumnIdData = internalData.fullColumnIdData = {};\n      var fullColumnFieldData = internalData.fullColumnFieldData = {};\n      var mouseOpts = computeMouseOpts.value;\n      var columnOpts = computeColumnOpts.value;\n      var rowOpts = computeRowOpts.value;\n      var isGroup = collectColumn.some(hasChildrenList);\n      var isAllOverflow = !!props.showOverflow;\n      var expandColumn;\n      var treeNodeColumn;\n      var checkboxColumn;\n      var radioColumn;\n      var htmlColumn;\n      var hasFixed;\n      var handleFunc = function(column, index, items, path, parent) {\n        var colid = column.id, field = column.field, fixed = column.fixed, type = column.type, treeNode = column.treeNode;\n        var rest = { column, colid, index, items, parent };\n        if (field) {\n          if (false) {\n            if (fullColumnFieldData[field]) {\n              warnLog(\"vxe.error.colRepet\", [\"field\", field]);\n            }\n          }\n          fullColumnFieldData[field] = rest;\n        }\n        if (!hasFixed && fixed) {\n          hasFixed = fixed;\n        }\n        if (!htmlColumn && type === \"html\") {\n          htmlColumn = column;\n        }\n        if (treeNode) {\n          if (false) {\n            if (treeNodeColumn) {\n              warnLog(\"vxe.error.colRepet\", [\"tree-node\", treeNode]);\n            }\n          }\n          if (!treeNodeColumn) {\n            treeNodeColumn = column;\n          }\n        } else if (type === \"expand\") {\n          if (false) {\n            if (expandColumn) {\n              warnLog(\"vxe.error.colRepet\", [\"type\", type]);\n            }\n          }\n          if (!expandColumn) {\n            expandColumn = column;\n          }\n        }\n        if (false) {\n          if (type === \"checkbox\") {\n            if (checkboxColumn) {\n              warnLog(\"vxe.error.colRepet\", [\"type\", type]);\n            }\n            if (!checkboxColumn) {\n              checkboxColumn = column;\n            }\n          } else if (type === \"radio\") {\n            if (radioColumn) {\n              warnLog(\"vxe.error.colRepet\", [\"type\", type]);\n            }\n            if (!radioColumn) {\n              radioColumn = column;\n            }\n          }\n        }\n        if (isAllOverflow && column.showOverflow === false) {\n          isAllOverflow = false;\n        }\n        if (fullColumnIdData[colid]) {\n          errLog(\"vxe.error.colRepet\", [\"colId\", colid]);\n        }\n        fullColumnIdData[colid] = rest;\n      };\n      if (isGroup) {\n        XEUtils.eachTree(collectColumn, function(column, index, items, path, parent, nodes) {\n          column.level = nodes.length;\n          handleFunc(column, index, items, path, parent);\n        });\n      } else {\n        tableFullColumn.forEach(handleFunc);\n      }\n      if (false) {\n        if (expandColumn && mouseOpts.area) {\n          errLog(\"vxe.error.errConflicts\", [\"mouse-config.area\", \"column.type=expand\"]);\n        }\n      }\n      if (false) {\n        if (htmlColumn) {\n          if (!columnOpts.useKey) {\n            errLog(\"vxe.error.reqProp\", [\"column-config.useKey\", \"column.type=html\"]);\n          }\n          if (!rowOpts.useKey) {\n            errLog(\"vxe.error.reqProp\", [\"row-config.useKey\", \"column.type=html\"]);\n          }\n        }\n      }\n      reactData.isGroup = isGroup;\n      reactData.treeNodeColumn = treeNodeColumn;\n      reactData.expandColumn = expandColumn;\n      reactData.isAllOverflow = isAllOverflow;\n    };\n    var updateHeight = function() {\n      internalData.customHeight = calcHeight(\"height\");\n      internalData.customMinHeight = calcHeight(\"minHeight\");\n      internalData.customMaxHeight = calcHeight(\"maxHeight\");\n    };\n    var autoCellWidth = function() {\n      var tableHeader = refTableHeader.value;\n      var tableBody = refTableBody.value;\n      var tableFooter = refTableFooter.value;\n      var bodyElem = tableBody ? tableBody.$el : null;\n      var headerElem = tableHeader ? tableHeader.$el : null;\n      var footerElem = tableFooter ? tableFooter.$el : null;\n      if (!bodyElem) {\n        return;\n      }\n      var tableWidth = 0;\n      var minCellWidth = 40;\n      var bodyWidth = bodyElem.clientWidth - 1;\n      var remainWidth = bodyWidth;\n      var meanWidth = remainWidth / 100;\n      var fit = props.fit;\n      var columnStore = reactData.columnStore;\n      var resizeList = columnStore.resizeList, pxMinList = columnStore.pxMinList, pxList = columnStore.pxList, scaleList = columnStore.scaleList, scaleMinList = columnStore.scaleMinList, autoList = columnStore.autoList;\n      pxMinList.forEach(function(column) {\n        var minWidth = XEUtils.toInteger(column.minWidth);\n        tableWidth += minWidth;\n        column.renderWidth = minWidth;\n      });\n      scaleMinList.forEach(function(column) {\n        var scaleWidth = Math.floor(XEUtils.toInteger(column.minWidth) * meanWidth);\n        tableWidth += scaleWidth;\n        column.renderWidth = scaleWidth;\n      });\n      scaleList.forEach(function(column) {\n        var scaleWidth = Math.floor(XEUtils.toInteger(column.width) * meanWidth);\n        tableWidth += scaleWidth;\n        column.renderWidth = scaleWidth;\n      });\n      pxList.forEach(function(column) {\n        var width = XEUtils.toInteger(column.width);\n        tableWidth += width;\n        column.renderWidth = width;\n      });\n      resizeList.forEach(function(column) {\n        var width = XEUtils.toInteger(column.resizeWidth);\n        tableWidth += width;\n        column.renderWidth = width;\n      });\n      remainWidth -= tableWidth;\n      meanWidth = remainWidth > 0 ? Math.floor(remainWidth / (scaleMinList.length + pxMinList.length + autoList.length)) : 0;\n      if (fit) {\n        if (remainWidth > 0) {\n          scaleMinList.concat(pxMinList).forEach(function(column) {\n            tableWidth += meanWidth;\n            column.renderWidth += meanWidth;\n          });\n        }\n      } else {\n        meanWidth = minCellWidth;\n      }\n      autoList.forEach(function(column) {\n        var width = Math.max(meanWidth, minCellWidth);\n        column.renderWidth = width;\n        tableWidth += width;\n      });\n      if (fit) {\n        var dynamicList = scaleList.concat(scaleMinList).concat(pxMinList).concat(autoList);\n        var dynamicSize = dynamicList.length - 1;\n        if (dynamicSize > 0) {\n          var odiffer = bodyWidth - tableWidth;\n          if (odiffer > 0) {\n            while (odiffer > 0 && dynamicSize >= 0) {\n              odiffer--;\n              dynamicList[dynamicSize--].renderWidth++;\n            }\n            tableWidth = bodyWidth;\n          }\n        }\n      }\n      var tableHeight = bodyElem.offsetHeight;\n      var overflowY = bodyElem.scrollHeight > bodyElem.clientHeight;\n      var scrollbarWidth = 0;\n      if (overflowY) {\n        scrollbarWidth = Math.max(bodyElem.offsetWidth - bodyElem.clientWidth, 0);\n      }\n      reactData.scrollbarWidth = scrollbarWidth;\n      reactData.overflowY = overflowY;\n      internalData.tableWidth = tableWidth;\n      internalData.tableHeight = tableHeight;\n      var headerHeight = 0;\n      if (headerElem) {\n        headerHeight = headerElem.clientHeight;\n        nextTick(function() {\n          if (headerElem && bodyElem && headerElem.scrollLeft !== bodyElem.scrollLeft) {\n            headerElem.scrollLeft = bodyElem.scrollLeft;\n          }\n        });\n      }\n      internalData.headerHeight = headerHeight;\n      var overflowX = false;\n      var footerHeight = 0;\n      var scrollbarHeight = 0;\n      if (footerElem) {\n        footerHeight = footerElem.offsetHeight;\n        overflowX = tableWidth > footerElem.clientWidth;\n        if (overflowX) {\n          scrollbarHeight = Math.max(footerHeight - footerElem.clientHeight, 0);\n        }\n      } else {\n        overflowX = tableWidth > bodyWidth;\n        if (overflowX) {\n          scrollbarHeight = Math.max(tableHeight - bodyElem.clientHeight, 0);\n        }\n      }\n      internalData.footerHeight = footerHeight;\n      reactData.overflowX = overflowX;\n      reactData.scrollbarHeight = scrollbarHeight;\n      updateHeight();\n      reactData.parentHeight = Math.max(internalData.headerHeight + footerHeight + 20, tablePrivateMethods.getParentHeight());\n      if (overflowX) {\n        tablePrivateMethods.checkScrolling();\n      }\n    };\n    var getOrderField = function(column) {\n      var sortBy = column.sortBy, sortType = column.sortType;\n      return function(row) {\n        var cellValue;\n        if (sortBy) {\n          cellValue = XEUtils.isFunction(sortBy) ? sortBy({ row, column }) : XEUtils.get(row, sortBy);\n        } else {\n          cellValue = tablePrivateMethods.getCellLabel(row, column);\n        }\n        if (!sortType || sortType === \"auto\") {\n          return isNaN(cellValue) ? cellValue : XEUtils.toNumber(cellValue);\n        } else if (sortType === \"number\") {\n          return XEUtils.toNumber(cellValue);\n        } else if (sortType === \"string\") {\n          return XEUtils.toValueString(cellValue);\n        }\n        return cellValue;\n      };\n    };\n    var updateAfterDataIndex = function() {\n      var treeConfig = props.treeConfig;\n      var afterFullData = internalData.afterFullData, fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n      var afterTreeFullData = internalData.afterTreeFullData;\n      var treeOpts = computeTreeOpts.value;\n      var childrenField = treeOpts.children || treeOpts.childrenField;\n      var fullMaps = {};\n      if (treeConfig) {\n        XEUtils.eachTree(afterTreeFullData, function(row, index, items, path) {\n          var rowid = getRowid($xetable, row);\n          var allrest = fullAllDataRowIdData[rowid];\n          var seq = path.map(function(num, i) {\n            return i % 2 === 0 ? Number(num) + 1 : \".\";\n          }).join(\"\");\n          if (allrest) {\n            allrest.seq = seq;\n            allrest._index = index;\n          } else {\n            var rest = { row, rowid, seq, index: -1, $index: -1, _index: index, items: [], parent: null, level: 0 };\n            fullAllDataRowIdData[rowid] = rest;\n            fullDataRowIdData[rowid] = rest;\n          }\n          fullMaps[rowid] = row;\n        }, { children: treeOpts.transform ? treeOpts.mapChildrenField : childrenField });\n      } else {\n        afterFullData.forEach(function(row, index) {\n          var rowid = getRowid($xetable, row);\n          var allrest = fullAllDataRowIdData[rowid];\n          var seq = index + 1;\n          if (allrest) {\n            allrest.seq = seq;\n            allrest._index = index;\n          } else {\n            var rest = { row, rowid, seq, index: -1, $index: -1, _index: index, items: [], parent: null, level: 0 };\n            fullAllDataRowIdData[rowid] = rest;\n            fullDataRowIdData[rowid] = rest;\n          }\n          fullMaps[rowid] = row;\n        });\n      }\n      internalData.afterFullRowMaps = fullMaps;\n    };\n    var handleVirtualTreeToList = function() {\n      var treeConfig = props.treeConfig;\n      var treeExpandedMaps = reactData.treeExpandedMaps;\n      var treeOpts = computeTreeOpts.value;\n      if (treeConfig && treeOpts.transform) {\n        var fullData_1 = [];\n        var expandMaps_1 = {};\n        XEUtils.eachTree(internalData.afterTreeFullData, function(row, index, items, path, parent) {\n          var rowid = getRowid($xetable, row);\n          var parentRowid = getRowid($xetable, parent);\n          if (!parent || expandMaps_1[parentRowid] && treeExpandedMaps[parentRowid]) {\n            expandMaps_1[rowid] = 1;\n            fullData_1.push(row);\n          }\n        }, { children: treeOpts.mapChildrenField });\n        internalData.afterFullData = fullData_1;\n        updateScrollYStatus(fullData_1);\n        return fullData_1;\n      }\n      return internalData.afterFullData;\n    };\n    var updateAfterFullData = function() {\n      var treeConfig = props.treeConfig;\n      var tableFullColumn = internalData.tableFullColumn, tableFullData = internalData.tableFullData, tableFullTreeData = internalData.tableFullTreeData;\n      var filterOpts = computeFilterOpts.value;\n      var sortOpts = computeSortOpts.value;\n      var treeOpts = computeTreeOpts.value;\n      var transform = treeOpts.transform;\n      var allRemoteFilter = filterOpts.remote, allFilterMethod = filterOpts.filterMethod;\n      var allRemoteSort = sortOpts.remote, allSortMethod = sortOpts.sortMethod, sortMultiple = sortOpts.multiple, chronological = sortOpts.chronological;\n      var tableData = [];\n      var tableTree = [];\n      if (!allRemoteFilter || !allRemoteSort) {\n        var filterColumns_1 = [];\n        var orderColumns_1 = [];\n        tableFullColumn.forEach(function(column) {\n          var field = column.field, sortable = column.sortable, order = column.order, filters = column.filters;\n          if (!allRemoteFilter && filters && filters.length) {\n            var valueList_1 = [];\n            var itemList_1 = [];\n            filters.forEach(function(item) {\n              if (item.checked) {\n                itemList_1.push(item);\n                valueList_1.push(item.value);\n              }\n            });\n            if (itemList_1.length) {\n              filterColumns_1.push({ column, valueList: valueList_1, itemList: itemList_1 });\n            }\n          }\n          if (!allRemoteSort && sortable && order) {\n            orderColumns_1.push({ column, field, property: field, order, sortTime: column.sortTime });\n          }\n        });\n        if (sortMultiple && chronological && orderColumns_1.length > 1) {\n          orderColumns_1 = XEUtils.orderBy(orderColumns_1, \"sortTime\");\n        }\n        if (!allRemoteFilter && filterColumns_1.length) {\n          var handleFilter = function(row) {\n            return filterColumns_1.every(function(_a) {\n              var column = _a.column, valueList = _a.valueList, itemList = _a.itemList;\n              var filterMethod = column.filterMethod, filterRender = column.filterRender;\n              var compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;\n              var compFilterMethod = compConf ? compConf.filterMethod : null;\n              var defaultFilterMethod = compConf ? compConf.defaultFilterMethod : null;\n              var cellValue = getCellValue(row, column);\n              if (filterMethod) {\n                return itemList.some(function(item) {\n                  return filterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xetable });\n                });\n              } else if (compFilterMethod) {\n                return itemList.some(function(item) {\n                  return compFilterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xetable });\n                });\n              } else if (allFilterMethod) {\n                return allFilterMethod({ options: itemList, values: valueList, cellValue, row, column });\n              } else if (defaultFilterMethod) {\n                return itemList.some(function(item) {\n                  return defaultFilterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xetable });\n                });\n              }\n              return valueList.indexOf(XEUtils.get(row, column.field)) > -1;\n            });\n          };\n          if (treeConfig && transform) {\n            tableTree = XEUtils.searchTree(tableFullTreeData, handleFilter, __assign(__assign({}, treeOpts), { original: true }));\n            tableData = tableTree;\n          } else {\n            tableData = treeConfig ? tableFullTreeData.filter(handleFilter) : tableFullData.filter(handleFilter);\n            tableTree = tableData;\n          }\n        } else {\n          if (treeConfig && transform) {\n            tableTree = XEUtils.searchTree(tableFullTreeData, function() {\n              return true;\n            }, __assign(__assign({}, treeOpts), { original: true }));\n            tableData = tableTree;\n          } else {\n            tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);\n            tableTree = tableData;\n          }\n        }\n        if (!allRemoteSort && orderColumns_1.length) {\n          if (treeConfig && transform) {\n            if (allSortMethod) {\n              var sortRests = allSortMethod({ data: tableTree, sortList: orderColumns_1, $table: $xetable });\n              tableTree = XEUtils.isArray(sortRests) ? sortRests : tableTree;\n            } else {\n              tableTree = XEUtils.orderBy(tableTree, orderColumns_1.map(function(_a) {\n                var column = _a.column, order = _a.order;\n                return [getOrderField(column), order];\n              }));\n            }\n            tableData = tableTree;\n          } else {\n            if (allSortMethod) {\n              var sortRests = allSortMethod({ data: tableData, sortList: orderColumns_1, $table: $xetable });\n              tableData = XEUtils.isArray(sortRests) ? sortRests : tableData;\n            } else {\n              tableData = XEUtils.orderBy(tableData, orderColumns_1.map(function(_a) {\n                var column = _a.column, order = _a.order;\n                return [getOrderField(column), order];\n              }));\n            }\n            tableTree = tableData;\n          }\n        }\n      } else {\n        if (treeConfig && transform) {\n          tableTree = XEUtils.searchTree(tableFullTreeData, function() {\n            return true;\n          }, __assign(__assign({}, treeOpts), { original: true }));\n          tableData = tableTree;\n        } else {\n          tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);\n          tableTree = tableData;\n        }\n      }\n      internalData.afterFullData = tableData;\n      internalData.afterTreeFullData = tableTree;\n      updateAfterDataIndex();\n    };\n    var updateStyle = function() {\n      var border = props.border, showFooter = props.showFooter, allColumnOverflow = props.showOverflow, allColumnHeaderOverflow = props.showHeaderOverflow, allColumnFooterOverflow = props.showFooterOverflow, mouseConfig = props.mouseConfig, spanMethod = props.spanMethod, footerSpanMethod = props.footerSpanMethod, keyboardConfig = props.keyboardConfig;\n      var isGroup = reactData.isGroup, currentRow = reactData.currentRow, tableColumn = reactData.tableColumn, scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad, scrollbarWidth = reactData.scrollbarWidth, scrollbarHeight = reactData.scrollbarHeight, columnStore = reactData.columnStore, editStore = reactData.editStore, mergeList = reactData.mergeList, mergeFooterList = reactData.mergeFooterList, isAllOverflow = reactData.isAllOverflow;\n      var visibleColumn = internalData.visibleColumn, fullColumnIdData = internalData.fullColumnIdData, tableHeight = internalData.tableHeight, tableWidth = internalData.tableWidth, headerHeight = internalData.headerHeight, footerHeight = internalData.footerHeight, elemStore = internalData.elemStore, customHeight = internalData.customHeight, customMinHeight = internalData.customMinHeight, customMaxHeight = internalData.customMaxHeight;\n      var containerList = [\"main\", \"left\", \"right\"];\n      var emptyPlaceholderElem = refEmptyPlaceholder.value;\n      var cellOffsetWidth = computeCellOffsetWidth.value;\n      var mouseOpts = computeMouseOpts.value;\n      var keyboardOpts = computeKeyboardOpts.value;\n      var bodyWrapperRef = elemStore[\"main-body-wrapper\"];\n      var bodyWrapperElem = bodyWrapperRef ? bodyWrapperRef.value : null;\n      if (emptyPlaceholderElem) {\n        emptyPlaceholderElem.style.top = \"\".concat(headerHeight, \"px\");\n        emptyPlaceholderElem.style.height = bodyWrapperElem ? \"\".concat(bodyWrapperElem.offsetHeight - scrollbarHeight, \"px\") : \"\";\n      }\n      if (customHeight > 0) {\n        if (showFooter) {\n          customHeight += scrollbarHeight;\n        }\n      }\n      containerList.forEach(function(name, index) {\n        var fixedType = index > 0 ? name : \"\";\n        var layoutList = [\"header\", \"body\", \"footer\"];\n        var isFixedLeft = fixedType === \"left\";\n        var fixedColumn = [];\n        var fixedWrapperElem;\n        if (fixedType) {\n          fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;\n          fixedWrapperElem = isFixedLeft ? refLeftContainer.value : refRightContainer.value;\n        }\n        layoutList.forEach(function(layout) {\n          var wrapperRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-wrapper\")];\n          var wrapperElem = wrapperRef ? wrapperRef.value : null;\n          var tableRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-table\")];\n          var tableElem = tableRef ? tableRef.value : null;\n          if (layout === \"header\") {\n            var tWidth = tableWidth;\n            var renderColumnList = tableColumn;\n            if (isGroup) {\n              renderColumnList = visibleColumn;\n            } else {\n              if (fixedType) {\n                if (scrollXLoad || allColumnHeaderOverflow) {\n                  renderColumnList = fixedColumn;\n                }\n              }\n            }\n            tWidth = renderColumnList.reduce(function(previous, column) {\n              return previous + column.renderWidth;\n            }, 0);\n            if (tableElem) {\n              tableElem.style.width = tWidth ? \"\".concat(tWidth + scrollbarWidth, \"px\") : \"\";\n            }\n            var repairRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-repair\")];\n            var repairElem = repairRef ? repairRef.value : null;\n            if (repairElem) {\n              repairElem.style.width = \"\".concat(tableWidth, \"px\");\n            }\n            var listRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-list\")];\n            var listElem = listRef ? listRef.value : null;\n            if (isGroup && listElem) {\n              XEUtils.arrayEach(listElem.querySelectorAll(\".col--group\"), function(thElem) {\n                var colNode = tableMethods.getColumnNode(thElem);\n                if (colNode) {\n                  var column_1 = colNode.item;\n                  var showHeaderOverflow = column_1.showHeaderOverflow;\n                  var cellOverflow = XEUtils.isBoolean(showHeaderOverflow) ? showHeaderOverflow : allColumnHeaderOverflow;\n                  var showEllipsis = cellOverflow === \"ellipsis\";\n                  var showTitle = cellOverflow === \"title\";\n                  var showTooltip = cellOverflow === true || cellOverflow === \"tooltip\";\n                  var hasEllipsis = showTitle || showTooltip || showEllipsis;\n                  var childWidth_1 = 0;\n                  var countChild_1 = 0;\n                  if (hasEllipsis) {\n                    XEUtils.eachTree(column_1.children, function(item) {\n                      if (!item.children || !column_1.children.length) {\n                        countChild_1++;\n                      }\n                      childWidth_1 += item.renderWidth;\n                    }, { children: \"children\" });\n                  }\n                  thElem.style.width = hasEllipsis ? \"\".concat(childWidth_1 - countChild_1 - (border ? 2 : 0), \"px\") : \"\";\n                }\n              });\n            }\n          } else if (layout === \"body\") {\n            var emptyBlockRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-emptyBlock\")];\n            var emptyBlockElem = emptyBlockRef ? emptyBlockRef.value : null;\n            if (isNodeElement(wrapperElem)) {\n              var bodyMaxHeight = 0;\n              var bodyMinHeight = customMinHeight - headerHeight - footerHeight;\n              if (customMaxHeight) {\n                bodyMaxHeight = customMaxHeight - headerHeight - footerHeight;\n                if (fixedType) {\n                  bodyMaxHeight -= showFooter ? 0 : scrollbarHeight;\n                }\n                bodyMaxHeight = Math.max(bodyMinHeight, bodyMaxHeight);\n                wrapperElem.style.maxHeight = \"\".concat(bodyMaxHeight, \"px\");\n              }\n              if (customHeight) {\n                var bodyHeight = customHeight - headerHeight - footerHeight;\n                if (fixedType) {\n                  bodyHeight -= showFooter ? 0 : scrollbarHeight;\n                }\n                if (bodyMaxHeight) {\n                  bodyHeight = Math.min(bodyMaxHeight, bodyHeight);\n                }\n                wrapperElem.style.height = \"\".concat(Math.max(bodyMinHeight, bodyHeight), \"px\");\n              } else {\n                wrapperElem.style.height = \"\";\n              }\n              wrapperElem.style.minHeight = \"\".concat(bodyMinHeight, \"px\");\n            }\n            if (fixedWrapperElem) {\n              if (isNodeElement(wrapperElem)) {\n                wrapperElem.style.top = \"\".concat(headerHeight, \"px\");\n              }\n              fixedWrapperElem.style.height = \"\".concat((customHeight > 0 ? customHeight - headerHeight - footerHeight : tableHeight) + headerHeight + footerHeight - scrollbarHeight * (showFooter ? 2 : 1), \"px\");\n              fixedWrapperElem.style.width = \"\".concat(fixedColumn.reduce(function(previous, column) {\n                return previous + column.renderWidth;\n              }, isFixedLeft ? 0 : scrollbarWidth), \"px\");\n            }\n            var tWidth = tableWidth;\n            var renderColumnList = tableColumn;\n            if (fixedType) {\n              if (!reactData.expandColumn && (scrollYLoad || (allColumnOverflow ? isAllOverflow : allColumnOverflow))) {\n                if (!mergeList.length && !spanMethod && !(keyboardConfig && keyboardOpts.isMerge)) {\n                  renderColumnList = fixedColumn;\n                } else {\n                  renderColumnList = visibleColumn;\n                }\n              } else {\n                renderColumnList = visibleColumn;\n              }\n            }\n            tWidth = renderColumnList.reduce(function(previous, column) {\n              return previous + column.renderWidth;\n            }, 0);\n            if (tableElem) {\n              tableElem.style.width = tWidth ? \"\".concat(tWidth, \"px\") : \"\";\n              tableElem.style.paddingRight = scrollbarWidth && fixedType && (browse[\"-moz\"] || browse.safari) ? \"\".concat(scrollbarWidth, \"px\") : \"\";\n            }\n            if (emptyBlockElem) {\n              emptyBlockElem.style.width = tWidth ? \"\".concat(tWidth, \"px\") : \"\";\n            }\n          } else if (layout === \"footer\") {\n            var tWidth = tableWidth;\n            var renderColumnList = tableColumn;\n            if (fixedType) {\n              if (!reactData.expandColumn && (scrollXLoad || allColumnFooterOverflow)) {\n                if (!mergeFooterList.length || !footerSpanMethod) {\n                  renderColumnList = fixedColumn;\n                } else {\n                  renderColumnList = visibleColumn;\n                }\n              } else {\n                renderColumnList = visibleColumn;\n              }\n            }\n            tWidth = renderColumnList.reduce(function(previous, column) {\n              return previous + column.renderWidth;\n            }, 0);\n            if (isNodeElement(wrapperElem)) {\n              if (fixedWrapperElem) {\n                wrapperElem.style.top = \"\".concat(customHeight > 0 ? customHeight - footerHeight : tableHeight + headerHeight, \"px\");\n              }\n              wrapperElem.style.marginTop = \"\".concat(-Math.max(1, scrollbarHeight), \"px\");\n            }\n            if (tableElem) {\n              tableElem.style.width = tWidth ? \"\".concat(tWidth + scrollbarWidth, \"px\") : \"\";\n            }\n          }\n          var colgroupRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-colgroup\")];\n          var colgroupElem = colgroupRef ? colgroupRef.value : null;\n          if (colgroupElem) {\n            XEUtils.arrayEach(colgroupElem.children, function(colElem) {\n              var colid = colElem.getAttribute(\"name\");\n              if (colid === \"col_gutter\") {\n                colElem.style.width = \"\".concat(scrollbarWidth, \"px\");\n              }\n              if (fullColumnIdData[colid]) {\n                var column_2 = fullColumnIdData[colid].column;\n                var showHeaderOverflow = column_2.showHeaderOverflow, showFooterOverflow = column_2.showFooterOverflow, showOverflow = column_2.showOverflow;\n                var cellOverflow = void 0;\n                colElem.style.width = \"\".concat(column_2.renderWidth, \"px\");\n                if (layout === \"header\") {\n                  cellOverflow = XEUtils.isUndefined(showHeaderOverflow) || XEUtils.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;\n                } else if (layout === \"footer\") {\n                  cellOverflow = XEUtils.isUndefined(showFooterOverflow) || XEUtils.isNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;\n                } else {\n                  cellOverflow = XEUtils.isUndefined(showOverflow) || XEUtils.isNull(showOverflow) ? allColumnOverflow : showOverflow;\n                }\n                var showEllipsis = cellOverflow === \"ellipsis\";\n                var showTitle = cellOverflow === \"title\";\n                var showTooltip = cellOverflow === true || cellOverflow === \"tooltip\";\n                var hasEllipsis_1 = showTitle || showTooltip || showEllipsis;\n                var listRef2 = elemStore[\"\".concat(name, \"-\").concat(layout, \"-list\")];\n                var listElem2 = listRef2 ? listRef2.value : null;\n                if (scrollYLoad && !hasEllipsis_1) {\n                  hasEllipsis_1 = true;\n                }\n                if (listElem2) {\n                  XEUtils.arrayEach(listElem2.querySelectorAll(\".\".concat(column_2.id)), function(elem) {\n                    var colspan = parseInt(elem.getAttribute(\"colspan\") || 1);\n                    var cellElem = elem.querySelector(\".vxe-cell\");\n                    var colWidth = column_2.renderWidth;\n                    if (cellElem) {\n                      if (colspan > 1) {\n                        var columnIndex = tableMethods.getColumnIndex(column_2);\n                        for (var index_1 = 1; index_1 < colspan; index_1++) {\n                          var nextColumn = tableMethods.getColumns(columnIndex + index_1);\n                          if (nextColumn) {\n                            colWidth += nextColumn.renderWidth;\n                          }\n                        }\n                      }\n                      cellElem.style.width = hasEllipsis_1 ? \"\".concat(colWidth - cellOffsetWidth * colspan, \"px\") : \"\";\n                    }\n                  });\n                }\n              }\n            });\n          }\n        });\n      });\n      if (currentRow) {\n        tableMethods.setCurrentRow(currentRow);\n      }\n      if (mouseConfig && mouseOpts.selected && editStore.selected.row && editStore.selected.column) {\n        $xetable.addCellSelectedClass();\n      }\n      return nextTick();\n    };\n    var checkValidate = function(type) {\n      if ($xetable.triggerValidate) {\n        return $xetable.triggerValidate(type);\n      }\n      return nextTick();\n    };\n    var handleChangeCell = function(evnt, params) {\n      checkValidate(\"blur\").catch(function(e) {\n        return e;\n      }).then(function() {\n        $xetable.handleActived(params, evnt).then(function() {\n          return checkValidate(\"change\");\n        }).catch(function(e) {\n          return e;\n        });\n      });\n    };\n    var handleDefaultSort = function() {\n      var sortConfig = props.sortConfig;\n      if (sortConfig) {\n        var sortOpts = computeSortOpts.value;\n        var defaultSort = sortOpts.defaultSort;\n        if (defaultSort) {\n          if (!XEUtils.isArray(defaultSort)) {\n            defaultSort = [defaultSort];\n          }\n          if (defaultSort.length) {\n            (sortConfig.multiple ? defaultSort : defaultSort.slice(0, 1)).forEach(function(item, index) {\n              var field = item.field, order = item.order;\n              if (field && order) {\n                var column = tableMethods.getColumnByField(field);\n                if (column && column.sortable) {\n                  column.order = order;\n                  column.sortTime = Date.now() + index;\n                }\n              }\n            });\n            if (!sortOpts.remote) {\n              tablePrivateMethods.handleTableData(true).then(updateStyle);\n            }\n          }\n        }\n      }\n    };\n    var handleDefaultSelectionChecked = function() {\n      var checkboxConfig = props.checkboxConfig;\n      if (checkboxConfig) {\n        var fullDataRowIdData_1 = internalData.fullDataRowIdData;\n        var checkboxOpts = computeCheckboxOpts.value;\n        var checkAll = checkboxOpts.checkAll, checkRowKeys = checkboxOpts.checkRowKeys;\n        if (checkAll) {\n          handleCheckedAllCheckboxRow(true, true);\n        } else if (checkRowKeys) {\n          var defSelection_1 = [];\n          checkRowKeys.forEach(function(rowid) {\n            if (fullDataRowIdData_1[rowid]) {\n              defSelection_1.push(fullDataRowIdData_1[rowid].row);\n            }\n          });\n          handleCheckedCheckboxRow(defSelection_1, true, true);\n        }\n      }\n    };\n    var handleDefaultRadioChecked = function() {\n      var _a;\n      var radioConfig = props.radioConfig;\n      if (radioConfig) {\n        var fullDataRowIdData = internalData.fullDataRowIdData;\n        var radioOpts = computeRadioOpts.value;\n        var rowid = radioOpts.checkRowKey, reserve = radioOpts.reserve;\n        if (rowid) {\n          if (fullDataRowIdData[rowid]) {\n            handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);\n          }\n          if (reserve) {\n            var rowkey = getRowkey($xetable);\n            internalData.radioReserveRow = (_a = {}, _a[rowkey] = rowid, _a);\n          }\n        }\n      }\n    };\n    var handleDefaultRowExpand = function() {\n      var expandConfig = props.expandConfig;\n      if (expandConfig) {\n        var fullDataRowIdData_2 = internalData.fullDataRowIdData;\n        var expandOpts = computeExpandOpts.value;\n        var expandAll = expandOpts.expandAll, expandRowKeys = expandOpts.expandRowKeys;\n        if (expandAll) {\n          tableMethods.setAllRowExpand(true);\n        } else if (expandRowKeys) {\n          var defExpandeds_1 = [];\n          expandRowKeys.forEach(function(rowid) {\n            if (fullDataRowIdData_2[rowid]) {\n              defExpandeds_1.push(fullDataRowIdData_2[rowid].row);\n            }\n          });\n          tableMethods.setRowExpand(defExpandeds_1, true);\n        }\n      }\n    };\n    var handleRadioReserveRow = function(row) {\n      var radioOpts = computeRadioOpts.value;\n      if (radioOpts.reserve) {\n        internalData.radioReserveRow = row;\n      }\n    };\n    var handleCheckboxReserveRow = function(row, checked) {\n      var checkboxReserveRowMap = internalData.checkboxReserveRowMap;\n      var checkboxOpts = computeCheckboxOpts.value;\n      if (checkboxOpts.reserve) {\n        var rowid = getRowid($xetable, row);\n        if (checked) {\n          checkboxReserveRowMap[rowid] = row;\n        } else if (checkboxReserveRowMap[rowid]) {\n          delete checkboxReserveRowMap[rowid];\n        }\n      }\n    };\n    var handleCheckedRadioRow = function(row, isForce) {\n      var radioOpts = computeRadioOpts.value;\n      var checkMethod = radioOpts.checkMethod;\n      if (row && (isForce || (!checkMethod || checkMethod({ row })))) {\n        reactData.selectRadioRow = row;\n        handleRadioReserveRow(row);\n      }\n      return nextTick();\n    };\n    var handleCheckedCheckboxRow = function(rows, value, isForce) {\n      if (rows && !XEUtils.isArray(rows)) {\n        rows = [rows];\n      }\n      rows.forEach(function(row) {\n        return tablePrivateMethods.handleSelectRow({ row }, !!value, isForce);\n      });\n      return nextTick();\n    };\n    var handleCheckedAllCheckboxRow = function(value, isForce) {\n      var treeConfig = props.treeConfig;\n      var selectCheckboxMaps = reactData.selectCheckboxMaps;\n      var afterFullData = internalData.afterFullData, afterFullRowMaps = internalData.afterFullRowMaps, checkboxReserveRowMap = internalData.checkboxReserveRowMap;\n      var treeOpts = computeTreeOpts.value;\n      var childrenField = treeOpts.children || treeOpts.childrenField;\n      var checkboxOpts = computeCheckboxOpts.value;\n      var checkField = checkboxOpts.checkField, reserve = checkboxOpts.reserve, checkStrictly = checkboxOpts.checkStrictly, checkMethod = checkboxOpts.checkMethod;\n      var indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;\n      var selectRowMaps = {};\n      if (!treeConfig) {\n        XEUtils.each(selectCheckboxMaps, function(row, rowid) {\n          if (!afterFullRowMaps[rowid]) {\n            selectRowMaps[rowid] = row;\n          }\n        });\n      }\n      if (checkStrictly) {\n        reactData.isAllSelected = value;\n      } else {\n        if (checkField) {\n          var checkValFn = function(row) {\n            if (isForce || (!checkMethod || checkMethod({ row }))) {\n              if (value) {\n                selectRowMaps[getRowid($xetable, row)] = row;\n              }\n              XEUtils.set(row, checkField, value);\n            }\n            if (treeConfig && indeterminateField) {\n              XEUtils.set(row, indeterminateField, false);\n            }\n          };\n          if (treeConfig) {\n            XEUtils.eachTree(afterFullData, checkValFn, { children: childrenField });\n          } else {\n            afterFullData.forEach(checkValFn);\n          }\n        } else {\n          if (treeConfig) {\n            if (value) {\n              XEUtils.eachTree(afterFullData, function(row) {\n                if (isForce || (!checkMethod || checkMethod({ row }))) {\n                  selectRowMaps[getRowid($xetable, row)] = row;\n                }\n              }, { children: childrenField });\n            } else {\n              if (!isForce && checkMethod) {\n                XEUtils.eachTree(afterFullData, function(row) {\n                  var rowid = getRowid($xetable, row);\n                  if (checkMethod({ row }) ? 0 : selectCheckboxMaps[rowid]) {\n                    selectRowMaps[rowid] = row;\n                  }\n                }, { children: childrenField });\n              }\n            }\n          } else {\n            if (value) {\n              if (!isForce && checkMethod) {\n                afterFullData.forEach(function(row) {\n                  var rowid = getRowid($xetable, row);\n                  if (selectCheckboxMaps[rowid] || checkMethod({ row })) {\n                    selectRowMaps[rowid] = row;\n                  }\n                });\n              } else {\n                afterFullData.forEach(function(row) {\n                  selectRowMaps[getRowid($xetable, row)] = row;\n                });\n              }\n            } else {\n              if (!isForce && checkMethod) {\n                afterFullData.forEach(function(row) {\n                  var rowid = getRowid($xetable, row);\n                  if (checkMethod({ row }) ? 0 : selectCheckboxMaps[rowid]) {\n                    selectRowMaps[rowid] = row;\n                  }\n                });\n              }\n            }\n          }\n        }\n        if (reserve) {\n          if (value) {\n            XEUtils.each(selectRowMaps, function(row, rowid) {\n              checkboxReserveRowMap[rowid] = row;\n            });\n          } else {\n            afterFullData.forEach(function(row) {\n              return handleCheckboxReserveRow(row, false);\n            });\n          }\n        }\n        reactData.selectCheckboxMaps = checkField ? {} : selectRowMaps;\n      }\n      reactData.treeIndeterminateMaps = {};\n      internalData.treeIndeterminateRowMaps = {};\n      tablePrivateMethods.checkSelectionStatus();\n      return nextTick();\n    };\n    var handleReserveStatus = function() {\n      var treeConfig = props.treeConfig;\n      var expandColumn = reactData.expandColumn, currentRow = reactData.currentRow, selectCheckboxMaps = reactData.selectCheckboxMaps, selectRadioRow = reactData.selectRadioRow, rowExpandedMaps = reactData.rowExpandedMaps, treeExpandedMaps = reactData.treeExpandedMaps;\n      var fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData, radioReserveRow = internalData.radioReserveRow;\n      var expandOpts = computeExpandOpts.value;\n      var treeOpts = computeTreeOpts.value;\n      var radioOpts = computeRadioOpts.value;\n      var checkboxOpts = computeCheckboxOpts.value;\n      if (selectRadioRow && !fullAllDataRowIdData[getRowid($xetable, selectRadioRow)]) {\n        reactData.selectRadioRow = null;\n      }\n      if (radioOpts.reserve && radioReserveRow) {\n        var rowid = getRowid($xetable, radioReserveRow);\n        if (fullDataRowIdData[rowid]) {\n          handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);\n        }\n      }\n      reactData.selectCheckboxMaps = getRecoverRowMaps(selectCheckboxMaps);\n      if (checkboxOpts.reserve) {\n        handleCheckedCheckboxRow(handleReserveRow(internalData.checkboxReserveRowMap), true, true);\n      }\n      if (currentRow && !fullAllDataRowIdData[getRowid($xetable, currentRow)]) {\n        reactData.currentRow = null;\n      }\n      reactData.rowExpandedMaps = expandColumn ? getRecoverRowMaps(rowExpandedMaps) : {};\n      if (expandColumn && expandOpts.reserve) {\n        tableMethods.setRowExpand(handleReserveRow(internalData.rowExpandedReserveRowMap), true);\n      }\n      reactData.treeExpandedMaps = treeConfig ? getRecoverRowMaps(treeExpandedMaps) : {};\n      if (treeConfig && treeOpts.reserve) {\n        tableMethods.setTreeExpand(handleReserveRow(internalData.treeExpandedReserveRowMap), true);\n      }\n    };\n    var handleDefaultTreeExpand = function() {\n      var treeConfig = props.treeConfig;\n      if (treeConfig) {\n        var tableFullData_1 = internalData.tableFullData;\n        var treeOpts = computeTreeOpts.value;\n        var expandAll = treeOpts.expandAll, expandRowKeys = treeOpts.expandRowKeys;\n        var childrenField_1 = treeOpts.children || treeOpts.childrenField;\n        if (expandAll) {\n          tableMethods.setAllTreeExpand(true);\n        } else if (expandRowKeys) {\n          var defExpandeds_2 = [];\n          var rowkey_1 = getRowkey($xetable);\n          expandRowKeys.forEach(function(rowid) {\n            var matchObj = XEUtils.findTree(tableFullData_1, function(item) {\n              return rowid === XEUtils.get(item, rowkey_1);\n            }, { children: childrenField_1 });\n            if (matchObj) {\n              defExpandeds_2.push(matchObj.item);\n            }\n          });\n          tableMethods.setTreeExpand(defExpandeds_2, true);\n        }\n      }\n    };\n    var handleAsyncTreeExpandChilds = function(row) {\n      var treeOpts = computeTreeOpts.value;\n      var checkboxOpts = computeCheckboxOpts.value;\n      var transform = treeOpts.transform, loadMethod = treeOpts.loadMethod;\n      var checkStrictly = checkboxOpts.checkStrictly;\n      return new Promise(function(resolve) {\n        if (loadMethod) {\n          var treeExpandLazyLoadedMaps_1 = reactData.treeExpandLazyLoadedMaps;\n          var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n          var rowid_1 = getRowid($xetable, row);\n          var rest_1 = fullAllDataRowIdData[rowid_1];\n          treeExpandLazyLoadedMaps_1[rowid_1] = row;\n          loadMethod({ $table: $xetable, row }).then(function(childRecords) {\n            rest_1.treeLoaded = true;\n            if (treeExpandLazyLoadedMaps_1[rowid_1]) {\n              delete treeExpandLazyLoadedMaps_1[rowid_1];\n            }\n            if (!XEUtils.isArray(childRecords)) {\n              childRecords = [];\n            }\n            if (childRecords) {\n              return tableMethods.loadTreeChildren(row, childRecords).then(function(childRows) {\n                var treeExpandedMaps = reactData.treeExpandedMaps;\n                if (childRows.length && !treeExpandedMaps[rowid_1]) {\n                  treeExpandedMaps[rowid_1] = row;\n                }\n                if (!checkStrictly && tableMethods.isCheckedByCheckboxRow(row)) {\n                  handleCheckedCheckboxRow(childRows, true);\n                }\n                return nextTick().then(function() {\n                  if (transform) {\n                    return tablePrivateMethods.handleTableData();\n                  }\n                });\n              });\n            }\n          }).catch(function() {\n            var treeExpandLazyLoadedMaps = reactData.treeExpandLazyLoadedMaps;\n            rest_1.treeLoaded = false;\n            if (treeExpandLazyLoadedMaps[rowid_1]) {\n              delete treeExpandLazyLoadedMaps[rowid_1];\n            }\n          }).finally(function() {\n            nextTick().then(function() {\n              return tableMethods.recalculate();\n            }).then(function() {\n              return resolve();\n            });\n          });\n        } else {\n          resolve();\n        }\n      });\n    };\n    var handleTreeExpandReserve = function(row, expanded) {\n      var treeExpandedReserveRowMap = internalData.treeExpandedReserveRowMap;\n      var treeOpts = computeTreeOpts.value;\n      if (treeOpts.reserve) {\n        var rowid = getRowid($xetable, row);\n        if (expanded) {\n          treeExpandedReserveRowMap[rowid] = row;\n        } else if (treeExpandedReserveRowMap[rowid]) {\n          delete treeExpandedReserveRowMap[rowid];\n        }\n      }\n    };\n    var handleAsyncRowExpand = function(row) {\n      return new Promise(function(resolve) {\n        var expandOpts = computeExpandOpts.value;\n        var loadMethod = expandOpts.loadMethod;\n        if (loadMethod) {\n          var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n          var rowExpandLazyLoadedMaps = reactData.rowExpandLazyLoadedMaps;\n          var rowid_2 = getRowid($xetable, row);\n          var rest_2 = fullAllDataRowIdData[rowid_2];\n          rowExpandLazyLoadedMaps[rowid_2] = row;\n          loadMethod({ $table: $xetable, row, rowIndex: tableMethods.getRowIndex(row), $rowIndex: tableMethods.getVMRowIndex(row) }).then(function() {\n            var rowExpandedMaps = reactData.rowExpandedMaps;\n            rest_2.expandLoaded = true;\n            rowExpandedMaps[rowid_2] = row;\n          }).catch(function() {\n            rest_2.expandLoaded = false;\n          }).finally(function() {\n            var rowExpandLazyLoadedMaps2 = reactData.rowExpandLazyLoadedMaps;\n            if (rowExpandLazyLoadedMaps2[rowid_2]) {\n              delete rowExpandLazyLoadedMaps2[rowid_2];\n            }\n            nextTick().then(function() {\n              return tableMethods.recalculate();\n            }).then(function() {\n              return resolve();\n            });\n          });\n        } else {\n          resolve();\n        }\n      });\n    };\n    var handleRowExpandReserve = function(row, expanded) {\n      var rowExpandedReserveRowMap = internalData.rowExpandedReserveRowMap;\n      var expandOpts = computeExpandOpts.value;\n      if (expandOpts.reserve) {\n        var rowid = getRowid($xetable, row);\n        if (expanded) {\n          rowExpandedReserveRowMap[rowid] = row;\n        } else if (rowExpandedReserveRowMap[rowid]) {\n          delete rowExpandedReserveRowMap[rowid];\n        }\n      }\n    };\n    var handleDefaultMergeCells = function() {\n      var mergeCells = props.mergeCells;\n      if (mergeCells) {\n        tableMethods.setMergeCells(mergeCells);\n      }\n    };\n    var handleDefaultMergeFooterItems = function() {\n      var mergeFooterItems = props.mergeFooterItems;\n      if (mergeFooterItems) {\n        tableMethods.setMergeFooterItems(mergeFooterItems);\n      }\n    };\n    var computeScrollLoad = function() {\n      return nextTick().then(function() {\n        var scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad;\n        var scrollXStore = internalData.scrollXStore, scrollYStore = internalData.scrollYStore;\n        var sYOpts = computeSYOpts.value;\n        var sXOpts = computeSXOpts.value;\n        if (scrollXLoad) {\n          var visibleXSize = computeVirtualX().visibleSize;\n          var offsetXSize = sXOpts.oSize ? XEUtils.toNumber(sXOpts.oSize) : browse.edge ? 5 : 0;\n          scrollXStore.offsetSize = offsetXSize;\n          scrollXStore.visibleSize = visibleXSize;\n          scrollXStore.endIndex = Math.max(scrollXStore.startIndex + scrollXStore.visibleSize + offsetXSize, scrollXStore.endIndex);\n          tablePrivateMethods.updateScrollXData();\n        } else {\n          tablePrivateMethods.updateScrollXSpace();\n        }\n        var _a = computeVirtualY(), rowHeight = _a.rowHeight, visibleYSize = _a.visibleSize;\n        scrollYStore.rowHeight = rowHeight;\n        if (scrollYLoad) {\n          var offsetYSize = sYOpts.oSize ? XEUtils.toNumber(sYOpts.oSize) : browse.edge ? 10 : 0;\n          scrollYStore.offsetSize = offsetYSize;\n          scrollYStore.visibleSize = visibleYSize;\n          scrollYStore.endIndex = Math.max(scrollYStore.startIndex + visibleYSize + offsetYSize, scrollYStore.endIndex);\n          tablePrivateMethods.updateScrollYData();\n        } else {\n          tablePrivateMethods.updateScrollYSpace();\n        }\n        reactData.rowHeight = rowHeight;\n        nextTick(updateStyle);\n      });\n    };\n    var loadTableData = function(datas) {\n      var keepSource = props.keepSource, treeConfig = props.treeConfig;\n      var editStore = reactData.editStore, oldScrollYLoad = reactData.scrollYLoad;\n      var scrollYStore = internalData.scrollYStore, scrollXStore = internalData.scrollXStore, lastScrollLeft = internalData.lastScrollLeft, lastScrollTop = internalData.lastScrollTop;\n      var treeOpts = computeTreeOpts.value;\n      var transform = treeOpts.transform;\n      var childrenField = treeOpts.children || treeOpts.childrenField;\n      var treeData = [];\n      var fullData = reactive(datas ? datas.slice(0) : []);\n      if (treeConfig) {\n        if (transform) {\n          if (false) {\n            if (!treeOpts.rowField) {\n              errLog(\"vxe.error.reqProp\", [\"tree-config.rowField\"]);\n            }\n            if (!treeOpts.parentField) {\n              errLog(\"vxe.error.reqProp\", [\"tree-config.parentField\"]);\n            }\n            if (!childrenField) {\n              errLog(\"vxe.error.reqProp\", [\"tree-config.childrenField\"]);\n            }\n            if (!treeOpts.mapChildrenField) {\n              errLog(\"vxe.error.reqProp\", [\"tree-config.mapChildrenField\"]);\n            }\n            if (childrenField === treeOpts.mapChildrenField) {\n              errLog(\"vxe.error.errConflicts\", [\"tree-config.childrenField\", \"tree-config.mapChildrenField\"]);\n            }\n          }\n          treeData = XEUtils.toArrayTree(fullData, {\n            key: treeOpts.rowField,\n            parentKey: treeOpts.parentField,\n            children: childrenField,\n            mapChildren: treeOpts.mapChildrenField\n          });\n          fullData = treeData.slice(0);\n        } else {\n          treeData = fullData.slice(0);\n        }\n      }\n      scrollYStore.startIndex = 0;\n      scrollYStore.endIndex = 1;\n      scrollXStore.startIndex = 0;\n      scrollXStore.endIndex = 1;\n      reactData.scrollVMLoading = false;\n      editStore.insertMaps = {};\n      editStore.removeMaps = {};\n      var sYLoad = updateScrollYStatus(fullData);\n      reactData.scrollYLoad = sYLoad;\n      internalData.tableFullData = fullData;\n      internalData.tableFullTreeData = treeData;\n      tablePrivateMethods.cacheRowMap(true);\n      internalData.tableSynchData = datas;\n      if (keepSource) {\n        tablePrivateMethods.cacheSourceMap(fullData);\n      }\n      if (false) {\n        if (sYLoad) {\n          if (!(props.height || props.maxHeight)) {\n            errLog(\"vxe.error.reqProp\", [\"table.height | table.max-height | table.scroll-y={enabled: false}\"]);\n          }\n          if (!props.showOverflow) {\n            warnLog(\"vxe.error.reqProp\", [\"table.show-overflow\"]);\n          }\n          if (props.spanMethod) {\n            warnLog(\"vxe.error.scrollErrProp\", [\"table.span-method\"]);\n          }\n        }\n      }\n      if ($xetable.clearCellAreas && props.mouseConfig) {\n        $xetable.clearCellAreas();\n        $xetable.clearCopyCellArea();\n      }\n      tableMethods.clearMergeCells();\n      tableMethods.clearMergeFooterItems();\n      tablePrivateMethods.handleTableData(true);\n      tableMethods.updateFooter();\n      return nextTick().then(function() {\n        updateHeight();\n        updateStyle();\n      }).then(function() {\n        computeScrollLoad();\n      }).then(function() {\n        if (sYLoad) {\n          scrollYStore.endIndex = scrollYStore.visibleSize;\n        }\n        handleReserveStatus();\n        tablePrivateMethods.checkSelectionStatus();\n        return new Promise(function(resolve) {\n          nextTick().then(function() {\n            return tableMethods.recalculate();\n          }).then(function() {\n            var targetScrollLeft = lastScrollLeft;\n            var targetScrollTop = lastScrollTop;\n            var sXOpts = computeSXOpts.value;\n            var sYOpts = computeSYOpts.value;\n            if (sXOpts.scrollToLeftOnChange) {\n              targetScrollLeft = 0;\n            }\n            if (sYOpts.scrollToTopOnChange) {\n              targetScrollTop = 0;\n            }\n            if (oldScrollYLoad === sYLoad) {\n              restoreScrollLocation($xetable, targetScrollLeft, targetScrollTop).then(resolve);\n            } else {\n              setTimeout(function() {\n                return restoreScrollLocation($xetable, targetScrollLeft, targetScrollTop).then(resolve);\n              });\n            }\n          });\n        });\n      });\n    };\n    var handleLoadDefaults = function() {\n      handleDefaultSelectionChecked();\n      handleDefaultRadioChecked();\n      handleDefaultRowExpand();\n      handleDefaultTreeExpand();\n      handleDefaultMergeCells();\n      handleDefaultMergeFooterItems();\n      nextTick(function() {\n        return setTimeout(function() {\n          return tableMethods.recalculate();\n        });\n      });\n    };\n    var handleInitDefaults = function() {\n      handleDefaultSort();\n    };\n    var handleTableColumn = function() {\n      var scrollXLoad = reactData.scrollXLoad;\n      var visibleColumn = internalData.visibleColumn, scrollXStore = internalData.scrollXStore, fullColumnIdData = internalData.fullColumnIdData;\n      var tableColumn = scrollXLoad ? visibleColumn.slice(scrollXStore.startIndex, scrollXStore.endIndex) : visibleColumn.slice(0);\n      tableColumn.forEach(function(column, $index) {\n        var colid = column.id;\n        var rest = fullColumnIdData[colid];\n        if (rest) {\n          rest.$index = $index;\n        }\n      });\n      reactData.tableColumn = tableColumn;\n    };\n    var loadScrollXData = function() {\n      var mergeList = reactData.mergeList, mergeFooterList = reactData.mergeFooterList;\n      var scrollXStore = internalData.scrollXStore;\n      var startIndex = scrollXStore.startIndex, endIndex = scrollXStore.endIndex, offsetSize = scrollXStore.offsetSize;\n      var _a = computeVirtualX(), toVisibleIndex = _a.toVisibleIndex, visibleSize = _a.visibleSize;\n      var offsetItem = {\n        startIndex: Math.max(0, toVisibleIndex - 1 - offsetSize),\n        endIndex: toVisibleIndex + visibleSize + offsetSize\n      };\n      calculateMergerOffserIndex(mergeList.concat(mergeFooterList), offsetItem, \"col\");\n      var offsetStartIndex = offsetItem.startIndex, offsetEndIndex = offsetItem.endIndex;\n      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {\n        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {\n          scrollXStore.startIndex = offsetStartIndex;\n          scrollXStore.endIndex = offsetEndIndex;\n          tablePrivateMethods.updateScrollXData();\n        }\n      }\n      tableMethods.closeTooltip();\n    };\n    var getColumnList = function(columns) {\n      var result = [];\n      columns.forEach(function(column) {\n        result.push.apply(result, column.children && column.children.length ? getColumnList(column.children) : [column]);\n      });\n      return result;\n    };\n    var parseColumns = function() {\n      var leftList = [];\n      var centerList = [];\n      var rightList = [];\n      var isGroup = reactData.isGroup, columnStore = reactData.columnStore;\n      var sXOpts = computeSXOpts.value;\n      var collectColumn = internalData.collectColumn, tableFullColumn = internalData.tableFullColumn, scrollXStore = internalData.scrollXStore, fullColumnIdData = internalData.fullColumnIdData;\n      if (isGroup) {\n        var leftGroupList_1 = [];\n        var centerGroupList_1 = [];\n        var rightGroupList_1 = [];\n        XEUtils.eachTree(collectColumn, function(column, index, items, path, parent) {\n          var isColGroup = hasChildrenList(column);\n          if (parent && parent.fixed) {\n            column.fixed = parent.fixed;\n          }\n          if (parent && column.fixed !== parent.fixed) {\n            errLog(\"vxe.error.groupFixed\");\n          }\n          if (isColGroup) {\n            column.visible = !!XEUtils.findTree(column.children, function(subColumn) {\n              return hasChildrenList(subColumn) ? false : subColumn.visible;\n            });\n          } else if (column.visible) {\n            if (column.fixed === \"left\") {\n              leftList.push(column);\n            } else if (column.fixed === \"right\") {\n              rightList.push(column);\n            } else {\n              centerList.push(column);\n            }\n          }\n        });\n        collectColumn.forEach(function(column) {\n          if (column.visible) {\n            if (column.fixed === \"left\") {\n              leftGroupList_1.push(column);\n            } else if (column.fixed === \"right\") {\n              rightGroupList_1.push(column);\n            } else {\n              centerGroupList_1.push(column);\n            }\n          }\n        });\n        reactData.tableGroupColumn = leftGroupList_1.concat(centerGroupList_1).concat(rightGroupList_1);\n      } else {\n        tableFullColumn.forEach(function(column) {\n          if (column.visible) {\n            if (column.fixed === \"left\") {\n              leftList.push(column);\n            } else if (column.fixed === \"right\") {\n              rightList.push(column);\n            } else {\n              centerList.push(column);\n            }\n          }\n        });\n      }\n      var visibleColumn = leftList.concat(centerList).concat(rightList);\n      var scrollXLoad = !!sXOpts.enabled && sXOpts.gt > -1 && (sXOpts.gt === 0 || sXOpts.gt < tableFullColumn.length);\n      reactData.hasFixedColumn = leftList.length > 0 || rightList.length > 0;\n      Object.assign(columnStore, { leftList, centerList, rightList });\n      if (scrollXLoad) {\n        if (false) {\n          if (props.spanMethod) {\n            warnLog(\"vxe.error.scrollErrProp\", [\"span-method\"]);\n          }\n          if (props.footerSpanMethod) {\n            warnLog(\"vxe.error.scrollErrProp\", [\"footer-span-method\"]);\n          }\n        }\n        var visibleSize = computeVirtualX().visibleSize;\n        scrollXStore.startIndex = 0;\n        scrollXStore.endIndex = visibleSize;\n        scrollXStore.visibleSize = visibleSize;\n      }\n      if (visibleColumn.length !== internalData.visibleColumn.length || !internalData.visibleColumn.every(function(column, index) {\n        return column === visibleColumn[index];\n      })) {\n        tableMethods.clearMergeCells();\n        tableMethods.clearMergeFooterItems();\n      }\n      reactData.scrollXLoad = scrollXLoad;\n      visibleColumn.forEach(function(column, index) {\n        var colid = column.id;\n        var rest = fullColumnIdData[colid];\n        if (rest) {\n          rest._index = index;\n        }\n      });\n      internalData.visibleColumn = visibleColumn;\n      handleTableColumn();\n      return tableMethods.updateFooter().then(function() {\n        return tableMethods.recalculate();\n      }).then(function() {\n        tableMethods.updateCellAreas();\n        return tableMethods.recalculate();\n      });\n    };\n    var handleColumn = function(collectColumn) {\n      internalData.collectColumn = collectColumn;\n      var tableFullColumn = getColumnList(collectColumn);\n      internalData.tableFullColumn = tableFullColumn;\n      cacheColumnMap();\n      restoreCustomStorage();\n      parseColumns().then(function() {\n        if (reactData.scrollXLoad) {\n          loadScrollXData();\n        }\n      });\n      tableMethods.clearMergeCells();\n      tableMethods.clearMergeFooterItems();\n      tablePrivateMethods.handleTableData(true);\n      if (false) {\n        if ((reactData.scrollXLoad || reactData.scrollYLoad) && reactData.expandColumn) {\n          warnLog(\"vxe.error.scrollErrProp\", [\"column.type=expand\"]);\n        }\n      }\n      return nextTick().then(function() {\n        if ($xetoolbar) {\n          $xetoolbar.syncUpdate({ collectColumn, $table: $xetable });\n        }\n        return tableMethods.recalculate();\n      });\n    };\n    var updateScrollYStatus = function(fullData) {\n      var treeConfig = props.treeConfig;\n      var sYOpts = computeSYOpts.value;\n      var treeOpts = computeTreeOpts.value;\n      var transform = treeOpts.transform;\n      var allList = fullData || internalData.tableFullData;\n      var scrollYLoad = (transform || !treeConfig) && !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt < allList.length);\n      reactData.scrollYLoad = scrollYLoad;\n      return scrollYLoad;\n    };\n    var handleBaseTreeExpand = function(rows, expanded) {\n      var treeExpandedMaps = reactData.treeExpandedMaps, treeExpandLazyLoadedMaps = reactData.treeExpandLazyLoadedMaps, treeNodeColumn = reactData.treeNodeColumn;\n      var treeTempExpandedMaps = __assign({}, treeExpandedMaps);\n      var fullAllDataRowIdData = internalData.fullAllDataRowIdData, tableFullData = internalData.tableFullData;\n      var treeOpts = computeTreeOpts.value;\n      var reserve = treeOpts.reserve, lazy = treeOpts.lazy, accordion = treeOpts.accordion, toggleMethod = treeOpts.toggleMethod;\n      var childrenField = treeOpts.children || treeOpts.childrenField;\n      var hasChildField = treeOpts.hasChild || treeOpts.hasChildField;\n      var result = [];\n      var columnIndex = tableMethods.getColumnIndex(treeNodeColumn);\n      var $columnIndex = tableMethods.getVMColumnIndex(treeNodeColumn);\n      var validRows = toggleMethod ? rows.filter(function(row) {\n        return toggleMethod({ $table: $xetable, expanded, column: treeNodeColumn, columnIndex, $columnIndex, row });\n      }) : rows;\n      if (accordion) {\n        validRows = validRows.length ? [validRows[validRows.length - 1]] : [];\n        var matchObj = XEUtils.findTree(tableFullData, function(item) {\n          return item === validRows[0];\n        }, { children: childrenField });\n        if (matchObj) {\n          matchObj.items.forEach(function(item) {\n            var rowid = getRowid($xetable, item);\n            if (treeTempExpandedMaps[rowid]) {\n              delete treeTempExpandedMaps[rowid];\n            }\n          });\n        }\n      }\n      if (expanded) {\n        validRows.forEach(function(row) {\n          var rowid = getRowid($xetable, row);\n          if (!treeTempExpandedMaps[rowid]) {\n            var rest = fullAllDataRowIdData[rowid];\n            var isLoad = lazy && row[hasChildField] && !rest.treeLoaded && !treeExpandLazyLoadedMaps[rowid];\n            if (isLoad) {\n              result.push(handleAsyncTreeExpandChilds(row));\n            } else {\n              if (row[childrenField] && row[childrenField].length) {\n                treeTempExpandedMaps[rowid] = row;\n              }\n            }\n          }\n        });\n      } else {\n        validRows.forEach(function(item) {\n          var rowid = getRowid($xetable, item);\n          if (treeTempExpandedMaps[rowid]) {\n            delete treeTempExpandedMaps[rowid];\n          }\n        });\n      }\n      if (reserve) {\n        validRows.forEach(function(row) {\n          return handleTreeExpandReserve(row, expanded);\n        });\n      }\n      reactData.treeExpandedMaps = treeTempExpandedMaps;\n      return Promise.all(result).then(function() {\n        return tableMethods.recalculate();\n      });\n    };\n    var handleVirtualTreeExpand = function(rows, expanded) {\n      return handleBaseTreeExpand(rows, expanded).then(function() {\n        handleVirtualTreeToList();\n        return tablePrivateMethods.handleTableData();\n      }).then(function() {\n        return tableMethods.recalculate();\n      });\n    };\n    var loadScrollYData = function(evnt) {\n      var mergeList = reactData.mergeList;\n      var scrollYStore = internalData.scrollYStore;\n      var startIndex = scrollYStore.startIndex, endIndex = scrollYStore.endIndex, visibleSize = scrollYStore.visibleSize, offsetSize = scrollYStore.offsetSize, rowHeight = scrollYStore.rowHeight;\n      var scrollBodyElem = evnt.currentTarget || evnt.target;\n      var scrollTop = scrollBodyElem.scrollTop;\n      var toVisibleIndex = Math.floor(scrollTop / rowHeight);\n      var offsetItem = {\n        startIndex: Math.max(0, toVisibleIndex - 1 - offsetSize),\n        endIndex: toVisibleIndex + visibleSize + offsetSize\n      };\n      calculateMergerOffserIndex(mergeList, offsetItem, \"row\");\n      var offsetStartIndex = offsetItem.startIndex, offsetEndIndex = offsetItem.endIndex;\n      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {\n        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {\n          scrollYStore.startIndex = offsetStartIndex;\n          scrollYStore.endIndex = offsetEndIndex;\n          tablePrivateMethods.updateScrollYData();\n        }\n      }\n    };\n    var createGetRowCacheProp = function(prop) {\n      return function(row) {\n        var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n        if (row) {\n          var rowid = getRowid($xetable, row);\n          var rest = fullAllDataRowIdData[rowid];\n          if (rest) {\n            return rest[prop];\n          }\n        }\n        return -1;\n      };\n    };\n    var createGetColumnCacheProp = function(prop) {\n      return function(column) {\n        var fullColumnIdData = internalData.fullColumnIdData;\n        if (column) {\n          var rest = fullColumnIdData[column.id];\n          if (rest) {\n            return rest[prop];\n          }\n        }\n        return -1;\n      };\n    };\n    var debounceScrollY = XEUtils.debounce(function(evnt) {\n      loadScrollYData(evnt);\n    }, 20, { leading: false, trailing: true });\n    var keyCtxTimeout;\n    tableMethods = {\n      dispatchEvent: function(type, params, evnt) {\n        emit(type, Object.assign({ $table: $xetable, $grid: $xegrid, $event: evnt }, params));\n      },\n      /**\n       * 重置表格的一切数据状态\n       */\n      clearAll: function() {\n        return clearTableAllStatus($xetable);\n      },\n      /**\n       * 同步 data 数据（即将废弃）\n       * 如果用了该方法，那么组件将不再记录增删改的状态，只能自行实现对应逻辑\n       * 对于某些特殊的场景，比如深层树节点元素发生变动时可能会用到\n       */\n      syncData: function() {\n        warnLog(\"vxe.error.delFunc\", [\"syncData\", \"getData\"]);\n        return nextTick().then(function() {\n          reactData.tableData = [];\n          emit(\"update:data\", internalData.tableFullData);\n          return nextTick();\n        });\n      },\n      /**\n       * 手动处理数据，用于手动排序与筛选\n       * 对于手动更改了排序、筛选...等条件后需要重新处理数据时可能会用到\n       */\n      updateData: function() {\n        var scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad;\n        return tablePrivateMethods.handleTableData(true).then(function() {\n          tableMethods.updateFooter();\n          if (scrollXLoad || scrollYLoad) {\n            if (scrollXLoad) {\n              tablePrivateMethods.updateScrollXSpace();\n            }\n            if (scrollYLoad) {\n              tablePrivateMethods.updateScrollYSpace();\n            }\n            return tableMethods.refreshScroll();\n          }\n        }).then(function() {\n          tableMethods.updateCellAreas();\n          return tableMethods.recalculate(true);\n        }).then(function() {\n          setTimeout(function() {\n            return $xetable.recalculate();\n          }, 50);\n        });\n      },\n      /**\n       * 重新加载数据，不会清空表格状态\n       * @param {Array} datas 数据\n       */\n      loadData: function(datas) {\n        var inited = internalData.inited, initStatus = internalData.initStatus;\n        return loadTableData(datas).then(function() {\n          internalData.inited = true;\n          internalData.initStatus = true;\n          if (!initStatus) {\n            handleLoadDefaults();\n          }\n          if (!inited) {\n            handleInitDefaults();\n          }\n          return tableMethods.recalculate();\n        });\n      },\n      /**\n       * 重新加载数据，会清空表格状态\n       * @param {Array} datas 数据\n       */\n      reloadData: function(datas) {\n        var inited = internalData.inited;\n        return tableMethods.clearAll().then(function() {\n          internalData.inited = true;\n          internalData.initStatus = true;\n          return loadTableData(datas);\n        }).then(function() {\n          handleLoadDefaults();\n          if (!inited) {\n            handleInitDefaults();\n          }\n          return tableMethods.recalculate();\n        });\n      },\n      /**\n       * 局部加载行数据并恢复到初始状态\n       * 对于行数据需要局部更改的场景中可能会用到\n       * @param {Row} row 行对象\n       * @param {Object} record 新数据\n       * @param {String} field 字段名\n       */\n      reloadRow: function(row, record, field) {\n        var keepSource = props.keepSource;\n        var tableData = reactData.tableData;\n        var tableSourceData = internalData.tableSourceData;\n        if (keepSource) {\n          var rowIndex = tableMethods.getRowIndex(row);\n          var oRow = tableSourceData[rowIndex];\n          if (oRow && row) {\n            if (field) {\n              var newValue = XEUtils.get(record || row, field);\n              XEUtils.set(row, field, newValue);\n              XEUtils.set(oRow, field, newValue);\n            } else {\n              var newRecord = XEUtils.clone(__assign({}, record), true);\n              XEUtils.destructuring(oRow, Object.assign(row, newRecord));\n            }\n          }\n          reactData.tableData = tableData.slice(0);\n        } else {\n          if (false) {\n            warnLog(\"vxe.error.reqProp\", [\"keep-source\"]);\n          }\n        }\n        return nextTick();\n      },\n      /**\n       * 用于树结构，给行数据加载子节点\n       */\n      loadTreeChildren: function(row, childRecords) {\n        var keepSource = props.keepSource;\n        var tableSourceData = internalData.tableSourceData, fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData, sourceDataRowIdData = internalData.sourceDataRowIdData;\n        var treeOpts = computeTreeOpts.value;\n        var transform = treeOpts.transform, mapChildrenField = treeOpts.mapChildrenField;\n        var childrenField = treeOpts.children || treeOpts.childrenField;\n        var parentRest = fullAllDataRowIdData[getRowid($xetable, row)];\n        var parentLevel = parentRest ? parentRest.level : 0;\n        return tableMethods.createData(childRecords).then(function(rows) {\n          if (keepSource) {\n            var rowid_3 = getRowid($xetable, row);\n            var matchObj = XEUtils.findTree(tableSourceData, function(item) {\n              return rowid_3 === getRowid($xetable, item);\n            }, { children: childrenField });\n            if (matchObj) {\n              matchObj.item[childrenField] = XEUtils.clone(rows, true);\n            }\n            rows.forEach(function(childRow) {\n              var rowid = getRowid($xetable, childRow);\n              sourceDataRowIdData[rowid] = XEUtils.clone(childRow, true);\n            });\n          }\n          XEUtils.eachTree(rows, function(childRow, index, items, path, parent, nodes) {\n            var rowid = getRowid($xetable, childRow);\n            var parentRow = parent || parentRest.row;\n            var rest = { row: childRow, rowid, seq: -1, index, _index: -1, $index: -1, items, parent: parentRow, level: parentLevel + nodes.length };\n            fullDataRowIdData[rowid] = rest;\n            fullAllDataRowIdData[rowid] = rest;\n          }, { children: childrenField });\n          row[childrenField] = rows;\n          if (transform) {\n            row[mapChildrenField] = rows;\n          }\n          updateAfterDataIndex();\n          return rows;\n        });\n      },\n      /**\n       * 加载列配置\n       * 对于表格列需要重载、局部递增场景下可能会用到\n       * @param {ColumnInfo} columns 列配置\n       */\n      loadColumn: function(columns) {\n        var collectColumn = XEUtils.mapTree(columns, function(column) {\n          return reactive(Cell.createColumn($xetable, column));\n        });\n        return handleColumn(collectColumn);\n      },\n      /**\n       * 加载列配置并恢复到初始状态\n       * 对于表格列需要重载、局部递增场景下可能会用到\n       * @param {ColumnInfo} columns 列配置\n       */\n      reloadColumn: function(columns) {\n        return tableMethods.clearAll().then(function() {\n          return tableMethods.loadColumn(columns);\n        });\n      },\n      /**\n       * 根据 tr 元素获取对应的 row 信息\n       * @param {Element} tr 元素\n       */\n      getRowNode: function(tr) {\n        if (tr) {\n          var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n          var rowid = tr.getAttribute(\"rowid\");\n          if (rowid) {\n            var rest = fullAllDataRowIdData[rowid];\n            if (rest) {\n              return { rowid: rest.rowid, item: rest.row, index: rest.index, items: rest.items, parent: rest.parent };\n            }\n          }\n        }\n        return null;\n      },\n      /**\n       * 根据 th/td 元素获取对应的 column 信息\n       * @param {Element} cell 元素\n       */\n      getColumnNode: function(cell) {\n        if (cell) {\n          var fullColumnIdData = internalData.fullColumnIdData;\n          var colid = cell.getAttribute(\"colid\");\n          if (colid) {\n            var rest = fullColumnIdData[colid];\n            if (rest) {\n              return { colid: rest.colid, item: rest.column, index: rest.index, items: rest.items, parent: rest.parent };\n            }\n          }\n        }\n        return null;\n      },\n      /**\n       * 根据 row 获取序号\n       * @param {Row} row 行对象\n       */\n      getRowSeq: createGetRowCacheProp(\"seq\"),\n      /**\n       * 根据 row 获取相对于 data 中的索引\n       * @param {Row} row 行对象\n       */\n      getRowIndex: createGetRowCacheProp(\"index\"),\n      /**\n       * 根据 row 获取相对于当前数据中的索引\n       * @param {Row} row 行对象\n       */\n      getVTRowIndex: createGetRowCacheProp(\"_index\"),\n      /**\n       * 根据 row 获取渲染中的虚拟索引\n       * @param {Row} row 行对象\n       */\n      getVMRowIndex: createGetRowCacheProp(\"$index\"),\n      /**\n       * 根据 column 获取相对于 columns 中的索引\n       * @param {ColumnInfo} column 列配置\n       */\n      getColumnIndex: createGetColumnCacheProp(\"index\"),\n      /**\n       * 根据 column 获取相对于当前表格列中的索引\n       * @param {ColumnInfo} column 列配置\n       */\n      getVTColumnIndex: createGetColumnCacheProp(\"_index\"),\n      /**\n       * 根据 column 获取渲染中的虚拟索引\n       * @param {ColumnInfo} column 列配置\n       */\n      getVMColumnIndex: createGetColumnCacheProp(\"$index\"),\n      /**\n       * 创建 data 对象\n       * 对于某些特殊场景可能会用到，会自动对数据的字段名进行检测，如果不存在就自动定义\n       * @param {Array} records 新数据\n       */\n      createData: function(records) {\n        return nextTick().then(function() {\n          return reactive(tablePrivateMethods.defineField(records));\n        });\n      },\n      /**\n       * 创建 Row|Rows 对象\n       * 对于某些特殊场景需要对数据进行手动插入时可能会用到\n       * @param {Array/Object} records 新数据\n       */\n      createRow: function(records) {\n        var isArr = XEUtils.isArray(records);\n        if (!isArr) {\n          records = [records || {}];\n        }\n        return tableMethods.createData(records).then(function(rows) {\n          return isArr ? rows : rows[0];\n        });\n      },\n      /**\n       * 还原数据\n       * 如果不传任何参数，则还原整个表格\n       * 如果传 row 则还原一行\n       * 如果传 rows 则还原多行\n       * 如果还额外传了 field 则还原指定的单元格数据\n       */\n      revertData: function(rows, field) {\n        var keepSource = props.keepSource;\n        var tableSourceData = internalData.tableSourceData, sourceDataRowIdData = internalData.sourceDataRowIdData;\n        if (!keepSource) {\n          if (false) {\n            warnLog(\"vxe.error.reqProp\", [\"keep-source\"]);\n          }\n          return nextTick();\n        }\n        var targetRows = rows;\n        if (rows) {\n          if (!XEUtils.isArray(rows)) {\n            targetRows = [rows];\n          }\n        } else {\n          targetRows = XEUtils.toArray($xetable.getUpdateRecords());\n        }\n        if (targetRows.length) {\n          targetRows.forEach(function(row) {\n            if (!tableMethods.isInsertByRow(row)) {\n              var rowid = getRowid($xetable, row);\n              var oRow = sourceDataRowIdData[rowid];\n              if (oRow && row) {\n                if (field) {\n                  XEUtils.set(row, field, XEUtils.clone(XEUtils.get(oRow, field), true));\n                } else {\n                  XEUtils.destructuring(row, XEUtils.clone(oRow, true));\n                }\n              }\n            }\n          });\n        }\n        if (rows) {\n          return nextTick();\n        }\n        return tableMethods.reloadData(tableSourceData);\n      },\n      /**\n       * 清空单元格内容\n       * 如果不创参数，则清空整个表格内容\n       * 如果传 row 则清空一行内容\n       * 如果传 rows 则清空多行内容\n       * 如果还额外传了 field 则清空指定单元格内容\n       * @param {Array/Row} rows 行数据\n       * @param {String} field 字段名\n       */\n      clearData: function(rows, field) {\n        var tableFullData = internalData.tableFullData, visibleColumn = internalData.visibleColumn;\n        if (!arguments.length) {\n          rows = tableFullData;\n        } else if (rows && !XEUtils.isArray(rows)) {\n          rows = [rows];\n        }\n        if (field) {\n          rows.forEach(function(row) {\n            return XEUtils.set(row, field, null);\n          });\n        } else {\n          rows.forEach(function(row) {\n            visibleColumn.forEach(function(column) {\n              if (column.field) {\n                setCellValue(row, column, null);\n              }\n            });\n          });\n        }\n        return nextTick();\n      },\n      /**\n       * 检查是否为临时行数据\n       * @param {Row} row 行对象\n       */\n      isInsertByRow: function(row) {\n        var editStore = reactData.editStore;\n        var rowid = getRowid($xetable, row);\n        return editStore.insertMaps[rowid];\n      },\n      /**\n       * 删除所有新增的临时数据\n       * @returns\n       */\n      removeInsertRow: function() {\n        var editStore = reactData.editStore;\n        editStore.insertMaps = {};\n        return $xetable.remove($xetable.getInsertRecords());\n      },\n      /**\n       * 检查行或列数据是否发生改变\n       * @param {Row} row 行对象\n       * @param {String} field 字段名\n       */\n      isUpdateByRow: function(row, field) {\n        var keepSource = props.keepSource;\n        var tableFullColumn = internalData.tableFullColumn, fullDataRowIdData = internalData.fullDataRowIdData, sourceDataRowIdData = internalData.sourceDataRowIdData;\n        if (keepSource) {\n          var rowid = getRowid($xetable, row);\n          if (!fullDataRowIdData[rowid]) {\n            return false;\n          }\n          var oRow = sourceDataRowIdData[rowid];\n          if (oRow) {\n            if (arguments.length > 1) {\n              return !eqCellValue(oRow, row, field);\n            }\n            for (var index = 0, len = tableFullColumn.length; index < len; index++) {\n              var property = tableFullColumn[index].field;\n              if (property && !eqCellValue(oRow, row, property)) {\n                return true;\n              }\n            }\n          }\n        }\n        return false;\n      },\n      /**\n       * 获取表格的可视列，也可以指定索引获取列\n       * @param {Number} columnIndex 索引\n       */\n      getColumns: function(columnIndex) {\n        var columns = internalData.visibleColumn;\n        return XEUtils.isUndefined(columnIndex) ? columns.slice(0) : columns[columnIndex];\n      },\n      /**\n       * 根据列的唯一主键获取列\n       * @param {String} colid 列主键\n       */\n      getColumnById: function(colid) {\n        var fullColumnIdData = internalData.fullColumnIdData;\n        return fullColumnIdData[colid] ? fullColumnIdData[colid].column : null;\n      },\n      /**\n       * 根据列的字段名获取列\n       * @param {String} field 字段名\n       */\n      getColumnByField: function(field) {\n        var fullColumnFieldData = internalData.fullColumnFieldData;\n        return fullColumnFieldData[field] ? fullColumnFieldData[field].column : null;\n      },\n      /**\n       * 获取当前表格的列\n       * 收集到的全量列、全量表头列、处理条件之后的全量表头列、当前渲染中的表头列\n       */\n      getTableColumn: function() {\n        return {\n          collectColumn: internalData.collectColumn.slice(0),\n          fullColumn: internalData.tableFullColumn.slice(0),\n          visibleColumn: internalData.visibleColumn.slice(0),\n          tableColumn: reactData.tableColumn.slice(0)\n        };\n      },\n      /**\n       * 获取数据，和 data 的行为一致，也可以指定索引获取数据\n       */\n      getData: function(rowIndex) {\n        var tableSynchData = props.data || internalData.tableSynchData;\n        return XEUtils.isUndefined(rowIndex) ? tableSynchData.slice(0) : tableSynchData[rowIndex];\n      },\n      /**\n       * 用于多选行，获取已选中的数据\n       */\n      getCheckboxRecords: function(isFull) {\n        var treeConfig = props.treeConfig;\n        var tableFullData = internalData.tableFullData, afterFullData = internalData.afterFullData, afterTreeFullData = internalData.afterTreeFullData, tableFullTreeData = internalData.tableFullTreeData, fullDataRowIdData = internalData.fullDataRowIdData, afterFullRowMaps = internalData.afterFullRowMaps;\n        var treeOpts = computeTreeOpts.value;\n        var checkboxOpts = computeCheckboxOpts.value;\n        var transform = treeOpts.transform, mapChildrenField = treeOpts.mapChildrenField;\n        var checkField = checkboxOpts.checkField;\n        var childrenField = treeOpts.children || treeOpts.childrenField;\n        var rowList = [];\n        var currTableData = isFull ? transform ? tableFullTreeData : tableFullData : transform ? afterTreeFullData : afterFullData;\n        if (checkField) {\n          if (treeConfig) {\n            rowList = XEUtils.filterTree(currTableData, function(row) {\n              return XEUtils.get(row, checkField);\n            }, { children: transform ? mapChildrenField : childrenField });\n          } else {\n            rowList = currTableData.filter(function(row) {\n              return XEUtils.get(row, checkField);\n            });\n          }\n        } else {\n          var selectCheckboxMaps = reactData.selectCheckboxMaps;\n          XEUtils.each(selectCheckboxMaps, function(row, rowid) {\n            if (isFull ? fullDataRowIdData[rowid] : afterFullRowMaps[rowid]) {\n              rowList.push(row);\n            }\n          });\n        }\n        return rowList;\n      },\n      /**\n       * 只对 tree-config 有效，获取行的父级\n       */\n      getParentRow: function(rowOrRowid) {\n        var treeConfig = props.treeConfig;\n        var fullDataRowIdData = internalData.fullDataRowIdData;\n        if (rowOrRowid && treeConfig) {\n          var rowid = void 0;\n          if (XEUtils.isString(rowOrRowid)) {\n            rowid = rowOrRowid;\n          } else {\n            rowid = getRowid($xetable, rowOrRowid);\n          }\n          if (rowid) {\n            var rest = fullDataRowIdData[rowid];\n            return rest ? rest.parent : null;\n          }\n        }\n        return null;\n      },\n      /**\n       * 根据行的唯一主键获取行\n       * @param {String/Number} rowid 行主键\n       */\n      getRowById: function(cellValue) {\n        var fullDataRowIdData = internalData.fullDataRowIdData;\n        var rowid = XEUtils.eqNull(cellValue) ? \"\" : encodeURIComponent(cellValue);\n        return fullDataRowIdData[rowid] ? fullDataRowIdData[rowid].row : null;\n      },\n      /**\n       * 根据行获取行的唯一主键\n       * @param {Row} row 行对象\n       */\n      getRowid: function(row) {\n        return getRowid($xetable, row);\n      },\n      /**\n       * 获取处理后的表格数据\n       * 如果存在筛选条件，继续处理\n       * 如果存在排序，继续处理\n       */\n      getTableData: function() {\n        var tableData = reactData.tableData, footerTableData = reactData.footerTableData;\n        var tableFullData = internalData.tableFullData, afterFullData = internalData.afterFullData, tableFullTreeData = internalData.tableFullTreeData;\n        return {\n          fullData: props.treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0),\n          visibleData: afterFullData.slice(0),\n          tableData: tableData.slice(0),\n          footerData: footerTableData.slice(0)\n        };\n      },\n      /**\n       * 设置为固定列\n       */\n      setColumnFixed: function(fieldOrColumn, fixed) {\n        var column = handleFieldOrColumn($xetable, fieldOrColumn);\n        var targetColumn = getRootColumn($xetable, column);\n        var isMaxFixedColumn = computeIsMaxFixedColumn.value;\n        var columnOpts = computeColumnOpts.value;\n        var maxFixedSize = columnOpts.maxFixedSize;\n        if (targetColumn && targetColumn.fixed !== fixed) {\n          if (!targetColumn.fixed && isMaxFixedColumn) {\n            if (VXETable.modal) {\n              VXETable.modal.message({\n                status: \"error\",\n                content: GlobalConfig.i18n(\"vxe.table.maxFixedCol\", [maxFixedSize])\n              });\n            }\n            return nextTick();\n          }\n          XEUtils.eachTree([targetColumn], function(column2) {\n            column2.fixed = fixed;\n          });\n          tablePrivateMethods.saveCustomFixed();\n          return tableMethods.refreshColumn();\n        }\n        return nextTick();\n      },\n      /**\n       * 取消指定固定列\n       */\n      clearColumnFixed: function(fieldOrColumn) {\n        var column = handleFieldOrColumn($xetable, fieldOrColumn);\n        var targetColumn = getRootColumn($xetable, column);\n        if (targetColumn && targetColumn.fixed) {\n          XEUtils.eachTree([targetColumn], function(column2) {\n            column2.fixed = null;\n          });\n          tablePrivateMethods.saveCustomFixed();\n          return tableMethods.refreshColumn();\n        }\n        return nextTick();\n      },\n      /**\n       * 隐藏指定列\n       */\n      hideColumn: function(fieldOrColumn) {\n        var column = handleFieldOrColumn($xetable, fieldOrColumn);\n        if (column && column.visible) {\n          column.visible = false;\n          return tablePrivateMethods.handleCustom();\n        }\n        return nextTick();\n      },\n      /**\n       * 显示指定列\n       */\n      showColumn: function(fieldOrColumn) {\n        var column = handleFieldOrColumn($xetable, fieldOrColumn);\n        if (column && !column.visible) {\n          column.visible = true;\n          return tablePrivateMethods.handleCustom();\n        }\n        return nextTick();\n      },\n      setColumnWidth: function(fieldOrColumn, width) {\n        var column = handleFieldOrColumn($xetable, fieldOrColumn);\n        if (column) {\n          var colWidth = XEUtils.toInteger(width);\n          var rdWidth = colWidth;\n          if (isScale(width)) {\n            var tableBody = refTableBody.value;\n            var bodyElem = tableBody ? tableBody.$el : null;\n            var bodyWidth = bodyElem ? bodyElem.clientWidth - 1 : 0;\n            rdWidth = Math.floor(colWidth * bodyWidth);\n          }\n          column.renderWidth = rdWidth;\n        }\n        return nextTick();\n      },\n      getColumnWidth: function(fieldOrColumn) {\n        var column = handleFieldOrColumn($xetable, fieldOrColumn);\n        if (column) {\n          return column.renderWidth;\n        }\n        return 0;\n      },\n      /**\n       * 手动重置列的显示隐藏、列宽拖动的状态、固定列、排序列；\n       * 如果为 true 则重置所有状态\n       * 如果已关联工具栏，则会同步更新\n       */\n      resetColumn: function(options) {\n        var collectColumn = internalData.collectColumn;\n        var customOpts = computeCustomOpts.value;\n        var checkMethod = customOpts.checkMethod;\n        var opts = Object.assign({\n          visible: true,\n          resizable: options === true,\n          fixed: options === true\n        }, options);\n        XEUtils.eachTree(collectColumn, function(column) {\n          if (opts.resizable) {\n            column.resizeWidth = 0;\n          }\n          if (opts.fixed) {\n            column.fixed = column.defaultFixed;\n          }\n          if (!checkMethod || checkMethod({ column })) {\n            column.visible = column.defaultVisible;\n          }\n        });\n        if (opts.resizable) {\n          tablePrivateMethods.saveCustomResizable(true);\n        }\n        if (opts.fixed) {\n          tablePrivateMethods.saveCustomFixed();\n        }\n        return tablePrivateMethods.handleCustom();\n      },\n      /**\n       * 刷新列信息\n       * 将固定的列左边、右边分别靠边\n       */\n      refreshColumn: function() {\n        return parseColumns().then(function() {\n          return tableMethods.refreshScroll();\n        }).then(function() {\n          return tableMethods.recalculate();\n        });\n      },\n      /**\n       * 刷新滚动操作，手动同步滚动相关位置（对于某些特殊的操作，比如滚动条错位、固定列不同步）\n       */\n      refreshScroll: function() {\n        var lastScrollLeft = internalData.lastScrollLeft, lastScrollTop = internalData.lastScrollTop;\n        var tableBody = refTableBody.value;\n        var tableFooter = refTableFooter.value;\n        var leftBody = refTableLeftBody.value;\n        var rightBody = refTableRightBody.value;\n        var tableBodyElem = tableBody ? tableBody.$el : null;\n        var leftBodyElem = leftBody ? leftBody.$el : null;\n        var rightBodyElem = rightBody ? rightBody.$el : null;\n        var tableFooterElem = tableFooter ? tableFooter.$el : null;\n        return new Promise(function(resolve) {\n          if (lastScrollLeft || lastScrollTop) {\n            return restoreScrollLocation($xetable, lastScrollLeft, lastScrollTop).then().then(function() {\n              setTimeout(resolve, 30);\n            });\n          }\n          setScrollTop(tableBodyElem, lastScrollTop);\n          setScrollTop(leftBodyElem, lastScrollTop);\n          setScrollTop(rightBodyElem, lastScrollTop);\n          setScrollLeft(tableFooterElem, lastScrollLeft);\n          setTimeout(resolve, 30);\n        });\n      },\n      /**\n       * 计算单元格列宽，动态分配可用剩余空间\n       * 支持 width=? width=?px width=?% min-width=? min-width=?px min-width=?%\n       */\n      recalculate: function(refull) {\n        autoCellWidth();\n        if (refull === true) {\n          return computeScrollLoad().then(function() {\n            autoCellWidth();\n            return computeScrollLoad();\n          });\n        }\n        return computeScrollLoad();\n      },\n      openTooltip: function(target, content) {\n        var $commTip = refCommTooltip.value;\n        if ($commTip) {\n          return $commTip.open(target, content);\n        }\n        return nextTick();\n      },\n      /**\n       * 关闭 tooltip\n       */\n      closeTooltip: function() {\n        var tooltipStore = reactData.tooltipStore;\n        var $tooltip = refTooltip.value;\n        var $commTip = refCommTooltip.value;\n        if (tooltipStore.visible) {\n          Object.assign(tooltipStore, {\n            row: null,\n            column: null,\n            content: null,\n            visible: false\n          });\n          if ($tooltip) {\n            $tooltip.close();\n          }\n        }\n        if ($commTip) {\n          $commTip.close();\n        }\n        return nextTick();\n      },\n      /**\n       * 判断列头复选框是否被选中\n       */\n      isAllCheckboxChecked: function() {\n        return reactData.isAllSelected;\n      },\n      /**\n       * 判断列头复选框是否被半选\n       */\n      isAllCheckboxIndeterminate: function() {\n        return !reactData.isAllSelected && reactData.isIndeterminate;\n      },\n      /**\n       * 获取复选框半选状态的行数据\n       */\n      getCheckboxIndeterminateRecords: function(isFull) {\n        var treeConfig = props.treeConfig;\n        var fullDataRowIdData = internalData.fullDataRowIdData;\n        var treeIndeterminateMaps = reactData.treeIndeterminateMaps;\n        if (treeConfig) {\n          var fullRest_1 = [];\n          var defRest_1 = [];\n          XEUtils.each(treeIndeterminateMaps, function(item, rowid) {\n            if (item) {\n              fullRest_1.push(item);\n              if (fullDataRowIdData[rowid]) {\n                defRest_1.push(item);\n              }\n            }\n          });\n          if (isFull) {\n            return fullRest_1;\n          }\n          return defRest_1;\n        }\n        return [];\n      },\n      /**\n       * 用于多选行，设置行为选中状态，第二个参数为选中与否\n       * @param {Array/Row} rows 行数据\n       * @param {Boolean} value 是否选中\n       */\n      setCheckboxRow: function(rows, value) {\n        return handleCheckedCheckboxRow(rows, value, true);\n      },\n      isCheckedByCheckboxRow: function(row) {\n        var selectCheckboxMaps = reactData.selectCheckboxMaps;\n        var checkboxOpts = computeCheckboxOpts.value;\n        var checkField = checkboxOpts.checkField;\n        if (checkField) {\n          return XEUtils.get(row, checkField);\n        }\n        return !!selectCheckboxMaps[getRowid($xetable, row)];\n      },\n      isIndeterminateByCheckboxRow: function(row) {\n        var treeIndeterminateMaps = reactData.treeIndeterminateMaps;\n        return !!treeIndeterminateMaps[getRowid($xetable, row)] && !tableMethods.isCheckedByCheckboxRow(row);\n      },\n      /**\n       * 多选，切换某一行的选中状态\n       */\n      toggleCheckboxRow: function(row) {\n        var selectCheckboxMaps = reactData.selectCheckboxMaps;\n        var checkboxOpts = computeCheckboxOpts.value;\n        var checkField = checkboxOpts.checkField;\n        var value = checkField ? !XEUtils.get(row, checkField) : !selectCheckboxMaps[getRowid($xetable, row)];\n        tablePrivateMethods.handleSelectRow({ row }, value, true);\n        return nextTick();\n      },\n      /**\n       * 用于多选行，设置所有行的选中状态\n       * @param {Boolean} value 是否选中\n       */\n      setAllCheckboxRow: function(value) {\n        return handleCheckedAllCheckboxRow(value, true);\n      },\n      /**\n       * 获取单选框保留选中的行\n       */\n      getRadioReserveRecord: function(isFull) {\n        var treeConfig = props.treeConfig;\n        var fullDataRowIdData = internalData.fullDataRowIdData, radioReserveRow = internalData.radioReserveRow, afterFullData = internalData.afterFullData;\n        var radioOpts = computeRadioOpts.value;\n        var treeOpts = computeTreeOpts.value;\n        var childrenField = treeOpts.children || treeOpts.childrenField;\n        if (radioOpts.reserve && radioReserveRow) {\n          var rowid_4 = getRowid($xetable, radioReserveRow);\n          if (isFull) {\n            if (!fullDataRowIdData[rowid_4]) {\n              return radioReserveRow;\n            }\n          } else {\n            var rowkey_2 = getRowkey($xetable);\n            if (treeConfig) {\n              var matchObj = XEUtils.findTree(afterFullData, function(row) {\n                return rowid_4 === XEUtils.get(row, rowkey_2);\n              }, { children: childrenField });\n              if (matchObj) {\n                return radioReserveRow;\n              }\n            } else {\n              if (!afterFullData.some(function(row) {\n                return rowid_4 === XEUtils.get(row, rowkey_2);\n              })) {\n                return radioReserveRow;\n              }\n            }\n          }\n        }\n        return null;\n      },\n      clearRadioReserve: function() {\n        internalData.radioReserveRow = null;\n        return nextTick();\n      },\n      /**\n       * 获取复选框保留选中的行\n       */\n      getCheckboxReserveRecords: function(isFull) {\n        var treeConfig = props.treeConfig;\n        var afterFullData = internalData.afterFullData, fullDataRowIdData = internalData.fullDataRowIdData, checkboxReserveRowMap = internalData.checkboxReserveRowMap;\n        var checkboxOpts = computeCheckboxOpts.value;\n        var treeOpts = computeTreeOpts.value;\n        var childrenField = treeOpts.children || treeOpts.childrenField;\n        var reserveSelection = [];\n        if (checkboxOpts.reserve) {\n          var afterFullIdMaps_1 = {};\n          if (treeConfig) {\n            XEUtils.eachTree(afterFullData, function(row) {\n              afterFullIdMaps_1[getRowid($xetable, row)] = 1;\n            }, { children: childrenField });\n          } else {\n            afterFullData.forEach(function(row) {\n              afterFullIdMaps_1[getRowid($xetable, row)] = 1;\n            });\n          }\n          XEUtils.each(checkboxReserveRowMap, function(oldRow, oldRowid) {\n            if (oldRow) {\n              if (isFull) {\n                if (!fullDataRowIdData[oldRowid]) {\n                  reserveSelection.push(oldRow);\n                }\n              } else {\n                if (!afterFullIdMaps_1[oldRowid]) {\n                  reserveSelection.push(oldRow);\n                }\n              }\n            }\n          });\n        }\n        return reserveSelection;\n      },\n      clearCheckboxReserve: function() {\n        internalData.checkboxReserveRowMap = {};\n        return nextTick();\n      },\n      /**\n       * 多选，切换所有行的选中状态\n       */\n      toggleAllCheckboxRow: function() {\n        tablePrivateMethods.triggerCheckAllEvent(null, !reactData.isAllSelected);\n        return nextTick();\n      },\n      /**\n       * 用于多选行，手动清空用户的选择\n       * 清空行为不管是否被禁用还是保留记录，都将彻底清空选中状态\n       */\n      clearCheckboxRow: function() {\n        var treeConfig = props.treeConfig;\n        var tableFullData = internalData.tableFullData;\n        var treeOpts = computeTreeOpts.value;\n        var childrenField = treeOpts.children || treeOpts.childrenField;\n        var checkboxOpts = computeCheckboxOpts.value;\n        var checkField = checkboxOpts.checkField, reserve = checkboxOpts.reserve;\n        var indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;\n        if (checkField) {\n          var handleClearChecked = function(item) {\n            if (treeConfig && indeterminateField) {\n              XEUtils.set(item, indeterminateField, false);\n            }\n            XEUtils.set(item, checkField, false);\n          };\n          if (treeConfig) {\n            XEUtils.eachTree(tableFullData, handleClearChecked, { children: childrenField });\n          } else {\n            tableFullData.forEach(handleClearChecked);\n          }\n        }\n        if (reserve) {\n          tableFullData.forEach(function(row) {\n            return handleCheckboxReserveRow(row, false);\n          });\n        }\n        reactData.isAllSelected = false;\n        reactData.isIndeterminate = false;\n        reactData.selectCheckboxMaps = {};\n        reactData.treeIndeterminateMaps = {};\n        return nextTick();\n      },\n      /**\n       * 用于当前行，设置某一行为高亮状态\n       * @param {Row} row 行对象\n       */\n      setCurrentRow: function(row) {\n        var rowOpts = computeRowOpts.value;\n        var el = refElem.value;\n        tableMethods.clearCurrentRow();\n        reactData.currentRow = row;\n        if (rowOpts.isCurrent || props.highlightCurrentRow) {\n          if (el) {\n            XEUtils.arrayEach(el.querySelectorAll('[rowid=\"'.concat(getRowid($xetable, row), '\"]')), function(elem) {\n              return addClass(elem, \"row--current\");\n            });\n          }\n        }\n        return nextTick();\n      },\n      isCheckedByRadioRow: function(row) {\n        return $xetable.eqRow(reactData.selectRadioRow, row);\n      },\n      /**\n       * 用于单选行，设置某一行为选中状态\n       * @param {Row} row 行对象\n       */\n      setRadioRow: function(row) {\n        return handleCheckedRadioRow(row, true);\n      },\n      /**\n       * 用于当前行，手动清空当前高亮的状态\n       */\n      clearCurrentRow: function() {\n        var el = refElem.value;\n        reactData.currentRow = null;\n        internalData.hoverRow = null;\n        if (el) {\n          XEUtils.arrayEach(el.querySelectorAll(\".row--current\"), function(elem) {\n            return removeClass(elem, \"row--current\");\n          });\n        }\n        return nextTick();\n      },\n      /**\n       * 用于单选行，手动清空用户的选择\n       */\n      clearRadioRow: function() {\n        reactData.selectRadioRow = null;\n        return nextTick();\n      },\n      /**\n       * 用于当前行，获取当前行的数据\n       */\n      getCurrentRecord: function() {\n        var rowOpts = computeRowOpts.value;\n        return rowOpts.isCurrent || props.highlightCurrentRow ? reactData.currentRow : null;\n      },\n      /**\n       * 用于单选行，获取当已选中的数据\n       */\n      getRadioRecord: function(isFull) {\n        var fullDataRowIdData = internalData.fullDataRowIdData, afterFullRowMaps = internalData.afterFullRowMaps;\n        var selectRadioRow = reactData.selectRadioRow;\n        if (selectRadioRow) {\n          var rowid = getRowid($xetable, selectRadioRow);\n          if (isFull) {\n            if (!fullDataRowIdData[rowid]) {\n              return selectRadioRow;\n            }\n          } else {\n            if (afterFullRowMaps[rowid]) {\n              return selectRadioRow;\n            }\n          }\n        }\n        return null;\n      },\n      getCurrentColumn: function() {\n        var columnOpts = computeColumnOpts.value;\n        return columnOpts.isCurrent || props.highlightCurrentColumn ? reactData.currentColumn : null;\n      },\n      /**\n       * 用于当前列，设置某列行为高亮状态\n       */\n      setCurrentColumn: function(fieldOrColumn) {\n        var column = handleFieldOrColumn($xetable, fieldOrColumn);\n        if (column) {\n          tableMethods.clearCurrentColumn();\n          reactData.currentColumn = column;\n        }\n        return nextTick();\n      },\n      /**\n       * 用于当前列，手动清空当前高亮的状态\n       */\n      clearCurrentColumn: function() {\n        reactData.currentColumn = null;\n        return nextTick();\n      },\n      setPendingRow: function(rows, status) {\n        var pendingMaps = __assign({}, reactData.pendingRowMaps);\n        var pendingList = __spreadArray([], reactData.pendingRowList, true);\n        if (rows && !XEUtils.isArray(rows)) {\n          rows = [rows];\n        }\n        if (status) {\n          rows.forEach(function(row) {\n            var rowid = getRowid($xetable, row);\n            if (rowid && !pendingMaps[rowid]) {\n              pendingList.push(row);\n              pendingMaps[rowid] = row;\n            }\n          });\n        } else {\n          rows.forEach(function(row) {\n            var rowid = getRowid($xetable, row);\n            if (rowid && pendingMaps[rowid]) {\n              var pendingIndex = $xetable.findRowIndexOf(pendingList, row);\n              if (pendingIndex > -1) {\n                pendingList.splice(pendingIndex, 1);\n              }\n              delete pendingMaps[rowid];\n            }\n          });\n        }\n        reactData.pendingRowMaps = pendingMaps;\n        reactData.pendingRowList = pendingList;\n        return nextTick();\n      },\n      togglePendingRow: function(rows) {\n        var pendingMaps = __assign({}, reactData.pendingRowMaps);\n        var pendingList = __spreadArray([], reactData.pendingRowList, true);\n        if (rows && !XEUtils.isArray(rows)) {\n          rows = [rows];\n        }\n        rows.forEach(function(row) {\n          var rowid = getRowid($xetable, row);\n          if (rowid) {\n            if (pendingMaps[rowid]) {\n              var pendingIndex = $xetable.findRowIndexOf(pendingList, row);\n              if (pendingIndex > -1) {\n                pendingList.splice(pendingIndex, 1);\n              }\n              delete pendingMaps[rowid];\n            } else {\n              pendingList.push(row);\n              pendingMaps[rowid] = row;\n            }\n          }\n        });\n        reactData.pendingRowMaps = pendingMaps;\n        reactData.pendingRowList = pendingList;\n        return nextTick();\n      },\n      hasPendingByRow: function(row) {\n        var pendingRowMaps = reactData.pendingRowMaps;\n        var rowid = getRowid($xetable, row);\n        return !!pendingRowMaps[rowid];\n      },\n      getPendingRecords: function() {\n        var pendingRowList = reactData.pendingRowList;\n        return pendingRowList.slice(0);\n      },\n      clearPendingRow: function() {\n        reactData.pendingRowMaps = {};\n        reactData.pendingRowList = [];\n        return nextTick();\n      },\n      sort: function(sortConfs, sortOrder) {\n        var sortOpts = computeSortOpts.value;\n        var multiple = sortOpts.multiple, remote = sortOpts.remote, orders = sortOpts.orders;\n        if (sortConfs) {\n          if (XEUtils.isString(sortConfs)) {\n            sortConfs = [\n              { field: sortConfs, order: sortOrder }\n            ];\n          }\n        }\n        if (!XEUtils.isArray(sortConfs)) {\n          sortConfs = [sortConfs];\n        }\n        if (sortConfs.length) {\n          if (!multiple) {\n            clearAllSort();\n          }\n          (multiple ? sortConfs : [sortConfs[0]]).forEach(function(confs, index) {\n            var field = confs.field, order = confs.order;\n            var column = field;\n            if (XEUtils.isString(field)) {\n              column = tableMethods.getColumnByField(field);\n            }\n            if (column && column.sortable) {\n              if (orders.indexOf(order) === -1) {\n                order = getNextSortOrder(column);\n              }\n              if (column.order !== order) {\n                column.order = order;\n              }\n              column.sortTime = Date.now() + index;\n            }\n          });\n          if (!remote) {\n            tablePrivateMethods.handleTableData(true);\n          }\n          return nextTick().then(function() {\n            tableMethods.updateCellAreas();\n            return updateStyle();\n          });\n        }\n        return nextTick();\n      },\n      /**\n       * 清空指定列的排序条件\n       * 如果为空则清空所有列的排序条件\n       * @param {String} fieldOrColumn 列或字段名\n       */\n      clearSort: function(fieldOrColumn) {\n        var sortOpts = computeSortOpts.value;\n        if (fieldOrColumn) {\n          var column = handleFieldOrColumn($xetable, fieldOrColumn);\n          if (column) {\n            column.order = null;\n          }\n        } else {\n          clearAllSort();\n        }\n        if (!sortOpts.remote) {\n          tablePrivateMethods.handleTableData(true);\n        }\n        return nextTick().then(updateStyle);\n      },\n      isSort: function(fieldOrColumn) {\n        if (fieldOrColumn) {\n          var column = handleFieldOrColumn($xetable, fieldOrColumn);\n          return column ? column.sortable && !!column.order : false;\n        }\n        return tableMethods.getSortColumns().length > 0;\n      },\n      getSortColumns: function() {\n        var sortOpts = computeSortOpts.value;\n        var multiple = sortOpts.multiple, chronological = sortOpts.chronological;\n        var sortList = [];\n        var tableFullColumn = internalData.tableFullColumn;\n        tableFullColumn.forEach(function(column) {\n          var field = column.field, order = column.order;\n          if (column.sortable && order) {\n            sortList.push({ column, field, property: field, order, sortTime: column.sortTime });\n          }\n        });\n        if (multiple && chronological && sortList.length > 1) {\n          return XEUtils.orderBy(sortList, \"sortTime\");\n        }\n        return sortList;\n      },\n      /**\n       * 关闭筛选\n       * @param {Event} evnt 事件\n       */\n      closeFilter: function() {\n        var filterStore = reactData.filterStore;\n        var column = filterStore.column, visible = filterStore.visible;\n        Object.assign(filterStore, {\n          isAllSelected: false,\n          isIndeterminate: false,\n          options: [],\n          visible: false\n        });\n        if (visible) {\n          $xetable.dispatchEvent(\"filter-visible\", { column, property: column.field, field: column.field, filterList: $xetable.getCheckedFilters(), visible: false }, null);\n        }\n        return nextTick();\n      },\n      /**\n       * 判断指定列是否为筛选状态，如果为空则判断所有列\n       * @param {String} fieldOrColumn 字段名\n       */\n      isActiveFilterByColumn: function(fieldOrColumn) {\n        var column = handleFieldOrColumn($xetable, fieldOrColumn);\n        if (column) {\n          return column.filters && column.filters.some(function(option) {\n            return option.checked;\n          });\n        }\n        return $xetable.getCheckedFilters().length > 0;\n      },\n      isFilter: function(fieldOrColumn) {\n        return tableMethods.isActiveFilterByColumn(fieldOrColumn);\n      },\n      /**\n       * 判断展开行是否懒加载完成\n       * @param {Row} row 行对象\n       */\n      isRowExpandLoaded: function(row) {\n        var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n        var rest = fullAllDataRowIdData[getRowid($xetable, row)];\n        return rest && !!rest.expandLoaded;\n      },\n      clearRowExpandLoaded: function(row) {\n        var rowExpandLazyLoadedMaps = reactData.rowExpandLazyLoadedMaps;\n        var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n        var expandOpts = computeExpandOpts.value;\n        var lazy = expandOpts.lazy;\n        var rowid = getRowid($xetable, row);\n        var rest = fullAllDataRowIdData[rowid];\n        if (lazy && rest) {\n          rest.expandLoaded = false;\n          delete rowExpandLazyLoadedMaps[rowid];\n        }\n        return nextTick();\n      },\n      /**\n       * 重新懒加载展开行，并展开内容\n       * @param {Row} row 行对象\n       */\n      reloadRowExpand: function(row) {\n        var rowExpandLazyLoadedMaps = reactData.rowExpandLazyLoadedMaps;\n        var expandOpts = computeExpandOpts.value;\n        var lazy = expandOpts.lazy;\n        var rowid = getRowid($xetable, row);\n        if (lazy && !rowExpandLazyLoadedMaps[rowid]) {\n          tableMethods.clearRowExpandLoaded(row).then(function() {\n            return handleAsyncRowExpand(row);\n          });\n        }\n        return nextTick();\n      },\n      reloadExpandContent: function(row) {\n        if (false) {\n          warnLog(\"vxe.error.delFunc\", [\"reloadExpandContent\", \"reloadRowExpand\"]);\n        }\n        return tableMethods.reloadRowExpand(row);\n      },\n      /**\n       * 切换展开行\n       */\n      toggleRowExpand: function(row) {\n        return tableMethods.setRowExpand(row, !tableMethods.isRowExpandByRow(row));\n      },\n      /**\n       * 设置所有行的展开与否\n       * @param {Boolean} expanded 是否展开\n       */\n      setAllRowExpand: function(expanded) {\n        var treeOpts = computeTreeOpts.value;\n        var tableFullData = internalData.tableFullData, tableFullTreeData = internalData.tableFullTreeData;\n        var childrenField = treeOpts.children || treeOpts.childrenField;\n        var expandedRows = [];\n        if (props.treeConfig) {\n          XEUtils.eachTree(tableFullTreeData, function(row) {\n            expandedRows.push(row);\n          }, { children: childrenField });\n        } else {\n          expandedRows = tableFullData;\n        }\n        return tableMethods.setRowExpand(expandedRows, expanded);\n      },\n      /**\n       * 设置展开行，二个参数设置这一行展开与否\n       * 支持单行\n       * 支持多行\n       * @param {Array/Row} rows 行数据\n       * @param {Boolean} expanded 是否展开\n       */\n      setRowExpand: function(rows, expanded) {\n        var rowExpandedMaps = reactData.rowExpandedMaps, rowExpandLazyLoadedMaps = reactData.rowExpandLazyLoadedMaps, column = reactData.expandColumn;\n        var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n        var rExpandedMaps = __assign({}, rowExpandedMaps);\n        var expandOpts = computeExpandOpts.value;\n        var reserve = expandOpts.reserve, lazy = expandOpts.lazy, accordion = expandOpts.accordion, toggleMethod = expandOpts.toggleMethod;\n        var lazyRests = [];\n        var columnIndex = tableMethods.getColumnIndex(column);\n        var $columnIndex = tableMethods.getVMColumnIndex(column);\n        if (rows) {\n          if (!XEUtils.isArray(rows)) {\n            rows = [rows];\n          }\n          if (accordion) {\n            rExpandedMaps = {};\n            rows = rows.slice(rows.length - 1, rows.length);\n          }\n          var validRows = toggleMethod ? rows.filter(function(row) {\n            return toggleMethod({ $table: $xetable, expanded, column, columnIndex, $columnIndex, row, rowIndex: tableMethods.getRowIndex(row), $rowIndex: tableMethods.getVMRowIndex(row) });\n          }) : rows;\n          if (expanded) {\n            validRows.forEach(function(row) {\n              var rowid = getRowid($xetable, row);\n              if (!rExpandedMaps[rowid]) {\n                var rest = fullAllDataRowIdData[rowid];\n                var isLoad = lazy && !rest.expandLoaded && !rowExpandLazyLoadedMaps[rowid];\n                if (isLoad) {\n                  lazyRests.push(handleAsyncRowExpand(row));\n                } else {\n                  rExpandedMaps[rowid] = row;\n                }\n              }\n            });\n          } else {\n            validRows.forEach(function(item) {\n              var rowid = getRowid($xetable, item);\n              if (rExpandedMaps[rowid]) {\n                delete rExpandedMaps[rowid];\n              }\n            });\n          }\n          if (reserve) {\n            validRows.forEach(function(row) {\n              return handleRowExpandReserve(row, expanded);\n            });\n          }\n        }\n        reactData.rowExpandedMaps = rExpandedMaps;\n        return Promise.all(lazyRests).then(function() {\n          return tableMethods.recalculate();\n        });\n      },\n      /**\n       * 判断行是否为展开状态\n       * @param {Row} row 行对象\n       */\n      isRowExpandByRow: function(row) {\n        var rowExpandedMaps = reactData.rowExpandedMaps;\n        var rowid = getRowid($xetable, row);\n        return !!rowExpandedMaps[rowid];\n      },\n      isExpandByRow: function(row) {\n        return tableMethods.isRowExpandByRow(row);\n      },\n      /**\n       * 手动清空展开行状态，数据会恢复成未展开的状态\n       */\n      clearRowExpand: function() {\n        var tableFullData = internalData.tableFullData;\n        var expandOpts = computeExpandOpts.value;\n        var reserve = expandOpts.reserve;\n        var expList = tableMethods.getRowExpandRecords();\n        reactData.rowExpandedMaps = {};\n        if (reserve) {\n          tableFullData.forEach(function(row) {\n            return handleRowExpandReserve(row, false);\n          });\n        }\n        return nextTick().then(function() {\n          if (expList.length) {\n            tableMethods.recalculate();\n          }\n        });\n      },\n      clearRowExpandReserve: function() {\n        internalData.rowExpandedReserveRowMap = {};\n        return nextTick();\n      },\n      getRowExpandRecords: function() {\n        var rest = [];\n        XEUtils.each(reactData.rowExpandedMaps, function(item) {\n          if (item) {\n            rest.push(item);\n          }\n        });\n        return rest;\n      },\n      getTreeExpandRecords: function() {\n        var rest = [];\n        XEUtils.each(reactData.treeExpandedMaps, function(item) {\n          if (item) {\n            rest.push(item);\n          }\n        });\n        return rest;\n      },\n      /**\n       * 判断树节点是否懒加载完成\n       * @param {Row} row 行对象\n       */\n      isTreeExpandLoaded: function(row) {\n        var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n        var rest = fullAllDataRowIdData[getRowid($xetable, row)];\n        return rest && !!rest.treeLoaded;\n      },\n      clearTreeExpandLoaded: function(row) {\n        var treeExpandedMaps = reactData.treeExpandedMaps;\n        var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n        var treeOpts = computeTreeOpts.value;\n        var transform = treeOpts.transform, lazy = treeOpts.lazy;\n        var rowid = getRowid($xetable, row);\n        var rest = fullAllDataRowIdData[rowid];\n        if (lazy && rest) {\n          rest.treeLoaded = false;\n          if (treeExpandedMaps[rowid]) {\n            delete treeExpandedMaps[rowid];\n          }\n        }\n        if (transform) {\n          handleVirtualTreeToList();\n          return tablePrivateMethods.handleTableData();\n        }\n        return nextTick();\n      },\n      /**\n       * 重新懒加载树节点，并展开该节点\n       * @param {Row} row 行对象\n       */\n      reloadTreeExpand: function(row) {\n        var treeExpandLazyLoadedMaps = reactData.treeExpandLazyLoadedMaps;\n        var treeOpts = computeTreeOpts.value;\n        var hasChildField = treeOpts.hasChild || treeOpts.hasChildField;\n        var transform = treeOpts.transform, lazy = treeOpts.lazy;\n        var rowid = getRowid($xetable, row);\n        if (lazy && row[hasChildField] && !treeExpandLazyLoadedMaps[rowid]) {\n          tableMethods.clearTreeExpandLoaded(row).then(function() {\n            return handleAsyncTreeExpandChilds(row);\n          }).then(function() {\n            if (transform) {\n              handleVirtualTreeToList();\n              return tablePrivateMethods.handleTableData();\n            }\n          }).then(function() {\n            return tableMethods.recalculate();\n          });\n        }\n        return nextTick();\n      },\n      reloadTreeChilds: function(row) {\n        if (false) {\n          warnLog(\"vxe.error.delFunc\", [\"reloadTreeChilds\", \"reloadTreeExpand\"]);\n        }\n        return tableMethods.reloadTreeExpand(row);\n      },\n      /**\n       * 切换/展开树节点\n       */\n      toggleTreeExpand: function(row) {\n        return tableMethods.setTreeExpand(row, !tableMethods.isTreeExpandByRow(row));\n      },\n      /**\n       * 设置所有树节点的展开与否\n       * @param {Boolean} expanded 是否展开\n       */\n      setAllTreeExpand: function(expanded) {\n        var tableFullData = internalData.tableFullData;\n        var treeOpts = computeTreeOpts.value;\n        var transform = treeOpts.transform, lazy = treeOpts.lazy;\n        var childrenField = treeOpts.children || treeOpts.childrenField;\n        var expandeds = [];\n        XEUtils.eachTree(tableFullData, function(row) {\n          var rowChildren = row[childrenField];\n          if (lazy || rowChildren && rowChildren.length) {\n            expandeds.push(row);\n          }\n        }, { children: childrenField });\n        return tableMethods.setTreeExpand(expandeds, expanded).then(function() {\n          if (transform) {\n            handleVirtualTreeToList();\n            return tableMethods.recalculate();\n          }\n        });\n      },\n      /**\n       * 设置展开树形节点，二个参数设置这一行展开与否\n       * 支持单行\n       * 支持多行\n       * @param {Array/Row} rows 行数据\n       * @param {Boolean} expanded 是否展开\n       */\n      setTreeExpand: function(rows, expanded) {\n        var treeOpts = computeTreeOpts.value;\n        var transform = treeOpts.transform;\n        if (rows) {\n          if (!XEUtils.isArray(rows)) {\n            rows = [rows];\n          }\n          if (rows.length) {\n            if (transform) {\n              return handleVirtualTreeExpand(rows, expanded);\n            } else {\n              return handleBaseTreeExpand(rows, expanded);\n            }\n          }\n        }\n        return nextTick();\n      },\n      /**\n       * 判断行是否为树形节点展开状态\n       * @param {Row} row 行对象\n       */\n      isTreeExpandByRow: function(row) {\n        var treeExpandedMaps = reactData.treeExpandedMaps;\n        return !!treeExpandedMaps[getRowid($xetable, row)];\n      },\n      /**\n       * 手动清空树形节点的展开状态，数据会恢复成未展开的状态\n       */\n      clearTreeExpand: function() {\n        var tableFullTreeData = internalData.tableFullTreeData;\n        var treeOpts = computeTreeOpts.value;\n        var childrenField = treeOpts.children || treeOpts.childrenField;\n        var transform = treeOpts.transform, reserve = treeOpts.reserve;\n        var expList = tableMethods.getTreeExpandRecords();\n        reactData.treeExpandedMaps = {};\n        if (reserve) {\n          XEUtils.eachTree(tableFullTreeData, function(row) {\n            return handleTreeExpandReserve(row, false);\n          }, { children: childrenField });\n        }\n        return tablePrivateMethods.handleTableData().then(function() {\n          if (transform) {\n            handleVirtualTreeToList();\n            return tablePrivateMethods.handleTableData();\n          }\n        }).then(function() {\n          if (expList.length) {\n            return tableMethods.recalculate();\n          }\n        });\n      },\n      clearTreeExpandReserve: function() {\n        internalData.treeExpandedReserveRowMap = {};\n        return nextTick();\n      },\n      /**\n       * 获取表格的滚动状态\n       */\n      getScroll: function() {\n        var scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad;\n        var tableBody = refTableBody.value;\n        var bodyElem = tableBody.$el;\n        return {\n          virtualX: scrollXLoad,\n          virtualY: scrollYLoad,\n          scrollTop: bodyElem.scrollTop,\n          scrollLeft: bodyElem.scrollLeft\n        };\n      },\n      /**\n       * 如果有滚动条，则滚动到对应的位置\n       * @param {Number} scrollLeft 左距离\n       * @param {Number} scrollTop 上距离\n       */\n      scrollTo: function(scrollLeft, scrollTop) {\n        var tableBody = refTableBody.value;\n        var tableFooter = refTableFooter.value;\n        var rightBody = refTableRightBody.value;\n        var tableBodyElem = tableBody ? tableBody.$el : null;\n        var rightBodyElem = rightBody ? rightBody.$el : null;\n        var tableFooterElem = tableFooter ? tableFooter.$el : null;\n        if (XEUtils.isNumber(scrollLeft)) {\n          setScrollLeft(tableFooterElem || tableBodyElem, scrollLeft);\n        }\n        if (XEUtils.isNumber(scrollTop)) {\n          setScrollTop(rightBodyElem || tableBodyElem, scrollTop);\n        }\n        if (reactData.scrollXLoad || reactData.scrollYLoad) {\n          return new Promise(function(resolve) {\n            setTimeout(function() {\n              nextTick(function() {\n                resolve();\n              });\n            }, 50);\n          });\n        }\n        return nextTick();\n      },\n      /**\n       * 如果有滚动条，则滚动到对应的行\n       * @param {Row} row 行对象\n       * @param {ColumnInfo} fieldOrColumn 列配置\n       */\n      scrollToRow: function(row, fieldOrColumn) {\n        var rest = [];\n        if (row) {\n          if (props.treeConfig) {\n            rest.push(tablePrivateMethods.scrollToTreeRow(row));\n          } else {\n            rest.push(rowToVisible($xetable, row));\n          }\n        }\n        if (fieldOrColumn) {\n          rest.push(tableMethods.scrollToColumn(fieldOrColumn));\n        }\n        return Promise.all(rest);\n      },\n      /**\n       * 如果有滚动条，则滚动到对应的列\n       */\n      scrollToColumn: function(fieldOrColumn) {\n        var fullColumnIdData = internalData.fullColumnIdData;\n        var column = handleFieldOrColumn($xetable, fieldOrColumn);\n        if (column && fullColumnIdData[column.id]) {\n          return colToVisible($xetable, column);\n        }\n        return nextTick();\n      },\n      /**\n       * 手动清除滚动相关信息，还原到初始状态\n       */\n      clearScroll: function() {\n        var scrollXStore = internalData.scrollXStore, scrollYStore = internalData.scrollYStore;\n        var tableBody = refTableBody.value;\n        var tableFooter = refTableFooter.value;\n        var rightBody = refTableRightBody.value;\n        var tableBodyElem = tableBody ? tableBody.$el : null;\n        var rightBodyElem = rightBody ? rightBody.$el : null;\n        var tableFooterElem = tableFooter ? tableFooter.$el : null;\n        if (rightBodyElem) {\n          restoreScrollListener(rightBodyElem);\n          rightBodyElem.scrollTop = 0;\n        }\n        if (tableFooterElem) {\n          tableFooterElem.scrollLeft = 0;\n        }\n        if (tableBodyElem) {\n          restoreScrollListener(tableBodyElem);\n          tableBodyElem.scrollTop = 0;\n          tableBodyElem.scrollLeft = 0;\n        }\n        scrollXStore.startIndex = 0;\n        scrollYStore.startIndex = 0;\n        return nextTick();\n      },\n      /**\n       * 更新表尾合计\n       */\n      updateFooter: function() {\n        var showFooter = props.showFooter, footerMethod = props.footerMethod;\n        var visibleColumn = internalData.visibleColumn, afterFullData = internalData.afterFullData;\n        if (showFooter && footerMethod) {\n          reactData.footerTableData = visibleColumn.length ? footerMethod({ columns: visibleColumn, data: afterFullData, $table: $xetable, $grid: $xegrid }) : [];\n        }\n        return nextTick();\n      },\n      /**\n       * 更新列状态 updateStatus({ row, column }, cellValue)\n       * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一列编辑状态\n       * 如果单元格配置了校验规则，则会进行校验\n       */\n      updateStatus: function(slotParams, cellValue) {\n        var customVal = !XEUtils.isUndefined(cellValue);\n        return nextTick().then(function() {\n          var editRules = props.editRules;\n          var validStore = reactData.validStore;\n          var tableBody = refTableBody.value;\n          if (slotParams && tableBody && editRules) {\n            var row_1 = slotParams.row, column_3 = slotParams.column;\n            var type = \"change\";\n            if ($xetable.hasCellRules) {\n              if ($xetable.hasCellRules(type, row_1, column_3)) {\n                var cell_1 = tablePrivateMethods.getCell(row_1, column_3);\n                if (cell_1) {\n                  return $xetable.validCellRules(type, row_1, column_3, cellValue).then(function() {\n                    if (customVal && validStore.visible) {\n                      setCellValue(row_1, column_3, cellValue);\n                    }\n                    $xetable.clearValidate(row_1, column_3);\n                  }).catch(function(_a) {\n                    var rule = _a.rule;\n                    if (customVal) {\n                      setCellValue(row_1, column_3, cellValue);\n                    }\n                    $xetable.showValidTooltip({ rule, row: row_1, column: column_3, cell: cell_1 });\n                  });\n                }\n              }\n            }\n          }\n        });\n      },\n      /**\n       * 设置合并单元格\n       * @param {TableMergeConfig[]} merges { row: Row|number, column: ColumnInfo|number, rowspan: number, colspan: number }\n       */\n      setMergeCells: function(merges) {\n        if (props.spanMethod) {\n          errLog(\"vxe.error.errConflicts\", [\"merge-cells\", \"span-method\"]);\n        }\n        setMerges(merges, reactData.mergeList, internalData.afterFullData);\n        return nextTick().then(function() {\n          return tableMethods.updateCellAreas();\n        });\n      },\n      /**\n       * 移除单元格合并\n       * @param {TableMergeConfig[]} merges 多个或数组 [{row:Row|number, col:ColumnInfo|number}]\n       */\n      removeMergeCells: function(merges) {\n        if (props.spanMethod) {\n          errLog(\"vxe.error.errConflicts\", [\"merge-cells\", \"span-method\"]);\n        }\n        var rest = removeMerges(merges, reactData.mergeList, internalData.afterFullData);\n        return nextTick().then(function() {\n          tableMethods.updateCellAreas();\n          return rest;\n        });\n      },\n      /**\n       * 获取所有被合并的单元格\n       */\n      getMergeCells: function() {\n        return reactData.mergeList.slice(0);\n      },\n      /**\n       * 清除所有单元格合并\n       */\n      clearMergeCells: function() {\n        reactData.mergeList = [];\n        return nextTick();\n      },\n      setMergeFooterItems: function(merges) {\n        if (props.footerSpanMethod) {\n          errLog(\"vxe.error.errConflicts\", [\"merge-footer-items\", \"footer-span-method\"]);\n        }\n        setMerges(merges, reactData.mergeFooterList);\n        return nextTick().then(function() {\n          return tableMethods.updateCellAreas();\n        });\n      },\n      removeMergeFooterItems: function(merges) {\n        if (props.footerSpanMethod) {\n          errLog(\"vxe.error.errConflicts\", [\"merge-footer-items\", \"footer-span-method\"]);\n        }\n        var rest = removeMerges(merges, reactData.mergeFooterList);\n        return nextTick().then(function() {\n          tableMethods.updateCellAreas();\n          return rest;\n        });\n      },\n      /**\n       * 获取所有被合并的表尾\n       */\n      getMergeFooterItems: function() {\n        return reactData.mergeFooterList.slice(0);\n      },\n      /**\n       * 清除所有表尾合并\n       */\n      clearMergeFooterItems: function() {\n        reactData.mergeFooterList = [];\n        return nextTick();\n      },\n      updateCellAreas: function() {\n        var mouseConfig = props.mouseConfig;\n        var mouseOpts = computeMouseOpts.value;\n        if (mouseConfig && mouseOpts.area && $xetable.handleUpdateCellAreas) {\n          return $xetable.handleUpdateCellAreas();\n        }\n        return nextTick();\n      },\n      focus: function() {\n        internalData.isActivated = true;\n        return nextTick();\n      },\n      blur: function() {\n        internalData.isActivated = false;\n        return nextTick();\n      },\n      /**\n       * 连接工具栏\n       * @param $toolbar\n       */\n      connect: function($toolbar) {\n        if ($toolbar) {\n          $xetoolbar = $toolbar;\n          $xetoolbar.syncUpdate({ collectColumn: internalData.collectColumn, $table: $xetable });\n        } else {\n          errLog(\"vxe.error.barUnableLink\");\n        }\n        return nextTick();\n      }\n    };\n    var handleGlobalMousedownEvent = function(evnt) {\n      var editStore = reactData.editStore, ctxMenuStore = reactData.ctxMenuStore, filterStore = reactData.filterStore;\n      var mouseConfig = props.mouseConfig, editRules = props.editRules;\n      var el = refElem.value;\n      var editOpts = computeEditOpts.value;\n      var validOpts = computeValidOpts.value;\n      var actived = editStore.actived;\n      var $validTooltip = refValidTooltip.value;\n      var tableFilter = refTableFilter.value;\n      var tableMenu = refTableMenu.value;\n      if (tableFilter) {\n        if (getEventTargetNode(evnt, el, \"vxe-cell--filter\").flag) {\n        } else if (getEventTargetNode(evnt, tableFilter.$el).flag) {\n        } else {\n          if (!getEventTargetNode(evnt, document.body, \"vxe-table--ignore-clear\").flag) {\n            tablePrivateMethods.preventEvent(evnt, \"event.clearFilter\", filterStore.args, tableMethods.closeFilter);\n          }\n        }\n      }\n      if (actived.row) {\n        if (!(editOpts.autoClear === false)) {\n          var cell = actived.args.cell;\n          if (!cell || !getEventTargetNode(evnt, cell).flag) {\n            if ($validTooltip && getEventTargetNode(evnt, $validTooltip.$el).flag) {\n            } else if (!internalData._lastCallTime || internalData._lastCallTime + 50 < Date.now()) {\n              if (!getEventTargetNode(evnt, document.body, \"vxe-table--ignore-clear\").flag) {\n                tablePrivateMethods.preventEvent(evnt, \"event.clearActived\", actived.args, function() {\n                  var isClear;\n                  if (editOpts.mode === \"row\") {\n                    var rowTargetNode = getEventTargetNode(evnt, el, \"vxe-body--row\");\n                    var rowNodeRest = rowTargetNode.flag ? tableMethods.getRowNode(rowTargetNode.targetElem) : null;\n                    isClear = rowNodeRest ? !$xetable.eqRow(rowNodeRest.item, actived.args.row) : false;\n                  } else {\n                    isClear = !getEventTargetNode(evnt, el, \"col--edit\").flag;\n                  }\n                  if (!isClear) {\n                    isClear = getEventTargetNode(evnt, el, \"vxe-header--row\").flag;\n                  }\n                  if (!isClear) {\n                    isClear = getEventTargetNode(evnt, el, \"vxe-footer--row\").flag;\n                  }\n                  if (!isClear && props.height && !reactData.overflowY) {\n                    var bodyWrapperElem = evnt.target;\n                    if (hasClass(bodyWrapperElem, \"vxe-table--body-wrapper\")) {\n                      isClear = evnt.offsetY < bodyWrapperElem.clientHeight;\n                    }\n                  }\n                  if (isClear || // 如果点击了当前表格之外\n                  !getEventTargetNode(evnt, el).flag) {\n                    setTimeout(function() {\n                      return $xetable.clearEdit(evnt);\n                    });\n                  }\n                });\n              }\n            }\n          }\n        }\n      } else if (mouseConfig) {\n        if (!getEventTargetNode(evnt, el).flag && !($xegrid && getEventTargetNode(evnt, $xegrid.getRefMaps().refElem.value).flag) && !(tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) && !($xetoolbar && getEventTargetNode(evnt, $xetoolbar.getRefMaps().refElem.value).flag)) {\n          $xetable.clearSelected();\n          if ($xetable.clearCellAreas) {\n            if (!getEventTargetNode(evnt, document.body, \"vxe-table--ignore-areas-clear\").flag) {\n              tablePrivateMethods.preventEvent(evnt, \"event.clearAreas\", {}, function() {\n                $xetable.clearCellAreas();\n                $xetable.clearCopyCellArea();\n              });\n            }\n          }\n        }\n      }\n      if ($xetable.closeMenu) {\n        if (ctxMenuStore.visible && tableMenu && !getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {\n          $xetable.closeMenu();\n        }\n      }\n      var isActivated = getEventTargetNode(evnt, $xegrid ? $xegrid.getRefMaps().refElem.value : el).flag;\n      if (!isActivated && editRules && validOpts.autoClear) {\n        reactData.validErrorMaps = {};\n      }\n      internalData.isActivated = isActivated;\n    };\n    var handleGlobalBlurEvent = function() {\n      tableMethods.closeFilter();\n      if ($xetable.closeMenu) {\n        $xetable.closeMenu();\n      }\n    };\n    var handleGlobalMousewheelEvent = function() {\n      tableMethods.closeTooltip();\n      if ($xetable.closeMenu) {\n        $xetable.closeMenu();\n      }\n    };\n    var keydownEvent = function(evnt) {\n      var mouseConfig = props.mouseConfig, keyboardConfig = props.keyboardConfig;\n      var filterStore = reactData.filterStore, ctxMenuStore = reactData.ctxMenuStore, editStore = reactData.editStore;\n      var mouseOpts = computeMouseOpts.value;\n      var keyboardOpts = computeKeyboardOpts.value;\n      var actived = editStore.actived;\n      var isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);\n      if (isEsc) {\n        tablePrivateMethods.preventEvent(evnt, \"event.keydown\", null, function() {\n          tableMethods.dispatchEvent(\"keydown-start\", {}, evnt);\n          if (keyboardConfig && mouseConfig && mouseOpts.area && $xetable.handleKeyboardEvent) {\n            $xetable.handleKeyboardEvent(evnt);\n          } else if (actived.row || filterStore.visible || ctxMenuStore.visible) {\n            evnt.stopPropagation();\n            if ($xetable.closeMenu) {\n              $xetable.closeMenu();\n            }\n            tableMethods.closeFilter();\n            if (keyboardConfig && keyboardOpts.isEsc) {\n              if (actived.row) {\n                var params_1 = actived.args;\n                $xetable.clearEdit(evnt);\n                if (mouseOpts.selected) {\n                  nextTick(function() {\n                    return $xetable.handleSelected(params_1, evnt);\n                  });\n                }\n              }\n            }\n          }\n          tableMethods.dispatchEvent(\"keydown\", {}, evnt);\n          tableMethods.dispatchEvent(\"keydown-end\", {}, evnt);\n        });\n      }\n    };\n    var handleGlobalKeydownEvent = function(evnt) {\n      if (internalData.isActivated) {\n        tablePrivateMethods.preventEvent(evnt, \"event.keydown\", null, function() {\n          var mouseConfig = props.mouseConfig, keyboardConfig = props.keyboardConfig, treeConfig = props.treeConfig, editConfig = props.editConfig, highlightCurrentRow = props.highlightCurrentRow;\n          var ctxMenuStore = reactData.ctxMenuStore, editStore = reactData.editStore, currentRow = reactData.currentRow;\n          var isMenu = computeIsMenu.value;\n          var bodyMenu = computeBodyMenu.value;\n          var keyboardOpts = computeKeyboardOpts.value;\n          var mouseOpts = computeMouseOpts.value;\n          var editOpts = computeEditOpts.value;\n          var treeOpts = computeTreeOpts.value;\n          var menuList = computeMenuList.value;\n          var rowOpts = computeRowOpts.value;\n          var selected = editStore.selected, actived = editStore.actived;\n          var childrenField = treeOpts.children || treeOpts.childrenField;\n          var keyCode = evnt.keyCode;\n          var isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);\n          var isBack = hasEventKey(evnt, EVENT_KEYS.BACKSPACE);\n          var isTab = hasEventKey(evnt, EVENT_KEYS.TAB);\n          var isEnter = hasEventKey(evnt, EVENT_KEYS.ENTER);\n          var isSpacebar = hasEventKey(evnt, EVENT_KEYS.SPACEBAR);\n          var isLeftArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_LEFT);\n          var isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);\n          var isRightArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_RIGHT);\n          var isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);\n          var isDel = hasEventKey(evnt, EVENT_KEYS.DELETE);\n          var isF2 = hasEventKey(evnt, EVENT_KEYS.F2);\n          var isContextMenu = hasEventKey(evnt, EVENT_KEYS.CONTEXT_MENU);\n          var hasMetaKey = evnt.metaKey;\n          var hasCtrlKey = evnt.ctrlKey;\n          var hasShiftKey = evnt.shiftKey;\n          var isAltKey = evnt.altKey;\n          var operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;\n          var operCtxMenu = isMenu && ctxMenuStore.visible && (isEnter || isSpacebar || operArrow);\n          var isEditStatus = isEnableConf(editConfig) && actived.column && actived.row;\n          var params;\n          if (operCtxMenu) {\n            evnt.preventDefault();\n            if (ctxMenuStore.showChild && hasChildrenList(ctxMenuStore.selected)) {\n              $xetable.moveCtxMenu(evnt, ctxMenuStore, \"selectChild\", isLeftArrow, false, ctxMenuStore.selected.children);\n            } else {\n              $xetable.moveCtxMenu(evnt, ctxMenuStore, \"selected\", isRightArrow, true, menuList);\n            }\n          } else if (keyboardConfig && mouseConfig && mouseOpts.area && $xetable.handleKeyboardEvent) {\n            $xetable.handleKeyboardEvent(evnt);\n          } else if (isEsc) {\n            if ($xetable.closeMenu) {\n              $xetable.closeMenu();\n            }\n            tableMethods.closeFilter();\n            if (keyboardConfig && keyboardOpts.isEsc) {\n              if (actived.row) {\n                var params_2 = actived.args;\n                $xetable.clearEdit(evnt);\n                if (mouseOpts.selected) {\n                  nextTick(function() {\n                    return $xetable.handleSelected(params_2, evnt);\n                  });\n                }\n              }\n            }\n          } else if (isSpacebar && keyboardConfig && keyboardOpts.isChecked && selected.row && selected.column && (selected.column.type === \"checkbox\" || selected.column.type === \"radio\")) {\n            evnt.preventDefault();\n            if (selected.column.type === \"checkbox\") {\n              tablePrivateMethods.handleToggleCheckRowEvent(evnt, selected.args);\n            } else {\n              tablePrivateMethods.triggerRadioRowEvent(evnt, selected.args);\n            }\n          } else if (isF2 && isEnableConf(editConfig)) {\n            if (!isEditStatus) {\n              if (selected.row && selected.column) {\n                evnt.preventDefault();\n                $xetable.handleActived(selected.args, evnt);\n              }\n            }\n          } else if (isContextMenu) {\n            internalData._keyCtx = selected.row && selected.column && bodyMenu.length;\n            clearTimeout(keyCtxTimeout);\n            keyCtxTimeout = setTimeout(function() {\n              internalData._keyCtx = false;\n            }, 1e3);\n          } else if (isEnter && !isAltKey && keyboardConfig && keyboardOpts.isEnter && (selected.row || actived.row || treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow)) {\n            if (hasCtrlKey) {\n              if (actived.row) {\n                params = actived.args;\n                $xetable.clearEdit(evnt);\n                if (mouseOpts.selected) {\n                  nextTick(function() {\n                    return $xetable.handleSelected(params, evnt);\n                  });\n                }\n              }\n            } else {\n              if (selected.row || actived.row) {\n                var targetArgs = selected.row ? selected.args : actived.args;\n                if (hasShiftKey) {\n                  if (keyboardOpts.enterToTab) {\n                    $xetable.moveTabSelected(targetArgs, hasShiftKey, evnt);\n                  } else {\n                    $xetable.moveSelected(targetArgs, isLeftArrow, true, isRightArrow, false, evnt);\n                  }\n                } else {\n                  if (keyboardOpts.enterToTab) {\n                    $xetable.moveTabSelected(targetArgs, hasShiftKey, evnt);\n                  } else {\n                    $xetable.moveSelected(targetArgs, isLeftArrow, false, isRightArrow, true, evnt);\n                  }\n                }\n              } else if (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {\n                var childrens = currentRow[childrenField];\n                if (childrens && childrens.length) {\n                  evnt.preventDefault();\n                  var targetRow_1 = childrens[0];\n                  params = {\n                    $table: $xetable,\n                    row: targetRow_1,\n                    rowIndex: tableMethods.getRowIndex(targetRow_1),\n                    $rowIndex: tableMethods.getVMRowIndex(targetRow_1)\n                  };\n                  tableMethods.setTreeExpand(currentRow, true).then(function() {\n                    return tableMethods.scrollToRow(targetRow_1);\n                  }).then(function() {\n                    return tablePrivateMethods.triggerCurrentRowEvent(evnt, params);\n                  });\n                }\n              }\n            }\n          } else if (operArrow && keyboardConfig && keyboardOpts.isArrow) {\n            if (!isEditStatus) {\n              if (selected.row && selected.column) {\n                $xetable.moveSelected(selected.args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt);\n              } else if ((isUpArrow || isDwArrow) && (rowOpts.isCurrent || highlightCurrentRow)) {\n                $xetable.moveCurrentRow(isUpArrow, isDwArrow, evnt);\n              }\n            }\n          } else if (isTab && keyboardConfig && keyboardOpts.isTab) {\n            if (selected.row || selected.column) {\n              $xetable.moveTabSelected(selected.args, hasShiftKey, evnt);\n            } else if (actived.row || actived.column) {\n              $xetable.moveTabSelected(actived.args, hasShiftKey, evnt);\n            }\n          } else if (keyboardConfig && isEnableConf(editConfig) && (isDel || (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow ? isBack && keyboardOpts.isArrow : isBack))) {\n            if (!isEditStatus) {\n              var delMethod = keyboardOpts.delMethod, backMethod = keyboardOpts.backMethod;\n              if (keyboardOpts.isDel && (selected.row || selected.column)) {\n                if (delMethod) {\n                  delMethod({\n                    row: selected.row,\n                    rowIndex: tableMethods.getRowIndex(selected.row),\n                    column: selected.column,\n                    columnIndex: tableMethods.getColumnIndex(selected.column),\n                    $table: $xetable\n                  });\n                } else {\n                  setCellValue(selected.row, selected.column, null);\n                }\n                if (isBack) {\n                  if (backMethod) {\n                    backMethod({\n                      row: selected.row,\n                      rowIndex: tableMethods.getRowIndex(selected.row),\n                      column: selected.column,\n                      columnIndex: tableMethods.getColumnIndex(selected.column),\n                      $table: $xetable\n                    });\n                  } else {\n                    $xetable.handleActived(selected.args, evnt);\n                  }\n                } else if (isDel) {\n                  tableMethods.updateFooter();\n                }\n              } else if (isBack && keyboardOpts.isArrow && treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {\n                var parentRow_1 = XEUtils.findTree(internalData.afterFullData, function(item) {\n                  return item === currentRow;\n                }, { children: childrenField }).parent;\n                if (parentRow_1) {\n                  evnt.preventDefault();\n                  params = {\n                    $table: $xetable,\n                    row: parentRow_1,\n                    rowIndex: tableMethods.getRowIndex(parentRow_1),\n                    $rowIndex: tableMethods.getVMRowIndex(parentRow_1)\n                  };\n                  tableMethods.setTreeExpand(parentRow_1, false).then(function() {\n                    return tableMethods.scrollToRow(parentRow_1);\n                  }).then(function() {\n                    return tablePrivateMethods.triggerCurrentRowEvent(evnt, params);\n                  });\n                }\n              }\n            }\n          } else if (keyboardConfig && isEnableConf(editConfig) && keyboardOpts.isEdit && !hasCtrlKey && !hasMetaKey && (isSpacebar || keyCode >= 48 && keyCode <= 57 || keyCode >= 65 && keyCode <= 90 || keyCode >= 96 && keyCode <= 111 || keyCode >= 186 && keyCode <= 192 || keyCode >= 219 && keyCode <= 222)) {\n            var editMethod = keyboardOpts.editMethod;\n            if (selected.column && selected.row && isEnableConf(selected.column.editRender)) {\n              var beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;\n              if (!beforeEditMethod || beforeEditMethod(__assign(__assign({}, selected.args), { $table: $xetable, $grid: $xegrid }))) {\n                if (editMethod) {\n                  editMethod({\n                    row: selected.row,\n                    rowIndex: tableMethods.getRowIndex(selected.row),\n                    column: selected.column,\n                    columnIndex: tableMethods.getColumnIndex(selected.column),\n                    $table: $xetable,\n                    $grid: $xegrid\n                  });\n                } else {\n                  setCellValue(selected.row, selected.column, null);\n                  $xetable.handleActived(selected.args, evnt);\n                }\n              }\n            }\n          }\n          tableMethods.dispatchEvent(\"keydown\", {}, evnt);\n        });\n      }\n    };\n    var handleGlobalPasteEvent = function(evnt) {\n      var keyboardConfig = props.keyboardConfig, mouseConfig = props.mouseConfig;\n      var editStore = reactData.editStore, filterStore = reactData.filterStore;\n      var isActivated = internalData.isActivated;\n      var mouseOpts = computeMouseOpts.value;\n      var keyboardOpts = computeKeyboardOpts.value;\n      var actived = editStore.actived;\n      if (isActivated && !filterStore.visible) {\n        if (!(actived.row || actived.column)) {\n          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handlePasteCellAreaEvent) {\n            $xetable.handlePasteCellAreaEvent(evnt);\n          }\n        }\n        tableMethods.dispatchEvent(\"paste\", {}, evnt);\n      }\n    };\n    var handleGlobalCopyEvent = function(evnt) {\n      var keyboardConfig = props.keyboardConfig, mouseConfig = props.mouseConfig;\n      var editStore = reactData.editStore, filterStore = reactData.filterStore;\n      var isActivated = internalData.isActivated;\n      var mouseOpts = computeMouseOpts.value;\n      var keyboardOpts = computeKeyboardOpts.value;\n      var actived = editStore.actived;\n      if (isActivated && !filterStore.visible) {\n        if (!(actived.row || actived.column)) {\n          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handleCopyCellAreaEvent) {\n            $xetable.handleCopyCellAreaEvent(evnt);\n          }\n        }\n        tableMethods.dispatchEvent(\"copy\", {}, evnt);\n      }\n    };\n    var handleGlobalCutEvent = function(evnt) {\n      var keyboardConfig = props.keyboardConfig, mouseConfig = props.mouseConfig;\n      var editStore = reactData.editStore, filterStore = reactData.filterStore;\n      var isActivated = internalData.isActivated;\n      var mouseOpts = computeMouseOpts.value;\n      var keyboardOpts = computeKeyboardOpts.value;\n      var actived = editStore.actived;\n      if (isActivated && !filterStore.visible) {\n        if (!(actived.row || actived.column)) {\n          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handleCutCellAreaEvent) {\n            $xetable.handleCutCellAreaEvent(evnt);\n          }\n        }\n        tableMethods.dispatchEvent(\"cut\", {}, evnt);\n      }\n    };\n    var handleGlobalResizeEvent = function() {\n      if ($xetable.closeMenu) {\n        $xetable.closeMenu();\n      }\n      tableMethods.updateCellAreas();\n      tableMethods.recalculate(true);\n    };\n    var handleTargetEnterEvent = function(isClear) {\n      var $tooltip = refTooltip.value;\n      clearTimeout(internalData.tooltipTimeout);\n      if (isClear) {\n        tableMethods.closeTooltip();\n      } else {\n        if ($tooltip) {\n          $tooltip.setActived(true);\n        }\n      }\n    };\n    var handleTooltip = function(evnt, cell, overflowElem, tipElem, params) {\n      params.cell = cell;\n      var tooltipStore = reactData.tooltipStore;\n      var tooltipOpts = computeTooltipOpts.value;\n      var column = params.column, row = params.row;\n      var showAll = tooltipOpts.showAll, contentMethod = tooltipOpts.contentMethod;\n      var customContent = contentMethod ? contentMethod(params) : null;\n      var useCustom = contentMethod && !XEUtils.eqNull(customContent);\n      var content = useCustom ? customContent : XEUtils.toString(column.type === \"html\" ? overflowElem.innerText : overflowElem.textContent).trim();\n      var isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;\n      if (content && (showAll || useCustom || isCellOverflow)) {\n        Object.assign(tooltipStore, {\n          row,\n          column,\n          visible: true,\n          currOpts: null\n        });\n        nextTick(function() {\n          var $tooltip = refTooltip.value;\n          if ($tooltip) {\n            $tooltip.open(isCellOverflow ? overflowElem : tipElem || overflowElem, formatText(content));\n          }\n        });\n      }\n      return nextTick();\n    };\n    tablePrivateMethods = {\n      getSetupOptions: function() {\n        return GlobalConfig;\n      },\n      updateAfterDataIndex,\n      callSlot: function(slotFunc, params) {\n        if (slotFunc) {\n          if ($xegrid) {\n            return $xegrid.callSlot(slotFunc, params);\n          }\n          if (XEUtils.isFunction(slotFunc)) {\n            return getSlotVNs(slotFunc(params));\n          }\n        }\n        return [];\n      },\n      /**\n       * 获取父容器元素\n       */\n      getParentElem: function() {\n        var el = refElem.value;\n        if ($xegrid) {\n          var gridEl = $xegrid.getRefMaps().refElem.value;\n          return gridEl ? gridEl.parentNode : null;\n        }\n        return el ? el.parentNode : null;\n      },\n      /**\n       * 获取父容器的高度\n       */\n      getParentHeight: function() {\n        var height = props.height;\n        var el = refElem.value;\n        if (el) {\n          var parentElem = el.parentNode;\n          var parentPaddingSize = height === \"auto\" ? getPaddingTopBottomSize(parentElem) : 0;\n          return Math.floor($xegrid ? $xegrid.getParentHeight() : XEUtils.toNumber(getComputedStyle(parentElem).height) - parentPaddingSize);\n        }\n        return 0;\n      },\n      /**\n       * 获取需要排除的高度\n       * 但渲染表格高度时，需要排除工具栏或分页等相关组件的高度\n       * 如果存在表尾合计滚动条，则需要排除滚动条高度\n       */\n      getExcludeHeight: function() {\n        return $xegrid ? $xegrid.getExcludeHeight() : 0;\n      },\n      /**\n       * 定义行数据中的列属性，如果不存在则定义\n       * @param {Row} records 行数据\n       */\n      defineField: function(records) {\n        var treeConfig = props.treeConfig;\n        var expandOpts = computeExpandOpts.value;\n        var treeOpts = computeTreeOpts.value;\n        var radioOpts = computeRadioOpts.value;\n        var checkboxOpts = computeCheckboxOpts.value;\n        var childrenField = treeOpts.children || treeOpts.childrenField;\n        var rowkey = getRowkey($xetable);\n        if (!XEUtils.isArray(records)) {\n          records = [records];\n        }\n        return records.map(function(record) {\n          internalData.tableFullColumn.forEach(function(column) {\n            var field = column.field, editRender = column.editRender;\n            if (field && !XEUtils.has(record, field) && !record[field]) {\n              var cellValue = null;\n              if (editRender) {\n                var defaultValue = editRender.defaultValue;\n                if (XEUtils.isFunction(defaultValue)) {\n                  cellValue = defaultValue({ column });\n                } else if (!XEUtils.isUndefined(defaultValue)) {\n                  cellValue = defaultValue;\n                }\n              }\n              XEUtils.set(record, field, cellValue);\n            }\n          });\n          var otherFields = [radioOpts.labelField, checkboxOpts.checkField, checkboxOpts.labelField, expandOpts.labelField];\n          otherFields.forEach(function(key) {\n            if (key && eqEmptyValue(XEUtils.get(record, key))) {\n              XEUtils.set(record, key, null);\n            }\n          });\n          if (treeConfig && treeOpts.lazy && XEUtils.isUndefined(record[childrenField])) {\n            record[childrenField] = null;\n          }\n          if (eqEmptyValue(XEUtils.get(record, rowkey))) {\n            XEUtils.set(record, rowkey, getRowUniqueId());\n          }\n          return record;\n        });\n      },\n      handleTableData: function(force) {\n        var scrollYLoad = reactData.scrollYLoad;\n        var scrollYStore = internalData.scrollYStore, fullDataRowIdData = internalData.fullDataRowIdData;\n        var fullList = internalData.afterFullData;\n        if (force) {\n          updateAfterFullData();\n          fullList = handleVirtualTreeToList();\n        }\n        var tableData = scrollYLoad ? fullList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullList.slice(0);\n        tableData.forEach(function(row, $index) {\n          var rowid = getRowid($xetable, row);\n          var rest = fullDataRowIdData[rowid];\n          if (rest) {\n            rest.$index = $index;\n          }\n        });\n        reactData.tableData = tableData;\n        return nextTick();\n      },\n      /**\n       * 更新数据行的 Map\n       * 牺牲数据组装的耗时，用来换取使用过程中的流畅\n       */\n      cacheRowMap: function(isSource) {\n        var treeConfig = props.treeConfig;\n        var treeOpts = computeTreeOpts.value;\n        var fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData, tableFullData = internalData.tableFullData, tableFullTreeData = internalData.tableFullTreeData;\n        var childrenField = treeOpts.children || treeOpts.childrenField;\n        var hasChildField = treeOpts.hasChild || treeOpts.hasChildField;\n        var rowkey = getRowkey($xetable);\n        var isLazy = treeConfig && treeOpts.lazy;\n        var handleRow = function(row, index, items, path, parent, nodes) {\n          var rowid = getRowid($xetable, row);\n          var seq = treeConfig && path ? toTreePathSeq(path) : index + 1;\n          var level = nodes ? nodes.length - 1 : 0;\n          if (eqEmptyValue(rowid)) {\n            rowid = getRowUniqueId();\n            XEUtils.set(row, rowkey, rowid);\n          }\n          if (isLazy && row[hasChildField] && XEUtils.isUndefined(row[childrenField])) {\n            row[childrenField] = null;\n          }\n          var rest = { row, rowid, seq, index: treeConfig && parent ? -1 : index, _index: -1, $index: -1, items, parent, level };\n          if (isSource) {\n            fullDataRowIdData[rowid] = rest;\n          }\n          fullAllDataRowIdData[rowid] = rest;\n        };\n        if (isSource) {\n          fullDataRowIdData = internalData.fullDataRowIdData = {};\n        }\n        fullAllDataRowIdData = internalData.fullAllDataRowIdData = {};\n        if (treeConfig) {\n          XEUtils.eachTree(tableFullTreeData, handleRow, { children: childrenField });\n        } else {\n          tableFullData.forEach(handleRow);\n        }\n      },\n      cacheSourceMap: function(fullData) {\n        var treeConfig = props.treeConfig;\n        var treeOpts = computeTreeOpts.value;\n        var sourceDataRowIdData = internalData.sourceDataRowIdData;\n        var sourceData = XEUtils.clone(fullData, true);\n        var rowkey = getRowkey($xetable);\n        sourceDataRowIdData = internalData.sourceDataRowIdData = {};\n        var handleSourceRow = function(row) {\n          var rowid = getRowid($xetable, row);\n          if (eqEmptyValue(rowid)) {\n            rowid = getRowUniqueId();\n            XEUtils.set(row, rowkey, rowid);\n          }\n          sourceDataRowIdData[rowid] = row;\n        };\n        if (treeConfig) {\n          var childrenField = treeOpts.children || treeOpts.childrenField;\n          XEUtils.eachTree(sourceData, handleSourceRow, { children: treeOpts.transform ? treeOpts.mapChildrenField : childrenField });\n        } else {\n          sourceData.forEach(handleSourceRow);\n        }\n        internalData.tableSourceData = sourceData;\n      },\n      /**\n       * 指定列宽的列进行拆分\n       */\n      analyColumnWidth: function() {\n        var tableFullColumn = internalData.tableFullColumn;\n        var columnOpts = computeColumnOpts.value;\n        var defaultWidth = columnOpts.width, defaultMinWidth = columnOpts.minWidth;\n        var resizeList = [];\n        var pxList = [];\n        var pxMinList = [];\n        var scaleList = [];\n        var scaleMinList = [];\n        var autoList = [];\n        tableFullColumn.forEach(function(column) {\n          if (defaultWidth && !column.width) {\n            column.width = defaultWidth;\n          }\n          if (defaultMinWidth && !column.minWidth) {\n            column.minWidth = defaultMinWidth;\n          }\n          if (column.visible) {\n            if (column.resizeWidth) {\n              resizeList.push(column);\n            } else if (isPx(column.width)) {\n              pxList.push(column);\n            } else if (isScale(column.width)) {\n              scaleList.push(column);\n            } else if (isPx(column.minWidth)) {\n              pxMinList.push(column);\n            } else if (isScale(column.minWidth)) {\n              scaleMinList.push(column);\n            } else {\n              autoList.push(column);\n            }\n          }\n        });\n        Object.assign(reactData.columnStore, { resizeList, pxList, pxMinList, scaleList, scaleMinList, autoList });\n      },\n      saveCustomResizable: function(isReset) {\n        var id = props.id, customConfig = props.customConfig;\n        var customOpts = computeCustomOpts.value;\n        var collectColumn = internalData.collectColumn;\n        var storage = customOpts.storage;\n        var isResizable = storage === true || storage && storage.resizable;\n        if (customConfig && isResizable) {\n          var columnWidthStorageMap = getCustomStorageMap(resizableStorageKey);\n          var columnWidthStorage_1;\n          if (!id) {\n            errLog(\"vxe.error.reqProp\", [\"id\"]);\n            return;\n          }\n          if (!isReset) {\n            columnWidthStorage_1 = XEUtils.isPlainObject(columnWidthStorageMap[id]) ? columnWidthStorageMap[id] : {};\n            XEUtils.eachTree(collectColumn, function(column) {\n              if (column.resizeWidth) {\n                var colKey = column.getKey();\n                if (colKey) {\n                  columnWidthStorage_1[colKey] = column.renderWidth;\n                }\n              }\n            });\n          }\n          columnWidthStorageMap[id] = XEUtils.isEmpty(columnWidthStorage_1) ? void 0 : columnWidthStorage_1;\n          localStorage.setItem(resizableStorageKey, XEUtils.toJSONString(columnWidthStorageMap));\n        }\n      },\n      saveCustomFixed: function() {\n        var id = props.id, customConfig = props.customConfig;\n        var collectColumn = internalData.collectColumn;\n        var customOpts = computeCustomOpts.value;\n        var storage = customOpts.storage;\n        var isCustomFixed = storage === true || storage && storage.fixed;\n        if (customConfig && isCustomFixed) {\n          var columnFixedStorageMap = getCustomStorageMap(fixedStorageKey);\n          var colFixeds_1 = [];\n          if (!id) {\n            errLog(\"vxe.error.reqProp\", [\"id\"]);\n            return;\n          }\n          XEUtils.eachTree(collectColumn, function(column) {\n            if (column.fixed && column.fixed !== column.defaultFixed) {\n              var colKey = column.getKey();\n              if (colKey) {\n                colFixeds_1.push(\"\".concat(colKey, \"|\").concat(column.fixed));\n              }\n            }\n          });\n          columnFixedStorageMap[id] = colFixeds_1.join(\",\") || void 0;\n          localStorage.setItem(fixedStorageKey, XEUtils.toJSONString(columnFixedStorageMap));\n        }\n      },\n      saveCustomVisible: function() {\n        var id = props.id, customConfig = props.customConfig;\n        var collectColumn = internalData.collectColumn;\n        var customOpts = computeCustomOpts.value;\n        var checkMethod = customOpts.checkMethod, storage = customOpts.storage;\n        var isCustomVisible = storage === true || storage && storage.visible;\n        if (customConfig && isCustomVisible) {\n          var columnVisibleStorageMap = getCustomStorageMap(visibleStorageKey);\n          var colHides_1 = [];\n          var colShows_1 = [];\n          if (!id) {\n            errLog(\"vxe.error.reqProp\", [\"id\"]);\n            return;\n          }\n          XEUtils.eachTree(collectColumn, function(column) {\n            if (!checkMethod || checkMethod({ column })) {\n              if (!column.visible && column.defaultVisible) {\n                var colKey = column.getKey();\n                if (colKey) {\n                  colHides_1.push(colKey);\n                }\n              } else if (column.visible && !column.defaultVisible) {\n                var colKey = column.getKey();\n                if (colKey) {\n                  colShows_1.push(colKey);\n                }\n              }\n            }\n          });\n          columnVisibleStorageMap[id] = [colHides_1.join(\",\")].concat(colShows_1.length ? [colShows_1.join(\",\")] : []).join(\"|\") || void 0;\n          localStorage.setItem(visibleStorageKey, XEUtils.toJSONString(columnVisibleStorageMap));\n        }\n      },\n      handleCustom: function() {\n        tablePrivateMethods.saveCustomVisible();\n        tablePrivateMethods.analyColumnWidth();\n        return tableMethods.refreshColumn();\n      },\n      handleUpdateDataQueue: function() {\n        reactData.upDataFlag++;\n      },\n      handleRefreshColumnQueue: function() {\n        reactData.reColumnFlag++;\n      },\n      preventEvent: function(evnt, type, args, next, end) {\n        var evntList = VXETable.interceptor.get(type);\n        var rest;\n        if (!evntList.some(function(func) {\n          return func(Object.assign({ $grid: $xegrid, $table: $xetable, $event: evnt }, args)) === false;\n        })) {\n          if (next) {\n            rest = next();\n          }\n        }\n        if (end) {\n          end();\n        }\n        return rest;\n      },\n      checkSelectionStatus: function() {\n        var treeConfig = props.treeConfig;\n        var selectCheckboxMaps = reactData.selectCheckboxMaps, treeIndeterminateMaps = reactData.treeIndeterminateMaps;\n        var afterFullData = internalData.afterFullData;\n        var checkboxOpts = computeCheckboxOpts.value;\n        var checkField = checkboxOpts.checkField, checkStrictly = checkboxOpts.checkStrictly, checkMethod = checkboxOpts.checkMethod;\n        var indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;\n        if (!checkStrictly) {\n          var disableRows_1 = [];\n          var checkRows_1 = [];\n          var isAllResolve = false;\n          var isAllSelected = false;\n          var isIndeterminate = false;\n          if (checkField) {\n            isAllResolve = afterFullData.every(checkMethod ? function(row) {\n              if (!checkMethod({ row })) {\n                disableRows_1.push(row);\n                return true;\n              }\n              if (XEUtils.get(row, checkField)) {\n                checkRows_1.push(row);\n                return true;\n              }\n              return false;\n            } : function(row) {\n              return XEUtils.get(row, checkField);\n            });\n            isAllSelected = isAllResolve && afterFullData.length !== disableRows_1.length;\n            if (treeConfig) {\n              if (indeterminateField) {\n                isIndeterminate = !isAllSelected && afterFullData.some(function(row) {\n                  return XEUtils.get(row, checkField) || XEUtils.get(row, indeterminateField) || !!treeIndeterminateMaps[getRowid($xetable, row)];\n                });\n              } else {\n                isIndeterminate = !isAllSelected && afterFullData.some(function(row) {\n                  return XEUtils.get(row, checkField) || !!treeIndeterminateMaps[getRowid($xetable, row)];\n                });\n              }\n            } else {\n              if (indeterminateField) {\n                isIndeterminate = !isAllSelected && afterFullData.some(function(row) {\n                  return XEUtils.get(row, checkField) || XEUtils.get(row, indeterminateField);\n                });\n              } else {\n                isIndeterminate = !isAllSelected && afterFullData.some(function(row) {\n                  return XEUtils.get(row, checkField);\n                });\n              }\n            }\n          } else {\n            isAllResolve = afterFullData.every(checkMethod ? function(row) {\n              if (!checkMethod({ row })) {\n                disableRows_1.push(row);\n                return true;\n              }\n              if (selectCheckboxMaps[getRowid($xetable, row)]) {\n                checkRows_1.push(row);\n                return true;\n              }\n              return false;\n            } : function(row) {\n              return selectCheckboxMaps[getRowid($xetable, row)];\n            });\n            isAllSelected = isAllResolve && afterFullData.length !== disableRows_1.length;\n            if (treeConfig) {\n              isIndeterminate = !isAllSelected && afterFullData.some(function(row) {\n                var itemRid = getRowid($xetable, row);\n                return treeIndeterminateMaps[itemRid] || selectCheckboxMaps[itemRid];\n              });\n            } else {\n              isIndeterminate = !isAllSelected && afterFullData.some(function(row) {\n                return selectCheckboxMaps[getRowid($xetable, row)];\n              });\n            }\n          }\n          reactData.isAllSelected = isAllSelected;\n          reactData.isIndeterminate = isIndeterminate;\n        }\n      },\n      /**\n       * 多选，行选中事件\n       * value 选中true 不选false 半选-1\n       */\n      handleSelectRow: function(_a, value, isForce) {\n        var row = _a.row;\n        var treeConfig = props.treeConfig;\n        var selectCheckboxMaps = reactData.selectCheckboxMaps, treeIndeterminateMaps = reactData.treeIndeterminateMaps;\n        var selectRowMaps = __assign({}, selectCheckboxMaps);\n        var afterFullData = internalData.afterFullData;\n        var treeOpts = computeTreeOpts.value;\n        var childrenField = treeOpts.children || treeOpts.childrenField;\n        var checkboxOpts = computeCheckboxOpts.value;\n        var checkField = checkboxOpts.checkField, checkStrictly = checkboxOpts.checkStrictly, checkMethod = checkboxOpts.checkMethod;\n        var indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;\n        var rowid = getRowid($xetable, row);\n        if (checkField) {\n          if (treeConfig && !checkStrictly) {\n            if (value === -1) {\n              if (!treeIndeterminateMaps[rowid]) {\n                if (indeterminateField) {\n                  XEUtils.set(row, indeterminateField, true);\n                }\n                treeIndeterminateMaps[rowid] = row;\n              }\n              XEUtils.set(row, checkField, false);\n            } else {\n              XEUtils.eachTree([row], function(item) {\n                if ($xetable.eqRow(item, row) || (isForce || (!checkMethod || checkMethod({ row: item })))) {\n                  XEUtils.set(item, checkField, value);\n                  if (indeterminateField) {\n                    XEUtils.set(row, indeterminateField, false);\n                  }\n                  delete treeIndeterminateMaps[getRowid($xetable, item)];\n                  handleCheckboxReserveRow(row, value);\n                }\n              }, { children: childrenField });\n            }\n            var matchObj = XEUtils.findTree(afterFullData, function(item) {\n              return $xetable.eqRow(item, row);\n            }, { children: childrenField });\n            if (matchObj && matchObj.parent) {\n              var parentStatus = void 0;\n              var vItems_1 = [];\n              var vItemMaps_1 = {};\n              if (!isForce && checkMethod) {\n                matchObj.items.forEach(function(item) {\n                  if (checkMethod({ row: item })) {\n                    var itemRid = getRowid($xetable, item);\n                    vItemMaps_1[itemRid] = item;\n                    vItems_1.push(item);\n                  }\n                });\n              } else {\n                matchObj.items.forEach(function(item) {\n                  var itemRid = getRowid($xetable, item);\n                  vItemMaps_1[itemRid] = item;\n                  vItems_1.push(item);\n                });\n              }\n              var indeterminatesItem = XEUtils.find(matchObj.items, function(item) {\n                return !!treeIndeterminateMaps[getRowid($xetable, item)];\n              });\n              if (indeterminatesItem) {\n                parentStatus = -1;\n              } else {\n                var selectItems_1 = [];\n                matchObj.items.forEach(function(item) {\n                  if (XEUtils.get(item, checkField)) {\n                    selectItems_1.push(item);\n                  }\n                });\n                parentStatus = selectItems_1.filter(function(item) {\n                  return vItemMaps_1[getRowid($xetable, item)];\n                }).length === vItems_1.length ? true : selectItems_1.length || value === -1 ? -1 : false;\n              }\n              reactData.selectCheckboxMaps = selectRowMaps;\n              return tablePrivateMethods.handleSelectRow({ row: matchObj.parent }, parentStatus, isForce);\n            }\n          } else {\n            if (isForce || (!checkMethod || checkMethod({ row }))) {\n              XEUtils.set(row, checkField, value);\n              handleCheckboxReserveRow(row, value);\n            }\n          }\n        } else {\n          if (treeConfig && !checkStrictly) {\n            if (value === -1) {\n              if (!treeIndeterminateMaps[rowid]) {\n                if (indeterminateField) {\n                  XEUtils.set(row, indeterminateField, true);\n                }\n                treeIndeterminateMaps[rowid] = row;\n              }\n              if (selectRowMaps[rowid]) {\n                delete selectRowMaps[rowid];\n              }\n            } else {\n              XEUtils.eachTree([row], function(item) {\n                var itemRid = getRowid($xetable, item);\n                if ($xetable.eqRow(item, row) || (isForce || (!checkMethod || checkMethod({ row: item })))) {\n                  if (value) {\n                    selectRowMaps[itemRid] = item;\n                  } else {\n                    if (selectRowMaps[itemRid]) {\n                      delete selectRowMaps[itemRid];\n                    }\n                  }\n                  if (indeterminateField) {\n                    XEUtils.set(row, indeterminateField, false);\n                  }\n                  delete treeIndeterminateMaps[getRowid($xetable, item)];\n                  handleCheckboxReserveRow(row, value);\n                }\n              }, { children: childrenField });\n            }\n            var matchObj = XEUtils.findTree(afterFullData, function(item) {\n              return $xetable.eqRow(item, row);\n            }, { children: childrenField });\n            if (matchObj && matchObj.parent) {\n              var parentStatus = void 0;\n              var vItems_2 = [];\n              var vItemMaps_2 = {};\n              if (!isForce && checkMethod) {\n                matchObj.items.forEach(function(item) {\n                  if (checkMethod({ row: item })) {\n                    var itemRid = getRowid($xetable, item);\n                    vItemMaps_2[itemRid] = item;\n                    vItems_2.push(item);\n                  }\n                });\n              } else {\n                matchObj.items.forEach(function(item) {\n                  var itemRid = getRowid($xetable, item);\n                  vItemMaps_2[itemRid] = item;\n                  vItems_2.push(item);\n                });\n              }\n              var indeterminatesItem = XEUtils.find(matchObj.items, function(item) {\n                return !!treeIndeterminateMaps[getRowid($xetable, item)];\n              });\n              if (indeterminatesItem) {\n                parentStatus = -1;\n              } else {\n                var selectItems_2 = [];\n                matchObj.items.forEach(function(item) {\n                  var itemRid = getRowid($xetable, item);\n                  if (selectRowMaps[itemRid]) {\n                    selectItems_2.push(item);\n                  }\n                });\n                parentStatus = selectItems_2.filter(function(item) {\n                  return vItemMaps_2[getRowid($xetable, item)];\n                }).length === vItems_2.length ? true : selectItems_2.length || value === -1 ? -1 : false;\n              }\n              reactData.selectCheckboxMaps = selectRowMaps;\n              return tablePrivateMethods.handleSelectRow({ row: matchObj.parent }, parentStatus, isForce);\n            }\n          } else {\n            if (isForce || (!checkMethod || checkMethod({ row }))) {\n              if (value) {\n                if (!selectRowMaps[rowid]) {\n                  selectRowMaps[rowid] = row;\n                }\n              } else {\n                if (selectRowMaps[rowid]) {\n                  delete selectRowMaps[rowid];\n                }\n              }\n              handleCheckboxReserveRow(row, value);\n            }\n          }\n        }\n        reactData.selectCheckboxMaps = selectRowMaps;\n        tablePrivateMethods.checkSelectionStatus();\n      },\n      triggerHeaderTitleEvent: function(evnt, iconParams, params) {\n        var tipContent = iconParams.content || iconParams.message;\n        if (tipContent) {\n          var tooltipStore = reactData.tooltipStore;\n          var content_1 = getFuncText(tipContent);\n          handleTargetEnterEvent(true);\n          tooltipStore.visible = true;\n          tooltipStore.currOpts = __assign(__assign({}, params), { content: null });\n          nextTick(function() {\n            var $tooltip = refTooltip.value;\n            if ($tooltip) {\n              $tooltip.open(evnt.currentTarget, content_1);\n            }\n          });\n        }\n      },\n      /**\n       * 触发表头 tooltip 事件\n       */\n      triggerHeaderTooltipEvent: function(evnt, params) {\n        var tooltipStore = reactData.tooltipStore;\n        var column = params.column;\n        var titleElem = evnt.currentTarget;\n        handleTargetEnterEvent(true);\n        if (tooltipStore.column !== column || !tooltipStore.visible) {\n          handleTooltip(evnt, titleElem, titleElem, null, params);\n        }\n      },\n      /**\n       * 触发单元格 tooltip 事件\n       */\n      triggerBodyTooltipEvent: function(evnt, params) {\n        var editConfig = props.editConfig;\n        var editStore = reactData.editStore;\n        var tooltipStore = reactData.tooltipStore;\n        var editOpts = computeEditOpts.value;\n        var actived = editStore.actived;\n        var row = params.row, column = params.column;\n        var cell = evnt.currentTarget;\n        handleTargetEnterEvent(tooltipStore.column !== column || tooltipStore.row !== row);\n        if (column.editRender && isEnableConf(editConfig)) {\n          if (editOpts.mode === \"row\" && actived.row === row) {\n            return;\n          }\n          if (actived.row === row && actived.column === column) {\n            return;\n          }\n        }\n        if (tooltipStore.column !== column || tooltipStore.row !== row || !tooltipStore.visible) {\n          var overflowElem = void 0;\n          var tipElem = void 0;\n          if (column.treeNode) {\n            overflowElem = cell.querySelector(\".vxe-tree-cell\");\n            if (column.type === \"html\") {\n              tipElem = cell.querySelector(\".vxe-cell--html\");\n            }\n          } else {\n            tipElem = cell.querySelector(column.type === \"html\" ? \".vxe-cell--html\" : \".vxe-cell--label\");\n          }\n          handleTooltip(evnt, cell, overflowElem || cell.children[0], tipElem, params);\n        }\n      },\n      /**\n       * 触发表尾 tooltip 事件\n       */\n      triggerFooterTooltipEvent: function(evnt, params) {\n        var column = params.column;\n        var tooltipStore = reactData.tooltipStore;\n        var cell = evnt.currentTarget;\n        handleTargetEnterEvent(tooltipStore.column !== column || !!tooltipStore.row);\n        if (tooltipStore.column !== column || !tooltipStore.visible) {\n          handleTooltip(evnt, cell, cell.querySelector(\".vxe-cell--item\") || cell.children[0], null, params);\n        }\n      },\n      handleTargetLeaveEvent: function() {\n        var tooltipOpts = computeTooltipOpts.value;\n        var $tooltip = refTooltip.value;\n        if ($tooltip) {\n          $tooltip.setActived(false);\n        }\n        if (tooltipOpts.enterable) {\n          internalData.tooltipTimeout = setTimeout(function() {\n            $tooltip = refTooltip.value;\n            if ($tooltip && !$tooltip.isActived()) {\n              tableMethods.closeTooltip();\n            }\n          }, tooltipOpts.leaveDelay);\n        } else {\n          tableMethods.closeTooltip();\n        }\n      },\n      triggerHeaderCellClickEvent: function(evnt, params) {\n        var _lastResizeTime = internalData._lastResizeTime;\n        var sortOpts = computeSortOpts.value;\n        var columnOpts = computeColumnOpts.value;\n        var column = params.column;\n        var cell = evnt.currentTarget;\n        var triggerResizable = _lastResizeTime && _lastResizeTime > Date.now() - 300;\n        var triggerSort = getEventTargetNode(evnt, cell, \"vxe-cell--sort\").flag;\n        var triggerFilter = getEventTargetNode(evnt, cell, \"vxe-cell--filter\").flag;\n        if (sortOpts.trigger === \"cell\" && !(triggerResizable || triggerSort || triggerFilter)) {\n          tablePrivateMethods.triggerSortEvent(evnt, column, getNextSortOrder(column));\n        }\n        tableMethods.dispatchEvent(\"header-cell-click\", Object.assign({ triggerResizable, triggerSort, triggerFilter, cell }, params), evnt);\n        if (columnOpts.isCurrent || props.highlightCurrentColumn) {\n          tableMethods.setCurrentColumn(column);\n        }\n      },\n      triggerHeaderCellDblclickEvent: function(evnt, params) {\n        tableMethods.dispatchEvent(\"header-cell-dblclick\", Object.assign({ cell: evnt.currentTarget }, params), evnt);\n      },\n      /**\n       * 列点击事件\n       * 如果是单击模式，则激活为编辑状态\n       * 如果是双击模式，则单击后选中状态\n       */\n      triggerCellClickEvent: function(evnt, params) {\n        var highlightCurrentRow = props.highlightCurrentRow, editConfig = props.editConfig;\n        var editStore = reactData.editStore;\n        var expandOpts = computeExpandOpts.value;\n        var editOpts = computeEditOpts.value;\n        var treeOpts = computeTreeOpts.value;\n        var radioOpts = computeRadioOpts.value;\n        var checkboxOpts = computeCheckboxOpts.value;\n        var rowOpts = computeRowOpts.value;\n        var actived = editStore.actived;\n        var row = params.row, column = params.column;\n        var type = column.type, treeNode = column.treeNode;\n        var isRadioType = type === \"radio\";\n        var isCheckboxType = type === \"checkbox\";\n        var isExpandType = type === \"expand\";\n        var cell = evnt.currentTarget;\n        var triggerRadio = isRadioType && getEventTargetNode(evnt, cell, \"vxe-cell--radio\").flag;\n        var triggerCheckbox = isCheckboxType && getEventTargetNode(evnt, cell, \"vxe-cell--checkbox\").flag;\n        var triggerTreeNode = treeNode && getEventTargetNode(evnt, cell, \"vxe-tree--btn-wrapper\").flag;\n        var triggerExpandNode = isExpandType && getEventTargetNode(evnt, cell, \"vxe-table--expanded\").flag;\n        params = Object.assign({ cell, triggerRadio, triggerCheckbox, triggerTreeNode, triggerExpandNode }, params);\n        if (!triggerCheckbox && !triggerRadio) {\n          if (!triggerExpandNode && (expandOpts.trigger === \"row\" || isExpandType && expandOpts.trigger === \"cell\")) {\n            tablePrivateMethods.triggerRowExpandEvent(evnt, params);\n          }\n          if (treeOpts.trigger === \"row\" || treeNode && treeOpts.trigger === \"cell\") {\n            tablePrivateMethods.triggerTreeExpandEvent(evnt, params);\n          }\n        }\n        if (!triggerTreeNode) {\n          if (!triggerExpandNode) {\n            if (rowOpts.isCurrent || highlightCurrentRow) {\n              if (!triggerCheckbox && !triggerRadio) {\n                tablePrivateMethods.triggerCurrentRowEvent(evnt, params);\n              }\n            }\n            if (!triggerRadio && (radioOpts.trigger === \"row\" || isRadioType && radioOpts.trigger === \"cell\")) {\n              tablePrivateMethods.triggerRadioRowEvent(evnt, params);\n            }\n            if (!triggerCheckbox && (checkboxOpts.trigger === \"row\" || isCheckboxType && checkboxOpts.trigger === \"cell\")) {\n              tablePrivateMethods.handleToggleCheckRowEvent(evnt, params);\n            }\n          }\n          if (isEnableConf(editConfig)) {\n            if (editOpts.trigger === \"manual\") {\n              if (actived.args && actived.row === row && column !== actived.column) {\n                handleChangeCell(evnt, params);\n              }\n            } else if (!actived.args || row !== actived.row || column !== actived.column) {\n              if (editOpts.trigger === \"click\") {\n                handleChangeCell(evnt, params);\n              } else if (editOpts.trigger === \"dblclick\") {\n                if (editOpts.mode === \"row\" && actived.row === row) {\n                  handleChangeCell(evnt, params);\n                }\n              }\n            }\n          }\n        }\n        tableMethods.dispatchEvent(\"cell-click\", params, evnt);\n      },\n      /**\n       * 列双击点击事件\n       * 如果是双击模式，则激活为编辑状态\n       */\n      triggerCellDblclickEvent: function(evnt, params) {\n        var editConfig = props.editConfig;\n        var editStore = reactData.editStore;\n        var editOpts = computeEditOpts.value;\n        var actived = editStore.actived;\n        var cell = evnt.currentTarget;\n        params = Object.assign({ cell }, params);\n        if (isEnableConf(editConfig) && editOpts.trigger === \"dblclick\") {\n          if (!actived.args || evnt.currentTarget !== actived.args.cell) {\n            if (editOpts.mode === \"row\") {\n              checkValidate(\"blur\").catch(function(e) {\n                return e;\n              }).then(function() {\n                $xetable.handleActived(params, evnt).then(function() {\n                  return checkValidate(\"change\");\n                }).catch(function(e) {\n                  return e;\n                });\n              });\n            } else if (editOpts.mode === \"cell\") {\n              $xetable.handleActived(params, evnt).then(function() {\n                return checkValidate(\"change\");\n              }).catch(function(e) {\n                return e;\n              });\n            }\n          }\n        }\n        tableMethods.dispatchEvent(\"cell-dblclick\", params, evnt);\n      },\n      handleToggleCheckRowEvent: function(evnt, params) {\n        var selectCheckboxMaps = reactData.selectCheckboxMaps;\n        var checkboxOpts = computeCheckboxOpts.value;\n        var checkField = checkboxOpts.checkField;\n        var row = params.row;\n        var value = false;\n        if (checkField) {\n          value = !XEUtils.get(row, checkField);\n        } else {\n          value = !selectCheckboxMaps[getRowid($xetable, row)];\n        }\n        if (evnt) {\n          tablePrivateMethods.triggerCheckRowEvent(evnt, params, value);\n        } else {\n          tablePrivateMethods.handleSelectRow(params, value);\n        }\n      },\n      triggerCheckRowEvent: function(evnt, params, value) {\n        var checkboxOpts = computeCheckboxOpts.value;\n        var row = params.row;\n        var afterFullData = internalData.afterFullData;\n        var checkMethod = checkboxOpts.checkMethod;\n        if (checkboxOpts.isShiftKey && evnt.shiftKey && !props.treeConfig) {\n          var checkboxRecords = tableMethods.getCheckboxRecords();\n          if (checkboxRecords.length) {\n            var firstRow = checkboxRecords[0];\n            var _rowIndex = tableMethods.getVTRowIndex(row);\n            var _firstRowIndex = tableMethods.getVTRowIndex(firstRow);\n            if (_rowIndex !== _firstRowIndex) {\n              tableMethods.setAllCheckboxRow(false);\n              var rangeRows = _rowIndex < _firstRowIndex ? afterFullData.slice(_rowIndex, _firstRowIndex + 1) : afterFullData.slice(_firstRowIndex, _rowIndex + 1);\n              handleCheckedCheckboxRow(rangeRows, true, false);\n              tableMethods.dispatchEvent(\"checkbox-range-select\", Object.assign({ rangeRecords: rangeRows }, params), evnt);\n              return;\n            }\n          }\n        }\n        if (!checkMethod || checkMethod({ row })) {\n          tablePrivateMethods.handleSelectRow(params, value);\n          tableMethods.dispatchEvent(\"checkbox-change\", Object.assign({\n            records: tableMethods.getCheckboxRecords(),\n            reserves: tableMethods.getCheckboxReserveRecords(),\n            indeterminates: tableMethods.getCheckboxIndeterminateRecords(),\n            checked: value\n          }, params), evnt);\n        }\n      },\n      /**\n       * 多选，选中所有事件\n       */\n      triggerCheckAllEvent: function(evnt, value) {\n        handleCheckedAllCheckboxRow(value);\n        if (evnt) {\n          tableMethods.dispatchEvent(\"checkbox-all\", {\n            records: tableMethods.getCheckboxRecords(),\n            reserves: tableMethods.getCheckboxReserveRecords(),\n            indeterminates: tableMethods.getCheckboxIndeterminateRecords(),\n            checked: value\n          }, evnt);\n        }\n      },\n      /**\n       * 单选，行选中事件\n       */\n      triggerRadioRowEvent: function(evnt, params) {\n        var oldValue = reactData.selectRadioRow;\n        var row = params.row;\n        var radioOpts = computeRadioOpts.value;\n        var newValue = row;\n        var isChange = oldValue !== newValue;\n        if (isChange) {\n          handleCheckedRadioRow(newValue);\n        } else if (!radioOpts.strict) {\n          isChange = oldValue === newValue;\n          if (isChange) {\n            newValue = null;\n            tableMethods.clearRadioRow();\n          }\n        }\n        if (isChange) {\n          tableMethods.dispatchEvent(\"radio-change\", __assign({ oldValue, newValue }, params), evnt);\n        }\n      },\n      triggerCurrentRowEvent: function(evnt, params) {\n        var oldValue = reactData.currentRow;\n        var newValue = params.row;\n        var isChange = oldValue !== newValue;\n        tableMethods.setCurrentRow(newValue);\n        if (isChange) {\n          tableMethods.dispatchEvent(\"current-change\", __assign({ oldValue, newValue }, params), evnt);\n        }\n      },\n      /**\n       * 展开行事件\n       */\n      triggerRowExpandEvent: function(evnt, params) {\n        var rowExpandLazyLoadedMaps = reactData.rowExpandLazyLoadedMaps, column = reactData.expandColumn;\n        var expandOpts = computeExpandOpts.value;\n        var row = params.row;\n        var lazy = expandOpts.lazy;\n        var rowid = getRowid($xetable, row);\n        if (!lazy || !rowExpandLazyLoadedMaps[rowid]) {\n          var expanded = !tableMethods.isExpandByRow(row);\n          var columnIndex = tableMethods.getColumnIndex(column);\n          var $columnIndex = tableMethods.getVMColumnIndex(column);\n          tableMethods.setRowExpand(row, expanded);\n          tableMethods.dispatchEvent(\"toggle-row-expand\", {\n            expanded,\n            column,\n            columnIndex,\n            $columnIndex,\n            row,\n            rowIndex: tableMethods.getRowIndex(row),\n            $rowIndex: tableMethods.getVMRowIndex(row)\n          }, evnt);\n        }\n      },\n      /**\n       * 展开树节点事件\n       */\n      triggerTreeExpandEvent: function(evnt, params) {\n        var treeExpandLazyLoadedMaps = reactData.treeExpandLazyLoadedMaps;\n        var treeOpts = computeTreeOpts.value;\n        var row = params.row, column = params.column;\n        var lazy = treeOpts.lazy;\n        var rowid = getRowid($xetable, row);\n        if (!lazy || !treeExpandLazyLoadedMaps[rowid]) {\n          var expanded = !tableMethods.isTreeExpandByRow(row);\n          var columnIndex = tableMethods.getColumnIndex(column);\n          var $columnIndex = tableMethods.getVMColumnIndex(column);\n          tableMethods.setTreeExpand(row, expanded);\n          tableMethods.dispatchEvent(\"toggle-tree-expand\", { expanded, column, columnIndex, $columnIndex, row }, evnt);\n        }\n      },\n      /**\n       * 点击排序事件\n       */\n      triggerSortEvent: function(evnt, column, order) {\n        var mouseConfig = props.mouseConfig;\n        var sortOpts = computeSortOpts.value;\n        var mouseOpts = computeMouseOpts.value;\n        var field = column.field, sortable = column.sortable;\n        if (sortable) {\n          if (!order || column.order === order) {\n            tableMethods.clearSort(sortOpts.multiple ? column : null);\n          } else {\n            tableMethods.sort({ field, order });\n          }\n          var params = { $table: $xetable, $event: evnt, column, field, property: field, order: column.order, sortList: tableMethods.getSortColumns(), sortTime: column.sortTime };\n          if (mouseConfig && mouseOpts.area && $xetable.handleSortEvent) {\n            $xetable.handleSortEvent(evnt, params);\n          }\n          tableMethods.dispatchEvent(\"sort-change\", params, evnt);\n        }\n      },\n      /**\n       * 横向 X 可视渲染事件处理\n       */\n      triggerScrollXEvent: function() {\n        loadScrollXData();\n      },\n      /**\n       * 纵向 Y 可视渲染事件处理\n       */\n      triggerScrollYEvent: function(evnt) {\n        var scrollYStore = internalData.scrollYStore;\n        var adaptive = scrollYStore.adaptive, offsetSize = scrollYStore.offsetSize, visibleSize = scrollYStore.visibleSize;\n        if (isWebkit && adaptive && offsetSize * 2 + visibleSize <= 40) {\n          loadScrollYData(evnt);\n        } else {\n          debounceScrollY(evnt);\n        }\n      },\n      /**\n       * 对于树形结构中，可以直接滚动到指定深层节点中\n       * 对于某些特定的场景可能会用到，比如定位到某一节点\n       * @param {Row} row 行对象\n       */\n      scrollToTreeRow: function(row) {\n        var treeConfig = props.treeConfig;\n        var tableFullData = internalData.tableFullData;\n        var rests = [];\n        if (treeConfig) {\n          var treeOpts = computeTreeOpts.value;\n          var childrenField = treeOpts.children || treeOpts.childrenField;\n          var matchObj = XEUtils.findTree(tableFullData, function(item) {\n            return $xetable.eqRow(item, row);\n          }, { children: childrenField });\n          if (matchObj) {\n            var nodes_1 = matchObj.nodes;\n            nodes_1.forEach(function(row2, index) {\n              if (index < nodes_1.length - 1 && !tableMethods.isTreeExpandByRow(row2)) {\n                rests.push(tableMethods.setTreeExpand(row2, true));\n              }\n            });\n          }\n        }\n        return Promise.all(rests).then(function() {\n          return rowToVisible($xetable, row);\n        });\n      },\n      updateScrollYStatus,\n      // 更新横向 X 可视渲染上下剩余空间大小\n      updateScrollXSpace: function() {\n        var isGroup = reactData.isGroup, scrollXLoad = reactData.scrollXLoad, scrollbarWidth = reactData.scrollbarWidth;\n        var visibleColumn = internalData.visibleColumn, scrollXStore = internalData.scrollXStore, elemStore = internalData.elemStore, tableWidth = internalData.tableWidth;\n        var tableHeader = refTableHeader.value;\n        var tableBody = refTableBody.value;\n        var tableFooter = refTableFooter.value;\n        var tableBodyElem = tableBody ? tableBody.$el : null;\n        if (tableBodyElem) {\n          var tableHeaderElem = tableHeader ? tableHeader.$el : null;\n          var tableFooterElem = tableFooter ? tableFooter.$el : null;\n          var headerElem = tableHeaderElem ? tableHeaderElem.querySelector(\".vxe-table--header\") : null;\n          var bodyElem = tableBodyElem.querySelector(\".vxe-table--body\");\n          var footerElem = tableFooterElem ? tableFooterElem.querySelector(\".vxe-table--footer\") : null;\n          var leftSpaceWidth = visibleColumn.slice(0, scrollXStore.startIndex).reduce(function(previous, column) {\n            return previous + column.renderWidth;\n          }, 0);\n          var marginLeft = \"\";\n          if (scrollXLoad) {\n            marginLeft = \"\".concat(leftSpaceWidth, \"px\");\n          }\n          if (headerElem) {\n            headerElem.style.marginLeft = isGroup ? \"\" : marginLeft;\n          }\n          bodyElem.style.marginLeft = marginLeft;\n          if (footerElem) {\n            footerElem.style.marginLeft = marginLeft;\n          }\n          var containerList = [\"main\"];\n          containerList.forEach(function(name) {\n            var layoutList = [\"header\", \"body\", \"footer\"];\n            layoutList.forEach(function(layout) {\n              var xSpaceRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-xSpace\")];\n              var xSpaceElem = xSpaceRef ? xSpaceRef.value : null;\n              if (xSpaceElem) {\n                xSpaceElem.style.width = scrollXLoad ? \"\".concat(tableWidth + (layout === \"header\" ? scrollbarWidth : 0), \"px\") : \"\";\n              }\n            });\n          });\n          nextTick(updateStyle);\n        }\n      },\n      // 更新纵向 Y 可视渲染上下剩余空间大小\n      updateScrollYSpace: function() {\n        var scrollYLoad = reactData.scrollYLoad;\n        var scrollYStore = internalData.scrollYStore, elemStore = internalData.elemStore, afterFullData = internalData.afterFullData;\n        var startIndex = scrollYStore.startIndex, rowHeight = scrollYStore.rowHeight;\n        var bodyHeight = afterFullData.length * rowHeight;\n        var topSpaceHeight = Math.max(0, startIndex * rowHeight);\n        var containerList = [\"main\", \"left\", \"right\"];\n        var marginTop = \"\";\n        var ySpaceHeight = \"\";\n        if (scrollYLoad) {\n          marginTop = \"\".concat(topSpaceHeight, \"px\");\n          ySpaceHeight = \"\".concat(bodyHeight, \"px\");\n        }\n        containerList.forEach(function(name) {\n          var layoutList = [\"header\", \"body\", \"footer\"];\n          var tableRef = elemStore[\"\".concat(name, \"-body-table\")];\n          var tableElem = tableRef ? tableRef.value : null;\n          if (tableElem) {\n            tableElem.style.marginTop = marginTop;\n          }\n          layoutList.forEach(function(layout) {\n            var ySpaceRef = elemStore[\"\".concat(name, \"-\").concat(layout, \"-ySpace\")];\n            var ySpaceElem = ySpaceRef ? ySpaceRef.value : null;\n            if (ySpaceElem) {\n              ySpaceElem.style.height = ySpaceHeight;\n            }\n          });\n        });\n        nextTick(updateStyle);\n      },\n      updateScrollXData: function() {\n        nextTick(function() {\n          handleTableColumn();\n          tablePrivateMethods.updateScrollXSpace();\n        });\n      },\n      updateScrollYData: function() {\n        nextTick(function() {\n          tablePrivateMethods.handleTableData();\n          tablePrivateMethods.updateScrollYSpace();\n        });\n      },\n      /**\n       * 处理固定列的显示状态\n       */\n      checkScrolling: function() {\n        var leftContainerElem = refLeftContainer.value;\n        var rightContainerElem = refRightContainer.value;\n        var tableBody = refTableBody.value;\n        var bodyElem = tableBody ? tableBody.$el : null;\n        if (bodyElem) {\n          if (leftContainerElem) {\n            if (bodyElem.scrollLeft > 0) {\n              addClass(leftContainerElem, \"scrolling--middle\");\n            } else {\n              removeClass(leftContainerElem, \"scrolling--middle\");\n            }\n          }\n          if (rightContainerElem) {\n            if (bodyElem.clientWidth < bodyElem.scrollWidth - Math.ceil(bodyElem.scrollLeft)) {\n              addClass(rightContainerElem, \"scrolling--middle\");\n            } else {\n              removeClass(rightContainerElem, \"scrolling--middle\");\n            }\n          }\n        }\n      },\n      updateZindex: function() {\n        if (props.zIndex) {\n          internalData.tZindex = props.zIndex;\n        } else if (internalData.tZindex < getLastZIndex()) {\n          internalData.tZindex = nextZIndex();\n        }\n      },\n      handleCheckedCheckboxRow,\n      /**\n       * 行 hover 事件\n       */\n      triggerHoverEvent: function(evnt, _a) {\n        var row = _a.row;\n        tablePrivateMethods.setHoverRow(row);\n      },\n      setHoverRow: function(row) {\n        var rowid = getRowid($xetable, row);\n        var el = refElem.value;\n        tablePrivateMethods.clearHoverRow();\n        if (el) {\n          XEUtils.arrayEach(el.querySelectorAll('[rowid=\"'.concat(rowid, '\"]')), function(elem) {\n            return addClass(elem, \"row--hover\");\n          });\n        }\n        internalData.hoverRow = row;\n      },\n      clearHoverRow: function() {\n        var el = refElem.value;\n        if (el) {\n          XEUtils.arrayEach(el.querySelectorAll(\".vxe-body--row.row--hover\"), function(elem) {\n            return removeClass(elem, \"row--hover\");\n          });\n        }\n        internalData.hoverRow = null;\n      },\n      getCell: function(row, column) {\n        var rowid = getRowid($xetable, row);\n        var tableBody = refTableBody.value;\n        var leftBody = refTableLeftBody.value;\n        var rightBody = refTableRightBody.value;\n        var bodyElem;\n        if (column) {\n          if (column.fixed) {\n            if (column.fixed === \"left\") {\n              if (leftBody) {\n                bodyElem = leftBody.$el;\n              }\n            } else {\n              if (rightBody) {\n                bodyElem = rightBody.$el;\n              }\n            }\n          }\n          if (!bodyElem) {\n            bodyElem = tableBody.$el;\n          }\n          if (bodyElem) {\n            return bodyElem.querySelector('.vxe-body--row[rowid=\"'.concat(rowid, '\"] .').concat(column.id));\n          }\n        }\n        return null;\n      },\n      getCellLabel: function(row, column) {\n        var formatter = column.formatter;\n        var cellValue = getCellValue(row, column);\n        var cellLabel = cellValue;\n        if (formatter) {\n          var formatData = void 0;\n          var fullAllDataRowIdData = internalData.fullAllDataRowIdData;\n          var rowid = getRowid($xetable, row);\n          var colid = column.id;\n          var rest = fullAllDataRowIdData[rowid];\n          if (rest) {\n            formatData = rest.formatData;\n            if (!formatData) {\n              formatData = fullAllDataRowIdData[rowid].formatData = {};\n            }\n            if (rest && formatData[colid]) {\n              if (formatData[colid].value === cellValue) {\n                return formatData[colid].label;\n              }\n            }\n          }\n          var formatParams = { cellValue, row, rowIndex: tableMethods.getRowIndex(row), column, columnIndex: tableMethods.getColumnIndex(column) };\n          if (XEUtils.isString(formatter)) {\n            var gFormatOpts = VXETable.formats.get(formatter);\n            cellLabel = gFormatOpts && gFormatOpts.cellFormatMethod ? gFormatOpts.cellFormatMethod(formatParams) : \"\";\n          } else if (XEUtils.isArray(formatter)) {\n            var gFormatOpts = VXETable.formats.get(formatter[0]);\n            cellLabel = gFormatOpts && gFormatOpts.cellFormatMethod ? gFormatOpts.cellFormatMethod.apply(gFormatOpts, __spreadArray([formatParams], formatter.slice(1), false)) : \"\";\n          } else {\n            cellLabel = formatter(formatParams);\n          }\n          if (formatData) {\n            formatData[colid] = { value: cellValue, label: cellLabel };\n          }\n        }\n        return cellLabel;\n      },\n      findRowIndexOf: function(list, row) {\n        return row ? XEUtils.findIndexOf(list, function(item) {\n          return $xetable.eqRow(item, row);\n        }) : -1;\n      },\n      eqRow: function(row1, row2) {\n        if (row1 && row2) {\n          if (row1 === row2) {\n            return true;\n          }\n          return getRowid($xetable, row1) === getRowid($xetable, row2);\n        }\n        return false;\n      }\n    };\n    if (false) {\n      \"openExport,openPrint,exportData,openImport,importData,saveFile,readFile,importByFile,print\".split(\",\").forEach(function(name) {\n        $xetable[name] = function() {\n          errLog(\"vxe.error.reqModule\", [\"Export\"]);\n        };\n      });\n      \"clearValidate,fullValidate,validate\".split(\",\").forEach(function(name) {\n        $xetable[name] = function() {\n          errLog(\"vxe.error.reqModule\", [\"Validator\"]);\n        };\n      });\n    }\n    Object.assign($xetable, tableMethods, tablePrivateMethods);\n    var renderFixed = function(fixedType) {\n      var showHeader = props.showHeader, showFooter = props.showFooter;\n      var tableData = reactData.tableData, tableColumn = reactData.tableColumn, tableGroupColumn = reactData.tableGroupColumn, columnStore = reactData.columnStore, footerTableData = reactData.footerTableData;\n      var isFixedLeft = fixedType === \"left\";\n      var fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;\n      return h(\"div\", {\n        ref: isFixedLeft ? refLeftContainer : refRightContainer,\n        class: \"vxe-table--fixed-\".concat(fixedType, \"-wrapper\")\n      }, [\n        showHeader ? h(TableHeaderComponent, {\n          ref: isFixedLeft ? refTableLeftHeader : refTableRightHeader,\n          fixedType,\n          tableData,\n          tableColumn,\n          tableGroupColumn,\n          fixedColumn\n        }) : createCommentVNode(),\n        h(TableBodyComponent, {\n          ref: isFixedLeft ? refTableLeftBody : refTableRightBody,\n          fixedType,\n          tableData,\n          tableColumn,\n          fixedColumn\n        }),\n        showFooter ? h(TableFooterComponent, {\n          ref: isFixedLeft ? refTableLeftFooter : refTableRightFooter,\n          footerTableData,\n          tableColumn,\n          fixedColumn,\n          fixedType\n        }) : createCommentVNode()\n      ]);\n    };\n    var renderEmptyContenet = function() {\n      var emptyOpts = computeEmptyOpts.value;\n      var params = { $table: $xetable };\n      if (slots.empty) {\n        return slots.empty(params);\n      } else {\n        var compConf = emptyOpts.name ? VXETable.renderer.get(emptyOpts.name) : null;\n        var renderEmpty = compConf ? compConf.renderEmpty : null;\n        if (renderEmpty) {\n          return getSlotVNs(renderEmpty(emptyOpts, params));\n        }\n      }\n      return getFuncText(props.emptyText) || GlobalConfig.i18n(\"vxe.table.emptyText\");\n    };\n    function handleUupdateResize() {\n      var el = refElem.value;\n      if (el && el.clientWidth && el.clientHeight) {\n        tableMethods.recalculate();\n      }\n    }\n    var dataFlag = ref(0);\n    watch(function() {\n      return props.data ? props.data.length : -1;\n    }, function() {\n      dataFlag.value++;\n    });\n    watch(function() {\n      return props.data;\n    }, function() {\n      dataFlag.value++;\n    });\n    watch(dataFlag, function() {\n      var inited = internalData.inited, initStatus = internalData.initStatus;\n      loadTableData(props.data || []).then(function() {\n        var scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad, expandColumn = reactData.expandColumn;\n        internalData.inited = true;\n        internalData.initStatus = true;\n        if (!initStatus) {\n          handleLoadDefaults();\n        }\n        if (!inited) {\n          handleInitDefaults();\n        }\n        if (false) {\n          if ((scrollXLoad || scrollYLoad) && expandColumn) {\n            warnLog(\"vxe.error.scrollErrProp\", [\"column.type=expand\"]);\n          }\n        }\n        tableMethods.recalculate();\n      });\n    });\n    var staticColumnFlag = ref(0);\n    watch(function() {\n      return reactData.staticColumns.length;\n    }, function() {\n      staticColumnFlag.value++;\n    });\n    watch(function() {\n      return reactData.staticColumns;\n    }, function() {\n      staticColumnFlag.value++;\n    });\n    watch(staticColumnFlag, function() {\n      handleColumn(reactData.staticColumns);\n    });\n    var tableColumnFlag = ref(0);\n    watch(function() {\n      return reactData.tableColumn.length;\n    }, function() {\n      tableColumnFlag.value++;\n    });\n    watch(function() {\n      return reactData.tableColumn;\n    }, function() {\n      tableColumnFlag.value++;\n    });\n    watch(tableColumnFlag, function() {\n      tablePrivateMethods.analyColumnWidth();\n    });\n    watch(function() {\n      return reactData.upDataFlag;\n    }, function() {\n      nextTick(function() {\n        tableMethods.updateData();\n      });\n    });\n    watch(function() {\n      return reactData.reColumnFlag;\n    }, function() {\n      nextTick(function() {\n        tableMethods.refreshColumn();\n      });\n    });\n    watch(function() {\n      return props.showHeader;\n    }, function() {\n      nextTick(function() {\n        tableMethods.recalculate(true).then(function() {\n          return tableMethods.refreshScroll();\n        });\n      });\n    });\n    watch(function() {\n      return props.showFooter;\n    }, function() {\n      nextTick(function() {\n        tableMethods.recalculate(true).then(function() {\n          return tableMethods.refreshScroll();\n        });\n      });\n    });\n    watch(function() {\n      return props.height;\n    }, function() {\n      nextTick(function() {\n        return tableMethods.recalculate(true);\n      });\n    });\n    watch(function() {\n      return props.maxHeight;\n    }, function() {\n      nextTick(function() {\n        return tableMethods.recalculate(true);\n      });\n    });\n    watch(function() {\n      return props.syncResize;\n    }, function(value) {\n      if (value) {\n        handleUupdateResize();\n        nextTick(function() {\n          handleUupdateResize();\n          setTimeout(function() {\n            return handleUupdateResize();\n          });\n        });\n      }\n    });\n    var mergeCellFlag = ref(0);\n    watch(function() {\n      return props.mergeCells ? props.mergeCells.length : -1;\n    }, function() {\n      mergeCellFlag.value++;\n    });\n    watch(function() {\n      return props.mergeCells;\n    }, function() {\n      mergeCellFlag.value++;\n    });\n    watch(mergeCellFlag, function() {\n      tableMethods.clearMergeCells();\n      nextTick(function() {\n        if (props.mergeCells) {\n          tableMethods.setMergeCells(props.mergeCells);\n        }\n      });\n    });\n    var mergeFooterItemFlag = ref(0);\n    watch(function() {\n      return props.mergeFooterItems ? props.mergeFooterItems.length : -1;\n    }, function() {\n      mergeFooterItemFlag.value++;\n    });\n    watch(function() {\n      return props.mergeFooterItems;\n    }, function() {\n      mergeFooterItemFlag.value++;\n    });\n    watch(mergeFooterItemFlag, function() {\n      tableMethods.clearMergeFooterItems();\n      nextTick(function() {\n        if (props.mergeFooterItems) {\n          tableMethods.setMergeFooterItems(props.mergeFooterItems);\n        }\n      });\n    });\n    VXETable.hooks.forEach(function(options) {\n      var setupTable = options.setupTable;\n      if (setupTable) {\n        var hookRest = setupTable($xetable);\n        if (hookRest && XEUtils.isObject(hookRest)) {\n          Object.assign($xetable, hookRest);\n        }\n      }\n    });\n    tablePrivateMethods.preventEvent(null, \"created\", { $table: $xetable });\n    var resizeObserver;\n    onActivated(function() {\n      tableMethods.recalculate().then(function() {\n        return tableMethods.refreshScroll();\n      });\n      tablePrivateMethods.preventEvent(null, \"activated\", { $table: $xetable });\n    });\n    onDeactivated(function() {\n      internalData.isActivated = false;\n      tablePrivateMethods.preventEvent(null, \"deactivated\", { $table: $xetable });\n    });\n    onMounted(function() {\n      nextTick(function() {\n        var data = props.data, treeConfig = props.treeConfig, showOverflow = props.showOverflow;\n        var scrollXStore = internalData.scrollXStore, scrollYStore = internalData.scrollYStore;\n        var sYOpts = computeSYOpts.value;\n        var editOpts = computeEditOpts.value;\n        var treeOpts = computeTreeOpts.value;\n        var radioOpts = computeRadioOpts.value;\n        var checkboxOpts = computeCheckboxOpts.value;\n        var expandOpts = computeExpandOpts.value;\n        var rowOpts = computeRowOpts.value;\n        if (false) {\n          if (!(props.rowId || rowOpts.keyField) && (checkboxOpts.reserve || checkboxOpts.checkRowKeys || radioOpts.reserve || radioOpts.checkRowKey || expandOpts.expandRowKeys || treeOpts.expandRowKeys)) {\n            warnLog(\"vxe.error.reqProp\", [\"row-config.keyField\"]);\n          }\n          if (props.editConfig && (editOpts.showStatus || editOpts.showUpdateStatus || editOpts.showInsertStatus) && !props.keepSource) {\n            warnLog(\"vxe.error.reqProp\", [\"keep-source\"]);\n          }\n          if (treeConfig && (treeOpts.showLine || treeOpts.line) && (!(props.rowKey || rowOpts.useKey) || !showOverflow)) {\n            warnLog(\"vxe.error.reqProp\", [\"row-config.useKey | show-overflow\"]);\n          }\n          if (treeConfig && props.stripe) {\n            warnLog(\"vxe.error.noTree\", [\"stripe\"]);\n          }\n          if (props.showFooter && !props.footerMethod) {\n            warnLog(\"vxe.error.reqProp\", [\"footer-method\"]);\n          }\n          var exportConfig = props.exportConfig, importConfig = props.importConfig;\n          var exportOpts = computeExportOpts.value;\n          var importOpts = computeImportOpts.value;\n          if (importConfig && importOpts.types && !importOpts.importMethod && !XEUtils.includeArrays(VXETable.globalConfs.importTypes, importOpts.types)) {\n            warnLog(\"vxe.error.errProp\", [\"export-config.types=\".concat(importOpts.types.join(\",\")), importOpts.types.filter(function(type) {\n              return XEUtils.includes(VXETable.globalConfs.importTypes, type);\n            }).join(\",\") || VXETable.globalConfs.importTypes.join(\",\")]);\n          }\n          if (exportConfig && exportOpts.types && !exportOpts.exportMethod && !XEUtils.includeArrays(VXETable.globalConfs.exportTypes, exportOpts.types)) {\n            warnLog(\"vxe.error.errProp\", [\"export-config.types=\".concat(exportOpts.types.join(\",\")), exportOpts.types.filter(function(type) {\n              return XEUtils.includes(VXETable.globalConfs.exportTypes, type);\n            }).join(\",\") || VXETable.globalConfs.exportTypes.join(\",\")]);\n          }\n        }\n        if (false) {\n          var customOpts = computeCustomOpts.value;\n          var mouseOpts = computeMouseOpts.value;\n          var rowOpts_1 = computeRowOpts.value;\n          if (!props.id && props.customConfig && (customOpts.storage === true || customOpts.storage && customOpts.storage.resizable || customOpts.storage && customOpts.storage.visible)) {\n            errLog(\"vxe.error.reqProp\", [\"id\"]);\n          }\n          if (props.treeConfig && checkboxOpts.range) {\n            errLog(\"vxe.error.noTree\", [\"checkbox-config.range\"]);\n          }\n          if (rowOpts_1.height && !props.showOverflow) {\n            warnLog(\"vxe.error.notProp\", [\"table.show-overflow\"]);\n          }\n          if (!$xetable.handleUpdateCellAreas) {\n            if (props.clipConfig) {\n              warnLog(\"vxe.error.notProp\", [\"clip-config\"]);\n            }\n            if (props.fnrConfig) {\n              warnLog(\"vxe.error.notProp\", [\"fnr-config\"]);\n            }\n            if (mouseOpts.area) {\n              errLog(\"vxe.error.notProp\", [\"mouse-config.area\"]);\n              return;\n            }\n          }\n          if (props.treeConfig && treeOpts.children) {\n            warnLog(\"vxe.error.delProp\", [\"tree-config.children\", \"tree-config.childrenField\"]);\n          }\n          if (props.treeConfig && treeOpts.line) {\n            warnLog(\"vxe.error.delProp\", [\"tree-config.line\", \"tree-config.showLine\"]);\n          }\n          if (mouseOpts.area && mouseOpts.selected) {\n            warnLog(\"vxe.error.errConflicts\", [\"mouse-config.area\", \"mouse-config.selected\"]);\n          }\n          if (mouseOpts.area && checkboxOpts.range) {\n            warnLog(\"vxe.error.errConflicts\", [\"mouse-config.area\", \"checkbox-config.range\"]);\n          }\n          if (props.treeConfig && mouseOpts.area) {\n            errLog(\"vxe.error.noTree\", [\"mouse-config.area\"]);\n          }\n          if (props.editConfig && editOpts.activeMethod) {\n            warnLog(\"vxe.error.delProp\", [\"edit-config.activeMethod\", \"edit-config.beforeEditMethod\"]);\n          }\n          if (props.treeConfig && checkboxOpts.isShiftKey) {\n            errLog(\"vxe.error.errConflicts\", [\"tree-config\", \"checkbox-config.isShiftKey\"]);\n          }\n          if (checkboxOpts.halfField) {\n            warnLog(\"vxe.error.delProp\", [\"checkbox-config.halfField\", \"checkbox-config.indeterminateField\"]);\n          }\n        }\n        if (false) {\n          if (props.editConfig && !$xetable.insert) {\n            errLog(\"vxe.error.reqModule\", [\"Edit\"]);\n          }\n          if (props.editRules && !$xetable.validate) {\n            errLog(\"vxe.error.reqModule\", [\"Validator\"]);\n          }\n          if ((checkboxOpts.range || props.keyboardConfig || props.mouseConfig) && !$xetable.triggerCellMousedownEvent) {\n            errLog(\"vxe.error.reqModule\", [\"Keyboard\"]);\n          }\n          if ((props.printConfig || props.importConfig || props.exportConfig) && !$xetable.exportData) {\n            errLog(\"vxe.error.reqModule\", [\"Export\"]);\n          }\n        }\n        Object.assign(scrollYStore, {\n          startIndex: 0,\n          endIndex: 0,\n          visibleSize: 0,\n          adaptive: sYOpts.adaptive !== false\n        });\n        Object.assign(scrollXStore, {\n          startIndex: 0,\n          endIndex: 0,\n          visibleSize: 0\n        });\n        loadTableData(data || []).then(function() {\n          if (data && data.length) {\n            internalData.inited = true;\n            internalData.initStatus = true;\n            handleLoadDefaults();\n            handleInitDefaults();\n          }\n          updateStyle();\n        });\n        if (props.autoResize) {\n          var resizeOpts = computeResizeleOpts.value;\n          var refreshDelay = resizeOpts.refreshDelay;\n          var el = refElem.value;\n          var parentEl = tablePrivateMethods.getParentElem();\n          var handleOptimizeResize_1 = refreshDelay ? XEUtils.throttle(function() {\n            return tableMethods.recalculate(true);\n          }, refreshDelay, { leading: true, trailing: true }) : null;\n          resizeObserver = createResizeEvent(handleOptimizeResize_1 ? function() {\n            if (props.autoResize) {\n              requestAnimationFrame(handleOptimizeResize_1);\n            }\n          } : function() {\n            if (props.autoResize) {\n              tableMethods.recalculate(true);\n            }\n          });\n          if (el) {\n            resizeObserver.observe(el);\n          }\n          if (parentEl) {\n            resizeObserver.observe(parentEl);\n          }\n        }\n      });\n      GlobalEvent.on($xetable, \"paste\", handleGlobalPasteEvent);\n      GlobalEvent.on($xetable, \"copy\", handleGlobalCopyEvent);\n      GlobalEvent.on($xetable, \"cut\", handleGlobalCutEvent);\n      GlobalEvent.on($xetable, \"mousedown\", handleGlobalMousedownEvent);\n      GlobalEvent.on($xetable, \"blur\", handleGlobalBlurEvent);\n      GlobalEvent.on($xetable, \"mousewheel\", handleGlobalMousewheelEvent);\n      GlobalEvent.on($xetable, \"keydown\", handleGlobalKeydownEvent);\n      GlobalEvent.on($xetable, \"resize\", handleGlobalResizeEvent);\n      if ($xetable.handleGlobalContextmenuEvent) {\n        GlobalEvent.on($xetable, \"contextmenu\", $xetable.handleGlobalContextmenuEvent);\n      }\n      tablePrivateMethods.preventEvent(null, \"mounted\", { $table: $xetable });\n    });\n    onBeforeUnmount(function() {\n      if (resizeObserver) {\n        resizeObserver.disconnect();\n      }\n      tableMethods.closeFilter();\n      if ($xetable.closeMenu) {\n        $xetable.closeMenu();\n      }\n      tablePrivateMethods.preventEvent(null, \"beforeUnmount\", { $table: $xetable });\n    });\n    onUnmounted(function() {\n      GlobalEvent.off($xetable, \"paste\");\n      GlobalEvent.off($xetable, \"copy\");\n      GlobalEvent.off($xetable, \"cut\");\n      GlobalEvent.off($xetable, \"mousedown\");\n      GlobalEvent.off($xetable, \"blur\");\n      GlobalEvent.off($xetable, \"mousewheel\");\n      GlobalEvent.off($xetable, \"keydown\");\n      GlobalEvent.off($xetable, \"resize\");\n      GlobalEvent.off($xetable, \"contextmenu\");\n      tablePrivateMethods.preventEvent(null, \"unmounted\", { $table: $xetable });\n    });\n    var renderVN = function() {\n      var _a;\n      var loading = props.loading, stripe = props.stripe, showHeader = props.showHeader, height = props.height, treeConfig = props.treeConfig, mouseConfig = props.mouseConfig, showFooter = props.showFooter, highlightCell = props.highlightCell, highlightHoverRow = props.highlightHoverRow, highlightHoverColumn = props.highlightHoverColumn, editConfig = props.editConfig, editRules = props.editRules;\n      var isGroup = reactData.isGroup, overflowX = reactData.overflowX, overflowY = reactData.overflowY, scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad, scrollbarHeight = reactData.scrollbarHeight, tableData = reactData.tableData, tableColumn = reactData.tableColumn, tableGroupColumn = reactData.tableGroupColumn, footerTableData = reactData.footerTableData, initStore = reactData.initStore, columnStore = reactData.columnStore, filterStore = reactData.filterStore;\n      var leftList = columnStore.leftList, rightList = columnStore.rightList;\n      var loadingSlot = slots.loading;\n      var tipConfig = computeTipConfig.value;\n      var validOpts = computeValidOpts.value;\n      var treeOpts = computeTreeOpts.value;\n      var rowOpts = computeRowOpts.value;\n      var columnOpts = computeColumnOpts.value;\n      var vSize = computeSize.value;\n      var tableBorder = computeTableBorder.value;\n      var mouseOpts = computeMouseOpts.value;\n      var validTipOpts = computeValidTipOpts.value;\n      var loadingOpts = computeLoadingOpts.value;\n      var isMenu = computeIsMenu.value;\n      return h(\"div\", {\n        ref: refElem,\n        class: [\"vxe-table\", \"vxe-table--render-default\", \"tid_\".concat(xID), \"border--\".concat(tableBorder), (_a = {}, _a[\"size--\".concat(vSize)] = vSize, _a[\"vaild-msg--\".concat(validOpts.msgMode)] = !!editRules, _a[\"vxe-editable\"] = !!editConfig, _a[\"old-cell-valid\"] = editRules && GlobalConfig.cellVaildMode === \"obsolete\", _a[\"cell--highlight\"] = highlightCell, _a[\"cell--selected\"] = mouseConfig && mouseOpts.selected, _a[\"cell--area\"] = mouseConfig && mouseOpts.area, _a[\"row--highlight\"] = rowOpts.isHover || highlightHoverRow, _a[\"column--highlight\"] = columnOpts.isHover || highlightHoverColumn, _a[\"is--header\"] = showHeader, _a[\"is--footer\"] = showFooter, _a[\"is--group\"] = isGroup, _a[\"is--tree-line\"] = treeConfig && (treeOpts.showLine || treeOpts.line), _a[\"is--fixed-left\"] = leftList.length, _a[\"is--fixed-right\"] = rightList.length, _a[\"is--animat\"] = !!props.animat, _a[\"is--round\"] = props.round, _a[\"is--stripe\"] = !treeConfig && stripe, _a[\"is--loading\"] = loading, _a[\"is--empty\"] = !loading && !tableData.length, _a[\"is--scroll-y\"] = overflowY, _a[\"is--scroll-x\"] = overflowX, _a[\"is--virtual-x\"] = scrollXLoad, _a[\"is--virtual-y\"] = scrollYLoad, _a)],\n        onKeydown: keydownEvent\n      }, [\n        /**\n         * 隐藏列\n         */\n        h(\"div\", {\n          class: \"vxe-table-slots\"\n        }, slots.default ? slots.default({}) : []),\n        h(\"div\", {\n          class: \"vxe-table--render-wrapper\"\n        }, [\n          h(\"div\", {\n            class: \"vxe-table--main-wrapper\"\n          }, [\n            /**\n             * 表头\n             */\n            showHeader ? h(TableHeaderComponent, {\n              ref: refTableHeader,\n              tableData,\n              tableColumn,\n              tableGroupColumn\n            }) : createCommentVNode(),\n            /**\n             * 表体\n             */\n            h(TableBodyComponent, {\n              ref: refTableBody,\n              tableData,\n              tableColumn\n            }),\n            /**\n             * 表尾\n             */\n            showFooter ? h(TableFooterComponent, {\n              ref: refTableFooter,\n              footerTableData,\n              tableColumn\n            }) : createCommentVNode()\n          ]),\n          h(\"div\", {\n            class: \"vxe-table--fixed-wrapper\"\n          }, [\n            /**\n             * 左侧固定区域\n             */\n            leftList && leftList.length && overflowX ? renderFixed(\"left\") : createCommentVNode(),\n            /**\n             * 右侧固定区域\n             */\n            rightList && rightList.length && overflowX ? renderFixed(\"right\") : createCommentVNode()\n          ])\n        ]),\n        /**\n         * 空数据\n         */\n        h(\"div\", {\n          ref: refEmptyPlaceholder,\n          class: \"vxe-table--empty-placeholder\"\n        }, [\n          h(\"div\", {\n            class: \"vxe-table--empty-content\"\n          }, renderEmptyContenet())\n        ]),\n        /**\n         * 边框线\n         */\n        h(\"div\", {\n          class: \"vxe-table--border-line\"\n        }),\n        /**\n         * 列宽线\n         */\n        h(\"div\", {\n          ref: refCellResizeBar,\n          class: \"vxe-table--resizable-bar\",\n          style: overflowX ? {\n            \"padding-bottom\": \"\".concat(scrollbarHeight, \"px\")\n          } : null\n        }),\n        /**\n         * 加载中\n         */\n        h(VxeLoading, {\n          class: \"vxe-table--loading\",\n          modelValue: loading,\n          icon: loadingOpts.icon,\n          text: loadingOpts.text\n        }, loadingSlot ? {\n          default: function() {\n            return loadingSlot({ $table: $xetable, $grid: $xegrid });\n          }\n        } : {}),\n        /**\n         * 筛选\n         */\n        initStore.filter ? h(resolveComponent(\"vxe-table-filter\"), {\n          ref: refTableFilter,\n          filterStore\n        }) : createCommentVNode(),\n        /**\n         * 导入\n         */\n        initStore.import && props.importConfig ? h(resolveComponent(\"vxe-import-panel\"), {\n          defaultOptions: reactData.importParams,\n          storeData: reactData.importStore\n        }) : createCommentVNode(),\n        /**\n         * 导出/导出\n         */\n        initStore.export && (props.exportConfig || props.printConfig) ? h(resolveComponent(\"vxe-export-panel\"), {\n          defaultOptions: reactData.exportParams,\n          storeData: reactData.exportStore\n        }) : createCommentVNode(),\n        /**\n         * 快捷菜单\n         */\n        isMenu ? h(resolveComponent(\"vxe-table-context-menu\"), {\n          ref: refTableMenu\n        }) : createCommentVNode(),\n        /**\n         * 通用提示\n         */\n        hasUseTooltip ? h(resolveComponent(\"vxe-tooltip\"), {\n          ref: refCommTooltip,\n          isArrow: false,\n          enterable: false\n        }) : createCommentVNode(),\n        /**\n         * 工具提示\n         */\n        hasUseTooltip ? h(resolveComponent(\"vxe-tooltip\"), __assign({ ref: refTooltip }, tipConfig)) : createCommentVNode(),\n        /**\n         * 校验提示\n         */\n        hasUseTooltip && props.editRules && validOpts.showMessage && (validOpts.message === \"default\" ? !height : validOpts.message === \"tooltip\") ? h(resolveComponent(\"vxe-tooltip\"), __assign({ ref: refValidTooltip, class: [{\n          \"old-cell-valid\": editRules && GlobalConfig.cellVaildMode === \"obsolete\"\n        }, \"vxe-table--valid-error\"] }, validOpts.message === \"tooltip\" || tableData.length === 1 ? validTipOpts : {})) : createCommentVNode()\n      ]);\n    };\n    $xetable.renderVN = renderVN;\n    provide(\"xecolgroup\", null);\n    provide(\"$xetable\", $xetable);\n    return $xetable;\n  },\n  render: function() {\n    return this.renderVN();\n  }\n});\n",
      "start": 1714699767848,
      "end": 1714699769080,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-post",
      "start": 1714699769080,
      "end": 1714699769080,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1714699769080,
      "end": 1714699769080,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1714699769080,
      "end": 1714699769080,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1714699769080,
      "end": 1714699769080,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1714699769080,
      "end": 1714699769089,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1714699769089,
      "end": 1714699769089,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1714699769089,
      "end": 1714699769090,
      "order": "normal"
    },
    {
      "name": "unplugin-auto-import",
      "start": 1714699769090,
      "end": 1714699769090,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1714699769090,
      "end": 1714699769090,
      "order": "post"
    },
    {
      "name": "vite:style-import",
      "start": 1714699769090,
      "end": 1714699769090,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1714699769090,
      "end": 1714699769090,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1714699769090,
      "end": 1714699769090,
      "order": "normal"
    }
  ]
}
