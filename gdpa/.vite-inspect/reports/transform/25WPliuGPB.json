{
  "resolvedId": "/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/vxe-table@4.5.21_vue@3.4.19_xe-utils@3.5.24/node_modules/vxe-table/es/table/src/util.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { watch, reactive } from 'vue';\nimport XEUtils from 'xe-utils';\nimport { ColumnInfo } from './columnInfo';\nimport { isPx, isScale } from '../../tools/dom';\nexport function restoreScrollLocation($xetable, scrollLeft, scrollTop) {\n    var internalData = $xetable.internalData;\n    return $xetable.clearScroll().then(function () {\n        if (scrollLeft || scrollTop) {\n            // 重置最后滚动状态\n            internalData.lastScrollLeft = 0;\n            internalData.lastScrollTop = 0;\n            // 还原滚动状态\n            return $xetable.scrollTo(scrollLeft, scrollTop);\n        }\n    });\n}\nexport function removeScrollListener(scrollElem) {\n    if (scrollElem && scrollElem._onscroll) {\n        scrollElem.onscroll = null;\n    }\n}\nexport function restoreScrollListener(scrollElem) {\n    if (scrollElem && scrollElem._onscroll) {\n        scrollElem.onscroll = scrollElem._onscroll;\n    }\n}\n/**\n * 生成行的唯一主键\n */\nexport function getRowUniqueId() {\n    return XEUtils.uniqueId('row_');\n}\n// 行主键 key\nexport function getRowkey($xetable) {\n    var props = $xetable.props;\n    var computeRowOpts = $xetable.getComputeMaps().computeRowOpts;\n    var rowId = props.rowId;\n    var rowOpts = computeRowOpts.value;\n    return rowId || rowOpts.keyField || '_X_ROW_KEY';\n}\n// 行主键 value\nexport function getRowid($xetable, row) {\n    var rowid = XEUtils.get(row, getRowkey($xetable));\n    return XEUtils.eqNull(rowid) ? '' : encodeURIComponent(rowid);\n}\nexport var handleFieldOrColumn = function ($xetable, fieldOrColumn) {\n    if (fieldOrColumn) {\n        return XEUtils.isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;\n    }\n    return null;\n};\nfunction getPaddingLeftRightSize(elem) {\n    if (elem) {\n        var computedStyle = getComputedStyle(elem);\n        var paddingLeft = XEUtils.toNumber(computedStyle.paddingLeft);\n        var paddingRight = XEUtils.toNumber(computedStyle.paddingRight);\n        return paddingLeft + paddingRight;\n    }\n    return 0;\n}\nfunction getElemenMarginWidth(elem) {\n    if (elem) {\n        var computedStyle = getComputedStyle(elem);\n        var marginLeft = XEUtils.toNumber(computedStyle.marginLeft);\n        var marginRight = XEUtils.toNumber(computedStyle.marginRight);\n        return elem.offsetWidth + marginLeft + marginRight;\n    }\n    return 0;\n}\nfunction queryCellElement(cell, selector) {\n    return cell.querySelector('.vxe-cell' + selector);\n}\nexport function toFilters(filters) {\n    if (filters && XEUtils.isArray(filters)) {\n        return filters.map(function (_a) {\n            var label = _a.label, value = _a.value, data = _a.data, resetValue = _a.resetValue, checked = _a.checked;\n            return { label: label, value: value, data: data, resetValue: resetValue, checked: !!checked, _checked: !!checked };\n        });\n    }\n    return filters;\n}\nexport function toTreePathSeq(path) {\n    return path.map(function (num, i) { return i % 2 === 0 ? (Number(num) + 1) : '.'; }).join('');\n}\nexport function getCellValue(row, column) {\n    return XEUtils.get(row, column.field);\n}\nexport function setCellValue(row, column, value) {\n    return XEUtils.set(row, column.field, value);\n}\n/**\n * 列宽拖动最大宽度\n * @param params\n * @returns\n */\nexport function getColReMaxWidth(params) {\n    var $table = params.$table;\n    var computeResizableOpts = $table.getComputeMaps().computeResizableOpts;\n    var resizableOpts = computeResizableOpts.value;\n    var reMaxWidth = resizableOpts.maxWidth;\n    // 如果自定义调整宽度逻辑\n    if (reMaxWidth) {\n        var customMaxWidth = XEUtils.isFunction(reMaxWidth) ? reMaxWidth(params) : reMaxWidth;\n        if (customMaxWidth !== 'auto') {\n            return Math.max(1, XEUtils.toNumber(customMaxWidth));\n        }\n    }\n    return -1;\n}\n/**\n * 列宽拖动最小宽度\n * @param params\n * @returns\n */\nexport function getColReMinWidth(params) {\n    var $table = params.$table, column = params.column, cell = params.cell;\n    var tableProps = $table.props;\n    var computeResizableOpts = $table.getComputeMaps().computeResizableOpts;\n    var resizableOpts = computeResizableOpts.value;\n    var reMinWidth = resizableOpts.minWidth;\n    // 如果自定义调整宽度逻辑\n    if (reMinWidth) {\n        var customMinWidth = XEUtils.isFunction(reMinWidth) ? reMinWidth(params) : reMinWidth;\n        if (customMinWidth !== 'auto') {\n            return Math.max(1, XEUtils.toNumber(customMinWidth));\n        }\n    }\n    var allColumnHeaderOverflow = tableProps.showHeaderOverflow;\n    var showHeaderOverflow = column.showHeaderOverflow, colMinWidth = column.minWidth;\n    var headOverflow = XEUtils.isUndefined(showHeaderOverflow) || XEUtils.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;\n    var showEllipsis = headOverflow === 'ellipsis';\n    var showTitle = headOverflow === 'title';\n    var showTooltip = headOverflow === true || headOverflow === 'tooltip';\n    var hasEllipsis = showTitle || showTooltip || showEllipsis;\n    var minTitleWidth = XEUtils.floor((XEUtils.toNumber(getComputedStyle(cell).fontSize) || 14) * 1.6);\n    var paddingLeftRight = getPaddingLeftRightSize(cell) + getPaddingLeftRightSize(queryCellElement(cell, ''));\n    var mWidth = minTitleWidth + paddingLeftRight;\n    // 默认最小宽处理\n    if (hasEllipsis) {\n        var checkboxIconWidth = getPaddingLeftRightSize(queryCellElement(cell, '--title>.vxe-cell--checkbox'));\n        var requiredIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell--required-icon'));\n        var editIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell--edit-icon'));\n        var prefixIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell-title-prefix-icon'));\n        var suffixIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell-title-suffix-icon'));\n        var sortIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell--sort'));\n        var filterIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell--filter'));\n        mWidth += checkboxIconWidth + requiredIconWidth + editIconWidth + prefixIconWidth + suffixIconWidth + filterIconWidth + sortIconWidth;\n    }\n    // 如果设置最小宽\n    if (colMinWidth) {\n        var refTableBody = $table.getRefMaps().refTableBody;\n        var tableBody = refTableBody.value;\n        var bodyElem = tableBody ? tableBody.$el : null;\n        if (bodyElem) {\n            if (isScale(colMinWidth)) {\n                var bodyWidth = bodyElem.clientWidth - 1;\n                var meanWidth = bodyWidth / 100;\n                return Math.max(mWidth, Math.floor(XEUtils.toInteger(colMinWidth) * meanWidth));\n            }\n            else if (isPx(colMinWidth)) {\n                return Math.max(mWidth, XEUtils.toInteger(colMinWidth));\n            }\n        }\n    }\n    return mWidth;\n}\nexport function isColumnInfo(column) {\n    return column && (column.constructor === ColumnInfo || column instanceof ColumnInfo);\n}\nexport function createColumn($xetable, options, renderOptions) {\n    return isColumnInfo(options) ? options : reactive(new ColumnInfo($xetable, options, renderOptions));\n}\nexport function watchColumn($xetable, props, column) {\n    Object.keys(props).forEach(function (name) {\n        watch(function () { return props[name]; }, function (value) {\n            column.update(name, value);\n            if ($xetable) {\n                if (name === 'filters') {\n                    $xetable.setFilter(column, value);\n                    $xetable.handleUpdateDataQueue();\n                }\n                else if (['visible', 'fixed', 'width', 'minWidth', 'maxWidth'].includes(name)) {\n                    $xetable.handleRefreshColumnQueue();\n                }\n            }\n        });\n    });\n}\nexport function assemColumn($xetable, elem, column, colgroup) {\n    var reactData = $xetable.reactData;\n    var staticColumns = reactData.staticColumns;\n    var parentElem = elem.parentNode;\n    var parentColumn = colgroup ? colgroup.column : null;\n    var parentCols = parentColumn ? parentColumn.children : staticColumns;\n    if (parentElem && parentCols) {\n        parentCols.splice(XEUtils.arrayIndexOf(parentElem.children, elem), 0, column);\n        reactData.staticColumns = staticColumns.slice(0);\n    }\n}\nexport function destroyColumn($xetable, column) {\n    var reactData = $xetable.reactData;\n    var staticColumns = reactData.staticColumns;\n    var matchObj = XEUtils.findTree(staticColumns, function (item) { return item.id === column.id; }, { children: 'children' });\n    if (matchObj) {\n        matchObj.items.splice(matchObj.index, 1);\n    }\n    reactData.staticColumns = staticColumns.slice(0);\n}\nexport function getRootColumn($xetable, column) {\n    var internalData = $xetable.internalData;\n    var fullColumnIdData = internalData.fullColumnIdData;\n    if (!column) {\n        return null;\n    }\n    var parentColId = column.parentId;\n    while (fullColumnIdData[parentColId]) {\n        var column_1 = fullColumnIdData[parentColId].column;\n        parentColId = column_1.parentId;\n        if (!parentColId) {\n            return column_1;\n        }\n    }\n    return column;\n}\nexport function mergeBodyMethod(mergeList, _rowIndex, _columnIndex) {\n    for (var mIndex = 0; mIndex < mergeList.length; mIndex++) {\n        var _a = mergeList[mIndex], mergeRowIndex = _a.row, mergeColIndex = _a.col, mergeRowspan = _a.rowspan, mergeColspan = _a.colspan;\n        if (mergeColIndex > -1 && mergeRowIndex > -1 && mergeRowspan && mergeColspan) {\n            if (mergeRowIndex === _rowIndex && mergeColIndex === _columnIndex) {\n                return { rowspan: mergeRowspan, colspan: mergeColspan };\n            }\n            if (_rowIndex >= mergeRowIndex && _rowIndex < mergeRowIndex + mergeRowspan && _columnIndex >= mergeColIndex && _columnIndex < mergeColIndex + mergeColspan) {\n                return { rowspan: 0, colspan: 0 };\n            }\n        }\n    }\n}\nexport function clearTableDefaultStatus($xetable) {\n    var props = $xetable.props, internalData = $xetable.internalData;\n    internalData.initStatus = false;\n    $xetable.clearSort();\n    $xetable.clearCurrentRow();\n    $xetable.clearCurrentColumn();\n    $xetable.clearRadioRow();\n    $xetable.clearRadioReserve();\n    $xetable.clearCheckboxRow();\n    $xetable.clearCheckboxReserve();\n    $xetable.clearRowExpand();\n    $xetable.clearTreeExpand();\n    $xetable.clearTreeExpandReserve();\n    $xetable.clearPendingRow();\n    if ($xetable.clearFilter) {\n        $xetable.clearFilter();\n    }\n    if ($xetable.clearSelected && (props.keyboardConfig || props.mouseConfig)) {\n        $xetable.clearSelected();\n    }\n    if ($xetable.clearCellAreas && props.mouseConfig) {\n        $xetable.clearCellAreas();\n        $xetable.clearCopyCellArea();\n    }\n    return $xetable.clearScroll();\n}\nexport function clearTableAllStatus($xetable) {\n    if ($xetable.clearFilter) {\n        $xetable.clearFilter();\n    }\n    return clearTableDefaultStatus($xetable);\n}\nexport function rowToVisible($xetable, row) {\n    var reactData = $xetable.reactData, internalData = $xetable.internalData;\n    var refTableBody = $xetable.getRefMaps().refTableBody;\n    var scrollYLoad = reactData.scrollYLoad;\n    var afterFullData = internalData.afterFullData, scrollYStore = internalData.scrollYStore;\n    var tableBody = refTableBody.value;\n    var bodyElem = tableBody ? tableBody.$el : null;\n    if (bodyElem) {\n        var trElem = bodyElem.querySelector(\"[rowid=\\\"\".concat(getRowid($xetable, row), \"\\\"]\"));\n        if (trElem) {\n            var bodyHeight = bodyElem.clientHeight;\n            var bodySrcollTop = bodyElem.scrollTop;\n            var trOffsetParent = trElem.offsetParent;\n            var trOffsetTop = trElem.offsetTop + (trOffsetParent ? trOffsetParent.offsetTop : 0);\n            var trHeight = trElem.clientHeight;\n            // 检测行是否在可视区中\n            if (trOffsetTop < bodySrcollTop || trOffsetTop > bodySrcollTop + bodyHeight) {\n                // 向上定位\n                return $xetable.scrollTo(null, trOffsetTop);\n            }\n            else if (trOffsetTop + trHeight >= bodyHeight + bodySrcollTop) {\n                // 向下定位\n                return $xetable.scrollTo(null, bodySrcollTop + trHeight);\n            }\n        }\n        else {\n            // 如果是虚拟渲染跨行滚动\n            if (scrollYLoad) {\n                return $xetable.scrollTo(null, (afterFullData.indexOf(row) - 1) * scrollYStore.rowHeight);\n            }\n        }\n    }\n    return Promise.resolve();\n}\nexport function colToVisible($xetable, column) {\n    var reactData = $xetable.reactData, internalData = $xetable.internalData;\n    var refTableBody = $xetable.getRefMaps().refTableBody;\n    var scrollXLoad = reactData.scrollXLoad;\n    var visibleColumn = internalData.visibleColumn;\n    var tableBody = refTableBody.value;\n    var bodyElem = tableBody ? tableBody.$el : null;\n    if (bodyElem) {\n        var tdElem = bodyElem.querySelector(\".\".concat(column.id));\n        if (tdElem) {\n            var bodyWidth = bodyElem.clientWidth;\n            var bodySrcollLeft = bodyElem.scrollLeft;\n            var tdOffsetParent = tdElem.offsetParent;\n            var tdOffsetLeft = tdElem.offsetLeft + (tdOffsetParent ? tdOffsetParent.offsetLeft : 0);\n            var tdWidth = tdElem.clientWidth;\n            // 检测行是否在可视区中\n            if (tdOffsetLeft < bodySrcollLeft || tdOffsetLeft > bodySrcollLeft + bodyWidth) {\n                // 向左定位\n                return $xetable.scrollTo(tdOffsetLeft);\n            }\n            else if (tdOffsetLeft + tdWidth >= bodyWidth + bodySrcollLeft) {\n                // 向右定位\n                return $xetable.scrollTo(bodySrcollLeft + tdWidth);\n            }\n        }\n        else {\n            // 如果是虚拟渲染跨行滚动\n            if (scrollXLoad) {\n                var scrollLeft = 0;\n                for (var index = 0; index < visibleColumn.length; index++) {\n                    if (visibleColumn[index] === column) {\n                        break;\n                    }\n                    scrollLeft += visibleColumn[index].renderWidth;\n                }\n                return $xetable.scrollTo(scrollLeft);\n            }\n        }\n    }\n    return Promise.resolve();\n}\n",
      "start": 1714699768217,
      "end": 1714699768251,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1714699768251,
      "end": 1714699768251,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1714699768251,
      "end": 1714699768251,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1714699768251,
      "end": 1714699768251,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1714699768251,
      "end": 1714699768251,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1714699768251,
      "end": 1714699768251,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1714699768251,
      "end": 1714699768251,
      "order": "normal"
    },
    {
      "name": "vite-plugin-vconsole",
      "result": "import { watch, reactive } from 'vue';\nimport XEUtils from 'xe-utils';\nimport { ColumnInfo } from './columnInfo';\nimport { isPx, isScale } from '../../tools/dom';\nexport function restoreScrollLocation($xetable, scrollLeft, scrollTop) {\n    var internalData = $xetable.internalData;\n    return $xetable.clearScroll().then(function () {\n        if (scrollLeft || scrollTop) {\n            // 重置最后滚动状态\n            internalData.lastScrollLeft = 0;\n            internalData.lastScrollTop = 0;\n            // 还原滚动状态\n            return $xetable.scrollTo(scrollLeft, scrollTop);\n        }\n    });\n}\nexport function removeScrollListener(scrollElem) {\n    if (scrollElem && scrollElem._onscroll) {\n        scrollElem.onscroll = null;\n    }\n}\nexport function restoreScrollListener(scrollElem) {\n    if (scrollElem && scrollElem._onscroll) {\n        scrollElem.onscroll = scrollElem._onscroll;\n    }\n}\n/**\n * 生成行的唯一主键\n */\nexport function getRowUniqueId() {\n    return XEUtils.uniqueId('row_');\n}\n// 行主键 key\nexport function getRowkey($xetable) {\n    var props = $xetable.props;\n    var computeRowOpts = $xetable.getComputeMaps().computeRowOpts;\n    var rowId = props.rowId;\n    var rowOpts = computeRowOpts.value;\n    return rowId || rowOpts.keyField || '_X_ROW_KEY';\n}\n// 行主键 value\nexport function getRowid($xetable, row) {\n    var rowid = XEUtils.get(row, getRowkey($xetable));\n    return XEUtils.eqNull(rowid) ? '' : encodeURIComponent(rowid);\n}\nexport var handleFieldOrColumn = function ($xetable, fieldOrColumn) {\n    if (fieldOrColumn) {\n        return XEUtils.isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;\n    }\n    return null;\n};\nfunction getPaddingLeftRightSize(elem) {\n    if (elem) {\n        var computedStyle = getComputedStyle(elem);\n        var paddingLeft = XEUtils.toNumber(computedStyle.paddingLeft);\n        var paddingRight = XEUtils.toNumber(computedStyle.paddingRight);\n        return paddingLeft + paddingRight;\n    }\n    return 0;\n}\nfunction getElemenMarginWidth(elem) {\n    if (elem) {\n        var computedStyle = getComputedStyle(elem);\n        var marginLeft = XEUtils.toNumber(computedStyle.marginLeft);\n        var marginRight = XEUtils.toNumber(computedStyle.marginRight);\n        return elem.offsetWidth + marginLeft + marginRight;\n    }\n    return 0;\n}\nfunction queryCellElement(cell, selector) {\n    return cell.querySelector('.vxe-cell' + selector);\n}\nexport function toFilters(filters) {\n    if (filters && XEUtils.isArray(filters)) {\n        return filters.map(function (_a) {\n            var label = _a.label, value = _a.value, data = _a.data, resetValue = _a.resetValue, checked = _a.checked;\n            return { label: label, value: value, data: data, resetValue: resetValue, checked: !!checked, _checked: !!checked };\n        });\n    }\n    return filters;\n}\nexport function toTreePathSeq(path) {\n    return path.map(function (num, i) { return i % 2 === 0 ? (Number(num) + 1) : '.'; }).join('');\n}\nexport function getCellValue(row, column) {\n    return XEUtils.get(row, column.field);\n}\nexport function setCellValue(row, column, value) {\n    return XEUtils.set(row, column.field, value);\n}\n/**\n * 列宽拖动最大宽度\n * @param params\n * @returns\n */\nexport function getColReMaxWidth(params) {\n    var $table = params.$table;\n    var computeResizableOpts = $table.getComputeMaps().computeResizableOpts;\n    var resizableOpts = computeResizableOpts.value;\n    var reMaxWidth = resizableOpts.maxWidth;\n    // 如果自定义调整宽度逻辑\n    if (reMaxWidth) {\n        var customMaxWidth = XEUtils.isFunction(reMaxWidth) ? reMaxWidth(params) : reMaxWidth;\n        if (customMaxWidth !== 'auto') {\n            return Math.max(1, XEUtils.toNumber(customMaxWidth));\n        }\n    }\n    return -1;\n}\n/**\n * 列宽拖动最小宽度\n * @param params\n * @returns\n */\nexport function getColReMinWidth(params) {\n    var $table = params.$table, column = params.column, cell = params.cell;\n    var tableProps = $table.props;\n    var computeResizableOpts = $table.getComputeMaps().computeResizableOpts;\n    var resizableOpts = computeResizableOpts.value;\n    var reMinWidth = resizableOpts.minWidth;\n    // 如果自定义调整宽度逻辑\n    if (reMinWidth) {\n        var customMinWidth = XEUtils.isFunction(reMinWidth) ? reMinWidth(params) : reMinWidth;\n        if (customMinWidth !== 'auto') {\n            return Math.max(1, XEUtils.toNumber(customMinWidth));\n        }\n    }\n    var allColumnHeaderOverflow = tableProps.showHeaderOverflow;\n    var showHeaderOverflow = column.showHeaderOverflow, colMinWidth = column.minWidth;\n    var headOverflow = XEUtils.isUndefined(showHeaderOverflow) || XEUtils.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;\n    var showEllipsis = headOverflow === 'ellipsis';\n    var showTitle = headOverflow === 'title';\n    var showTooltip = headOverflow === true || headOverflow === 'tooltip';\n    var hasEllipsis = showTitle || showTooltip || showEllipsis;\n    var minTitleWidth = XEUtils.floor((XEUtils.toNumber(getComputedStyle(cell).fontSize) || 14) * 1.6);\n    var paddingLeftRight = getPaddingLeftRightSize(cell) + getPaddingLeftRightSize(queryCellElement(cell, ''));\n    var mWidth = minTitleWidth + paddingLeftRight;\n    // 默认最小宽处理\n    if (hasEllipsis) {\n        var checkboxIconWidth = getPaddingLeftRightSize(queryCellElement(cell, '--title>.vxe-cell--checkbox'));\n        var requiredIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell--required-icon'));\n        var editIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell--edit-icon'));\n        var prefixIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell-title-prefix-icon'));\n        var suffixIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell-title-suffix-icon'));\n        var sortIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell--sort'));\n        var filterIconWidth = getElemenMarginWidth(queryCellElement(cell, '>.vxe-cell--filter'));\n        mWidth += checkboxIconWidth + requiredIconWidth + editIconWidth + prefixIconWidth + suffixIconWidth + filterIconWidth + sortIconWidth;\n    }\n    // 如果设置最小宽\n    if (colMinWidth) {\n        var refTableBody = $table.getRefMaps().refTableBody;\n        var tableBody = refTableBody.value;\n        var bodyElem = tableBody ? tableBody.$el : null;\n        if (bodyElem) {\n            if (isScale(colMinWidth)) {\n                var bodyWidth = bodyElem.clientWidth - 1;\n                var meanWidth = bodyWidth / 100;\n                return Math.max(mWidth, Math.floor(XEUtils.toInteger(colMinWidth) * meanWidth));\n            }\n            else if (isPx(colMinWidth)) {\n                return Math.max(mWidth, XEUtils.toInteger(colMinWidth));\n            }\n        }\n    }\n    return mWidth;\n}\nexport function isColumnInfo(column) {\n    return column && (column.constructor === ColumnInfo || column instanceof ColumnInfo);\n}\nexport function createColumn($xetable, options, renderOptions) {\n    return isColumnInfo(options) ? options : reactive(new ColumnInfo($xetable, options, renderOptions));\n}\nexport function watchColumn($xetable, props, column) {\n    Object.keys(props).forEach(function (name) {\n        watch(function () { return props[name]; }, function (value) {\n            column.update(name, value);\n            if ($xetable) {\n                if (name === 'filters') {\n                    $xetable.setFilter(column, value);\n                    $xetable.handleUpdateDataQueue();\n                }\n                else if (['visible', 'fixed', 'width', 'minWidth', 'maxWidth'].includes(name)) {\n                    $xetable.handleRefreshColumnQueue();\n                }\n            }\n        });\n    });\n}\nexport function assemColumn($xetable, elem, column, colgroup) {\n    var reactData = $xetable.reactData;\n    var staticColumns = reactData.staticColumns;\n    var parentElem = elem.parentNode;\n    var parentColumn = colgroup ? colgroup.column : null;\n    var parentCols = parentColumn ? parentColumn.children : staticColumns;\n    if (parentElem && parentCols) {\n        parentCols.splice(XEUtils.arrayIndexOf(parentElem.children, elem), 0, column);\n        reactData.staticColumns = staticColumns.slice(0);\n    }\n}\nexport function destroyColumn($xetable, column) {\n    var reactData = $xetable.reactData;\n    var staticColumns = reactData.staticColumns;\n    var matchObj = XEUtils.findTree(staticColumns, function (item) { return item.id === column.id; }, { children: 'children' });\n    if (matchObj) {\n        matchObj.items.splice(matchObj.index, 1);\n    }\n    reactData.staticColumns = staticColumns.slice(0);\n}\nexport function getRootColumn($xetable, column) {\n    var internalData = $xetable.internalData;\n    var fullColumnIdData = internalData.fullColumnIdData;\n    if (!column) {\n        return null;\n    }\n    var parentColId = column.parentId;\n    while (fullColumnIdData[parentColId]) {\n        var column_1 = fullColumnIdData[parentColId].column;\n        parentColId = column_1.parentId;\n        if (!parentColId) {\n            return column_1;\n        }\n    }\n    return column;\n}\nexport function mergeBodyMethod(mergeList, _rowIndex, _columnIndex) {\n    for (var mIndex = 0; mIndex < mergeList.length; mIndex++) {\n        var _a = mergeList[mIndex], mergeRowIndex = _a.row, mergeColIndex = _a.col, mergeRowspan = _a.rowspan, mergeColspan = _a.colspan;\n        if (mergeColIndex > -1 && mergeRowIndex > -1 && mergeRowspan && mergeColspan) {\n            if (mergeRowIndex === _rowIndex && mergeColIndex === _columnIndex) {\n                return { rowspan: mergeRowspan, colspan: mergeColspan };\n            }\n            if (_rowIndex >= mergeRowIndex && _rowIndex < mergeRowIndex + mergeRowspan && _columnIndex >= mergeColIndex && _columnIndex < mergeColIndex + mergeColspan) {\n                return { rowspan: 0, colspan: 0 };\n            }\n        }\n    }\n}\nexport function clearTableDefaultStatus($xetable) {\n    var props = $xetable.props, internalData = $xetable.internalData;\n    internalData.initStatus = false;\n    $xetable.clearSort();\n    $xetable.clearCurrentRow();\n    $xetable.clearCurrentColumn();\n    $xetable.clearRadioRow();\n    $xetable.clearRadioReserve();\n    $xetable.clearCheckboxRow();\n    $xetable.clearCheckboxReserve();\n    $xetable.clearRowExpand();\n    $xetable.clearTreeExpand();\n    $xetable.clearTreeExpandReserve();\n    $xetable.clearPendingRow();\n    if ($xetable.clearFilter) {\n        $xetable.clearFilter();\n    }\n    if ($xetable.clearSelected && (props.keyboardConfig || props.mouseConfig)) {\n        $xetable.clearSelected();\n    }\n    if ($xetable.clearCellAreas && props.mouseConfig) {\n        $xetable.clearCellAreas();\n        $xetable.clearCopyCellArea();\n    }\n    return $xetable.clearScroll();\n}\nexport function clearTableAllStatus($xetable) {\n    if ($xetable.clearFilter) {\n        $xetable.clearFilter();\n    }\n    return clearTableDefaultStatus($xetable);\n}\nexport function rowToVisible($xetable, row) {\n    var reactData = $xetable.reactData, internalData = $xetable.internalData;\n    var refTableBody = $xetable.getRefMaps().refTableBody;\n    var scrollYLoad = reactData.scrollYLoad;\n    var afterFullData = internalData.afterFullData, scrollYStore = internalData.scrollYStore;\n    var tableBody = refTableBody.value;\n    var bodyElem = tableBody ? tableBody.$el : null;\n    if (bodyElem) {\n        var trElem = bodyElem.querySelector(\"[rowid=\\\"\".concat(getRowid($xetable, row), \"\\\"]\"));\n        if (trElem) {\n            var bodyHeight = bodyElem.clientHeight;\n            var bodySrcollTop = bodyElem.scrollTop;\n            var trOffsetParent = trElem.offsetParent;\n            var trOffsetTop = trElem.offsetTop + (trOffsetParent ? trOffsetParent.offsetTop : 0);\n            var trHeight = trElem.clientHeight;\n            // 检测行是否在可视区中\n            if (trOffsetTop < bodySrcollTop || trOffsetTop > bodySrcollTop + bodyHeight) {\n                // 向上定位\n                return $xetable.scrollTo(null, trOffsetTop);\n            }\n            else if (trOffsetTop + trHeight >= bodyHeight + bodySrcollTop) {\n                // 向下定位\n                return $xetable.scrollTo(null, bodySrcollTop + trHeight);\n            }\n        }\n        else {\n            // 如果是虚拟渲染跨行滚动\n            if (scrollYLoad) {\n                return $xetable.scrollTo(null, (afterFullData.indexOf(row) - 1) * scrollYStore.rowHeight);\n            }\n        }\n    }\n    return Promise.resolve();\n}\nexport function colToVisible($xetable, column) {\n    var reactData = $xetable.reactData, internalData = $xetable.internalData;\n    var refTableBody = $xetable.getRefMaps().refTableBody;\n    var scrollXLoad = reactData.scrollXLoad;\n    var visibleColumn = internalData.visibleColumn;\n    var tableBody = refTableBody.value;\n    var bodyElem = tableBody ? tableBody.$el : null;\n    if (bodyElem) {\n        var tdElem = bodyElem.querySelector(\".\".concat(column.id));\n        if (tdElem) {\n            var bodyWidth = bodyElem.clientWidth;\n            var bodySrcollLeft = bodyElem.scrollLeft;\n            var tdOffsetParent = tdElem.offsetParent;\n            var tdOffsetLeft = tdElem.offsetLeft + (tdOffsetParent ? tdOffsetParent.offsetLeft : 0);\n            var tdWidth = tdElem.clientWidth;\n            // 检测行是否在可视区中\n            if (tdOffsetLeft < bodySrcollLeft || tdOffsetLeft > bodySrcollLeft + bodyWidth) {\n                // 向左定位\n                return $xetable.scrollTo(tdOffsetLeft);\n            }\n            else if (tdOffsetLeft + tdWidth >= bodyWidth + bodySrcollLeft) {\n                // 向右定位\n                return $xetable.scrollTo(bodySrcollLeft + tdWidth);\n            }\n        }\n        else {\n            // 如果是虚拟渲染跨行滚动\n            if (scrollXLoad) {\n                var scrollLeft = 0;\n                for (var index = 0; index < visibleColumn.length; index++) {\n                    if (visibleColumn[index] === column) {\n                        break;\n                    }\n                    scrollLeft += visibleColumn[index].renderWidth;\n                }\n                return $xetable.scrollTo(scrollLeft);\n            }\n        }\n    }\n    return Promise.resolve();\n}\n",
      "start": 1714699768251,
      "end": 1714699768251,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "esbuild",
      "start": 1714699768251,
      "end": 1714699768251,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1714699768251,
      "end": 1714699768251,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1714699768251,
      "end": 1714699768251,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1714699768251,
      "end": 1714699768251,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1714699768251,
      "end": 1714699768251,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1714699768251,
      "end": 1714699768251,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1714699768251,
      "end": 1714699768252,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1714699768252,
      "end": 1714699768252,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1714699768252,
      "end": 1714699768252,
      "order": "normal"
    },
    {
      "name": "unplugin-auto-import",
      "start": 1714699768252,
      "end": 1714699768252,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1714699768252,
      "end": 1714699768252,
      "order": "post"
    },
    {
      "name": "vite:style-import",
      "start": 1714699768252,
      "end": 1714699768252,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1714699768252,
      "end": 1714699768252,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1714699768252,
      "end": 1714699768252,
      "order": "normal"
    }
  ]
}
