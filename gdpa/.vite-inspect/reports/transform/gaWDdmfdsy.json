{
  "resolvedId": "/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/version.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "const Utils = require('./utils')\nconst ECCode = require('./error-correction-code')\nconst ECLevel = require('./error-correction-level')\nconst Mode = require('./mode')\nconst VersionCheck = require('./version-check')\n\n// Generator polynomial used to encode version information\nconst G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0)\nconst G18_BCH = Utils.getBCHDigit(G18)\n\nfunction getBestVersionForDataLength (mode, length, errorCorrectionLevel) {\n  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {\n      return currentVersion\n    }\n  }\n\n  return undefined\n}\n\nfunction getReservedBitsCount (mode, version) {\n  // Character count indicator + mode indicator bits\n  return Mode.getCharCountIndicator(mode, version) + 4\n}\n\nfunction getTotalBitsFromDataArray (segments, version) {\n  let totalBits = 0\n\n  segments.forEach(function (data) {\n    const reservedBits = getReservedBitsCount(data.mode, version)\n    totalBits += reservedBits + data.getBitsLength()\n  })\n\n  return totalBits\n}\n\nfunction getBestVersionForMixedData (segments, errorCorrectionLevel) {\n  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n    const length = getTotalBitsFromDataArray(segments, currentVersion)\n    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {\n      return currentVersion\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Returns version number from a value.\n * If value is not a valid version, returns defaultValue\n *\n * @param  {Number|String} value        QR Code version\n * @param  {Number}        defaultValue Fallback value\n * @return {Number}                     QR Code version number\n */\nexports.from = function from (value, defaultValue) {\n  if (VersionCheck.isValid(value)) {\n    return parseInt(value, 10)\n  }\n\n  return defaultValue\n}\n\n/**\n * Returns how much data can be stored with the specified QR code version\n * and error correction level\n *\n * @param  {Number} version              QR Code version (1-40)\n * @param  {Number} errorCorrectionLevel Error correction level\n * @param  {Mode}   mode                 Data mode\n * @return {Number}                      Quantity of storable data\n */\nexports.getCapacity = function getCapacity (version, errorCorrectionLevel, mode) {\n  if (!VersionCheck.isValid(version)) {\n    throw new Error('Invalid QR Code version')\n  }\n\n  // Use Byte mode as default\n  if (typeof mode === 'undefined') mode = Mode.BYTE\n\n  // Total codewords for this QR code version (Data + Error correction)\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n\n  // Total number of error correction codewords\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n\n  // Total number of data codewords\n  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8\n\n  if (mode === Mode.MIXED) return dataTotalCodewordsBits\n\n  const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version)\n\n  // Return max number of storable codewords\n  switch (mode) {\n    case Mode.NUMERIC:\n      return Math.floor((usableBits / 10) * 3)\n\n    case Mode.ALPHANUMERIC:\n      return Math.floor((usableBits / 11) * 2)\n\n    case Mode.KANJI:\n      return Math.floor(usableBits / 13)\n\n    case Mode.BYTE:\n    default:\n      return Math.floor(usableBits / 8)\n  }\n}\n\n/**\n * Returns the minimum version needed to contain the amount of data\n *\n * @param  {Segment} data                    Segment of data\n * @param  {Number} [errorCorrectionLevel=H] Error correction level\n * @param  {Mode} mode                       Data mode\n * @return {Number}                          QR Code version\n */\nexports.getBestVersionForData = function getBestVersionForData (data, errorCorrectionLevel) {\n  let seg\n\n  const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M)\n\n  if (Array.isArray(data)) {\n    if (data.length > 1) {\n      return getBestVersionForMixedData(data, ecl)\n    }\n\n    if (data.length === 0) {\n      return 1\n    }\n\n    seg = data[0]\n  } else {\n    seg = data\n  }\n\n  return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl)\n}\n\n/**\n * Returns version information with relative error correction bits\n *\n * The version information is included in QR Code symbols of version 7 or larger.\n * It consists of an 18-bit sequence containing 6 data bits,\n * with 12 error correction bits calculated using the (18, 6) Golay code.\n *\n * @param  {Number} version QR Code version\n * @return {Number}         Encoded version info bits\n */\nexports.getEncodedBits = function getEncodedBits (version) {\n  if (!VersionCheck.isValid(version) || version < 7) {\n    throw new Error('Invalid QR Code version')\n  }\n\n  let d = version << 12\n\n  while (Utils.getBCHDigit(d) - G18_BCH >= 0) {\n    d ^= (G18 << (Utils.getBCHDigit(d) - G18_BCH))\n  }\n\n  return (version << 12) | d\n}\n",
      "start": 1714699771036,
      "end": 1714699771062,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1714699771062,
      "end": 1714699771062,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1714699771062,
      "end": 1714699771062,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1714699771062,
      "end": 1714699771062,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1714699771062,
      "end": 1714699771062,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1714699771062,
      "end": 1714699771062,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1714699771062,
      "end": 1714699771062,
      "order": "normal"
    },
    {
      "name": "vite-plugin-vconsole",
      "result": "const Utils = require('./utils')\nconst ECCode = require('./error-correction-code')\nconst ECLevel = require('./error-correction-level')\nconst Mode = require('./mode')\nconst VersionCheck = require('./version-check')\n\n// Generator polynomial used to encode version information\nconst G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0)\nconst G18_BCH = Utils.getBCHDigit(G18)\n\nfunction getBestVersionForDataLength (mode, length, errorCorrectionLevel) {\n  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {\n      return currentVersion\n    }\n  }\n\n  return undefined\n}\n\nfunction getReservedBitsCount (mode, version) {\n  // Character count indicator + mode indicator bits\n  return Mode.getCharCountIndicator(mode, version) + 4\n}\n\nfunction getTotalBitsFromDataArray (segments, version) {\n  let totalBits = 0\n\n  segments.forEach(function (data) {\n    const reservedBits = getReservedBitsCount(data.mode, version)\n    totalBits += reservedBits + data.getBitsLength()\n  })\n\n  return totalBits\n}\n\nfunction getBestVersionForMixedData (segments, errorCorrectionLevel) {\n  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n    const length = getTotalBitsFromDataArray(segments, currentVersion)\n    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {\n      return currentVersion\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Returns version number from a value.\n * If value is not a valid version, returns defaultValue\n *\n * @param  {Number|String} value        QR Code version\n * @param  {Number}        defaultValue Fallback value\n * @return {Number}                     QR Code version number\n */\nexports.from = function from (value, defaultValue) {\n  if (VersionCheck.isValid(value)) {\n    return parseInt(value, 10)\n  }\n\n  return defaultValue\n}\n\n/**\n * Returns how much data can be stored with the specified QR code version\n * and error correction level\n *\n * @param  {Number} version              QR Code version (1-40)\n * @param  {Number} errorCorrectionLevel Error correction level\n * @param  {Mode}   mode                 Data mode\n * @return {Number}                      Quantity of storable data\n */\nexports.getCapacity = function getCapacity (version, errorCorrectionLevel, mode) {\n  if (!VersionCheck.isValid(version)) {\n    throw new Error('Invalid QR Code version')\n  }\n\n  // Use Byte mode as default\n  if (typeof mode === 'undefined') mode = Mode.BYTE\n\n  // Total codewords for this QR code version (Data + Error correction)\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n\n  // Total number of error correction codewords\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n\n  // Total number of data codewords\n  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8\n\n  if (mode === Mode.MIXED) return dataTotalCodewordsBits\n\n  const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version)\n\n  // Return max number of storable codewords\n  switch (mode) {\n    case Mode.NUMERIC:\n      return Math.floor((usableBits / 10) * 3)\n\n    case Mode.ALPHANUMERIC:\n      return Math.floor((usableBits / 11) * 2)\n\n    case Mode.KANJI:\n      return Math.floor(usableBits / 13)\n\n    case Mode.BYTE:\n    default:\n      return Math.floor(usableBits / 8)\n  }\n}\n\n/**\n * Returns the minimum version needed to contain the amount of data\n *\n * @param  {Segment} data                    Segment of data\n * @param  {Number} [errorCorrectionLevel=H] Error correction level\n * @param  {Mode} mode                       Data mode\n * @return {Number}                          QR Code version\n */\nexports.getBestVersionForData = function getBestVersionForData (data, errorCorrectionLevel) {\n  let seg\n\n  const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M)\n\n  if (Array.isArray(data)) {\n    if (data.length > 1) {\n      return getBestVersionForMixedData(data, ecl)\n    }\n\n    if (data.length === 0) {\n      return 1\n    }\n\n    seg = data[0]\n  } else {\n    seg = data\n  }\n\n  return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl)\n}\n\n/**\n * Returns version information with relative error correction bits\n *\n * The version information is included in QR Code symbols of version 7 or larger.\n * It consists of an 18-bit sequence containing 6 data bits,\n * with 12 error correction bits calculated using the (18, 6) Golay code.\n *\n * @param  {Number} version QR Code version\n * @return {Number}         Encoded version info bits\n */\nexports.getEncodedBits = function getEncodedBits (version) {\n  if (!VersionCheck.isValid(version) || version < 7) {\n    throw new Error('Invalid QR Code version')\n  }\n\n  let d = version << 12\n\n  while (Utils.getBCHDigit(d) - G18_BCH >= 0) {\n    d ^= (G18 << (Utils.getBCHDigit(d) - G18_BCH))\n  }\n\n  return (version << 12) | d\n}\n",
      "start": 1714699771062,
      "end": 1714699771062,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "esbuild",
      "start": 1714699771062,
      "end": 1714699771062,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1714699771062,
      "end": 1714699771062,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1714699771062,
      "end": 1714699771062,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1714699771062,
      "end": 1714699771062,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1714699771062,
      "end": 1714699771062,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1714699771062,
      "end": 1714699771062,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "result": "import * as commonjsHelpers from \"\u0000commonjsHelpers.js\";\nimport { __exports as version } from \"\\u0000/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/version.js?commonjs-exports\";\nimport require$$0 from \"\\u0000/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/utils.js?commonjs-proxy\";\nimport require$$1 from \"\\u0000/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/error-correction-code.js?commonjs-proxy\";\nimport require$$2 from \"\\u0000/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/error-correction-level.js?commonjs-proxy\";\nimport require$$3 from \"\\u0000/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/mode.js?commonjs-proxy\";\nimport require$$4 from \"\\u0000/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/qrcode@1.5.3/node_modules/qrcode/lib/core/version-check.js?commonjs-proxy\";\n\n(function (exports) {\n\tconst Utils = require$$0\n\tconst ECCode = require$$1\n\tconst ECLevel = require$$2\n\tconst Mode = require$$3\n\tconst VersionCheck = require$$4\n\n\t// Generator polynomial used to encode version information\n\tconst G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0)\n\tconst G18_BCH = Utils.getBCHDigit(G18)\n\n\tfunction getBestVersionForDataLength (mode, length, errorCorrectionLevel) {\n\t  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n\t    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {\n\t      return currentVersion\n\t    }\n\t  }\n\n\t  return undefined\n\t}\n\n\tfunction getReservedBitsCount (mode, version) {\n\t  // Character count indicator + mode indicator bits\n\t  return Mode.getCharCountIndicator(mode, version) + 4\n\t}\n\n\tfunction getTotalBitsFromDataArray (segments, version) {\n\t  let totalBits = 0\n\n\t  segments.forEach(function (data) {\n\t    const reservedBits = getReservedBitsCount(data.mode, version)\n\t    totalBits += reservedBits + data.getBitsLength()\n\t  })\n\n\t  return totalBits\n\t}\n\n\tfunction getBestVersionForMixedData (segments, errorCorrectionLevel) {\n\t  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n\t    const length = getTotalBitsFromDataArray(segments, currentVersion)\n\t    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {\n\t      return currentVersion\n\t    }\n\t  }\n\n\t  return undefined\n\t}\n\n\t/**\n\t * Returns version number from a value.\n\t * If value is not a valid version, returns defaultValue\n\t *\n\t * @param  {Number|String} value        QR Code version\n\t * @param  {Number}        defaultValue Fallback value\n\t * @return {Number}                     QR Code version number\n\t */\n\texports.from = function from (value, defaultValue) {\n\t  if (VersionCheck.isValid(value)) {\n\t    return parseInt(value, 10)\n\t  }\n\n\t  return defaultValue\n\t}\n\n\t/**\n\t * Returns how much data can be stored with the specified QR code version\n\t * and error correction level\n\t *\n\t * @param  {Number} version              QR Code version (1-40)\n\t * @param  {Number} errorCorrectionLevel Error correction level\n\t * @param  {Mode}   mode                 Data mode\n\t * @return {Number}                      Quantity of storable data\n\t */\n\texports.getCapacity = function getCapacity (version, errorCorrectionLevel, mode) {\n\t  if (!VersionCheck.isValid(version)) {\n\t    throw new Error('Invalid QR Code version')\n\t  }\n\n\t  // Use Byte mode as default\n\t  if (typeof mode === 'undefined') mode = Mode.BYTE\n\n\t  // Total codewords for this QR code version (Data + Error correction)\n\t  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n\n\t  // Total number of error correction codewords\n\t  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n\n\t  // Total number of data codewords\n\t  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8\n\n\t  if (mode === Mode.MIXED) return dataTotalCodewordsBits\n\n\t  const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version)\n\n\t  // Return max number of storable codewords\n\t  switch (mode) {\n\t    case Mode.NUMERIC:\n\t      return Math.floor((usableBits / 10) * 3)\n\n\t    case Mode.ALPHANUMERIC:\n\t      return Math.floor((usableBits / 11) * 2)\n\n\t    case Mode.KANJI:\n\t      return Math.floor(usableBits / 13)\n\n\t    case Mode.BYTE:\n\t    default:\n\t      return Math.floor(usableBits / 8)\n\t  }\n\t}\n\n\t/**\n\t * Returns the minimum version needed to contain the amount of data\n\t *\n\t * @param  {Segment} data                    Segment of data\n\t * @param  {Number} [errorCorrectionLevel=H] Error correction level\n\t * @param  {Mode} mode                       Data mode\n\t * @return {Number}                          QR Code version\n\t */\n\texports.getBestVersionForData = function getBestVersionForData (data, errorCorrectionLevel) {\n\t  let seg\n\n\t  const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M)\n\n\t  if (Array.isArray(data)) {\n\t    if (data.length > 1) {\n\t      return getBestVersionForMixedData(data, ecl)\n\t    }\n\n\t    if (data.length === 0) {\n\t      return 1\n\t    }\n\n\t    seg = data[0]\n\t  } else {\n\t    seg = data\n\t  }\n\n\t  return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl)\n\t}\n\n\t/**\n\t * Returns version information with relative error correction bits\n\t *\n\t * The version information is included in QR Code symbols of version 7 or larger.\n\t * It consists of an 18-bit sequence containing 6 data bits,\n\t * with 12 error correction bits calculated using the (18, 6) Golay code.\n\t *\n\t * @param  {Number} version QR Code version\n\t * @return {Number}         Encoded version info bits\n\t */\n\texports.getEncodedBits = function getEncodedBits (version) {\n\t  if (!VersionCheck.isValid(version) || version < 7) {\n\t    throw new Error('Invalid QR Code version')\n\t  }\n\n\t  let d = version << 12\n\n\t  while (Utils.getBCHDigit(d) - G18_BCH >= 0) {\n\t    d ^= (G18 << (Utils.getBCHDigit(d) - G18_BCH))\n\t  }\n\n\t  return (version << 12) | d\n\t} \n} (version));\n\nexport default /*@__PURE__*/commonjsHelpers.getDefaultExportFromCjs(version);\nexport { version as __moduleExports };",
      "start": 1714699771062,
      "end": 1714699771103,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          ""
        ],
        "names": [],
        "mappings": "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"
      }
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1714699771103,
      "end": 1714699771103,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1714699771103,
      "end": 1714699771103,
      "order": "normal"
    },
    {
      "name": "unplugin-auto-import",
      "start": 1714699771103,
      "end": 1714699771103,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1714699771103,
      "end": 1714699771103,
      "order": "post"
    },
    {
      "name": "vite:style-import",
      "start": 1714699771103,
      "end": 1714699771103,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1714699771103,
      "end": 1714699771103,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1714699771103,
      "end": 1714699771103,
      "order": "normal"
    }
  ]
}
