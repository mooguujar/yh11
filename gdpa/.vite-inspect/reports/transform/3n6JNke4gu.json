{
  "resolvedId": "/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/vxe-table@4.5.21_vue@3.4.19_xe-utils@3.5.24/node_modules/vxe-table/es/modal/src/modal.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { defineComponent, h, Teleport, ref, computed, reactive, nextTick, watch, onMounted, onUnmounted } from 'vue';\nimport XEUtils from 'xe-utils';\nimport { useSize } from '../../hooks/size';\nimport { getDomNode, getEventTargetNode } from '../../tools/dom';\nimport { getLastZIndex, nextZIndex, getFuncText } from '../../tools/utils';\nimport { errLog } from '../../tools/log';\nimport { GlobalEvent, hasEventKey, EVENT_KEYS } from '../../tools/event';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport VxeButtonConstructor from '../../button/src/button';\nimport VxeLoading from '../../loading/index';\nimport { getSlotVNs } from '../../tools/vn';\nexport var allActivedModals = [];\nexport var msgQueue = [];\nexport default defineComponent({\n    name: 'VxeModal',\n    props: {\n        modelValue: Boolean,\n        id: String,\n        type: { type: String, default: 'modal' },\n        loading: { type: Boolean, default: null },\n        status: String,\n        iconStatus: String,\n        className: String,\n        top: { type: [Number, String], default: function () { return GlobalConfig.modal.top; } },\n        position: [String, Object],\n        title: String,\n        duration: { type: [Number, String], default: function () { return GlobalConfig.modal.duration; } },\n        message: [Number, String],\n        content: [Number, String],\n        cancelButtonText: { type: String, default: function () { return GlobalConfig.modal.cancelButtonText; } },\n        confirmButtonText: { type: String, default: function () { return GlobalConfig.modal.confirmButtonText; } },\n        lockView: { type: Boolean, default: function () { return GlobalConfig.modal.lockView; } },\n        lockScroll: Boolean,\n        mask: { type: Boolean, default: function () { return GlobalConfig.modal.mask; } },\n        maskClosable: { type: Boolean, default: function () { return GlobalConfig.modal.maskClosable; } },\n        escClosable: { type: Boolean, default: function () { return GlobalConfig.modal.escClosable; } },\n        resize: Boolean,\n        showHeader: { type: Boolean, default: function () { return GlobalConfig.modal.showHeader; } },\n        showFooter: { type: Boolean, default: function () { return GlobalConfig.modal.showFooter; } },\n        showZoom: Boolean,\n        showClose: { type: Boolean, default: function () { return GlobalConfig.modal.showClose; } },\n        dblclickZoom: { type: Boolean, default: function () { return GlobalConfig.modal.dblclickZoom; } },\n        width: [Number, String],\n        height: [Number, String],\n        minWidth: { type: [Number, String], default: function () { return GlobalConfig.modal.minWidth; } },\n        minHeight: { type: [Number, String], default: function () { return GlobalConfig.modal.minHeight; } },\n        zIndex: Number,\n        marginSize: { type: [Number, String], default: function () { return GlobalConfig.modal.marginSize; } },\n        fullscreen: Boolean,\n        draggable: { type: Boolean, default: function () { return GlobalConfig.modal.draggable; } },\n        remember: { type: Boolean, default: function () { return GlobalConfig.modal.remember; } },\n        destroyOnClose: { type: Boolean, default: function () { return GlobalConfig.modal.destroyOnClose; } },\n        showTitleOverflow: { type: Boolean, default: function () { return GlobalConfig.modal.showTitleOverflow; } },\n        transfer: { type: Boolean, default: function () { return GlobalConfig.modal.transfer; } },\n        storage: { type: Boolean, default: function () { return GlobalConfig.modal.storage; } },\n        storageKey: { type: String, default: function () { return GlobalConfig.modal.storageKey; } },\n        animat: { type: Boolean, default: function () { return GlobalConfig.modal.animat; } },\n        size: { type: String, default: function () { return GlobalConfig.modal.size || GlobalConfig.size; } },\n        beforeHideMethod: { type: Function, default: function () { return GlobalConfig.modal.beforeHideMethod; } },\n        slots: Object\n    },\n    emits: [\n        'update:modelValue',\n        'show',\n        'hide',\n        'before-hide',\n        'close',\n        'confirm',\n        'cancel',\n        'zoom'\n    ],\n    setup: function (props, context) {\n        var slots = context.slots, emit = context.emit;\n        var xID = XEUtils.uniqueId();\n        var computeSize = useSize(props);\n        var reactData = reactive({\n            inited: false,\n            visible: false,\n            contentVisible: false,\n            modalTop: 0,\n            modalZindex: 0,\n            zoomLocat: null,\n            firstOpen: true\n        });\n        var refElem = ref();\n        var refModalBox = ref();\n        var refConfirmBtn = ref();\n        var refCancelBtn = ref();\n        var refMaps = {\n            refElem: refElem\n        };\n        var $xemodal = {\n            xID: xID,\n            props: props,\n            context: context,\n            reactData: reactData,\n            getRefMaps: function () { return refMaps; }\n        };\n        var modalMethods = {};\n        var computeIsMsg = computed(function () {\n            return props.type === 'message';\n        });\n        var getBox = function () {\n            var boxElem = refModalBox.value;\n            return boxElem;\n        };\n        var recalculate = function () {\n            var width = props.width, height = props.height;\n            var boxElem = getBox();\n            boxElem.style.width = \"\".concat(width ? (isNaN(width) ? width : \"\".concat(width, \"px\")) : '');\n            boxElem.style.height = \"\".concat(height ? (isNaN(height) ? height : \"\".concat(height, \"px\")) : '');\n            return nextTick();\n        };\n        var updateZindex = function () {\n            var zIndex = props.zIndex;\n            var modalZindex = reactData.modalZindex;\n            if (zIndex) {\n                reactData.modalZindex = zIndex;\n            }\n            else if (modalZindex < getLastZIndex()) {\n                reactData.modalZindex = nextZIndex();\n            }\n        };\n        var updatePosition = function () {\n            return nextTick().then(function () {\n                var position = props.position;\n                var marginSize = XEUtils.toNumber(props.marginSize);\n                var boxElem = getBox();\n                var clientVisibleWidth = document.documentElement.clientWidth || document.body.clientWidth;\n                var clientVisibleHeight = document.documentElement.clientHeight || document.body.clientHeight;\n                var isPosCenter = position === 'center';\n                var _a = XEUtils.isString(position) ? { top: position, left: position } : Object.assign({}, position), top = _a.top, left = _a.left;\n                var topCenter = isPosCenter || top === 'center';\n                var leftCenter = isPosCenter || left === 'center';\n                var posTop = '';\n                var posLeft = '';\n                if (left && !leftCenter) {\n                    posLeft = isNaN(left) ? left : \"\".concat(left, \"px\");\n                }\n                else {\n                    posLeft = \"\".concat(Math.max(marginSize, clientVisibleWidth / 2 - boxElem.offsetWidth / 2), \"px\");\n                }\n                if (top && !topCenter) {\n                    posTop = isNaN(top) ? top : \"\".concat(top, \"px\");\n                }\n                else {\n                    posTop = \"\".concat(Math.max(marginSize, clientVisibleHeight / 2 - boxElem.offsetHeight / 2), \"px\");\n                }\n                boxElem.style.top = posTop;\n                boxElem.style.left = posLeft;\n            });\n        };\n        var updateStyle = function () {\n            nextTick(function () {\n                var offsetTop = 0;\n                msgQueue.forEach(function (comp) {\n                    var boxElem = comp.getBox();\n                    offsetTop += XEUtils.toNumber(comp.props.top);\n                    comp.reactData.modalTop = offsetTop;\n                    offsetTop += boxElem.clientHeight;\n                });\n            });\n        };\n        var removeMsgQueue = function () {\n            if (msgQueue.indexOf($xemodal) > -1) {\n                XEUtils.remove(msgQueue, function (comp) { return comp === $xemodal; });\n            }\n            updateStyle();\n        };\n        var closeModal = function (type) {\n            var remember = props.remember, beforeHideMethod = props.beforeHideMethod;\n            var visible = reactData.visible;\n            var isMsg = computeIsMsg.value;\n            var params = { type: type };\n            if (visible) {\n                Promise.resolve(beforeHideMethod ? beforeHideMethod(params) : null).then(function (rest) {\n                    if (!XEUtils.isError(rest)) {\n                        if (isMsg) {\n                            removeMsgQueue();\n                        }\n                        reactData.contentVisible = false;\n                        if (!remember) {\n                            reactData.zoomLocat = null;\n                        }\n                        XEUtils.remove(allActivedModals, function (item) { return item === $xemodal; });\n                        modalMethods.dispatchEvent('before-hide', params);\n                        setTimeout(function () {\n                            reactData.visible = false;\n                            emit('update:modelValue', false);\n                            modalMethods.dispatchEvent('hide', params);\n                        }, 200);\n                    }\n                }).catch(function (e) { return e; });\n            }\n            return nextTick();\n        };\n        var closeEvent = function (evnt) {\n            var type = 'close';\n            modalMethods.dispatchEvent(type, { type: type }, evnt);\n            closeModal(type);\n        };\n        var confirmEvent = function (evnt) {\n            var type = 'confirm';\n            modalMethods.dispatchEvent(type, { type: type }, evnt);\n            closeModal(type);\n        };\n        var cancelEvent = function (evnt) {\n            var type = 'cancel';\n            modalMethods.dispatchEvent(type, { type: type }, evnt);\n            closeModal(type);\n        };\n        var getStorageMap = function (key) {\n            var version = GlobalConfig.version;\n            var rest = XEUtils.toStringJSON(localStorage.getItem(key) || '');\n            return rest && rest._v === version ? rest : { _v: version };\n        };\n        var hasPosStorage = function () {\n            var id = props.id, remember = props.remember, storage = props.storage, storageKey = props.storageKey;\n            return !!(id && remember && storage && getStorageMap(storageKey)[id]);\n        };\n        var restorePosStorage = function () {\n            var id = props.id, remember = props.remember, storage = props.storage, storageKey = props.storageKey;\n            if (id && remember && storage) {\n                var posStorage = getStorageMap(storageKey)[id];\n                if (posStorage) {\n                    var boxElem = getBox();\n                    var _a = posStorage.split(','), left = _a[0], top_1 = _a[1], width = _a[2], height = _a[3], zoomLeft = _a[4], zoomTop = _a[5], zoomWidth = _a[6], zoomHeight = _a[7];\n                    if (left) {\n                        boxElem.style.left = \"\".concat(left, \"px\");\n                    }\n                    if (top_1) {\n                        boxElem.style.top = \"\".concat(top_1, \"px\");\n                    }\n                    if (width) {\n                        boxElem.style.width = \"\".concat(width, \"px\");\n                    }\n                    if (height) {\n                        boxElem.style.height = \"\".concat(height, \"px\");\n                    }\n                    if (zoomLeft && zoomTop) {\n                        reactData.zoomLocat = {\n                            left: zoomLeft,\n                            top: zoomTop,\n                            width: zoomWidth,\n                            height: zoomHeight\n                        };\n                    }\n                }\n            }\n        };\n        var addMsgQueue = function () {\n            if (msgQueue.indexOf($xemodal) === -1) {\n                msgQueue.push($xemodal);\n            }\n            updateStyle();\n        };\n        var savePosStorage = function () {\n            var id = props.id, remember = props.remember, storage = props.storage, storageKey = props.storageKey;\n            var zoomLocat = reactData.zoomLocat;\n            if (id && remember && storage) {\n                var boxElem = getBox();\n                var posStorageMap = getStorageMap(storageKey);\n                posStorageMap[id] = [\n                    boxElem.style.left,\n                    boxElem.style.top,\n                    boxElem.style.width,\n                    boxElem.style.height\n                ].concat(zoomLocat ? [\n                    zoomLocat.left,\n                    zoomLocat.top,\n                    zoomLocat.width,\n                    zoomLocat.height\n                ] : []).map(function (val) { return val ? XEUtils.toNumber(val) : ''; }).join(',');\n                localStorage.setItem(storageKey, XEUtils.toJSONString(posStorageMap));\n            }\n        };\n        var maximize = function () {\n            return nextTick().then(function () {\n                if (!reactData.zoomLocat) {\n                    var marginSize = Math.max(0, XEUtils.toNumber(props.marginSize));\n                    var boxElem = getBox();\n                    var _a = getDomNode(), visibleHeight = _a.visibleHeight, visibleWidth = _a.visibleWidth;\n                    reactData.zoomLocat = {\n                        top: boxElem.offsetTop,\n                        left: boxElem.offsetLeft,\n                        width: boxElem.offsetWidth + (boxElem.style.width ? 0 : 1),\n                        height: boxElem.offsetHeight + (boxElem.style.height ? 0 : 1)\n                    };\n                    Object.assign(boxElem.style, {\n                        top: \"\".concat(marginSize, \"px\"),\n                        left: \"\".concat(marginSize, \"px\"),\n                        width: \"\".concat(visibleWidth - marginSize * 2, \"px\"),\n                        height: \"\".concat(visibleHeight - marginSize * 2, \"px\")\n                    });\n                    savePosStorage();\n                }\n            });\n        };\n        var openModal = function () {\n            var duration = props.duration, remember = props.remember, showFooter = props.showFooter;\n            var inited = reactData.inited, visible = reactData.visible;\n            var isMsg = computeIsMsg.value;\n            if (!inited) {\n                reactData.inited = true;\n            }\n            if (!visible) {\n                if (!remember) {\n                    recalculate();\n                }\n                reactData.visible = true;\n                reactData.contentVisible = false;\n                updateZindex();\n                allActivedModals.push($xemodal);\n                setTimeout(function () {\n                    reactData.contentVisible = true;\n                    nextTick(function () {\n                        if (showFooter) {\n                            var confirmBtn = refConfirmBtn.value;\n                            var cancelBtn = refCancelBtn.value;\n                            var operBtn = confirmBtn || cancelBtn;\n                            if (operBtn) {\n                                operBtn.focus();\n                            }\n                        }\n                        var type = '';\n                        var params = { type: type };\n                        emit('update:modelValue', true);\n                        modalMethods.dispatchEvent('show', params);\n                    });\n                }, 10);\n                if (isMsg) {\n                    addMsgQueue();\n                    if (duration !== -1) {\n                        setTimeout(function () { return closeModal('close'); }, XEUtils.toNumber(duration));\n                    }\n                }\n                else {\n                    nextTick(function () {\n                        var fullscreen = props.fullscreen;\n                        var firstOpen = reactData.firstOpen;\n                        if (!remember || firstOpen) {\n                            updatePosition().then(function () {\n                                setTimeout(function () { return updatePosition(); }, 20);\n                            });\n                        }\n                        if (firstOpen) {\n                            reactData.firstOpen = false;\n                            if (hasPosStorage()) {\n                                restorePosStorage();\n                            }\n                            else if (fullscreen) {\n                                nextTick(function () { return maximize(); });\n                            }\n                        }\n                        else {\n                            if (fullscreen) {\n                                nextTick(function () { return maximize(); });\n                            }\n                        }\n                    });\n                }\n            }\n            return nextTick();\n        };\n        var selfClickEvent = function (evnt) {\n            var el = refElem.value;\n            if (props.maskClosable && evnt.target === el) {\n                var type = 'mask';\n                closeModal(type);\n            }\n        };\n        var handleGlobalKeydownEvent = function (evnt) {\n            var isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);\n            if (isEsc) {\n                var lastModal_1 = XEUtils.max(allActivedModals, function (item) { return item.reactData.modalZindex; });\n                // 多个时，只关掉最上层的窗口\n                if (lastModal_1) {\n                    setTimeout(function () {\n                        if (lastModal_1 === $xemodal && lastModal_1.props.escClosable) {\n                            closeModal('exit');\n                        }\n                    }, 10);\n                }\n            }\n        };\n        var isMaximized = function () {\n            return !!reactData.zoomLocat;\n        };\n        var revert = function () {\n            return nextTick().then(function () {\n                var zoomLocat = reactData.zoomLocat;\n                if (zoomLocat) {\n                    var boxElem = getBox();\n                    reactData.zoomLocat = null;\n                    Object.assign(boxElem.style, {\n                        top: \"\".concat(zoomLocat.top, \"px\"),\n                        left: \"\".concat(zoomLocat.left, \"px\"),\n                        width: \"\".concat(zoomLocat.width, \"px\"),\n                        height: \"\".concat(zoomLocat.height, \"px\")\n                    });\n                    savePosStorage();\n                }\n            });\n        };\n        var zoom = function () {\n            if (reactData.zoomLocat) {\n                return revert().then(function () { return isMaximized(); });\n            }\n            return maximize().then(function () { return isMaximized(); });\n        };\n        var toggleZoomEvent = function (evnt) {\n            var zoomLocat = reactData.zoomLocat;\n            var params = { type: zoomLocat ? 'revert' : 'max' };\n            return zoom().then(function () {\n                modalMethods.dispatchEvent('zoom', params, evnt);\n            });\n        };\n        var getPosition = function () {\n            var isMsg = computeIsMsg.value;\n            if (!isMsg) {\n                var boxElem = getBox();\n                if (boxElem) {\n                    return {\n                        top: boxElem.offsetTop,\n                        left: boxElem.offsetLeft\n                    };\n                }\n            }\n            return null;\n        };\n        var setPosition = function (top, left) {\n            var isMsg = computeIsMsg.value;\n            if (!isMsg) {\n                var boxElem = getBox();\n                if (XEUtils.isNumber(top)) {\n                    boxElem.style.top = \"\".concat(top, \"px\");\n                }\n                if (XEUtils.isNumber(left)) {\n                    boxElem.style.left = \"\".concat(left, \"px\");\n                }\n            }\n            return nextTick();\n        };\n        var boxMousedownEvent = function () {\n            var modalZindex = reactData.modalZindex;\n            if (allActivedModals.some(function (comp) { return comp.reactData.visible && comp.reactData.modalZindex > modalZindex; })) {\n                updateZindex();\n            }\n        };\n        var mousedownEvent = function (evnt) {\n            var remember = props.remember, storage = props.storage;\n            var zoomLocat = reactData.zoomLocat;\n            var marginSize = XEUtils.toNumber(props.marginSize);\n            var boxElem = getBox();\n            if (!zoomLocat && evnt.button === 0 && !getEventTargetNode(evnt, boxElem, 'trigger--btn').flag) {\n                evnt.preventDefault();\n                var domMousemove_1 = document.onmousemove;\n                var domMouseup_1 = document.onmouseup;\n                var disX_1 = evnt.clientX - boxElem.offsetLeft;\n                var disY_1 = evnt.clientY - boxElem.offsetTop;\n                var _a = getDomNode(), visibleHeight_1 = _a.visibleHeight, visibleWidth_1 = _a.visibleWidth;\n                document.onmousemove = function (evnt) {\n                    evnt.preventDefault();\n                    var offsetWidth = boxElem.offsetWidth;\n                    var offsetHeight = boxElem.offsetHeight;\n                    var minX = marginSize;\n                    var maxX = visibleWidth_1 - offsetWidth - marginSize - 1;\n                    var minY = marginSize;\n                    var maxY = visibleHeight_1 - offsetHeight - marginSize - 1;\n                    var left = evnt.clientX - disX_1;\n                    var top = evnt.clientY - disY_1;\n                    if (left > maxX) {\n                        left = maxX;\n                    }\n                    if (left < minX) {\n                        left = minX;\n                    }\n                    if (top > maxY) {\n                        top = maxY;\n                    }\n                    if (top < minY) {\n                        top = minY;\n                    }\n                    boxElem.style.left = \"\".concat(left, \"px\");\n                    boxElem.style.top = \"\".concat(top, \"px\");\n                    boxElem.className = boxElem.className.replace(/\\s?is--drag/, '') + ' is--drag';\n                };\n                document.onmouseup = function () {\n                    document.onmousemove = domMousemove_1;\n                    document.onmouseup = domMouseup_1;\n                    if (remember && storage) {\n                        nextTick(function () {\n                            savePosStorage();\n                        });\n                    }\n                    setTimeout(function () {\n                        boxElem.className = boxElem.className.replace(/\\s?is--drag/, '');\n                    }, 50);\n                };\n            }\n        };\n        var dragEvent = function (evnt) {\n            evnt.preventDefault();\n            var remember = props.remember, storage = props.storage;\n            var _a = getDomNode(), visibleHeight = _a.visibleHeight, visibleWidth = _a.visibleWidth;\n            var marginSize = XEUtils.toNumber(props.marginSize);\n            var targetElem = evnt.target;\n            var type = targetElem.getAttribute('type');\n            var minWidth = XEUtils.toNumber(props.minWidth);\n            var minHeight = XEUtils.toNumber(props.minHeight);\n            var maxWidth = visibleWidth;\n            var maxHeight = visibleHeight;\n            var boxElem = getBox();\n            var domMousemove = document.onmousemove;\n            var domMouseup = document.onmouseup;\n            var clientWidth = boxElem.clientWidth;\n            var clientHeight = boxElem.clientHeight;\n            var disX = evnt.clientX;\n            var disY = evnt.clientY;\n            var offsetTop = boxElem.offsetTop;\n            var offsetLeft = boxElem.offsetLeft;\n            var params = { type: 'resize' };\n            document.onmousemove = function (evnt) {\n                evnt.preventDefault();\n                var dragLeft;\n                var dragTop;\n                var width;\n                var height;\n                switch (type) {\n                    case 'wl':\n                        dragLeft = disX - evnt.clientX;\n                        width = dragLeft + clientWidth;\n                        if (offsetLeft - dragLeft > marginSize) {\n                            if (width > minWidth) {\n                                boxElem.style.width = \"\".concat(width < maxWidth ? width : maxWidth, \"px\");\n                                boxElem.style.left = \"\".concat(offsetLeft - dragLeft, \"px\");\n                            }\n                        }\n                        break;\n                    case 'swst':\n                        dragLeft = disX - evnt.clientX;\n                        dragTop = disY - evnt.clientY;\n                        width = dragLeft + clientWidth;\n                        height = dragTop + clientHeight;\n                        if (offsetLeft - dragLeft > marginSize) {\n                            if (width > minWidth) {\n                                boxElem.style.width = \"\".concat(width < maxWidth ? width : maxWidth, \"px\");\n                                boxElem.style.left = \"\".concat(offsetLeft - dragLeft, \"px\");\n                            }\n                        }\n                        if (offsetTop - dragTop > marginSize) {\n                            if (height > minHeight) {\n                                boxElem.style.height = \"\".concat(height < maxHeight ? height : maxHeight, \"px\");\n                                boxElem.style.top = \"\".concat(offsetTop - dragTop, \"px\");\n                            }\n                        }\n                        break;\n                    case 'swlb':\n                        dragLeft = disX - evnt.clientX;\n                        dragTop = evnt.clientY - disY;\n                        width = dragLeft + clientWidth;\n                        height = dragTop + clientHeight;\n                        if (offsetLeft - dragLeft > marginSize) {\n                            if (width > minWidth) {\n                                boxElem.style.width = \"\".concat(width < maxWidth ? width : maxWidth, \"px\");\n                                boxElem.style.left = \"\".concat(offsetLeft - dragLeft, \"px\");\n                            }\n                        }\n                        if (offsetTop + height + marginSize < visibleHeight) {\n                            if (height > minHeight) {\n                                boxElem.style.height = \"\".concat(height < maxHeight ? height : maxHeight, \"px\");\n                            }\n                        }\n                        break;\n                    case 'st':\n                        dragTop = disY - evnt.clientY;\n                        height = clientHeight + dragTop;\n                        if (offsetTop - dragTop > marginSize) {\n                            if (height > minHeight) {\n                                boxElem.style.height = \"\".concat(height < maxHeight ? height : maxHeight, \"px\");\n                                boxElem.style.top = \"\".concat(offsetTop - dragTop, \"px\");\n                            }\n                        }\n                        break;\n                    case 'wr':\n                        dragLeft = evnt.clientX - disX;\n                        width = dragLeft + clientWidth;\n                        if (offsetLeft + width + marginSize < visibleWidth) {\n                            if (width > minWidth) {\n                                boxElem.style.width = \"\".concat(width < maxWidth ? width : maxWidth, \"px\");\n                            }\n                        }\n                        break;\n                    case 'sest':\n                        dragLeft = evnt.clientX - disX;\n                        dragTop = disY - evnt.clientY;\n                        width = dragLeft + clientWidth;\n                        height = dragTop + clientHeight;\n                        if (offsetLeft + width + marginSize < visibleWidth) {\n                            if (width > minWidth) {\n                                boxElem.style.width = \"\".concat(width < maxWidth ? width : maxWidth, \"px\");\n                            }\n                        }\n                        if (offsetTop - dragTop > marginSize) {\n                            if (height > minHeight) {\n                                boxElem.style.height = \"\".concat(height < maxHeight ? height : maxHeight, \"px\");\n                                boxElem.style.top = \"\".concat(offsetTop - dragTop, \"px\");\n                            }\n                        }\n                        break;\n                    case 'selb':\n                        dragLeft = evnt.clientX - disX;\n                        dragTop = evnt.clientY - disY;\n                        width = dragLeft + clientWidth;\n                        height = dragTop + clientHeight;\n                        if (offsetLeft + width + marginSize < visibleWidth) {\n                            if (width > minWidth) {\n                                boxElem.style.width = \"\".concat(width < maxWidth ? width : maxWidth, \"px\");\n                            }\n                        }\n                        if (offsetTop + height + marginSize < visibleHeight) {\n                            if (height > minHeight) {\n                                boxElem.style.height = \"\".concat(height < maxHeight ? height : maxHeight, \"px\");\n                            }\n                        }\n                        break;\n                    case 'sb':\n                        dragTop = evnt.clientY - disY;\n                        height = dragTop + clientHeight;\n                        if (offsetTop + height + marginSize < visibleHeight) {\n                            if (height > minHeight) {\n                                boxElem.style.height = \"\".concat(height < maxHeight ? height : maxHeight, \"px\");\n                            }\n                        }\n                        break;\n                }\n                boxElem.className = boxElem.className.replace(/\\s?is--drag/, '') + ' is--drag';\n                if (remember && storage) {\n                    savePosStorage();\n                }\n                modalMethods.dispatchEvent('zoom', params, evnt);\n            };\n            document.onmouseup = function () {\n                reactData.zoomLocat = null;\n                document.onmousemove = domMousemove;\n                document.onmouseup = domMouseup;\n                setTimeout(function () {\n                    boxElem.className = boxElem.className.replace(/\\s?is--drag/, '');\n                }, 50);\n            };\n        };\n        var renderTitles = function () {\n            var _a = props.slots, propSlots = _a === void 0 ? {} : _a, showClose = props.showClose, showZoom = props.showZoom, title = props.title;\n            var zoomLocat = reactData.zoomLocat;\n            var titleSlot = slots.title || propSlots.title;\n            var cornerSlot = slots.corner || propSlots.corner;\n            var titVNs = [\n                h('div', {\n                    class: 'vxe-modal--header-title'\n                }, titleSlot ? getSlotVNs(titleSlot({ $modal: $xemodal })) : (title ? getFuncText(title) : GlobalConfig.i18n('vxe.alert.title')))\n            ];\n            var rightVNs = [];\n            if (cornerSlot) {\n                rightVNs.push(h('span', {\n                    class: 'vxe-modal--corner-warpper'\n                }, getSlotVNs(cornerSlot({ $modal: $xemodal }))));\n            }\n            if (showZoom) {\n                rightVNs.push(h('i', {\n                    class: ['vxe-modal--zoom-btn', 'trigger--btn', zoomLocat ? GlobalConfig.icon.MODAL_ZOOM_OUT : GlobalConfig.icon.MODAL_ZOOM_IN],\n                    title: GlobalConfig.i18n(\"vxe.modal.zoom\".concat(zoomLocat ? 'Out' : 'In')),\n                    onClick: toggleZoomEvent\n                }));\n            }\n            if (showClose) {\n                rightVNs.push(h('i', {\n                    class: ['vxe-modal--close-btn', 'trigger--btn', GlobalConfig.icon.MODAL_CLOSE],\n                    title: GlobalConfig.i18n('vxe.modal.close'),\n                    onClick: closeEvent\n                }));\n            }\n            titVNs.push(h('div', {\n                class: 'vxe-modal--header-right'\n            }, rightVNs));\n            return titVNs;\n        };\n        var renderHeaders = function () {\n            var _a = props.slots, propSlots = _a === void 0 ? {} : _a, showZoom = props.showZoom, draggable = props.draggable;\n            var isMsg = computeIsMsg.value;\n            var headerSlot = slots.header || propSlots.header;\n            var headVNs = [];\n            if (props.showHeader) {\n                var headerOns = {};\n                if (draggable) {\n                    headerOns.onMousedown = mousedownEvent;\n                }\n                if (showZoom && props.dblclickZoom && props.type === 'modal') {\n                    headerOns.onDblclick = toggleZoomEvent;\n                }\n                headVNs.push(h('div', __assign({ class: ['vxe-modal--header', {\n                            'is--draggable': draggable,\n                            'is--ellipsis': !isMsg && props.showTitleOverflow\n                        }] }, headerOns), headerSlot ? (!reactData.inited || (props.destroyOnClose && !reactData.visible) ? [] : getSlotVNs(headerSlot({ $modal: $xemodal }))) : renderTitles()));\n            }\n            return headVNs;\n        };\n        var renderBodys = function () {\n            var _a = props.slots, propSlots = _a === void 0 ? {} : _a, status = props.status, message = props.message;\n            var content = props.content || message;\n            var isMsg = computeIsMsg.value;\n            var defaultSlot = slots.default || propSlots.default;\n            var contVNs = [];\n            if (status) {\n                contVNs.push(h('div', {\n                    class: 'vxe-modal--status-wrapper'\n                }, [\n                    h('i', {\n                        class: ['vxe-modal--status-icon', props.iconStatus || GlobalConfig.icon[\"MODAL_\".concat(status).toLocaleUpperCase()]]\n                    })\n                ]));\n            }\n            contVNs.push(h('div', {\n                class: 'vxe-modal--content'\n            }, defaultSlot ? (!reactData.inited || (props.destroyOnClose && !reactData.visible) ? [] : getSlotVNs(defaultSlot({ $modal: $xemodal }))) : getFuncText(content)));\n            if (!isMsg) {\n                /**\n                 * 加载中\n                 */\n                contVNs.push(h(VxeLoading, {\n                    class: 'vxe-modal--loading',\n                    modelValue: props.loading\n                }));\n            }\n            return [\n                h('div', {\n                    class: 'vxe-modal--body'\n                }, contVNs)\n            ];\n        };\n        var renderBtns = function () {\n            var type = props.type;\n            var btnVNs = [];\n            if (type === 'confirm') {\n                btnVNs.push(h(VxeButtonConstructor, {\n                    ref: refCancelBtn,\n                    content: props.cancelButtonText || GlobalConfig.i18n('vxe.button.cancel'),\n                    onClick: cancelEvent\n                }));\n            }\n            btnVNs.push(h(VxeButtonConstructor, {\n                ref: refConfirmBtn,\n                status: 'primary',\n                content: props.confirmButtonText || GlobalConfig.i18n('vxe.button.confirm'),\n                onClick: confirmEvent\n            }));\n            return btnVNs;\n        };\n        var renderFooters = function () {\n            var _a = props.slots, propSlots = _a === void 0 ? {} : _a;\n            var isMsg = computeIsMsg.value;\n            var footerSlot = slots.footer || propSlots.footer;\n            var footVNs = [];\n            if (props.showFooter) {\n                footVNs.push(h('div', {\n                    class: 'vxe-modal--footer'\n                }, footerSlot ? (!reactData.inited || (props.destroyOnClose && !reactData.visible) ? [] : getSlotVNs(footerSlot({ $modal: $xemodal }))) : renderBtns()));\n            }\n            if (!isMsg && props.resize) {\n                footVNs.push(h('span', {\n                    class: 'vxe-modal--resize'\n                }, ['wl', 'wr', 'swst', 'sest', 'st', 'swlb', 'selb', 'sb'].map(function (type) {\n                    return h('span', {\n                        class: \"\".concat(type, \"-resize\"),\n                        type: type,\n                        onMousedown: dragEvent\n                    });\n                })));\n            }\n            return footVNs;\n        };\n        modalMethods = {\n            dispatchEvent: function (type, params, evnt) {\n                emit(type, Object.assign({ $modal: $xemodal, $event: evnt }, params));\n            },\n            open: openModal,\n            close: function () {\n                return closeModal('close');\n            },\n            getBox: getBox,\n            getPosition: getPosition,\n            setPosition: setPosition,\n            isMaximized: isMaximized,\n            zoom: zoom,\n            maximize: maximize,\n            revert: revert\n        };\n        Object.assign($xemodal, modalMethods);\n        watch(function () { return props.width; }, recalculate);\n        watch(function () { return props.height; }, recalculate);\n        watch(function () { return props.modelValue; }, function (value) {\n            if (value) {\n                openModal();\n            }\n            else {\n                closeModal('model');\n            }\n        });\n        onMounted(function () {\n            nextTick(function () {\n                if (props.storage && !props.id) {\n                    errLog('vxe.error.reqProp', ['modal.id']);\n                }\n                if (props.modelValue) {\n                    openModal();\n                }\n                recalculate();\n            });\n            if (props.escClosable) {\n                GlobalEvent.on($xemodal, 'keydown', handleGlobalKeydownEvent);\n            }\n        });\n        onUnmounted(function () {\n            GlobalEvent.off($xemodal, 'keydown');\n            removeMsgQueue();\n        });\n        var renderVN = function () {\n            var _a;\n            var className = props.className, type = props.type, animat = props.animat, loading = props.loading, status = props.status, lockScroll = props.lockScroll, lockView = props.lockView, mask = props.mask, resize = props.resize;\n            var inited = reactData.inited, zoomLocat = reactData.zoomLocat, modalTop = reactData.modalTop, contentVisible = reactData.contentVisible, visible = reactData.visible;\n            var vSize = computeSize.value;\n            return h(Teleport, {\n                to: 'body',\n                disabled: props.transfer ? !inited : true\n            }, [\n                h('div', {\n                    ref: refElem,\n                    class: ['vxe-modal--wrapper', \"type--\".concat(type), className || '', (_a = {},\n                            _a[\"size--\".concat(vSize)] = vSize,\n                            _a[\"status--\".concat(status)] = status,\n                            _a['is--animat'] = animat,\n                            _a['lock--scroll'] = lockScroll,\n                            _a['lock--view'] = lockView,\n                            _a['is--resize'] = resize,\n                            _a['is--mask'] = mask,\n                            _a['is--maximize'] = zoomLocat,\n                            _a['is--visible'] = contentVisible,\n                            _a['is--active'] = visible,\n                            _a['is--loading'] = loading,\n                            _a)],\n                    style: {\n                        zIndex: reactData.modalZindex,\n                        top: modalTop ? \"\".concat(modalTop, \"px\") : null\n                    },\n                    onClick: selfClickEvent\n                }, [\n                    h('div', {\n                        ref: refModalBox,\n                        class: 'vxe-modal--box',\n                        onMousedown: boxMousedownEvent\n                    }, renderHeaders().concat(renderBodys(), renderFooters()))\n                ])\n            ]);\n        };\n        $xemodal.renderVN = renderVN;\n        return $xemodal;\n    },\n    render: function () {\n        return this.renderVN();\n    }\n});\n",
      "start": 1714699767752,
      "end": 1714699767800,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1714699767800,
      "end": 1714699767800,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1714699767800,
      "end": 1714699767800,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1714699767800,
      "end": 1714699767800,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1714699767800,
      "end": 1714699767800,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1714699767800,
      "end": 1714699767800,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1714699767800,
      "end": 1714699767800,
      "order": "normal"
    },
    {
      "name": "vite-plugin-vconsole",
      "result": "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { defineComponent, h, Teleport, ref, computed, reactive, nextTick, watch, onMounted, onUnmounted } from 'vue';\nimport XEUtils from 'xe-utils';\nimport { useSize } from '../../hooks/size';\nimport { getDomNode, getEventTargetNode } from '../../tools/dom';\nimport { getLastZIndex, nextZIndex, getFuncText } from '../../tools/utils';\nimport { errLog } from '../../tools/log';\nimport { GlobalEvent, hasEventKey, EVENT_KEYS } from '../../tools/event';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport VxeButtonConstructor from '../../button/src/button';\nimport VxeLoading from '../../loading/index';\nimport { getSlotVNs } from '../../tools/vn';\nexport var allActivedModals = [];\nexport var msgQueue = [];\nexport default defineComponent({\n    name: 'VxeModal',\n    props: {\n        modelValue: Boolean,\n        id: String,\n        type: { type: String, default: 'modal' },\n        loading: { type: Boolean, default: null },\n        status: String,\n        iconStatus: String,\n        className: String,\n        top: { type: [Number, String], default: function () { return GlobalConfig.modal.top; } },\n        position: [String, Object],\n        title: String,\n        duration: { type: [Number, String], default: function () { return GlobalConfig.modal.duration; } },\n        message: [Number, String],\n        content: [Number, String],\n        cancelButtonText: { type: String, default: function () { return GlobalConfig.modal.cancelButtonText; } },\n        confirmButtonText: { type: String, default: function () { return GlobalConfig.modal.confirmButtonText; } },\n        lockView: { type: Boolean, default: function () { return GlobalConfig.modal.lockView; } },\n        lockScroll: Boolean,\n        mask: { type: Boolean, default: function () { return GlobalConfig.modal.mask; } },\n        maskClosable: { type: Boolean, default: function () { return GlobalConfig.modal.maskClosable; } },\n        escClosable: { type: Boolean, default: function () { return GlobalConfig.modal.escClosable; } },\n        resize: Boolean,\n        showHeader: { type: Boolean, default: function () { return GlobalConfig.modal.showHeader; } },\n        showFooter: { type: Boolean, default: function () { return GlobalConfig.modal.showFooter; } },\n        showZoom: Boolean,\n        showClose: { type: Boolean, default: function () { return GlobalConfig.modal.showClose; } },\n        dblclickZoom: { type: Boolean, default: function () { return GlobalConfig.modal.dblclickZoom; } },\n        width: [Number, String],\n        height: [Number, String],\n        minWidth: { type: [Number, String], default: function () { return GlobalConfig.modal.minWidth; } },\n        minHeight: { type: [Number, String], default: function () { return GlobalConfig.modal.minHeight; } },\n        zIndex: Number,\n        marginSize: { type: [Number, String], default: function () { return GlobalConfig.modal.marginSize; } },\n        fullscreen: Boolean,\n        draggable: { type: Boolean, default: function () { return GlobalConfig.modal.draggable; } },\n        remember: { type: Boolean, default: function () { return GlobalConfig.modal.remember; } },\n        destroyOnClose: { type: Boolean, default: function () { return GlobalConfig.modal.destroyOnClose; } },\n        showTitleOverflow: { type: Boolean, default: function () { return GlobalConfig.modal.showTitleOverflow; } },\n        transfer: { type: Boolean, default: function () { return GlobalConfig.modal.transfer; } },\n        storage: { type: Boolean, default: function () { return GlobalConfig.modal.storage; } },\n        storageKey: { type: String, default: function () { return GlobalConfig.modal.storageKey; } },\n        animat: { type: Boolean, default: function () { return GlobalConfig.modal.animat; } },\n        size: { type: String, default: function () { return GlobalConfig.modal.size || GlobalConfig.size; } },\n        beforeHideMethod: { type: Function, default: function () { return GlobalConfig.modal.beforeHideMethod; } },\n        slots: Object\n    },\n    emits: [\n        'update:modelValue',\n        'show',\n        'hide',\n        'before-hide',\n        'close',\n        'confirm',\n        'cancel',\n        'zoom'\n    ],\n    setup: function (props, context) {\n        var slots = context.slots, emit = context.emit;\n        var xID = XEUtils.uniqueId();\n        var computeSize = useSize(props);\n        var reactData = reactive({\n            inited: false,\n            visible: false,\n            contentVisible: false,\n            modalTop: 0,\n            modalZindex: 0,\n            zoomLocat: null,\n            firstOpen: true\n        });\n        var refElem = ref();\n        var refModalBox = ref();\n        var refConfirmBtn = ref();\n        var refCancelBtn = ref();\n        var refMaps = {\n            refElem: refElem\n        };\n        var $xemodal = {\n            xID: xID,\n            props: props,\n            context: context,\n            reactData: reactData,\n            getRefMaps: function () { return refMaps; }\n        };\n        var modalMethods = {};\n        var computeIsMsg = computed(function () {\n            return props.type === 'message';\n        });\n        var getBox = function () {\n            var boxElem = refModalBox.value;\n            return boxElem;\n        };\n        var recalculate = function () {\n            var width = props.width, height = props.height;\n            var boxElem = getBox();\n            boxElem.style.width = \"\".concat(width ? (isNaN(width) ? width : \"\".concat(width, \"px\")) : '');\n            boxElem.style.height = \"\".concat(height ? (isNaN(height) ? height : \"\".concat(height, \"px\")) : '');\n            return nextTick();\n        };\n        var updateZindex = function () {\n            var zIndex = props.zIndex;\n            var modalZindex = reactData.modalZindex;\n            if (zIndex) {\n                reactData.modalZindex = zIndex;\n            }\n            else if (modalZindex < getLastZIndex()) {\n                reactData.modalZindex = nextZIndex();\n            }\n        };\n        var updatePosition = function () {\n            return nextTick().then(function () {\n                var position = props.position;\n                var marginSize = XEUtils.toNumber(props.marginSize);\n                var boxElem = getBox();\n                var clientVisibleWidth = document.documentElement.clientWidth || document.body.clientWidth;\n                var clientVisibleHeight = document.documentElement.clientHeight || document.body.clientHeight;\n                var isPosCenter = position === 'center';\n                var _a = XEUtils.isString(position) ? { top: position, left: position } : Object.assign({}, position), top = _a.top, left = _a.left;\n                var topCenter = isPosCenter || top === 'center';\n                var leftCenter = isPosCenter || left === 'center';\n                var posTop = '';\n                var posLeft = '';\n                if (left && !leftCenter) {\n                    posLeft = isNaN(left) ? left : \"\".concat(left, \"px\");\n                }\n                else {\n                    posLeft = \"\".concat(Math.max(marginSize, clientVisibleWidth / 2 - boxElem.offsetWidth / 2), \"px\");\n                }\n                if (top && !topCenter) {\n                    posTop = isNaN(top) ? top : \"\".concat(top, \"px\");\n                }\n                else {\n                    posTop = \"\".concat(Math.max(marginSize, clientVisibleHeight / 2 - boxElem.offsetHeight / 2), \"px\");\n                }\n                boxElem.style.top = posTop;\n                boxElem.style.left = posLeft;\n            });\n        };\n        var updateStyle = function () {\n            nextTick(function () {\n                var offsetTop = 0;\n                msgQueue.forEach(function (comp) {\n                    var boxElem = comp.getBox();\n                    offsetTop += XEUtils.toNumber(comp.props.top);\n                    comp.reactData.modalTop = offsetTop;\n                    offsetTop += boxElem.clientHeight;\n                });\n            });\n        };\n        var removeMsgQueue = function () {\n            if (msgQueue.indexOf($xemodal) > -1) {\n                XEUtils.remove(msgQueue, function (comp) { return comp === $xemodal; });\n            }\n            updateStyle();\n        };\n        var closeModal = function (type) {\n            var remember = props.remember, beforeHideMethod = props.beforeHideMethod;\n            var visible = reactData.visible;\n            var isMsg = computeIsMsg.value;\n            var params = { type: type };\n            if (visible) {\n                Promise.resolve(beforeHideMethod ? beforeHideMethod(params) : null).then(function (rest) {\n                    if (!XEUtils.isError(rest)) {\n                        if (isMsg) {\n                            removeMsgQueue();\n                        }\n                        reactData.contentVisible = false;\n                        if (!remember) {\n                            reactData.zoomLocat = null;\n                        }\n                        XEUtils.remove(allActivedModals, function (item) { return item === $xemodal; });\n                        modalMethods.dispatchEvent('before-hide', params);\n                        setTimeout(function () {\n                            reactData.visible = false;\n                            emit('update:modelValue', false);\n                            modalMethods.dispatchEvent('hide', params);\n                        }, 200);\n                    }\n                }).catch(function (e) { return e; });\n            }\n            return nextTick();\n        };\n        var closeEvent = function (evnt) {\n            var type = 'close';\n            modalMethods.dispatchEvent(type, { type: type }, evnt);\n            closeModal(type);\n        };\n        var confirmEvent = function (evnt) {\n            var type = 'confirm';\n            modalMethods.dispatchEvent(type, { type: type }, evnt);\n            closeModal(type);\n        };\n        var cancelEvent = function (evnt) {\n            var type = 'cancel';\n            modalMethods.dispatchEvent(type, { type: type }, evnt);\n            closeModal(type);\n        };\n        var getStorageMap = function (key) {\n            var version = GlobalConfig.version;\n            var rest = XEUtils.toStringJSON(localStorage.getItem(key) || '');\n            return rest && rest._v === version ? rest : { _v: version };\n        };\n        var hasPosStorage = function () {\n            var id = props.id, remember = props.remember, storage = props.storage, storageKey = props.storageKey;\n            return !!(id && remember && storage && getStorageMap(storageKey)[id]);\n        };\n        var restorePosStorage = function () {\n            var id = props.id, remember = props.remember, storage = props.storage, storageKey = props.storageKey;\n            if (id && remember && storage) {\n                var posStorage = getStorageMap(storageKey)[id];\n                if (posStorage) {\n                    var boxElem = getBox();\n                    var _a = posStorage.split(','), left = _a[0], top_1 = _a[1], width = _a[2], height = _a[3], zoomLeft = _a[4], zoomTop = _a[5], zoomWidth = _a[6], zoomHeight = _a[7];\n                    if (left) {\n                        boxElem.style.left = \"\".concat(left, \"px\");\n                    }\n                    if (top_1) {\n                        boxElem.style.top = \"\".concat(top_1, \"px\");\n                    }\n                    if (width) {\n                        boxElem.style.width = \"\".concat(width, \"px\");\n                    }\n                    if (height) {\n                        boxElem.style.height = \"\".concat(height, \"px\");\n                    }\n                    if (zoomLeft && zoomTop) {\n                        reactData.zoomLocat = {\n                            left: zoomLeft,\n                            top: zoomTop,\n                            width: zoomWidth,\n                            height: zoomHeight\n                        };\n                    }\n                }\n            }\n        };\n        var addMsgQueue = function () {\n            if (msgQueue.indexOf($xemodal) === -1) {\n                msgQueue.push($xemodal);\n            }\n            updateStyle();\n        };\n        var savePosStorage = function () {\n            var id = props.id, remember = props.remember, storage = props.storage, storageKey = props.storageKey;\n            var zoomLocat = reactData.zoomLocat;\n            if (id && remember && storage) {\n                var boxElem = getBox();\n                var posStorageMap = getStorageMap(storageKey);\n                posStorageMap[id] = [\n                    boxElem.style.left,\n                    boxElem.style.top,\n                    boxElem.style.width,\n                    boxElem.style.height\n                ].concat(zoomLocat ? [\n                    zoomLocat.left,\n                    zoomLocat.top,\n                    zoomLocat.width,\n                    zoomLocat.height\n                ] : []).map(function (val) { return val ? XEUtils.toNumber(val) : ''; }).join(',');\n                localStorage.setItem(storageKey, XEUtils.toJSONString(posStorageMap));\n            }\n        };\n        var maximize = function () {\n            return nextTick().then(function () {\n                if (!reactData.zoomLocat) {\n                    var marginSize = Math.max(0, XEUtils.toNumber(props.marginSize));\n                    var boxElem = getBox();\n                    var _a = getDomNode(), visibleHeight = _a.visibleHeight, visibleWidth = _a.visibleWidth;\n                    reactData.zoomLocat = {\n                        top: boxElem.offsetTop,\n                        left: boxElem.offsetLeft,\n                        width: boxElem.offsetWidth + (boxElem.style.width ? 0 : 1),\n                        height: boxElem.offsetHeight + (boxElem.style.height ? 0 : 1)\n                    };\n                    Object.assign(boxElem.style, {\n                        top: \"\".concat(marginSize, \"px\"),\n                        left: \"\".concat(marginSize, \"px\"),\n                        width: \"\".concat(visibleWidth - marginSize * 2, \"px\"),\n                        height: \"\".concat(visibleHeight - marginSize * 2, \"px\")\n                    });\n                    savePosStorage();\n                }\n            });\n        };\n        var openModal = function () {\n            var duration = props.duration, remember = props.remember, showFooter = props.showFooter;\n            var inited = reactData.inited, visible = reactData.visible;\n            var isMsg = computeIsMsg.value;\n            if (!inited) {\n                reactData.inited = true;\n            }\n            if (!visible) {\n                if (!remember) {\n                    recalculate();\n                }\n                reactData.visible = true;\n                reactData.contentVisible = false;\n                updateZindex();\n                allActivedModals.push($xemodal);\n                setTimeout(function () {\n                    reactData.contentVisible = true;\n                    nextTick(function () {\n                        if (showFooter) {\n                            var confirmBtn = refConfirmBtn.value;\n                            var cancelBtn = refCancelBtn.value;\n                            var operBtn = confirmBtn || cancelBtn;\n                            if (operBtn) {\n                                operBtn.focus();\n                            }\n                        }\n                        var type = '';\n                        var params = { type: type };\n                        emit('update:modelValue', true);\n                        modalMethods.dispatchEvent('show', params);\n                    });\n                }, 10);\n                if (isMsg) {\n                    addMsgQueue();\n                    if (duration !== -1) {\n                        setTimeout(function () { return closeModal('close'); }, XEUtils.toNumber(duration));\n                    }\n                }\n                else {\n                    nextTick(function () {\n                        var fullscreen = props.fullscreen;\n                        var firstOpen = reactData.firstOpen;\n                        if (!remember || firstOpen) {\n                            updatePosition().then(function () {\n                                setTimeout(function () { return updatePosition(); }, 20);\n                            });\n                        }\n                        if (firstOpen) {\n                            reactData.firstOpen = false;\n                            if (hasPosStorage()) {\n                                restorePosStorage();\n                            }\n                            else if (fullscreen) {\n                                nextTick(function () { return maximize(); });\n                            }\n                        }\n                        else {\n                            if (fullscreen) {\n                                nextTick(function () { return maximize(); });\n                            }\n                        }\n                    });\n                }\n            }\n            return nextTick();\n        };\n        var selfClickEvent = function (evnt) {\n            var el = refElem.value;\n            if (props.maskClosable && evnt.target === el) {\n                var type = 'mask';\n                closeModal(type);\n            }\n        };\n        var handleGlobalKeydownEvent = function (evnt) {\n            var isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);\n            if (isEsc) {\n                var lastModal_1 = XEUtils.max(allActivedModals, function (item) { return item.reactData.modalZindex; });\n                // 多个时，只关掉最上层的窗口\n                if (lastModal_1) {\n                    setTimeout(function () {\n                        if (lastModal_1 === $xemodal && lastModal_1.props.escClosable) {\n                            closeModal('exit');\n                        }\n                    }, 10);\n                }\n            }\n        };\n        var isMaximized = function () {\n            return !!reactData.zoomLocat;\n        };\n        var revert = function () {\n            return nextTick().then(function () {\n                var zoomLocat = reactData.zoomLocat;\n                if (zoomLocat) {\n                    var boxElem = getBox();\n                    reactData.zoomLocat = null;\n                    Object.assign(boxElem.style, {\n                        top: \"\".concat(zoomLocat.top, \"px\"),\n                        left: \"\".concat(zoomLocat.left, \"px\"),\n                        width: \"\".concat(zoomLocat.width, \"px\"),\n                        height: \"\".concat(zoomLocat.height, \"px\")\n                    });\n                    savePosStorage();\n                }\n            });\n        };\n        var zoom = function () {\n            if (reactData.zoomLocat) {\n                return revert().then(function () { return isMaximized(); });\n            }\n            return maximize().then(function () { return isMaximized(); });\n        };\n        var toggleZoomEvent = function (evnt) {\n            var zoomLocat = reactData.zoomLocat;\n            var params = { type: zoomLocat ? 'revert' : 'max' };\n            return zoom().then(function () {\n                modalMethods.dispatchEvent('zoom', params, evnt);\n            });\n        };\n        var getPosition = function () {\n            var isMsg = computeIsMsg.value;\n            if (!isMsg) {\n                var boxElem = getBox();\n                if (boxElem) {\n                    return {\n                        top: boxElem.offsetTop,\n                        left: boxElem.offsetLeft\n                    };\n                }\n            }\n            return null;\n        };\n        var setPosition = function (top, left) {\n            var isMsg = computeIsMsg.value;\n            if (!isMsg) {\n                var boxElem = getBox();\n                if (XEUtils.isNumber(top)) {\n                    boxElem.style.top = \"\".concat(top, \"px\");\n                }\n                if (XEUtils.isNumber(left)) {\n                    boxElem.style.left = \"\".concat(left, \"px\");\n                }\n            }\n            return nextTick();\n        };\n        var boxMousedownEvent = function () {\n            var modalZindex = reactData.modalZindex;\n            if (allActivedModals.some(function (comp) { return comp.reactData.visible && comp.reactData.modalZindex > modalZindex; })) {\n                updateZindex();\n            }\n        };\n        var mousedownEvent = function (evnt) {\n            var remember = props.remember, storage = props.storage;\n            var zoomLocat = reactData.zoomLocat;\n            var marginSize = XEUtils.toNumber(props.marginSize);\n            var boxElem = getBox();\n            if (!zoomLocat && evnt.button === 0 && !getEventTargetNode(evnt, boxElem, 'trigger--btn').flag) {\n                evnt.preventDefault();\n                var domMousemove_1 = document.onmousemove;\n                var domMouseup_1 = document.onmouseup;\n                var disX_1 = evnt.clientX - boxElem.offsetLeft;\n                var disY_1 = evnt.clientY - boxElem.offsetTop;\n                var _a = getDomNode(), visibleHeight_1 = _a.visibleHeight, visibleWidth_1 = _a.visibleWidth;\n                document.onmousemove = function (evnt) {\n                    evnt.preventDefault();\n                    var offsetWidth = boxElem.offsetWidth;\n                    var offsetHeight = boxElem.offsetHeight;\n                    var minX = marginSize;\n                    var maxX = visibleWidth_1 - offsetWidth - marginSize - 1;\n                    var minY = marginSize;\n                    var maxY = visibleHeight_1 - offsetHeight - marginSize - 1;\n                    var left = evnt.clientX - disX_1;\n                    var top = evnt.clientY - disY_1;\n                    if (left > maxX) {\n                        left = maxX;\n                    }\n                    if (left < minX) {\n                        left = minX;\n                    }\n                    if (top > maxY) {\n                        top = maxY;\n                    }\n                    if (top < minY) {\n                        top = minY;\n                    }\n                    boxElem.style.left = \"\".concat(left, \"px\");\n                    boxElem.style.top = \"\".concat(top, \"px\");\n                    boxElem.className = boxElem.className.replace(/\\s?is--drag/, '') + ' is--drag';\n                };\n                document.onmouseup = function () {\n                    document.onmousemove = domMousemove_1;\n                    document.onmouseup = domMouseup_1;\n                    if (remember && storage) {\n                        nextTick(function () {\n                            savePosStorage();\n                        });\n                    }\n                    setTimeout(function () {\n                        boxElem.className = boxElem.className.replace(/\\s?is--drag/, '');\n                    }, 50);\n                };\n            }\n        };\n        var dragEvent = function (evnt) {\n            evnt.preventDefault();\n            var remember = props.remember, storage = props.storage;\n            var _a = getDomNode(), visibleHeight = _a.visibleHeight, visibleWidth = _a.visibleWidth;\n            var marginSize = XEUtils.toNumber(props.marginSize);\n            var targetElem = evnt.target;\n            var type = targetElem.getAttribute('type');\n            var minWidth = XEUtils.toNumber(props.minWidth);\n            var minHeight = XEUtils.toNumber(props.minHeight);\n            var maxWidth = visibleWidth;\n            var maxHeight = visibleHeight;\n            var boxElem = getBox();\n            var domMousemove = document.onmousemove;\n            var domMouseup = document.onmouseup;\n            var clientWidth = boxElem.clientWidth;\n            var clientHeight = boxElem.clientHeight;\n            var disX = evnt.clientX;\n            var disY = evnt.clientY;\n            var offsetTop = boxElem.offsetTop;\n            var offsetLeft = boxElem.offsetLeft;\n            var params = { type: 'resize' };\n            document.onmousemove = function (evnt) {\n                evnt.preventDefault();\n                var dragLeft;\n                var dragTop;\n                var width;\n                var height;\n                switch (type) {\n                    case 'wl':\n                        dragLeft = disX - evnt.clientX;\n                        width = dragLeft + clientWidth;\n                        if (offsetLeft - dragLeft > marginSize) {\n                            if (width > minWidth) {\n                                boxElem.style.width = \"\".concat(width < maxWidth ? width : maxWidth, \"px\");\n                                boxElem.style.left = \"\".concat(offsetLeft - dragLeft, \"px\");\n                            }\n                        }\n                        break;\n                    case 'swst':\n                        dragLeft = disX - evnt.clientX;\n                        dragTop = disY - evnt.clientY;\n                        width = dragLeft + clientWidth;\n                        height = dragTop + clientHeight;\n                        if (offsetLeft - dragLeft > marginSize) {\n                            if (width > minWidth) {\n                                boxElem.style.width = \"\".concat(width < maxWidth ? width : maxWidth, \"px\");\n                                boxElem.style.left = \"\".concat(offsetLeft - dragLeft, \"px\");\n                            }\n                        }\n                        if (offsetTop - dragTop > marginSize) {\n                            if (height > minHeight) {\n                                boxElem.style.height = \"\".concat(height < maxHeight ? height : maxHeight, \"px\");\n                                boxElem.style.top = \"\".concat(offsetTop - dragTop, \"px\");\n                            }\n                        }\n                        break;\n                    case 'swlb':\n                        dragLeft = disX - evnt.clientX;\n                        dragTop = evnt.clientY - disY;\n                        width = dragLeft + clientWidth;\n                        height = dragTop + clientHeight;\n                        if (offsetLeft - dragLeft > marginSize) {\n                            if (width > minWidth) {\n                                boxElem.style.width = \"\".concat(width < maxWidth ? width : maxWidth, \"px\");\n                                boxElem.style.left = \"\".concat(offsetLeft - dragLeft, \"px\");\n                            }\n                        }\n                        if (offsetTop + height + marginSize < visibleHeight) {\n                            if (height > minHeight) {\n                                boxElem.style.height = \"\".concat(height < maxHeight ? height : maxHeight, \"px\");\n                            }\n                        }\n                        break;\n                    case 'st':\n                        dragTop = disY - evnt.clientY;\n                        height = clientHeight + dragTop;\n                        if (offsetTop - dragTop > marginSize) {\n                            if (height > minHeight) {\n                                boxElem.style.height = \"\".concat(height < maxHeight ? height : maxHeight, \"px\");\n                                boxElem.style.top = \"\".concat(offsetTop - dragTop, \"px\");\n                            }\n                        }\n                        break;\n                    case 'wr':\n                        dragLeft = evnt.clientX - disX;\n                        width = dragLeft + clientWidth;\n                        if (offsetLeft + width + marginSize < visibleWidth) {\n                            if (width > minWidth) {\n                                boxElem.style.width = \"\".concat(width < maxWidth ? width : maxWidth, \"px\");\n                            }\n                        }\n                        break;\n                    case 'sest':\n                        dragLeft = evnt.clientX - disX;\n                        dragTop = disY - evnt.clientY;\n                        width = dragLeft + clientWidth;\n                        height = dragTop + clientHeight;\n                        if (offsetLeft + width + marginSize < visibleWidth) {\n                            if (width > minWidth) {\n                                boxElem.style.width = \"\".concat(width < maxWidth ? width : maxWidth, \"px\");\n                            }\n                        }\n                        if (offsetTop - dragTop > marginSize) {\n                            if (height > minHeight) {\n                                boxElem.style.height = \"\".concat(height < maxHeight ? height : maxHeight, \"px\");\n                                boxElem.style.top = \"\".concat(offsetTop - dragTop, \"px\");\n                            }\n                        }\n                        break;\n                    case 'selb':\n                        dragLeft = evnt.clientX - disX;\n                        dragTop = evnt.clientY - disY;\n                        width = dragLeft + clientWidth;\n                        height = dragTop + clientHeight;\n                        if (offsetLeft + width + marginSize < visibleWidth) {\n                            if (width > minWidth) {\n                                boxElem.style.width = \"\".concat(width < maxWidth ? width : maxWidth, \"px\");\n                            }\n                        }\n                        if (offsetTop + height + marginSize < visibleHeight) {\n                            if (height > minHeight) {\n                                boxElem.style.height = \"\".concat(height < maxHeight ? height : maxHeight, \"px\");\n                            }\n                        }\n                        break;\n                    case 'sb':\n                        dragTop = evnt.clientY - disY;\n                        height = dragTop + clientHeight;\n                        if (offsetTop + height + marginSize < visibleHeight) {\n                            if (height > minHeight) {\n                                boxElem.style.height = \"\".concat(height < maxHeight ? height : maxHeight, \"px\");\n                            }\n                        }\n                        break;\n                }\n                boxElem.className = boxElem.className.replace(/\\s?is--drag/, '') + ' is--drag';\n                if (remember && storage) {\n                    savePosStorage();\n                }\n                modalMethods.dispatchEvent('zoom', params, evnt);\n            };\n            document.onmouseup = function () {\n                reactData.zoomLocat = null;\n                document.onmousemove = domMousemove;\n                document.onmouseup = domMouseup;\n                setTimeout(function () {\n                    boxElem.className = boxElem.className.replace(/\\s?is--drag/, '');\n                }, 50);\n            };\n        };\n        var renderTitles = function () {\n            var _a = props.slots, propSlots = _a === void 0 ? {} : _a, showClose = props.showClose, showZoom = props.showZoom, title = props.title;\n            var zoomLocat = reactData.zoomLocat;\n            var titleSlot = slots.title || propSlots.title;\n            var cornerSlot = slots.corner || propSlots.corner;\n            var titVNs = [\n                h('div', {\n                    class: 'vxe-modal--header-title'\n                }, titleSlot ? getSlotVNs(titleSlot({ $modal: $xemodal })) : (title ? getFuncText(title) : GlobalConfig.i18n('vxe.alert.title')))\n            ];\n            var rightVNs = [];\n            if (cornerSlot) {\n                rightVNs.push(h('span', {\n                    class: 'vxe-modal--corner-warpper'\n                }, getSlotVNs(cornerSlot({ $modal: $xemodal }))));\n            }\n            if (showZoom) {\n                rightVNs.push(h('i', {\n                    class: ['vxe-modal--zoom-btn', 'trigger--btn', zoomLocat ? GlobalConfig.icon.MODAL_ZOOM_OUT : GlobalConfig.icon.MODAL_ZOOM_IN],\n                    title: GlobalConfig.i18n(\"vxe.modal.zoom\".concat(zoomLocat ? 'Out' : 'In')),\n                    onClick: toggleZoomEvent\n                }));\n            }\n            if (showClose) {\n                rightVNs.push(h('i', {\n                    class: ['vxe-modal--close-btn', 'trigger--btn', GlobalConfig.icon.MODAL_CLOSE],\n                    title: GlobalConfig.i18n('vxe.modal.close'),\n                    onClick: closeEvent\n                }));\n            }\n            titVNs.push(h('div', {\n                class: 'vxe-modal--header-right'\n            }, rightVNs));\n            return titVNs;\n        };\n        var renderHeaders = function () {\n            var _a = props.slots, propSlots = _a === void 0 ? {} : _a, showZoom = props.showZoom, draggable = props.draggable;\n            var isMsg = computeIsMsg.value;\n            var headerSlot = slots.header || propSlots.header;\n            var headVNs = [];\n            if (props.showHeader) {\n                var headerOns = {};\n                if (draggable) {\n                    headerOns.onMousedown = mousedownEvent;\n                }\n                if (showZoom && props.dblclickZoom && props.type === 'modal') {\n                    headerOns.onDblclick = toggleZoomEvent;\n                }\n                headVNs.push(h('div', __assign({ class: ['vxe-modal--header', {\n                            'is--draggable': draggable,\n                            'is--ellipsis': !isMsg && props.showTitleOverflow\n                        }] }, headerOns), headerSlot ? (!reactData.inited || (props.destroyOnClose && !reactData.visible) ? [] : getSlotVNs(headerSlot({ $modal: $xemodal }))) : renderTitles()));\n            }\n            return headVNs;\n        };\n        var renderBodys = function () {\n            var _a = props.slots, propSlots = _a === void 0 ? {} : _a, status = props.status, message = props.message;\n            var content = props.content || message;\n            var isMsg = computeIsMsg.value;\n            var defaultSlot = slots.default || propSlots.default;\n            var contVNs = [];\n            if (status) {\n                contVNs.push(h('div', {\n                    class: 'vxe-modal--status-wrapper'\n                }, [\n                    h('i', {\n                        class: ['vxe-modal--status-icon', props.iconStatus || GlobalConfig.icon[\"MODAL_\".concat(status).toLocaleUpperCase()]]\n                    })\n                ]));\n            }\n            contVNs.push(h('div', {\n                class: 'vxe-modal--content'\n            }, defaultSlot ? (!reactData.inited || (props.destroyOnClose && !reactData.visible) ? [] : getSlotVNs(defaultSlot({ $modal: $xemodal }))) : getFuncText(content)));\n            if (!isMsg) {\n                /**\n                 * 加载中\n                 */\n                contVNs.push(h(VxeLoading, {\n                    class: 'vxe-modal--loading',\n                    modelValue: props.loading\n                }));\n            }\n            return [\n                h('div', {\n                    class: 'vxe-modal--body'\n                }, contVNs)\n            ];\n        };\n        var renderBtns = function () {\n            var type = props.type;\n            var btnVNs = [];\n            if (type === 'confirm') {\n                btnVNs.push(h(VxeButtonConstructor, {\n                    ref: refCancelBtn,\n                    content: props.cancelButtonText || GlobalConfig.i18n('vxe.button.cancel'),\n                    onClick: cancelEvent\n                }));\n            }\n            btnVNs.push(h(VxeButtonConstructor, {\n                ref: refConfirmBtn,\n                status: 'primary',\n                content: props.confirmButtonText || GlobalConfig.i18n('vxe.button.confirm'),\n                onClick: confirmEvent\n            }));\n            return btnVNs;\n        };\n        var renderFooters = function () {\n            var _a = props.slots, propSlots = _a === void 0 ? {} : _a;\n            var isMsg = computeIsMsg.value;\n            var footerSlot = slots.footer || propSlots.footer;\n            var footVNs = [];\n            if (props.showFooter) {\n                footVNs.push(h('div', {\n                    class: 'vxe-modal--footer'\n                }, footerSlot ? (!reactData.inited || (props.destroyOnClose && !reactData.visible) ? [] : getSlotVNs(footerSlot({ $modal: $xemodal }))) : renderBtns()));\n            }\n            if (!isMsg && props.resize) {\n                footVNs.push(h('span', {\n                    class: 'vxe-modal--resize'\n                }, ['wl', 'wr', 'swst', 'sest', 'st', 'swlb', 'selb', 'sb'].map(function (type) {\n                    return h('span', {\n                        class: \"\".concat(type, \"-resize\"),\n                        type: type,\n                        onMousedown: dragEvent\n                    });\n                })));\n            }\n            return footVNs;\n        };\n        modalMethods = {\n            dispatchEvent: function (type, params, evnt) {\n                emit(type, Object.assign({ $modal: $xemodal, $event: evnt }, params));\n            },\n            open: openModal,\n            close: function () {\n                return closeModal('close');\n            },\n            getBox: getBox,\n            getPosition: getPosition,\n            setPosition: setPosition,\n            isMaximized: isMaximized,\n            zoom: zoom,\n            maximize: maximize,\n            revert: revert\n        };\n        Object.assign($xemodal, modalMethods);\n        watch(function () { return props.width; }, recalculate);\n        watch(function () { return props.height; }, recalculate);\n        watch(function () { return props.modelValue; }, function (value) {\n            if (value) {\n                openModal();\n            }\n            else {\n                closeModal('model');\n            }\n        });\n        onMounted(function () {\n            nextTick(function () {\n                if (props.storage && !props.id) {\n                    errLog('vxe.error.reqProp', ['modal.id']);\n                }\n                if (props.modelValue) {\n                    openModal();\n                }\n                recalculate();\n            });\n            if (props.escClosable) {\n                GlobalEvent.on($xemodal, 'keydown', handleGlobalKeydownEvent);\n            }\n        });\n        onUnmounted(function () {\n            GlobalEvent.off($xemodal, 'keydown');\n            removeMsgQueue();\n        });\n        var renderVN = function () {\n            var _a;\n            var className = props.className, type = props.type, animat = props.animat, loading = props.loading, status = props.status, lockScroll = props.lockScroll, lockView = props.lockView, mask = props.mask, resize = props.resize;\n            var inited = reactData.inited, zoomLocat = reactData.zoomLocat, modalTop = reactData.modalTop, contentVisible = reactData.contentVisible, visible = reactData.visible;\n            var vSize = computeSize.value;\n            return h(Teleport, {\n                to: 'body',\n                disabled: props.transfer ? !inited : true\n            }, [\n                h('div', {\n                    ref: refElem,\n                    class: ['vxe-modal--wrapper', \"type--\".concat(type), className || '', (_a = {},\n                            _a[\"size--\".concat(vSize)] = vSize,\n                            _a[\"status--\".concat(status)] = status,\n                            _a['is--animat'] = animat,\n                            _a['lock--scroll'] = lockScroll,\n                            _a['lock--view'] = lockView,\n                            _a['is--resize'] = resize,\n                            _a['is--mask'] = mask,\n                            _a['is--maximize'] = zoomLocat,\n                            _a['is--visible'] = contentVisible,\n                            _a['is--active'] = visible,\n                            _a['is--loading'] = loading,\n                            _a)],\n                    style: {\n                        zIndex: reactData.modalZindex,\n                        top: modalTop ? \"\".concat(modalTop, \"px\") : null\n                    },\n                    onClick: selfClickEvent\n                }, [\n                    h('div', {\n                        ref: refModalBox,\n                        class: 'vxe-modal--box',\n                        onMousedown: boxMousedownEvent\n                    }, renderHeaders().concat(renderBodys(), renderFooters()))\n                ])\n            ]);\n        };\n        $xemodal.renderVN = renderVN;\n        return $xemodal;\n    },\n    render: function () {\n        return this.renderVN();\n    }\n});\n",
      "start": 1714699767800,
      "end": 1714699767800,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "esbuild",
      "start": 1714699767800,
      "end": 1714699767800,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1714699767800,
      "end": 1714699767800,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1714699767800,
      "end": 1714699767800,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1714699767800,
      "end": 1714699767800,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1714699767800,
      "end": 1714699767800,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1714699767800,
      "end": 1714699767800,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1714699767800,
      "end": 1714699767803,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1714699767803,
      "end": 1714699767803,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1714699767803,
      "end": 1714699767803,
      "order": "normal"
    },
    {
      "name": "unplugin-auto-import",
      "start": 1714699767803,
      "end": 1714699767803,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1714699767803,
      "end": 1714699767803,
      "order": "post"
    },
    {
      "name": "vite:style-import",
      "start": 1714699767803,
      "end": 1714699767804,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1714699767804,
      "end": 1714699767804,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1714699767804,
      "end": 1714699767804,
      "order": "normal"
    }
  ]
}
