{
  "resolvedId": "/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/vant@4.8.4_vue@3.4.19/node_modules/vant/es/lazyload/vue-lazyload/lazy.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { nextTick } from \"vue\";\nimport { inBrowser, getScrollParent } from \"@vant/use\";\nimport {\n  remove,\n  on,\n  off,\n  throttle,\n  supportWebp,\n  getDPR,\n  getBestSelectionFromSrcset,\n  hasIntersectionObserver,\n  modeType,\n  ImageCache\n} from \"./util.mjs\";\nimport { isObject } from \"../../utils/index.mjs\";\nimport ReactiveListener from \"./listener.mjs\";\nconst DEFAULT_URL = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\nconst DEFAULT_EVENTS = [\n  \"scroll\",\n  \"wheel\",\n  \"mousewheel\",\n  \"resize\",\n  \"animationend\",\n  \"transitionend\",\n  \"touchmove\"\n];\nconst DEFAULT_OBSERVER_OPTIONS = {\n  rootMargin: \"0px\",\n  threshold: 0\n};\nfunction stdin_default() {\n  return class Lazy {\n    constructor({\n      preLoad,\n      error,\n      throttleWait,\n      preLoadTop,\n      dispatchEvent,\n      loading,\n      attempt,\n      silent = true,\n      scale,\n      listenEvents,\n      filter,\n      adapter,\n      observer,\n      observerOptions\n    }) {\n      this.mode = modeType.event;\n      this.listeners = [];\n      this.targetIndex = 0;\n      this.targets = [];\n      this.options = {\n        silent,\n        dispatchEvent: !!dispatchEvent,\n        throttleWait: throttleWait || 200,\n        preLoad: preLoad || 1.3,\n        preLoadTop: preLoadTop || 0,\n        error: error || DEFAULT_URL,\n        loading: loading || DEFAULT_URL,\n        attempt: attempt || 3,\n        scale: scale || getDPR(scale),\n        ListenEvents: listenEvents || DEFAULT_EVENTS,\n        supportWebp: supportWebp(),\n        filter: filter || {},\n        adapter: adapter || {},\n        observer: !!observer,\n        observerOptions: observerOptions || DEFAULT_OBSERVER_OPTIONS\n      };\n      this.initEvent();\n      this.imageCache = new ImageCache({ max: 200 });\n      this.lazyLoadHandler = throttle(\n        this.lazyLoadHandler.bind(this),\n        this.options.throttleWait\n      );\n      this.setMode(this.options.observer ? modeType.observer : modeType.event);\n    }\n    /**\n     * update config\n     * @param  {Object} config params\n     * @return\n     */\n    config(options = {}) {\n      Object.assign(this.options, options);\n    }\n    /**\n     * output listener's load performance\n     * @return {Array}\n     */\n    performance() {\n      return this.listeners.map((item) => item.performance());\n    }\n    /*\n     * add lazy component to queue\n     * @param  {Vue} vm lazy component instance\n     * @return\n     */\n    addLazyBox(vm) {\n      this.listeners.push(vm);\n      if (inBrowser) {\n        this.addListenerTarget(window);\n        this.observer && this.observer.observe(vm.el);\n        if (vm.$el && vm.$el.parentNode) {\n          this.addListenerTarget(vm.$el.parentNode);\n        }\n      }\n    }\n    /*\n     * add image listener to queue\n     * @param  {DOM} el\n     * @param  {object} binding vue directive binding\n     * @param  {vnode} vnode vue directive vnode\n     * @return\n     */\n    add(el, binding, vnode) {\n      if (this.listeners.some((item) => item.el === el)) {\n        this.update(el, binding);\n        return nextTick(this.lazyLoadHandler);\n      }\n      const value = this.valueFormatter(binding.value);\n      let { src } = value;\n      nextTick(() => {\n        src = getBestSelectionFromSrcset(el, this.options.scale) || src;\n        this.observer && this.observer.observe(el);\n        const container = Object.keys(binding.modifiers)[0];\n        let $parent;\n        if (container) {\n          $parent = vnode.context.$refs[container];\n          $parent = $parent ? $parent.$el || $parent : document.getElementById(container);\n        }\n        if (!$parent) {\n          $parent = getScrollParent(el);\n        }\n        const newListener = new ReactiveListener({\n          bindType: binding.arg,\n          $parent,\n          el,\n          src,\n          loading: value.loading,\n          error: value.error,\n          cors: value.cors,\n          elRenderer: this.elRenderer.bind(this),\n          options: this.options,\n          imageCache: this.imageCache\n        });\n        this.listeners.push(newListener);\n        if (inBrowser) {\n          this.addListenerTarget(window);\n          this.addListenerTarget($parent);\n        }\n        this.lazyLoadHandler();\n        nextTick(() => this.lazyLoadHandler());\n      });\n    }\n    /**\n     * update image src\n     * @param  {DOM} el\n     * @param  {object} vue directive binding\n     * @return\n     */\n    update(el, binding, vnode) {\n      const value = this.valueFormatter(binding.value);\n      let { src } = value;\n      src = getBestSelectionFromSrcset(el, this.options.scale) || src;\n      const exist = this.listeners.find((item) => item.el === el);\n      if (!exist) {\n        this.add(el, binding, vnode);\n      } else {\n        exist.update({\n          src,\n          error: value.error,\n          loading: value.loading\n        });\n      }\n      if (this.observer) {\n        this.observer.unobserve(el);\n        this.observer.observe(el);\n      }\n      this.lazyLoadHandler();\n      nextTick(() => this.lazyLoadHandler());\n    }\n    /**\n     * remove listener form list\n     * @param  {DOM} el\n     * @return\n     */\n    remove(el) {\n      if (!el)\n        return;\n      this.observer && this.observer.unobserve(el);\n      const existItem = this.listeners.find((item) => item.el === el);\n      if (existItem) {\n        this.removeListenerTarget(existItem.$parent);\n        this.removeListenerTarget(window);\n        remove(this.listeners, existItem);\n        existItem.$destroy();\n      }\n    }\n    /*\n     * remove lazy components form list\n     * @param  {Vue} vm Vue instance\n     * @return\n     */\n    removeComponent(vm) {\n      if (!vm)\n        return;\n      remove(this.listeners, vm);\n      this.observer && this.observer.unobserve(vm.el);\n      if (vm.$parent && vm.$el.parentNode) {\n        this.removeListenerTarget(vm.$el.parentNode);\n      }\n      this.removeListenerTarget(window);\n    }\n    setMode(mode) {\n      if (!hasIntersectionObserver && mode === modeType.observer) {\n        mode = modeType.event;\n      }\n      this.mode = mode;\n      if (mode === modeType.event) {\n        if (this.observer) {\n          this.listeners.forEach((listener) => {\n            this.observer.unobserve(listener.el);\n          });\n          this.observer = null;\n        }\n        this.targets.forEach((target) => {\n          this.initListen(target.el, true);\n        });\n      } else {\n        this.targets.forEach((target) => {\n          this.initListen(target.el, false);\n        });\n        this.initIntersectionObserver();\n      }\n    }\n    /*\n     *** Private functions ***\n     */\n    /*\n     * add listener target\n     * @param  {DOM} el listener target\n     * @return\n     */\n    addListenerTarget(el) {\n      if (!el)\n        return;\n      let target = this.targets.find((target2) => target2.el === el);\n      if (!target) {\n        target = {\n          el,\n          id: ++this.targetIndex,\n          childrenCount: 1,\n          listened: true\n        };\n        this.mode === modeType.event && this.initListen(target.el, true);\n        this.targets.push(target);\n      } else {\n        target.childrenCount++;\n      }\n      return this.targetIndex;\n    }\n    /*\n     * remove listener target or reduce target childrenCount\n     * @param  {DOM} el or window\n     * @return\n     */\n    removeListenerTarget(el) {\n      this.targets.forEach((target, index) => {\n        if (target.el === el) {\n          target.childrenCount--;\n          if (!target.childrenCount) {\n            this.initListen(target.el, false);\n            this.targets.splice(index, 1);\n            target = null;\n          }\n        }\n      });\n    }\n    /*\n     * add or remove eventlistener\n     * @param  {DOM} el DOM or Window\n     * @param  {boolean} start flag\n     * @return\n     */\n    initListen(el, start) {\n      this.options.ListenEvents.forEach(\n        (evt) => (start ? on : off)(el, evt, this.lazyLoadHandler)\n      );\n    }\n    initEvent() {\n      this.Event = {\n        listeners: {\n          loading: [],\n          loaded: [],\n          error: []\n        }\n      };\n      this.$on = (event, func) => {\n        if (!this.Event.listeners[event])\n          this.Event.listeners[event] = [];\n        this.Event.listeners[event].push(func);\n      };\n      this.$once = (event, func) => {\n        const on2 = (...args) => {\n          this.$off(event, on2);\n          func.apply(this, args);\n        };\n        this.$on(event, on2);\n      };\n      this.$off = (event, func) => {\n        if (!func) {\n          if (!this.Event.listeners[event])\n            return;\n          this.Event.listeners[event].length = 0;\n          return;\n        }\n        remove(this.Event.listeners[event], func);\n      };\n      this.$emit = (event, context, inCache) => {\n        if (!this.Event.listeners[event])\n          return;\n        this.Event.listeners[event].forEach((func) => func(context, inCache));\n      };\n    }\n    /**\n     * find nodes which in viewport and trigger load\n     * @return\n     */\n    lazyLoadHandler() {\n      const freeList = [];\n      this.listeners.forEach((listener) => {\n        if (!listener.el || !listener.el.parentNode) {\n          freeList.push(listener);\n        }\n        const catIn = listener.checkInView();\n        if (!catIn)\n          return;\n        listener.load();\n      });\n      freeList.forEach((item) => {\n        remove(this.listeners, item);\n        item.$destroy();\n      });\n    }\n    /**\n     * init IntersectionObserver\n     * set mode to observer\n     * @return\n     */\n    initIntersectionObserver() {\n      if (!hasIntersectionObserver) {\n        return;\n      }\n      this.observer = new IntersectionObserver(\n        this.observerHandler.bind(this),\n        this.options.observerOptions\n      );\n      if (this.listeners.length) {\n        this.listeners.forEach((listener) => {\n          this.observer.observe(listener.el);\n        });\n      }\n    }\n    /**\n     * init IntersectionObserver\n     * @return\n     */\n    observerHandler(entries) {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          this.listeners.forEach((listener) => {\n            if (listener.el === entry.target) {\n              if (listener.state.loaded)\n                return this.observer.unobserve(listener.el);\n              listener.load();\n            }\n          });\n        }\n      });\n    }\n    /**\n     * set element attribute with image'url and state\n     * @param  {object} lazyload listener object\n     * @param  {string} state will be rendered\n     * @param  {bool} inCache  is rendered from cache\n     * @return\n     */\n    elRenderer(listener, state, cache) {\n      if (!listener.el)\n        return;\n      const { el, bindType } = listener;\n      let src;\n      switch (state) {\n        case \"loading\":\n          src = listener.loading;\n          break;\n        case \"error\":\n          src = listener.error;\n          break;\n        default:\n          ({ src } = listener);\n          break;\n      }\n      if (bindType) {\n        el.style[bindType] = 'url(\"' + src + '\")';\n      } else if (el.getAttribute(\"src\") !== src) {\n        el.setAttribute(\"src\", src);\n      }\n      el.setAttribute(\"lazy\", state);\n      this.$emit(state, listener, cache);\n      this.options.adapter[state] && this.options.adapter[state](listener, this.options);\n      if (this.options.dispatchEvent) {\n        const event = new CustomEvent(state, {\n          detail: listener\n        });\n        el.dispatchEvent(event);\n      }\n    }\n    /**\n     * generate loading loaded error image url\n     * @param {string} image's src\n     * @return {object} image's loading, loaded, error url\n     */\n    valueFormatter(value) {\n      let src = value;\n      let { loading, error } = this.options;\n      if (isObject(value)) {\n        if (process.env.NODE_ENV !== \"production\" && !value.src && !this.options.silent) {\n          console.error(\"[@vant/lazyload] miss src with \" + value);\n        }\n        ({ src } = value);\n        loading = value.loading || this.options.loading;\n        error = value.error || this.options.error;\n      }\n      return {\n        src,\n        loading,\n        error\n      };\n    }\n  };\n}\nexport {\n  stdin_default as default\n};\n",
      "start": 1714699768212,
      "end": 1714699768244,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1714699768244,
      "end": 1714699768244,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1714699768244,
      "end": 1714699768244,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1714699768244,
      "end": 1714699768244,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1714699768244,
      "end": 1714699768244,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1714699768244,
      "end": 1714699768244,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1714699768244,
      "end": 1714699768244,
      "order": "normal"
    },
    {
      "name": "vite-plugin-vconsole",
      "result": "import { nextTick } from \"vue\";\nimport { inBrowser, getScrollParent } from \"@vant/use\";\nimport {\n  remove,\n  on,\n  off,\n  throttle,\n  supportWebp,\n  getDPR,\n  getBestSelectionFromSrcset,\n  hasIntersectionObserver,\n  modeType,\n  ImageCache\n} from \"./util.mjs\";\nimport { isObject } from \"../../utils/index.mjs\";\nimport ReactiveListener from \"./listener.mjs\";\nconst DEFAULT_URL = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\nconst DEFAULT_EVENTS = [\n  \"scroll\",\n  \"wheel\",\n  \"mousewheel\",\n  \"resize\",\n  \"animationend\",\n  \"transitionend\",\n  \"touchmove\"\n];\nconst DEFAULT_OBSERVER_OPTIONS = {\n  rootMargin: \"0px\",\n  threshold: 0\n};\nfunction stdin_default() {\n  return class Lazy {\n    constructor({\n      preLoad,\n      error,\n      throttleWait,\n      preLoadTop,\n      dispatchEvent,\n      loading,\n      attempt,\n      silent = true,\n      scale,\n      listenEvents,\n      filter,\n      adapter,\n      observer,\n      observerOptions\n    }) {\n      this.mode = modeType.event;\n      this.listeners = [];\n      this.targetIndex = 0;\n      this.targets = [];\n      this.options = {\n        silent,\n        dispatchEvent: !!dispatchEvent,\n        throttleWait: throttleWait || 200,\n        preLoad: preLoad || 1.3,\n        preLoadTop: preLoadTop || 0,\n        error: error || DEFAULT_URL,\n        loading: loading || DEFAULT_URL,\n        attempt: attempt || 3,\n        scale: scale || getDPR(scale),\n        ListenEvents: listenEvents || DEFAULT_EVENTS,\n        supportWebp: supportWebp(),\n        filter: filter || {},\n        adapter: adapter || {},\n        observer: !!observer,\n        observerOptions: observerOptions || DEFAULT_OBSERVER_OPTIONS\n      };\n      this.initEvent();\n      this.imageCache = new ImageCache({ max: 200 });\n      this.lazyLoadHandler = throttle(\n        this.lazyLoadHandler.bind(this),\n        this.options.throttleWait\n      );\n      this.setMode(this.options.observer ? modeType.observer : modeType.event);\n    }\n    /**\n     * update config\n     * @param  {Object} config params\n     * @return\n     */\n    config(options = {}) {\n      Object.assign(this.options, options);\n    }\n    /**\n     * output listener's load performance\n     * @return {Array}\n     */\n    performance() {\n      return this.listeners.map((item) => item.performance());\n    }\n    /*\n     * add lazy component to queue\n     * @param  {Vue} vm lazy component instance\n     * @return\n     */\n    addLazyBox(vm) {\n      this.listeners.push(vm);\n      if (inBrowser) {\n        this.addListenerTarget(window);\n        this.observer && this.observer.observe(vm.el);\n        if (vm.$el && vm.$el.parentNode) {\n          this.addListenerTarget(vm.$el.parentNode);\n        }\n      }\n    }\n    /*\n     * add image listener to queue\n     * @param  {DOM} el\n     * @param  {object} binding vue directive binding\n     * @param  {vnode} vnode vue directive vnode\n     * @return\n     */\n    add(el, binding, vnode) {\n      if (this.listeners.some((item) => item.el === el)) {\n        this.update(el, binding);\n        return nextTick(this.lazyLoadHandler);\n      }\n      const value = this.valueFormatter(binding.value);\n      let { src } = value;\n      nextTick(() => {\n        src = getBestSelectionFromSrcset(el, this.options.scale) || src;\n        this.observer && this.observer.observe(el);\n        const container = Object.keys(binding.modifiers)[0];\n        let $parent;\n        if (container) {\n          $parent = vnode.context.$refs[container];\n          $parent = $parent ? $parent.$el || $parent : document.getElementById(container);\n        }\n        if (!$parent) {\n          $parent = getScrollParent(el);\n        }\n        const newListener = new ReactiveListener({\n          bindType: binding.arg,\n          $parent,\n          el,\n          src,\n          loading: value.loading,\n          error: value.error,\n          cors: value.cors,\n          elRenderer: this.elRenderer.bind(this),\n          options: this.options,\n          imageCache: this.imageCache\n        });\n        this.listeners.push(newListener);\n        if (inBrowser) {\n          this.addListenerTarget(window);\n          this.addListenerTarget($parent);\n        }\n        this.lazyLoadHandler();\n        nextTick(() => this.lazyLoadHandler());\n      });\n    }\n    /**\n     * update image src\n     * @param  {DOM} el\n     * @param  {object} vue directive binding\n     * @return\n     */\n    update(el, binding, vnode) {\n      const value = this.valueFormatter(binding.value);\n      let { src } = value;\n      src = getBestSelectionFromSrcset(el, this.options.scale) || src;\n      const exist = this.listeners.find((item) => item.el === el);\n      if (!exist) {\n        this.add(el, binding, vnode);\n      } else {\n        exist.update({\n          src,\n          error: value.error,\n          loading: value.loading\n        });\n      }\n      if (this.observer) {\n        this.observer.unobserve(el);\n        this.observer.observe(el);\n      }\n      this.lazyLoadHandler();\n      nextTick(() => this.lazyLoadHandler());\n    }\n    /**\n     * remove listener form list\n     * @param  {DOM} el\n     * @return\n     */\n    remove(el) {\n      if (!el)\n        return;\n      this.observer && this.observer.unobserve(el);\n      const existItem = this.listeners.find((item) => item.el === el);\n      if (existItem) {\n        this.removeListenerTarget(existItem.$parent);\n        this.removeListenerTarget(window);\n        remove(this.listeners, existItem);\n        existItem.$destroy();\n      }\n    }\n    /*\n     * remove lazy components form list\n     * @param  {Vue} vm Vue instance\n     * @return\n     */\n    removeComponent(vm) {\n      if (!vm)\n        return;\n      remove(this.listeners, vm);\n      this.observer && this.observer.unobserve(vm.el);\n      if (vm.$parent && vm.$el.parentNode) {\n        this.removeListenerTarget(vm.$el.parentNode);\n      }\n      this.removeListenerTarget(window);\n    }\n    setMode(mode) {\n      if (!hasIntersectionObserver && mode === modeType.observer) {\n        mode = modeType.event;\n      }\n      this.mode = mode;\n      if (mode === modeType.event) {\n        if (this.observer) {\n          this.listeners.forEach((listener) => {\n            this.observer.unobserve(listener.el);\n          });\n          this.observer = null;\n        }\n        this.targets.forEach((target) => {\n          this.initListen(target.el, true);\n        });\n      } else {\n        this.targets.forEach((target) => {\n          this.initListen(target.el, false);\n        });\n        this.initIntersectionObserver();\n      }\n    }\n    /*\n     *** Private functions ***\n     */\n    /*\n     * add listener target\n     * @param  {DOM} el listener target\n     * @return\n     */\n    addListenerTarget(el) {\n      if (!el)\n        return;\n      let target = this.targets.find((target2) => target2.el === el);\n      if (!target) {\n        target = {\n          el,\n          id: ++this.targetIndex,\n          childrenCount: 1,\n          listened: true\n        };\n        this.mode === modeType.event && this.initListen(target.el, true);\n        this.targets.push(target);\n      } else {\n        target.childrenCount++;\n      }\n      return this.targetIndex;\n    }\n    /*\n     * remove listener target or reduce target childrenCount\n     * @param  {DOM} el or window\n     * @return\n     */\n    removeListenerTarget(el) {\n      this.targets.forEach((target, index) => {\n        if (target.el === el) {\n          target.childrenCount--;\n          if (!target.childrenCount) {\n            this.initListen(target.el, false);\n            this.targets.splice(index, 1);\n            target = null;\n          }\n        }\n      });\n    }\n    /*\n     * add or remove eventlistener\n     * @param  {DOM} el DOM or Window\n     * @param  {boolean} start flag\n     * @return\n     */\n    initListen(el, start) {\n      this.options.ListenEvents.forEach(\n        (evt) => (start ? on : off)(el, evt, this.lazyLoadHandler)\n      );\n    }\n    initEvent() {\n      this.Event = {\n        listeners: {\n          loading: [],\n          loaded: [],\n          error: []\n        }\n      };\n      this.$on = (event, func) => {\n        if (!this.Event.listeners[event])\n          this.Event.listeners[event] = [];\n        this.Event.listeners[event].push(func);\n      };\n      this.$once = (event, func) => {\n        const on2 = (...args) => {\n          this.$off(event, on2);\n          func.apply(this, args);\n        };\n        this.$on(event, on2);\n      };\n      this.$off = (event, func) => {\n        if (!func) {\n          if (!this.Event.listeners[event])\n            return;\n          this.Event.listeners[event].length = 0;\n          return;\n        }\n        remove(this.Event.listeners[event], func);\n      };\n      this.$emit = (event, context, inCache) => {\n        if (!this.Event.listeners[event])\n          return;\n        this.Event.listeners[event].forEach((func) => func(context, inCache));\n      };\n    }\n    /**\n     * find nodes which in viewport and trigger load\n     * @return\n     */\n    lazyLoadHandler() {\n      const freeList = [];\n      this.listeners.forEach((listener) => {\n        if (!listener.el || !listener.el.parentNode) {\n          freeList.push(listener);\n        }\n        const catIn = listener.checkInView();\n        if (!catIn)\n          return;\n        listener.load();\n      });\n      freeList.forEach((item) => {\n        remove(this.listeners, item);\n        item.$destroy();\n      });\n    }\n    /**\n     * init IntersectionObserver\n     * set mode to observer\n     * @return\n     */\n    initIntersectionObserver() {\n      if (!hasIntersectionObserver) {\n        return;\n      }\n      this.observer = new IntersectionObserver(\n        this.observerHandler.bind(this),\n        this.options.observerOptions\n      );\n      if (this.listeners.length) {\n        this.listeners.forEach((listener) => {\n          this.observer.observe(listener.el);\n        });\n      }\n    }\n    /**\n     * init IntersectionObserver\n     * @return\n     */\n    observerHandler(entries) {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          this.listeners.forEach((listener) => {\n            if (listener.el === entry.target) {\n              if (listener.state.loaded)\n                return this.observer.unobserve(listener.el);\n              listener.load();\n            }\n          });\n        }\n      });\n    }\n    /**\n     * set element attribute with image'url and state\n     * @param  {object} lazyload listener object\n     * @param  {string} state will be rendered\n     * @param  {bool} inCache  is rendered from cache\n     * @return\n     */\n    elRenderer(listener, state, cache) {\n      if (!listener.el)\n        return;\n      const { el, bindType } = listener;\n      let src;\n      switch (state) {\n        case \"loading\":\n          src = listener.loading;\n          break;\n        case \"error\":\n          src = listener.error;\n          break;\n        default:\n          ({ src } = listener);\n          break;\n      }\n      if (bindType) {\n        el.style[bindType] = 'url(\"' + src + '\")';\n      } else if (el.getAttribute(\"src\") !== src) {\n        el.setAttribute(\"src\", src);\n      }\n      el.setAttribute(\"lazy\", state);\n      this.$emit(state, listener, cache);\n      this.options.adapter[state] && this.options.adapter[state](listener, this.options);\n      if (this.options.dispatchEvent) {\n        const event = new CustomEvent(state, {\n          detail: listener\n        });\n        el.dispatchEvent(event);\n      }\n    }\n    /**\n     * generate loading loaded error image url\n     * @param {string} image's src\n     * @return {object} image's loading, loaded, error url\n     */\n    valueFormatter(value) {\n      let src = value;\n      let { loading, error } = this.options;\n      if (isObject(value)) {\n        if (process.env.NODE_ENV !== \"production\" && !value.src && !this.options.silent) {\n          console.error(\"[@vant/lazyload] miss src with \" + value);\n        }\n        ({ src } = value);\n        loading = value.loading || this.options.loading;\n        error = value.error || this.options.error;\n      }\n      return {\n        src,\n        loading,\n        error\n      };\n    }\n  };\n}\nexport {\n  stdin_default as default\n};\n",
      "start": 1714699768244,
      "end": 1714699768244,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "esbuild",
      "start": 1714699768244,
      "end": 1714699768244,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { nextTick } from \"vue\";\nimport { inBrowser, getScrollParent } from \"@vant/use\";\nimport {\n  remove,\n  on,\n  off,\n  throttle,\n  supportWebp,\n  getDPR,\n  getBestSelectionFromSrcset,\n  hasIntersectionObserver,\n  modeType,\n  ImageCache\n} from \"./util.mjs\";\nimport { isObject } from \"../../utils/index.mjs\";\nimport ReactiveListener from \"./listener.mjs\";\nconst DEFAULT_URL = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\nconst DEFAULT_EVENTS = [\n  \"scroll\",\n  \"wheel\",\n  \"mousewheel\",\n  \"resize\",\n  \"animationend\",\n  \"transitionend\",\n  \"touchmove\"\n];\nconst DEFAULT_OBSERVER_OPTIONS = {\n  rootMargin: \"0px\",\n  threshold: 0\n};\nfunction stdin_default() {\n  return class Lazy {\n    constructor({\n      preLoad,\n      error,\n      throttleWait,\n      preLoadTop,\n      dispatchEvent,\n      loading,\n      attempt,\n      silent = true,\n      scale,\n      listenEvents,\n      filter,\n      adapter,\n      observer,\n      observerOptions\n    }) {\n      this.mode = modeType.event;\n      this.listeners = [];\n      this.targetIndex = 0;\n      this.targets = [];\n      this.options = {\n        silent,\n        dispatchEvent: !!dispatchEvent,\n        throttleWait: throttleWait || 200,\n        preLoad: preLoad || 1.3,\n        preLoadTop: preLoadTop || 0,\n        error: error || DEFAULT_URL,\n        loading: loading || DEFAULT_URL,\n        attempt: attempt || 3,\n        scale: scale || getDPR(scale),\n        ListenEvents: listenEvents || DEFAULT_EVENTS,\n        supportWebp: supportWebp(),\n        filter: filter || {},\n        adapter: adapter || {},\n        observer: !!observer,\n        observerOptions: observerOptions || DEFAULT_OBSERVER_OPTIONS\n      };\n      this.initEvent();\n      this.imageCache = new ImageCache({ max: 200 });\n      this.lazyLoadHandler = throttle(\n        this.lazyLoadHandler.bind(this),\n        this.options.throttleWait\n      );\n      this.setMode(this.options.observer ? modeType.observer : modeType.event);\n    }\n    /**\n     * update config\n     * @param  {Object} config params\n     * @return\n     */\n    config(options = {}) {\n      Object.assign(this.options, options);\n    }\n    /**\n     * output listener's load performance\n     * @return {Array}\n     */\n    performance() {\n      return this.listeners.map((item) => item.performance());\n    }\n    /*\n     * add lazy component to queue\n     * @param  {Vue} vm lazy component instance\n     * @return\n     */\n    addLazyBox(vm) {\n      this.listeners.push(vm);\n      if (inBrowser) {\n        this.addListenerTarget(window);\n        this.observer && this.observer.observe(vm.el);\n        if (vm.$el && vm.$el.parentNode) {\n          this.addListenerTarget(vm.$el.parentNode);\n        }\n      }\n    }\n    /*\n     * add image listener to queue\n     * @param  {DOM} el\n     * @param  {object} binding vue directive binding\n     * @param  {vnode} vnode vue directive vnode\n     * @return\n     */\n    add(el, binding, vnode) {\n      if (this.listeners.some((item) => item.el === el)) {\n        this.update(el, binding);\n        return nextTick(this.lazyLoadHandler);\n      }\n      const value = this.valueFormatter(binding.value);\n      let { src } = value;\n      nextTick(() => {\n        src = getBestSelectionFromSrcset(el, this.options.scale) || src;\n        this.observer && this.observer.observe(el);\n        const container = Object.keys(binding.modifiers)[0];\n        let $parent;\n        if (container) {\n          $parent = vnode.context.$refs[container];\n          $parent = $parent ? $parent.$el || $parent : document.getElementById(container);\n        }\n        if (!$parent) {\n          $parent = getScrollParent(el);\n        }\n        const newListener = new ReactiveListener({\n          bindType: binding.arg,\n          $parent,\n          el,\n          src,\n          loading: value.loading,\n          error: value.error,\n          cors: value.cors,\n          elRenderer: this.elRenderer.bind(this),\n          options: this.options,\n          imageCache: this.imageCache\n        });\n        this.listeners.push(newListener);\n        if (inBrowser) {\n          this.addListenerTarget(window);\n          this.addListenerTarget($parent);\n        }\n        this.lazyLoadHandler();\n        nextTick(() => this.lazyLoadHandler());\n      });\n    }\n    /**\n     * update image src\n     * @param  {DOM} el\n     * @param  {object} vue directive binding\n     * @return\n     */\n    update(el, binding, vnode) {\n      const value = this.valueFormatter(binding.value);\n      let { src } = value;\n      src = getBestSelectionFromSrcset(el, this.options.scale) || src;\n      const exist = this.listeners.find((item) => item.el === el);\n      if (!exist) {\n        this.add(el, binding, vnode);\n      } else {\n        exist.update({\n          src,\n          error: value.error,\n          loading: value.loading\n        });\n      }\n      if (this.observer) {\n        this.observer.unobserve(el);\n        this.observer.observe(el);\n      }\n      this.lazyLoadHandler();\n      nextTick(() => this.lazyLoadHandler());\n    }\n    /**\n     * remove listener form list\n     * @param  {DOM} el\n     * @return\n     */\n    remove(el) {\n      if (!el)\n        return;\n      this.observer && this.observer.unobserve(el);\n      const existItem = this.listeners.find((item) => item.el === el);\n      if (existItem) {\n        this.removeListenerTarget(existItem.$parent);\n        this.removeListenerTarget(window);\n        remove(this.listeners, existItem);\n        existItem.$destroy();\n      }\n    }\n    /*\n     * remove lazy components form list\n     * @param  {Vue} vm Vue instance\n     * @return\n     */\n    removeComponent(vm) {\n      if (!vm)\n        return;\n      remove(this.listeners, vm);\n      this.observer && this.observer.unobserve(vm.el);\n      if (vm.$parent && vm.$el.parentNode) {\n        this.removeListenerTarget(vm.$el.parentNode);\n      }\n      this.removeListenerTarget(window);\n    }\n    setMode(mode) {\n      if (!hasIntersectionObserver && mode === modeType.observer) {\n        mode = modeType.event;\n      }\n      this.mode = mode;\n      if (mode === modeType.event) {\n        if (this.observer) {\n          this.listeners.forEach((listener) => {\n            this.observer.unobserve(listener.el);\n          });\n          this.observer = null;\n        }\n        this.targets.forEach((target) => {\n          this.initListen(target.el, true);\n        });\n      } else {\n        this.targets.forEach((target) => {\n          this.initListen(target.el, false);\n        });\n        this.initIntersectionObserver();\n      }\n    }\n    /*\n     *** Private functions ***\n     */\n    /*\n     * add listener target\n     * @param  {DOM} el listener target\n     * @return\n     */\n    addListenerTarget(el) {\n      if (!el)\n        return;\n      let target = this.targets.find((target2) => target2.el === el);\n      if (!target) {\n        target = {\n          el,\n          id: ++this.targetIndex,\n          childrenCount: 1,\n          listened: true\n        };\n        this.mode === modeType.event && this.initListen(target.el, true);\n        this.targets.push(target);\n      } else {\n        target.childrenCount++;\n      }\n      return this.targetIndex;\n    }\n    /*\n     * remove listener target or reduce target childrenCount\n     * @param  {DOM} el or window\n     * @return\n     */\n    removeListenerTarget(el) {\n      this.targets.forEach((target, index) => {\n        if (target.el === el) {\n          target.childrenCount--;\n          if (!target.childrenCount) {\n            this.initListen(target.el, false);\n            this.targets.splice(index, 1);\n            target = null;\n          }\n        }\n      });\n    }\n    /*\n     * add or remove eventlistener\n     * @param  {DOM} el DOM or Window\n     * @param  {boolean} start flag\n     * @return\n     */\n    initListen(el, start) {\n      this.options.ListenEvents.forEach(\n        (evt) => (start ? on : off)(el, evt, this.lazyLoadHandler)\n      );\n    }\n    initEvent() {\n      this.Event = {\n        listeners: {\n          loading: [],\n          loaded: [],\n          error: []\n        }\n      };\n      this.$on = (event, func) => {\n        if (!this.Event.listeners[event])\n          this.Event.listeners[event] = [];\n        this.Event.listeners[event].push(func);\n      };\n      this.$once = (event, func) => {\n        const on2 = (...args) => {\n          this.$off(event, on2);\n          func.apply(this, args);\n        };\n        this.$on(event, on2);\n      };\n      this.$off = (event, func) => {\n        if (!func) {\n          if (!this.Event.listeners[event])\n            return;\n          this.Event.listeners[event].length = 0;\n          return;\n        }\n        remove(this.Event.listeners[event], func);\n      };\n      this.$emit = (event, context, inCache) => {\n        if (!this.Event.listeners[event])\n          return;\n        this.Event.listeners[event].forEach((func) => func(context, inCache));\n      };\n    }\n    /**\n     * find nodes which in viewport and trigger load\n     * @return\n     */\n    lazyLoadHandler() {\n      const freeList = [];\n      this.listeners.forEach((listener) => {\n        if (!listener.el || !listener.el.parentNode) {\n          freeList.push(listener);\n        }\n        const catIn = listener.checkInView();\n        if (!catIn)\n          return;\n        listener.load();\n      });\n      freeList.forEach((item) => {\n        remove(this.listeners, item);\n        item.$destroy();\n      });\n    }\n    /**\n     * init IntersectionObserver\n     * set mode to observer\n     * @return\n     */\n    initIntersectionObserver() {\n      if (!hasIntersectionObserver) {\n        return;\n      }\n      this.observer = new IntersectionObserver(\n        this.observerHandler.bind(this),\n        this.options.observerOptions\n      );\n      if (this.listeners.length) {\n        this.listeners.forEach((listener) => {\n          this.observer.observe(listener.el);\n        });\n      }\n    }\n    /**\n     * init IntersectionObserver\n     * @return\n     */\n    observerHandler(entries) {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          this.listeners.forEach((listener) => {\n            if (listener.el === entry.target) {\n              if (listener.state.loaded)\n                return this.observer.unobserve(listener.el);\n              listener.load();\n            }\n          });\n        }\n      });\n    }\n    /**\n     * set element attribute with image'url and state\n     * @param  {object} lazyload listener object\n     * @param  {string} state will be rendered\n     * @param  {bool} inCache  is rendered from cache\n     * @return\n     */\n    elRenderer(listener, state, cache) {\n      if (!listener.el)\n        return;\n      const { el, bindType } = listener;\n      let src;\n      switch (state) {\n        case \"loading\":\n          src = listener.loading;\n          break;\n        case \"error\":\n          src = listener.error;\n          break;\n        default:\n          ({ src } = listener);\n          break;\n      }\n      if (bindType) {\n        el.style[bindType] = 'url(\"' + src + '\")';\n      } else if (el.getAttribute(\"src\") !== src) {\n        el.setAttribute(\"src\", src);\n      }\n      el.setAttribute(\"lazy\", state);\n      this.$emit(state, listener, cache);\n      this.options.adapter[state] && this.options.adapter[state](listener, this.options);\n      if (this.options.dispatchEvent) {\n        const event = new CustomEvent(state, {\n          detail: listener\n        });\n        el.dispatchEvent(event);\n      }\n    }\n    /**\n     * generate loading loaded error image url\n     * @param {string} image's src\n     * @return {object} image's loading, loaded, error url\n     */\n    valueFormatter(value) {\n      let src = value;\n      let { loading, error } = this.options;\n      if (isObject(value)) {\n        if (!value.src && !this.options.silent) {\n          console.error(\"[@vant/lazyload] miss src with \" + value);\n        }\n        ({ src } = value);\n        loading = value.loading || this.options.loading;\n        error = value.error || this.options.error;\n      }\n      return {\n        src,\n        loading,\n        error\n      };\n    }\n  };\n}\nexport {\n  stdin_default as default\n};\n",
      "start": 1714699768244,
      "end": 1714699769066,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-post",
      "start": 1714699769066,
      "end": 1714699769066,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1714699769066,
      "end": 1714699769066,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1714699769066,
      "end": 1714699769066,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1714699769066,
      "end": 1714699769066,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1714699769066,
      "end": 1714699769066,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1714699769066,
      "end": 1714699769066,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1714699769066,
      "end": 1714699769066,
      "order": "normal"
    },
    {
      "name": "unplugin-auto-import",
      "start": 1714699769066,
      "end": 1714699769066,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1714699769066,
      "end": 1714699769066,
      "order": "post"
    },
    {
      "name": "vite:style-import",
      "start": 1714699769066,
      "end": 1714699769066,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1714699769066,
      "end": 1714699769066,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1714699769066,
      "end": 1714699769066,
      "order": "normal"
    }
  ]
}
