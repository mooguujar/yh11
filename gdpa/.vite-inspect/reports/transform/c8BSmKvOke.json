{
  "resolvedId": "/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/vxe-table@4.5.21_vue@3.4.19_xe-utils@3.5.24/node_modules/vxe-table/es/validator/src/hook.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { nextTick } from 'vue';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport XEUtils from 'xe-utils';\nimport { VXETable } from '../../v-x-e-table';\nimport { getFuncText, eqEmptyValue } from '../../tools/utils';\nimport { scrollToView } from '../../tools/dom';\nimport { errLog, warnLog } from '../../tools/log';\nimport { handleFieldOrColumn, getRowid } from '../../table/src/util';\n/**\n * 校验规则\n */\nvar Rule = /** @class */ (function () {\n    function Rule(rule) {\n        Object.assign(this, {\n            $options: rule,\n            required: rule.required,\n            min: rule.min,\n            max: rule.max,\n            type: rule.type,\n            pattern: rule.pattern,\n            validator: rule.validator,\n            trigger: rule.trigger,\n            maxWidth: rule.maxWidth\n        });\n    }\n    Object.defineProperty(Rule.prototype, \"content\", {\n        /**\n         * 获取校验不通过的消息\n         * 支持国际化翻译\n         */\n        get: function () {\n            return getFuncText(this.$options.content || this.$options.message);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rule.prototype, \"message\", {\n        get: function () {\n            return this.content;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Rule;\n}());\nvar tableValidatorMethodKeys = ['fullValidate', 'validate', 'clearValidate'];\nvar validatorHook = {\n    setupTable: function ($xetable) {\n        var props = $xetable.props, reactData = $xetable.reactData, internalData = $xetable.internalData;\n        var refValidTooltip = $xetable.getRefMaps().refValidTooltip;\n        var _a = $xetable.getComputeMaps(), computeValidOpts = _a.computeValidOpts, computeTreeOpts = _a.computeTreeOpts, computeEditOpts = _a.computeEditOpts;\n        var validatorMethods = {};\n        var validatorPrivateMethods = {};\n        var validRuleErr;\n        /**\n         * 聚焦到校验通过的单元格并弹出校验错误提示\n         */\n        var handleValidError = function (params) {\n            return new Promise(function (resolve) {\n                var validOpts = computeValidOpts.value;\n                if (validOpts.autoPos === false) {\n                    $xetable.dispatchEvent('valid-error', params, null);\n                    resolve();\n                }\n                else {\n                    $xetable.handleActived(params, { type: 'valid-error', trigger: 'call' }).then(function () {\n                        resolve(validatorPrivateMethods.showValidTooltip(params));\n                    });\n                }\n            });\n        };\n        var handleErrMsgMode = function (validErrMaps) {\n            var validOpts = computeValidOpts.value;\n            if (validOpts.msgMode === 'single') {\n                var keys = Object.keys(validErrMaps);\n                var resMaps = validErrMaps;\n                if (keys.length) {\n                    var firstKey = keys[0];\n                    resMaps[firstKey] = validErrMaps[firstKey];\n                }\n                return resMaps;\n            }\n            return validErrMaps;\n        };\n        /**\n         * 对表格数据进行校验\n         * 如果不指定数据，则默认只校验临时变动的数据，例如新增或修改\n         * 如果传 true 则校验当前表格数据\n         * 如果传 row 指定行记录，则只验证传入的行\n         * 如果传 rows 为多行记录，则只验证传入的行\n         * 如果只传 callback 否则默认验证整个表格数据\n         * 返回 Promise 对象，或者使用回调方式\n         */\n        var beginValidate = function (rows, cb, isFull) {\n            var validRest = {};\n            var editRules = props.editRules, treeConfig = props.treeConfig;\n            var afterFullData = internalData.afterFullData, visibleColumn = internalData.visibleColumn;\n            var treeOpts = computeTreeOpts.value;\n            var childrenField = treeOpts.children || treeOpts.childrenField;\n            var validOpts = computeValidOpts.value;\n            var vaildDatas;\n            if (rows === true) {\n                vaildDatas = afterFullData;\n            }\n            else if (rows) {\n                if (XEUtils.isFunction(rows)) {\n                    cb = rows;\n                }\n                else {\n                    vaildDatas = XEUtils.isArray(rows) ? rows : [rows];\n                }\n            }\n            if (!vaildDatas) {\n                if ($xetable.getInsertRecords) {\n                    vaildDatas = $xetable.getInsertRecords().concat($xetable.getUpdateRecords());\n                }\n                else {\n                    vaildDatas = [];\n                }\n            }\n            var rowValids = [];\n            internalData._lastCallTime = Date.now();\n            validRuleErr = false; // 如果为快速校验，当存在某列校验不通过时将终止执行\n            validatorMethods.clearValidate();\n            var validErrMaps = {};\n            if (editRules) {\n                var columns_1 = $xetable.getColumns();\n                var handleVaild = function (row) {\n                    if (isFull || !validRuleErr) {\n                        var colVailds_1 = [];\n                        columns_1.forEach(function (column) {\n                            if ((isFull || !validRuleErr) && XEUtils.has(editRules, column.property)) {\n                                colVailds_1.push(validatorPrivateMethods.validCellRules('all', row, column)\n                                    .catch(function (_a) {\n                                    var rule = _a.rule, rules = _a.rules;\n                                    var rest = {\n                                        rule: rule,\n                                        rules: rules,\n                                        rowIndex: $xetable.getRowIndex(row),\n                                        row: row,\n                                        columnIndex: $xetable.getColumnIndex(column),\n                                        column: column,\n                                        field: column.property,\n                                        $table: $xetable\n                                    };\n                                    if (!validRest[column.property]) {\n                                        validRest[column.property] = [];\n                                    }\n                                    validErrMaps[\"\".concat(getRowid($xetable, row), \":\").concat(column.id)] = {\n                                        column: column,\n                                        row: row,\n                                        rule: rule,\n                                        content: rule.content\n                                    };\n                                    validRest[column.property].push(rest);\n                                    if (!isFull) {\n                                        validRuleErr = true;\n                                        return Promise.reject(rest);\n                                    }\n                                }));\n                            }\n                        });\n                        rowValids.push(Promise.all(colVailds_1));\n                    }\n                };\n                if (treeConfig) {\n                    XEUtils.eachTree(vaildDatas, handleVaild, { children: childrenField });\n                }\n                else {\n                    vaildDatas.forEach(handleVaild);\n                }\n                return Promise.all(rowValids).then(function () {\n                    var ruleProps = Object.keys(validRest);\n                    reactData.validErrorMaps = handleErrMsgMode(validErrMaps);\n                    return nextTick().then(function () {\n                        if (ruleProps.length) {\n                            return Promise.reject(validRest[ruleProps[0]][0]);\n                        }\n                        if (cb) {\n                            cb();\n                        }\n                    });\n                }).catch(function (firstErrParams) {\n                    return new Promise(function (resolve, reject) {\n                        var finish = function () {\n                            nextTick(function () {\n                                if (cb) {\n                                    cb(validRest);\n                                    resolve();\n                                }\n                                else {\n                                    if (GlobalConfig.validToReject === 'obsolete') {\n                                        // 已废弃，校验失败将不会执行catch\n                                        reject(validRest);\n                                    }\n                                    else {\n                                        resolve(validRest);\n                                    }\n                                }\n                            });\n                        };\n                        var posAndFinish = function () {\n                            firstErrParams.cell = $xetable.getCell(firstErrParams.row, firstErrParams.column);\n                            scrollToView(firstErrParams.cell);\n                            handleValidError(firstErrParams).then(finish);\n                        };\n                        /**\n                         * 当校验不通过时\n                         * 将表格滚动到可视区\n                         * 由于提示信息至少需要占一行，定位向上偏移一行\n                         */\n                        if (validOpts.autoPos === false) {\n                            finish();\n                        }\n                        else {\n                            var row = firstErrParams.row;\n                            var column = firstErrParams.column;\n                            var rowIndex = afterFullData.indexOf(row);\n                            var columnIndex = visibleColumn.indexOf(column);\n                            var locatRow = rowIndex > 0 ? afterFullData[rowIndex - 1] : row;\n                            var locatColumn = columnIndex > 0 ? visibleColumn[rowIndex - 1] : column;\n                            $xetable.scrollToRow(locatRow, locatColumn).then(posAndFinish);\n                        }\n                    });\n                });\n            }\n            else {\n                reactData.validErrorMaps = {};\n            }\n            return nextTick().then(function () {\n                if (cb) {\n                    cb();\n                }\n            });\n        };\n        validatorMethods = {\n            /**\n             * 完整校验，和 validate 的区别就是会给有效数据中的每一行进行校验\n             */\n            fullValidate: function (rows, cb) {\n                if (process.env.NODE_ENV === 'development') {\n                    if (XEUtils.isFunction(cb)) {\n                        warnLog('vxe.error.notValidators', ['fullValidate(rows, callback)', 'fullValidate(rows)']);\n                    }\n                }\n                return beginValidate(rows, cb, true);\n            },\n            /**\n             * 快速校验，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）\n             */\n            validate: function (rows, cb) {\n                if (process.env.NODE_ENV === 'development') {\n                    if (XEUtils.isFunction(cb)) {\n                        warnLog('vxe.error.notValidators', ['validate(rows, callback)', 'validate(rows)']);\n                    }\n                }\n                return beginValidate(rows, cb);\n            },\n            clearValidate: function (rows, fieldOrColumn) {\n                var validErrorMaps = reactData.validErrorMaps;\n                var validTip = refValidTooltip.value;\n                var validOpts = computeValidOpts.value;\n                var rowList = XEUtils.isArray(rows) ? rows : (rows ? [rows] : []);\n                var colList = (XEUtils.isArray(fieldOrColumn) ? fieldOrColumn : (fieldOrColumn ? [fieldOrColumn] : []).map(function (column) { return handleFieldOrColumn($xetable, column); }));\n                var validErrMaps = {};\n                if (validTip && validTip.reactData.visible) {\n                    validTip.close();\n                }\n                // 如果是单个提示模式\n                if (validOpts.msgMode === 'single') {\n                    reactData.validErrorMaps = {};\n                    return nextTick();\n                }\n                if (rowList.length && colList.length) {\n                    validErrMaps = Object.assign({}, validErrorMaps);\n                    rowList.forEach(function (row) {\n                        colList.forEach(function (column) {\n                            var vaildKey = \"\".concat(getRowid($xetable, row), \":\").concat(column.id);\n                            if (validErrMaps[vaildKey]) {\n                                delete validErrMaps[vaildKey];\n                            }\n                        });\n                    });\n                }\n                else if (rowList.length) {\n                    var rowidList_1 = rowList.map(function (row) { return \"\".concat(getRowid($xetable, row)); });\n                    XEUtils.each(validErrorMaps, function (item, key) {\n                        if (rowidList_1.indexOf(key.split(':')[0]) > -1) {\n                            validErrMaps[key] = item;\n                        }\n                    });\n                }\n                else if (colList.length) {\n                    var colidList_1 = colList.map(function (column) { return \"\".concat(column.id); });\n                    XEUtils.each(validErrorMaps, function (item, key) {\n                        if (colidList_1.indexOf(key.split(':')[1]) > -1) {\n                            validErrMaps[key] = item;\n                        }\n                    });\n                }\n                reactData.validErrorMaps = validErrMaps;\n                return nextTick();\n            }\n        };\n        var validErrorRuleValue = function (rule, val) {\n            var type = rule.type, min = rule.min, max = rule.max, pattern = rule.pattern;\n            var isNumType = type === 'number';\n            var numVal = isNumType ? XEUtils.toNumber(val) : XEUtils.getSize(val);\n            // 判断数值\n            if (isNumType && isNaN(val)) {\n                return true;\n            }\n            // 如果存在 min，判断最小值\n            if (!XEUtils.eqNull(min) && numVal < XEUtils.toNumber(min)) {\n                return true;\n            }\n            // 如果存在 max，判断最大值\n            if (!XEUtils.eqNull(max) && numVal > XEUtils.toNumber(max)) {\n                return true;\n            }\n            // 如果存在 pattern，正则校验\n            if (pattern && !(XEUtils.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {\n                return true;\n            }\n            return false;\n        };\n        validatorPrivateMethods = {\n            /**\n             * 校验数据\n             * 按表格行、列顺序依次校验（同步或异步）\n             * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列\n             * 如果校验失败则，触发回调或者Promise<不通过列的错误消息>\n             * 如果是传回调方式这返回一个校验不通过列的错误消息\n             *\n             * rule 配置：\n             *  required=Boolean 是否必填\n             *  min=Number 最小长度\n             *  max=Number 最大长度\n             *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex }) 自定义校验，接收一个 Promise\n             *  trigger=blur|change 触发方式（除非特殊场景，否则默认为空就行）\n             */\n            validCellRules: function (validType, row, column, val) {\n                var editRules = props.editRules;\n                var field = column.field;\n                var errorRules = [];\n                var syncVailds = [];\n                if (field && editRules) {\n                    var rules_1 = XEUtils.get(editRules, field);\n                    if (rules_1) {\n                        var cellValue_1 = XEUtils.isUndefined(val) ? XEUtils.get(row, field) : val;\n                        rules_1.forEach(function (rule) {\n                            var type = rule.type, trigger = rule.trigger, required = rule.required, validator = rule.validator;\n                            if (validType === 'all' || !trigger || validType === trigger) {\n                                if (validator) {\n                                    var validParams = {\n                                        cellValue: cellValue_1,\n                                        rule: rule,\n                                        rules: rules_1,\n                                        row: row,\n                                        rowIndex: $xetable.getRowIndex(row),\n                                        column: column,\n                                        columnIndex: $xetable.getColumnIndex(column),\n                                        field: column.field,\n                                        $table: $xetable,\n                                        $grid: $xetable.xegrid\n                                    };\n                                    var customValid = void 0;\n                                    if (XEUtils.isString(validator)) {\n                                        var gvItem = VXETable.validators.get(validator);\n                                        if (gvItem) {\n                                            if (gvItem.cellValidatorMethod) {\n                                                customValid = gvItem.cellValidatorMethod(validParams);\n                                            }\n                                            else {\n                                                if (process.env.NODE_ENV === 'development') {\n                                                    warnLog('vxe.error.notValidators', [validator]);\n                                                }\n                                            }\n                                        }\n                                        else {\n                                            if (process.env.NODE_ENV === 'development') {\n                                                errLog('vxe.error.notValidators', [validator]);\n                                            }\n                                        }\n                                    }\n                                    else {\n                                        customValid = validator(validParams);\n                                    }\n                                    if (customValid) {\n                                        if (XEUtils.isError(customValid)) {\n                                            validRuleErr = true;\n                                            errorRules.push(new Rule({ type: 'custom', trigger: trigger, content: customValid.message, rule: new Rule(rule) }));\n                                        }\n                                        else if (customValid.catch) {\n                                            // 如果为异步校验（注：异步校验是并发无序的）\n                                            syncVailds.push(customValid.catch(function (e) {\n                                                validRuleErr = true;\n                                                errorRules.push(new Rule({ type: 'custom', trigger: trigger, content: e && e.message ? e.message : (rule.content || rule.message), rule: new Rule(rule) }));\n                                            }));\n                                        }\n                                    }\n                                }\n                                else {\n                                    var isArrType = type === 'array';\n                                    var isArrVal = XEUtils.isArray(cellValue_1);\n                                    var hasEmpty = true;\n                                    if (isArrType || isArrVal) {\n                                        hasEmpty = !isArrVal || !cellValue_1.length;\n                                    }\n                                    else if (XEUtils.isString(cellValue_1)) {\n                                        hasEmpty = eqEmptyValue(cellValue_1.trim());\n                                    }\n                                    else {\n                                        hasEmpty = eqEmptyValue(cellValue_1);\n                                    }\n                                    if (required ? (hasEmpty || validErrorRuleValue(rule, cellValue_1)) : (!hasEmpty && validErrorRuleValue(rule, cellValue_1))) {\n                                        validRuleErr = true;\n                                        errorRules.push(new Rule(rule));\n                                    }\n                                }\n                            }\n                        });\n                    }\n                }\n                return Promise.all(syncVailds).then(function () {\n                    if (errorRules.length) {\n                        var rest = { rules: errorRules, rule: errorRules[0] };\n                        return Promise.reject(rest);\n                    }\n                });\n            },\n            hasCellRules: function (type, row, column) {\n                var editRules = props.editRules;\n                var field = column.field;\n                if (field && editRules) {\n                    var rules = XEUtils.get(editRules, field);\n                    return rules && !!XEUtils.find(rules, function (rule) { return type === 'all' || !rule.trigger || type === rule.trigger; });\n                }\n                return false;\n            },\n            /**\n             * 触发校验\n             */\n            triggerValidate: function (type) {\n                var editConfig = props.editConfig, editRules = props.editRules;\n                var editStore = reactData.editStore;\n                var actived = editStore.actived;\n                var editOpts = computeEditOpts.value;\n                var validOpts = computeValidOpts.value;\n                // 检查清除校验消息\n                if (editRules && validOpts.msgMode === 'single') {\n                    reactData.validErrorMaps = {};\n                }\n                // 校验单元格\n                if (editConfig && editRules && actived.row) {\n                    var _a = actived.args, row_1 = _a.row, column_1 = _a.column, cell_1 = _a.cell;\n                    if (validatorPrivateMethods.hasCellRules(type, row_1, column_1)) {\n                        return validatorPrivateMethods.validCellRules(type, row_1, column_1).then(function () {\n                            if (editOpts.mode === 'row') {\n                                validatorMethods.clearValidate(row_1, column_1);\n                            }\n                        }).catch(function (_a) {\n                            var rule = _a.rule;\n                            // 如果校验不通过与触发方式一致，则聚焦提示错误，否则跳过并不作任何处理\n                            if (!rule.trigger || type === rule.trigger) {\n                                var rest = { rule: rule, row: row_1, column: column_1, cell: cell_1 };\n                                validatorPrivateMethods.showValidTooltip(rest);\n                                return Promise.reject(rest);\n                            }\n                            return Promise.resolve();\n                        });\n                    }\n                }\n                return Promise.resolve();\n            },\n            /**\n             * 弹出校验错误提示\n             */\n            showValidTooltip: function (params) {\n                var _a, _b;\n                var height = props.height;\n                var tableData = reactData.tableData, validStore = reactData.validStore, validErrorMaps = reactData.validErrorMaps;\n                var rule = params.rule, row = params.row, column = params.column, cell = params.cell;\n                var validOpts = computeValidOpts.value;\n                var validTip = refValidTooltip.value;\n                var content = rule.content;\n                validStore.visible = true;\n                if (validOpts.msgMode === 'single') {\n                    reactData.validErrorMaps = (_a = {},\n                        _a[\"\".concat(getRowid($xetable, row), \":\").concat(column.id)] = {\n                            column: column,\n                            row: row,\n                            rule: rule,\n                            content: content\n                        },\n                        _a);\n                }\n                else {\n                    reactData.validErrorMaps = Object.assign({}, validErrorMaps, (_b = {},\n                        _b[\"\".concat(getRowid($xetable, row), \":\").concat(column.id)] = {\n                            column: column,\n                            row: row,\n                            rule: rule,\n                            content: content\n                        },\n                        _b));\n                }\n                $xetable.dispatchEvent('valid-error', params, null);\n                if (validTip) {\n                    if (validTip && (validOpts.message === 'tooltip' || (validOpts.message === 'default' && !height && tableData.length < 2))) {\n                        return validTip.open(cell, content);\n                    }\n                }\n                return nextTick();\n            }\n        };\n        return __assign(__assign({}, validatorMethods), validatorPrivateMethods);\n    },\n    setupGrid: function ($xegrid) {\n        return $xegrid.extendTableMethods(tableValidatorMethodKeys);\n    }\n};\nexport default validatorHook;\n",
      "start": 1714699767739,
      "end": 1714699767773,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1714699767773,
      "end": 1714699767773,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1714699767773,
      "end": 1714699767773,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1714699767773,
      "end": 1714699767773,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1714699767773,
      "end": 1714699767773,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1714699767773,
      "end": 1714699767773,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1714699767773,
      "end": 1714699767773,
      "order": "normal"
    },
    {
      "name": "vite-plugin-vconsole",
      "result": "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { nextTick } from 'vue';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport XEUtils from 'xe-utils';\nimport { VXETable } from '../../v-x-e-table';\nimport { getFuncText, eqEmptyValue } from '../../tools/utils';\nimport { scrollToView } from '../../tools/dom';\nimport { errLog, warnLog } from '../../tools/log';\nimport { handleFieldOrColumn, getRowid } from '../../table/src/util';\n/**\n * 校验规则\n */\nvar Rule = /** @class */ (function () {\n    function Rule(rule) {\n        Object.assign(this, {\n            $options: rule,\n            required: rule.required,\n            min: rule.min,\n            max: rule.max,\n            type: rule.type,\n            pattern: rule.pattern,\n            validator: rule.validator,\n            trigger: rule.trigger,\n            maxWidth: rule.maxWidth\n        });\n    }\n    Object.defineProperty(Rule.prototype, \"content\", {\n        /**\n         * 获取校验不通过的消息\n         * 支持国际化翻译\n         */\n        get: function () {\n            return getFuncText(this.$options.content || this.$options.message);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rule.prototype, \"message\", {\n        get: function () {\n            return this.content;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Rule;\n}());\nvar tableValidatorMethodKeys = ['fullValidate', 'validate', 'clearValidate'];\nvar validatorHook = {\n    setupTable: function ($xetable) {\n        var props = $xetable.props, reactData = $xetable.reactData, internalData = $xetable.internalData;\n        var refValidTooltip = $xetable.getRefMaps().refValidTooltip;\n        var _a = $xetable.getComputeMaps(), computeValidOpts = _a.computeValidOpts, computeTreeOpts = _a.computeTreeOpts, computeEditOpts = _a.computeEditOpts;\n        var validatorMethods = {};\n        var validatorPrivateMethods = {};\n        var validRuleErr;\n        /**\n         * 聚焦到校验通过的单元格并弹出校验错误提示\n         */\n        var handleValidError = function (params) {\n            return new Promise(function (resolve) {\n                var validOpts = computeValidOpts.value;\n                if (validOpts.autoPos === false) {\n                    $xetable.dispatchEvent('valid-error', params, null);\n                    resolve();\n                }\n                else {\n                    $xetable.handleActived(params, { type: 'valid-error', trigger: 'call' }).then(function () {\n                        resolve(validatorPrivateMethods.showValidTooltip(params));\n                    });\n                }\n            });\n        };\n        var handleErrMsgMode = function (validErrMaps) {\n            var validOpts = computeValidOpts.value;\n            if (validOpts.msgMode === 'single') {\n                var keys = Object.keys(validErrMaps);\n                var resMaps = validErrMaps;\n                if (keys.length) {\n                    var firstKey = keys[0];\n                    resMaps[firstKey] = validErrMaps[firstKey];\n                }\n                return resMaps;\n            }\n            return validErrMaps;\n        };\n        /**\n         * 对表格数据进行校验\n         * 如果不指定数据，则默认只校验临时变动的数据，例如新增或修改\n         * 如果传 true 则校验当前表格数据\n         * 如果传 row 指定行记录，则只验证传入的行\n         * 如果传 rows 为多行记录，则只验证传入的行\n         * 如果只传 callback 否则默认验证整个表格数据\n         * 返回 Promise 对象，或者使用回调方式\n         */\n        var beginValidate = function (rows, cb, isFull) {\n            var validRest = {};\n            var editRules = props.editRules, treeConfig = props.treeConfig;\n            var afterFullData = internalData.afterFullData, visibleColumn = internalData.visibleColumn;\n            var treeOpts = computeTreeOpts.value;\n            var childrenField = treeOpts.children || treeOpts.childrenField;\n            var validOpts = computeValidOpts.value;\n            var vaildDatas;\n            if (rows === true) {\n                vaildDatas = afterFullData;\n            }\n            else if (rows) {\n                if (XEUtils.isFunction(rows)) {\n                    cb = rows;\n                }\n                else {\n                    vaildDatas = XEUtils.isArray(rows) ? rows : [rows];\n                }\n            }\n            if (!vaildDatas) {\n                if ($xetable.getInsertRecords) {\n                    vaildDatas = $xetable.getInsertRecords().concat($xetable.getUpdateRecords());\n                }\n                else {\n                    vaildDatas = [];\n                }\n            }\n            var rowValids = [];\n            internalData._lastCallTime = Date.now();\n            validRuleErr = false; // 如果为快速校验，当存在某列校验不通过时将终止执行\n            validatorMethods.clearValidate();\n            var validErrMaps = {};\n            if (editRules) {\n                var columns_1 = $xetable.getColumns();\n                var handleVaild = function (row) {\n                    if (isFull || !validRuleErr) {\n                        var colVailds_1 = [];\n                        columns_1.forEach(function (column) {\n                            if ((isFull || !validRuleErr) && XEUtils.has(editRules, column.property)) {\n                                colVailds_1.push(validatorPrivateMethods.validCellRules('all', row, column)\n                                    .catch(function (_a) {\n                                    var rule = _a.rule, rules = _a.rules;\n                                    var rest = {\n                                        rule: rule,\n                                        rules: rules,\n                                        rowIndex: $xetable.getRowIndex(row),\n                                        row: row,\n                                        columnIndex: $xetable.getColumnIndex(column),\n                                        column: column,\n                                        field: column.property,\n                                        $table: $xetable\n                                    };\n                                    if (!validRest[column.property]) {\n                                        validRest[column.property] = [];\n                                    }\n                                    validErrMaps[\"\".concat(getRowid($xetable, row), \":\").concat(column.id)] = {\n                                        column: column,\n                                        row: row,\n                                        rule: rule,\n                                        content: rule.content\n                                    };\n                                    validRest[column.property].push(rest);\n                                    if (!isFull) {\n                                        validRuleErr = true;\n                                        return Promise.reject(rest);\n                                    }\n                                }));\n                            }\n                        });\n                        rowValids.push(Promise.all(colVailds_1));\n                    }\n                };\n                if (treeConfig) {\n                    XEUtils.eachTree(vaildDatas, handleVaild, { children: childrenField });\n                }\n                else {\n                    vaildDatas.forEach(handleVaild);\n                }\n                return Promise.all(rowValids).then(function () {\n                    var ruleProps = Object.keys(validRest);\n                    reactData.validErrorMaps = handleErrMsgMode(validErrMaps);\n                    return nextTick().then(function () {\n                        if (ruleProps.length) {\n                            return Promise.reject(validRest[ruleProps[0]][0]);\n                        }\n                        if (cb) {\n                            cb();\n                        }\n                    });\n                }).catch(function (firstErrParams) {\n                    return new Promise(function (resolve, reject) {\n                        var finish = function () {\n                            nextTick(function () {\n                                if (cb) {\n                                    cb(validRest);\n                                    resolve();\n                                }\n                                else {\n                                    if (GlobalConfig.validToReject === 'obsolete') {\n                                        // 已废弃，校验失败将不会执行catch\n                                        reject(validRest);\n                                    }\n                                    else {\n                                        resolve(validRest);\n                                    }\n                                }\n                            });\n                        };\n                        var posAndFinish = function () {\n                            firstErrParams.cell = $xetable.getCell(firstErrParams.row, firstErrParams.column);\n                            scrollToView(firstErrParams.cell);\n                            handleValidError(firstErrParams).then(finish);\n                        };\n                        /**\n                         * 当校验不通过时\n                         * 将表格滚动到可视区\n                         * 由于提示信息至少需要占一行，定位向上偏移一行\n                         */\n                        if (validOpts.autoPos === false) {\n                            finish();\n                        }\n                        else {\n                            var row = firstErrParams.row;\n                            var column = firstErrParams.column;\n                            var rowIndex = afterFullData.indexOf(row);\n                            var columnIndex = visibleColumn.indexOf(column);\n                            var locatRow = rowIndex > 0 ? afterFullData[rowIndex - 1] : row;\n                            var locatColumn = columnIndex > 0 ? visibleColumn[rowIndex - 1] : column;\n                            $xetable.scrollToRow(locatRow, locatColumn).then(posAndFinish);\n                        }\n                    });\n                });\n            }\n            else {\n                reactData.validErrorMaps = {};\n            }\n            return nextTick().then(function () {\n                if (cb) {\n                    cb();\n                }\n            });\n        };\n        validatorMethods = {\n            /**\n             * 完整校验，和 validate 的区别就是会给有效数据中的每一行进行校验\n             */\n            fullValidate: function (rows, cb) {\n                if (process.env.NODE_ENV === 'development') {\n                    if (XEUtils.isFunction(cb)) {\n                        warnLog('vxe.error.notValidators', ['fullValidate(rows, callback)', 'fullValidate(rows)']);\n                    }\n                }\n                return beginValidate(rows, cb, true);\n            },\n            /**\n             * 快速校验，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）\n             */\n            validate: function (rows, cb) {\n                if (process.env.NODE_ENV === 'development') {\n                    if (XEUtils.isFunction(cb)) {\n                        warnLog('vxe.error.notValidators', ['validate(rows, callback)', 'validate(rows)']);\n                    }\n                }\n                return beginValidate(rows, cb);\n            },\n            clearValidate: function (rows, fieldOrColumn) {\n                var validErrorMaps = reactData.validErrorMaps;\n                var validTip = refValidTooltip.value;\n                var validOpts = computeValidOpts.value;\n                var rowList = XEUtils.isArray(rows) ? rows : (rows ? [rows] : []);\n                var colList = (XEUtils.isArray(fieldOrColumn) ? fieldOrColumn : (fieldOrColumn ? [fieldOrColumn] : []).map(function (column) { return handleFieldOrColumn($xetable, column); }));\n                var validErrMaps = {};\n                if (validTip && validTip.reactData.visible) {\n                    validTip.close();\n                }\n                // 如果是单个提示模式\n                if (validOpts.msgMode === 'single') {\n                    reactData.validErrorMaps = {};\n                    return nextTick();\n                }\n                if (rowList.length && colList.length) {\n                    validErrMaps = Object.assign({}, validErrorMaps);\n                    rowList.forEach(function (row) {\n                        colList.forEach(function (column) {\n                            var vaildKey = \"\".concat(getRowid($xetable, row), \":\").concat(column.id);\n                            if (validErrMaps[vaildKey]) {\n                                delete validErrMaps[vaildKey];\n                            }\n                        });\n                    });\n                }\n                else if (rowList.length) {\n                    var rowidList_1 = rowList.map(function (row) { return \"\".concat(getRowid($xetable, row)); });\n                    XEUtils.each(validErrorMaps, function (item, key) {\n                        if (rowidList_1.indexOf(key.split(':')[0]) > -1) {\n                            validErrMaps[key] = item;\n                        }\n                    });\n                }\n                else if (colList.length) {\n                    var colidList_1 = colList.map(function (column) { return \"\".concat(column.id); });\n                    XEUtils.each(validErrorMaps, function (item, key) {\n                        if (colidList_1.indexOf(key.split(':')[1]) > -1) {\n                            validErrMaps[key] = item;\n                        }\n                    });\n                }\n                reactData.validErrorMaps = validErrMaps;\n                return nextTick();\n            }\n        };\n        var validErrorRuleValue = function (rule, val) {\n            var type = rule.type, min = rule.min, max = rule.max, pattern = rule.pattern;\n            var isNumType = type === 'number';\n            var numVal = isNumType ? XEUtils.toNumber(val) : XEUtils.getSize(val);\n            // 判断数值\n            if (isNumType && isNaN(val)) {\n                return true;\n            }\n            // 如果存在 min，判断最小值\n            if (!XEUtils.eqNull(min) && numVal < XEUtils.toNumber(min)) {\n                return true;\n            }\n            // 如果存在 max，判断最大值\n            if (!XEUtils.eqNull(max) && numVal > XEUtils.toNumber(max)) {\n                return true;\n            }\n            // 如果存在 pattern，正则校验\n            if (pattern && !(XEUtils.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {\n                return true;\n            }\n            return false;\n        };\n        validatorPrivateMethods = {\n            /**\n             * 校验数据\n             * 按表格行、列顺序依次校验（同步或异步）\n             * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列\n             * 如果校验失败则，触发回调或者Promise<不通过列的错误消息>\n             * 如果是传回调方式这返回一个校验不通过列的错误消息\n             *\n             * rule 配置：\n             *  required=Boolean 是否必填\n             *  min=Number 最小长度\n             *  max=Number 最大长度\n             *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex }) 自定义校验，接收一个 Promise\n             *  trigger=blur|change 触发方式（除非特殊场景，否则默认为空就行）\n             */\n            validCellRules: function (validType, row, column, val) {\n                var editRules = props.editRules;\n                var field = column.field;\n                var errorRules = [];\n                var syncVailds = [];\n                if (field && editRules) {\n                    var rules_1 = XEUtils.get(editRules, field);\n                    if (rules_1) {\n                        var cellValue_1 = XEUtils.isUndefined(val) ? XEUtils.get(row, field) : val;\n                        rules_1.forEach(function (rule) {\n                            var type = rule.type, trigger = rule.trigger, required = rule.required, validator = rule.validator;\n                            if (validType === 'all' || !trigger || validType === trigger) {\n                                if (validator) {\n                                    var validParams = {\n                                        cellValue: cellValue_1,\n                                        rule: rule,\n                                        rules: rules_1,\n                                        row: row,\n                                        rowIndex: $xetable.getRowIndex(row),\n                                        column: column,\n                                        columnIndex: $xetable.getColumnIndex(column),\n                                        field: column.field,\n                                        $table: $xetable,\n                                        $grid: $xetable.xegrid\n                                    };\n                                    var customValid = void 0;\n                                    if (XEUtils.isString(validator)) {\n                                        var gvItem = VXETable.validators.get(validator);\n                                        if (gvItem) {\n                                            if (gvItem.cellValidatorMethod) {\n                                                customValid = gvItem.cellValidatorMethod(validParams);\n                                            }\n                                            else {\n                                                if (process.env.NODE_ENV === 'development') {\n                                                    warnLog('vxe.error.notValidators', [validator]);\n                                                }\n                                            }\n                                        }\n                                        else {\n                                            if (process.env.NODE_ENV === 'development') {\n                                                errLog('vxe.error.notValidators', [validator]);\n                                            }\n                                        }\n                                    }\n                                    else {\n                                        customValid = validator(validParams);\n                                    }\n                                    if (customValid) {\n                                        if (XEUtils.isError(customValid)) {\n                                            validRuleErr = true;\n                                            errorRules.push(new Rule({ type: 'custom', trigger: trigger, content: customValid.message, rule: new Rule(rule) }));\n                                        }\n                                        else if (customValid.catch) {\n                                            // 如果为异步校验（注：异步校验是并发无序的）\n                                            syncVailds.push(customValid.catch(function (e) {\n                                                validRuleErr = true;\n                                                errorRules.push(new Rule({ type: 'custom', trigger: trigger, content: e && e.message ? e.message : (rule.content || rule.message), rule: new Rule(rule) }));\n                                            }));\n                                        }\n                                    }\n                                }\n                                else {\n                                    var isArrType = type === 'array';\n                                    var isArrVal = XEUtils.isArray(cellValue_1);\n                                    var hasEmpty = true;\n                                    if (isArrType || isArrVal) {\n                                        hasEmpty = !isArrVal || !cellValue_1.length;\n                                    }\n                                    else if (XEUtils.isString(cellValue_1)) {\n                                        hasEmpty = eqEmptyValue(cellValue_1.trim());\n                                    }\n                                    else {\n                                        hasEmpty = eqEmptyValue(cellValue_1);\n                                    }\n                                    if (required ? (hasEmpty || validErrorRuleValue(rule, cellValue_1)) : (!hasEmpty && validErrorRuleValue(rule, cellValue_1))) {\n                                        validRuleErr = true;\n                                        errorRules.push(new Rule(rule));\n                                    }\n                                }\n                            }\n                        });\n                    }\n                }\n                return Promise.all(syncVailds).then(function () {\n                    if (errorRules.length) {\n                        var rest = { rules: errorRules, rule: errorRules[0] };\n                        return Promise.reject(rest);\n                    }\n                });\n            },\n            hasCellRules: function (type, row, column) {\n                var editRules = props.editRules;\n                var field = column.field;\n                if (field && editRules) {\n                    var rules = XEUtils.get(editRules, field);\n                    return rules && !!XEUtils.find(rules, function (rule) { return type === 'all' || !rule.trigger || type === rule.trigger; });\n                }\n                return false;\n            },\n            /**\n             * 触发校验\n             */\n            triggerValidate: function (type) {\n                var editConfig = props.editConfig, editRules = props.editRules;\n                var editStore = reactData.editStore;\n                var actived = editStore.actived;\n                var editOpts = computeEditOpts.value;\n                var validOpts = computeValidOpts.value;\n                // 检查清除校验消息\n                if (editRules && validOpts.msgMode === 'single') {\n                    reactData.validErrorMaps = {};\n                }\n                // 校验单元格\n                if (editConfig && editRules && actived.row) {\n                    var _a = actived.args, row_1 = _a.row, column_1 = _a.column, cell_1 = _a.cell;\n                    if (validatorPrivateMethods.hasCellRules(type, row_1, column_1)) {\n                        return validatorPrivateMethods.validCellRules(type, row_1, column_1).then(function () {\n                            if (editOpts.mode === 'row') {\n                                validatorMethods.clearValidate(row_1, column_1);\n                            }\n                        }).catch(function (_a) {\n                            var rule = _a.rule;\n                            // 如果校验不通过与触发方式一致，则聚焦提示错误，否则跳过并不作任何处理\n                            if (!rule.trigger || type === rule.trigger) {\n                                var rest = { rule: rule, row: row_1, column: column_1, cell: cell_1 };\n                                validatorPrivateMethods.showValidTooltip(rest);\n                                return Promise.reject(rest);\n                            }\n                            return Promise.resolve();\n                        });\n                    }\n                }\n                return Promise.resolve();\n            },\n            /**\n             * 弹出校验错误提示\n             */\n            showValidTooltip: function (params) {\n                var _a, _b;\n                var height = props.height;\n                var tableData = reactData.tableData, validStore = reactData.validStore, validErrorMaps = reactData.validErrorMaps;\n                var rule = params.rule, row = params.row, column = params.column, cell = params.cell;\n                var validOpts = computeValidOpts.value;\n                var validTip = refValidTooltip.value;\n                var content = rule.content;\n                validStore.visible = true;\n                if (validOpts.msgMode === 'single') {\n                    reactData.validErrorMaps = (_a = {},\n                        _a[\"\".concat(getRowid($xetable, row), \":\").concat(column.id)] = {\n                            column: column,\n                            row: row,\n                            rule: rule,\n                            content: content\n                        },\n                        _a);\n                }\n                else {\n                    reactData.validErrorMaps = Object.assign({}, validErrorMaps, (_b = {},\n                        _b[\"\".concat(getRowid($xetable, row), \":\").concat(column.id)] = {\n                            column: column,\n                            row: row,\n                            rule: rule,\n                            content: content\n                        },\n                        _b));\n                }\n                $xetable.dispatchEvent('valid-error', params, null);\n                if (validTip) {\n                    if (validTip && (validOpts.message === 'tooltip' || (validOpts.message === 'default' && !height && tableData.length < 2))) {\n                        return validTip.open(cell, content);\n                    }\n                }\n                return nextTick();\n            }\n        };\n        return __assign(__assign({}, validatorMethods), validatorPrivateMethods);\n    },\n    setupGrid: function ($xegrid) {\n        return $xegrid.extendTableMethods(tableValidatorMethodKeys);\n    }\n};\nexport default validatorHook;\n",
      "start": 1714699767773,
      "end": 1714699767773,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "esbuild",
      "start": 1714699767773,
      "end": 1714699767773,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "var __assign = function() {\n  __assign = Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s)\n        if (Object.prototype.hasOwnProperty.call(s, p))\n          t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport { nextTick } from \"vue\";\nimport GlobalConfig from \"../../v-x-e-table/src/conf\";\nimport XEUtils from \"xe-utils\";\nimport { VXETable } from \"../../v-x-e-table\";\nimport { getFuncText, eqEmptyValue } from \"../../tools/utils\";\nimport { scrollToView } from \"../../tools/dom\";\nimport { errLog, warnLog } from \"../../tools/log\";\nimport { handleFieldOrColumn, getRowid } from \"../../table/src/util\";\nvar Rule = (\n  /** @class */\n  function() {\n    function Rule2(rule) {\n      Object.assign(this, {\n        $options: rule,\n        required: rule.required,\n        min: rule.min,\n        max: rule.max,\n        type: rule.type,\n        pattern: rule.pattern,\n        validator: rule.validator,\n        trigger: rule.trigger,\n        maxWidth: rule.maxWidth\n      });\n    }\n    Object.defineProperty(Rule2.prototype, \"content\", {\n      /**\n       * 获取校验不通过的消息\n       * 支持国际化翻译\n       */\n      get: function() {\n        return getFuncText(this.$options.content || this.$options.message);\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(Rule2.prototype, \"message\", {\n      get: function() {\n        return this.content;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    return Rule2;\n  }()\n);\nvar tableValidatorMethodKeys = [\"fullValidate\", \"validate\", \"clearValidate\"];\nvar validatorHook = {\n  setupTable: function($xetable) {\n    var props = $xetable.props, reactData = $xetable.reactData, internalData = $xetable.internalData;\n    var refValidTooltip = $xetable.getRefMaps().refValidTooltip;\n    var _a = $xetable.getComputeMaps(), computeValidOpts = _a.computeValidOpts, computeTreeOpts = _a.computeTreeOpts, computeEditOpts = _a.computeEditOpts;\n    var validatorMethods = {};\n    var validatorPrivateMethods = {};\n    var validRuleErr;\n    var handleValidError = function(params) {\n      return new Promise(function(resolve) {\n        var validOpts = computeValidOpts.value;\n        if (validOpts.autoPos === false) {\n          $xetable.dispatchEvent(\"valid-error\", params, null);\n          resolve();\n        } else {\n          $xetable.handleActived(params, { type: \"valid-error\", trigger: \"call\" }).then(function() {\n            resolve(validatorPrivateMethods.showValidTooltip(params));\n          });\n        }\n      });\n    };\n    var handleErrMsgMode = function(validErrMaps) {\n      var validOpts = computeValidOpts.value;\n      if (validOpts.msgMode === \"single\") {\n        var keys = Object.keys(validErrMaps);\n        var resMaps = validErrMaps;\n        if (keys.length) {\n          var firstKey = keys[0];\n          resMaps[firstKey] = validErrMaps[firstKey];\n        }\n        return resMaps;\n      }\n      return validErrMaps;\n    };\n    var beginValidate = function(rows, cb, isFull) {\n      var validRest = {};\n      var editRules = props.editRules, treeConfig = props.treeConfig;\n      var afterFullData = internalData.afterFullData, visibleColumn = internalData.visibleColumn;\n      var treeOpts = computeTreeOpts.value;\n      var childrenField = treeOpts.children || treeOpts.childrenField;\n      var validOpts = computeValidOpts.value;\n      var vaildDatas;\n      if (rows === true) {\n        vaildDatas = afterFullData;\n      } else if (rows) {\n        if (XEUtils.isFunction(rows)) {\n          cb = rows;\n        } else {\n          vaildDatas = XEUtils.isArray(rows) ? rows : [rows];\n        }\n      }\n      if (!vaildDatas) {\n        if ($xetable.getInsertRecords) {\n          vaildDatas = $xetable.getInsertRecords().concat($xetable.getUpdateRecords());\n        } else {\n          vaildDatas = [];\n        }\n      }\n      var rowValids = [];\n      internalData._lastCallTime = Date.now();\n      validRuleErr = false;\n      validatorMethods.clearValidate();\n      var validErrMaps = {};\n      if (editRules) {\n        var columns_1 = $xetable.getColumns();\n        var handleVaild = function(row) {\n          if (isFull || !validRuleErr) {\n            var colVailds_1 = [];\n            columns_1.forEach(function(column) {\n              if ((isFull || !validRuleErr) && XEUtils.has(editRules, column.property)) {\n                colVailds_1.push(validatorPrivateMethods.validCellRules(\"all\", row, column).catch(function(_a2) {\n                  var rule = _a2.rule, rules = _a2.rules;\n                  var rest = {\n                    rule,\n                    rules,\n                    rowIndex: $xetable.getRowIndex(row),\n                    row,\n                    columnIndex: $xetable.getColumnIndex(column),\n                    column,\n                    field: column.property,\n                    $table: $xetable\n                  };\n                  if (!validRest[column.property]) {\n                    validRest[column.property] = [];\n                  }\n                  validErrMaps[\"\".concat(getRowid($xetable, row), \":\").concat(column.id)] = {\n                    column,\n                    row,\n                    rule,\n                    content: rule.content\n                  };\n                  validRest[column.property].push(rest);\n                  if (!isFull) {\n                    validRuleErr = true;\n                    return Promise.reject(rest);\n                  }\n                }));\n              }\n            });\n            rowValids.push(Promise.all(colVailds_1));\n          }\n        };\n        if (treeConfig) {\n          XEUtils.eachTree(vaildDatas, handleVaild, { children: childrenField });\n        } else {\n          vaildDatas.forEach(handleVaild);\n        }\n        return Promise.all(rowValids).then(function() {\n          var ruleProps = Object.keys(validRest);\n          reactData.validErrorMaps = handleErrMsgMode(validErrMaps);\n          return nextTick().then(function() {\n            if (ruleProps.length) {\n              return Promise.reject(validRest[ruleProps[0]][0]);\n            }\n            if (cb) {\n              cb();\n            }\n          });\n        }).catch(function(firstErrParams) {\n          return new Promise(function(resolve, reject) {\n            var finish = function() {\n              nextTick(function() {\n                if (cb) {\n                  cb(validRest);\n                  resolve();\n                } else {\n                  if (GlobalConfig.validToReject === \"obsolete\") {\n                    reject(validRest);\n                  } else {\n                    resolve(validRest);\n                  }\n                }\n              });\n            };\n            var posAndFinish = function() {\n              firstErrParams.cell = $xetable.getCell(firstErrParams.row, firstErrParams.column);\n              scrollToView(firstErrParams.cell);\n              handleValidError(firstErrParams).then(finish);\n            };\n            if (validOpts.autoPos === false) {\n              finish();\n            } else {\n              var row = firstErrParams.row;\n              var column = firstErrParams.column;\n              var rowIndex = afterFullData.indexOf(row);\n              var columnIndex = visibleColumn.indexOf(column);\n              var locatRow = rowIndex > 0 ? afterFullData[rowIndex - 1] : row;\n              var locatColumn = columnIndex > 0 ? visibleColumn[rowIndex - 1] : column;\n              $xetable.scrollToRow(locatRow, locatColumn).then(posAndFinish);\n            }\n          });\n        });\n      } else {\n        reactData.validErrorMaps = {};\n      }\n      return nextTick().then(function() {\n        if (cb) {\n          cb();\n        }\n      });\n    };\n    validatorMethods = {\n      /**\n       * 完整校验，和 validate 的区别就是会给有效数据中的每一行进行校验\n       */\n      fullValidate: function(rows, cb) {\n        if (false) {\n          if (XEUtils.isFunction(cb)) {\n            warnLog(\"vxe.error.notValidators\", [\"fullValidate(rows, callback)\", \"fullValidate(rows)\"]);\n          }\n        }\n        return beginValidate(rows, cb, true);\n      },\n      /**\n       * 快速校验，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）\n       */\n      validate: function(rows, cb) {\n        if (false) {\n          if (XEUtils.isFunction(cb)) {\n            warnLog(\"vxe.error.notValidators\", [\"validate(rows, callback)\", \"validate(rows)\"]);\n          }\n        }\n        return beginValidate(rows, cb);\n      },\n      clearValidate: function(rows, fieldOrColumn) {\n        var validErrorMaps = reactData.validErrorMaps;\n        var validTip = refValidTooltip.value;\n        var validOpts = computeValidOpts.value;\n        var rowList = XEUtils.isArray(rows) ? rows : rows ? [rows] : [];\n        var colList = XEUtils.isArray(fieldOrColumn) ? fieldOrColumn : (fieldOrColumn ? [fieldOrColumn] : []).map(function(column) {\n          return handleFieldOrColumn($xetable, column);\n        });\n        var validErrMaps = {};\n        if (validTip && validTip.reactData.visible) {\n          validTip.close();\n        }\n        if (validOpts.msgMode === \"single\") {\n          reactData.validErrorMaps = {};\n          return nextTick();\n        }\n        if (rowList.length && colList.length) {\n          validErrMaps = Object.assign({}, validErrorMaps);\n          rowList.forEach(function(row) {\n            colList.forEach(function(column) {\n              var vaildKey = \"\".concat(getRowid($xetable, row), \":\").concat(column.id);\n              if (validErrMaps[vaildKey]) {\n                delete validErrMaps[vaildKey];\n              }\n            });\n          });\n        } else if (rowList.length) {\n          var rowidList_1 = rowList.map(function(row) {\n            return \"\".concat(getRowid($xetable, row));\n          });\n          XEUtils.each(validErrorMaps, function(item, key) {\n            if (rowidList_1.indexOf(key.split(\":\")[0]) > -1) {\n              validErrMaps[key] = item;\n            }\n          });\n        } else if (colList.length) {\n          var colidList_1 = colList.map(function(column) {\n            return \"\".concat(column.id);\n          });\n          XEUtils.each(validErrorMaps, function(item, key) {\n            if (colidList_1.indexOf(key.split(\":\")[1]) > -1) {\n              validErrMaps[key] = item;\n            }\n          });\n        }\n        reactData.validErrorMaps = validErrMaps;\n        return nextTick();\n      }\n    };\n    var validErrorRuleValue = function(rule, val) {\n      var type = rule.type, min = rule.min, max = rule.max, pattern = rule.pattern;\n      var isNumType = type === \"number\";\n      var numVal = isNumType ? XEUtils.toNumber(val) : XEUtils.getSize(val);\n      if (isNumType && isNaN(val)) {\n        return true;\n      }\n      if (!XEUtils.eqNull(min) && numVal < XEUtils.toNumber(min)) {\n        return true;\n      }\n      if (!XEUtils.eqNull(max) && numVal > XEUtils.toNumber(max)) {\n        return true;\n      }\n      if (pattern && !(XEUtils.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {\n        return true;\n      }\n      return false;\n    };\n    validatorPrivateMethods = {\n      /**\n       * 校验数据\n       * 按表格行、列顺序依次校验（同步或异步）\n       * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列\n       * 如果校验失败则，触发回调或者Promise<不通过列的错误消息>\n       * 如果是传回调方式这返回一个校验不通过列的错误消息\n       *\n       * rule 配置：\n       *  required=Boolean 是否必填\n       *  min=Number 最小长度\n       *  max=Number 最大长度\n       *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex }) 自定义校验，接收一个 Promise\n       *  trigger=blur|change 触发方式（除非特殊场景，否则默认为空就行）\n       */\n      validCellRules: function(validType, row, column, val) {\n        var editRules = props.editRules;\n        var field = column.field;\n        var errorRules = [];\n        var syncVailds = [];\n        if (field && editRules) {\n          var rules_1 = XEUtils.get(editRules, field);\n          if (rules_1) {\n            var cellValue_1 = XEUtils.isUndefined(val) ? XEUtils.get(row, field) : val;\n            rules_1.forEach(function(rule) {\n              var type = rule.type, trigger = rule.trigger, required = rule.required, validator = rule.validator;\n              if (validType === \"all\" || !trigger || validType === trigger) {\n                if (validator) {\n                  var validParams = {\n                    cellValue: cellValue_1,\n                    rule,\n                    rules: rules_1,\n                    row,\n                    rowIndex: $xetable.getRowIndex(row),\n                    column,\n                    columnIndex: $xetable.getColumnIndex(column),\n                    field: column.field,\n                    $table: $xetable,\n                    $grid: $xetable.xegrid\n                  };\n                  var customValid = void 0;\n                  if (XEUtils.isString(validator)) {\n                    var gvItem = VXETable.validators.get(validator);\n                    if (gvItem) {\n                      if (gvItem.cellValidatorMethod) {\n                        customValid = gvItem.cellValidatorMethod(validParams);\n                      } else {\n                        if (false) {\n                          warnLog(\"vxe.error.notValidators\", [validator]);\n                        }\n                      }\n                    } else {\n                      if (false) {\n                        errLog(\"vxe.error.notValidators\", [validator]);\n                      }\n                    }\n                  } else {\n                    customValid = validator(validParams);\n                  }\n                  if (customValid) {\n                    if (XEUtils.isError(customValid)) {\n                      validRuleErr = true;\n                      errorRules.push(new Rule({ type: \"custom\", trigger, content: customValid.message, rule: new Rule(rule) }));\n                    } else if (customValid.catch) {\n                      syncVailds.push(customValid.catch(function(e) {\n                        validRuleErr = true;\n                        errorRules.push(new Rule({ type: \"custom\", trigger, content: e && e.message ? e.message : rule.content || rule.message, rule: new Rule(rule) }));\n                      }));\n                    }\n                  }\n                } else {\n                  var isArrType = type === \"array\";\n                  var isArrVal = XEUtils.isArray(cellValue_1);\n                  var hasEmpty = true;\n                  if (isArrType || isArrVal) {\n                    hasEmpty = !isArrVal || !cellValue_1.length;\n                  } else if (XEUtils.isString(cellValue_1)) {\n                    hasEmpty = eqEmptyValue(cellValue_1.trim());\n                  } else {\n                    hasEmpty = eqEmptyValue(cellValue_1);\n                  }\n                  if (required ? hasEmpty || validErrorRuleValue(rule, cellValue_1) : !hasEmpty && validErrorRuleValue(rule, cellValue_1)) {\n                    validRuleErr = true;\n                    errorRules.push(new Rule(rule));\n                  }\n                }\n              }\n            });\n          }\n        }\n        return Promise.all(syncVailds).then(function() {\n          if (errorRules.length) {\n            var rest = { rules: errorRules, rule: errorRules[0] };\n            return Promise.reject(rest);\n          }\n        });\n      },\n      hasCellRules: function(type, row, column) {\n        var editRules = props.editRules;\n        var field = column.field;\n        if (field && editRules) {\n          var rules = XEUtils.get(editRules, field);\n          return rules && !!XEUtils.find(rules, function(rule) {\n            return type === \"all\" || !rule.trigger || type === rule.trigger;\n          });\n        }\n        return false;\n      },\n      /**\n       * 触发校验\n       */\n      triggerValidate: function(type) {\n        var editConfig = props.editConfig, editRules = props.editRules;\n        var editStore = reactData.editStore;\n        var actived = editStore.actived;\n        var editOpts = computeEditOpts.value;\n        var validOpts = computeValidOpts.value;\n        if (editRules && validOpts.msgMode === \"single\") {\n          reactData.validErrorMaps = {};\n        }\n        if (editConfig && editRules && actived.row) {\n          var _a2 = actived.args, row_1 = _a2.row, column_1 = _a2.column, cell_1 = _a2.cell;\n          if (validatorPrivateMethods.hasCellRules(type, row_1, column_1)) {\n            return validatorPrivateMethods.validCellRules(type, row_1, column_1).then(function() {\n              if (editOpts.mode === \"row\") {\n                validatorMethods.clearValidate(row_1, column_1);\n              }\n            }).catch(function(_a3) {\n              var rule = _a3.rule;\n              if (!rule.trigger || type === rule.trigger) {\n                var rest = { rule, row: row_1, column: column_1, cell: cell_1 };\n                validatorPrivateMethods.showValidTooltip(rest);\n                return Promise.reject(rest);\n              }\n              return Promise.resolve();\n            });\n          }\n        }\n        return Promise.resolve();\n      },\n      /**\n       * 弹出校验错误提示\n       */\n      showValidTooltip: function(params) {\n        var _a2, _b;\n        var height = props.height;\n        var tableData = reactData.tableData, validStore = reactData.validStore, validErrorMaps = reactData.validErrorMaps;\n        var rule = params.rule, row = params.row, column = params.column, cell = params.cell;\n        var validOpts = computeValidOpts.value;\n        var validTip = refValidTooltip.value;\n        var content = rule.content;\n        validStore.visible = true;\n        if (validOpts.msgMode === \"single\") {\n          reactData.validErrorMaps = (_a2 = {}, _a2[\"\".concat(getRowid($xetable, row), \":\").concat(column.id)] = {\n            column,\n            row,\n            rule,\n            content\n          }, _a2);\n        } else {\n          reactData.validErrorMaps = Object.assign({}, validErrorMaps, (_b = {}, _b[\"\".concat(getRowid($xetable, row), \":\").concat(column.id)] = {\n            column,\n            row,\n            rule,\n            content\n          }, _b));\n        }\n        $xetable.dispatchEvent(\"valid-error\", params, null);\n        if (validTip) {\n          if (validTip && (validOpts.message === \"tooltip\" || validOpts.message === \"default\" && !height && tableData.length < 2)) {\n            return validTip.open(cell, content);\n          }\n        }\n        return nextTick();\n      }\n    };\n    return __assign(__assign({}, validatorMethods), validatorPrivateMethods);\n  },\n  setupGrid: function($xegrid) {\n    return $xegrid.extendTableMethods(tableValidatorMethodKeys);\n  }\n};\nexport default validatorHook;\n",
      "start": 1714699767773,
      "end": 1714699768390,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-post",
      "start": 1714699768391,
      "end": 1714699768391,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1714699768391,
      "end": 1714699768391,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1714699768391,
      "end": 1714699768391,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1714699768391,
      "end": 1714699768391,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1714699768391,
      "end": 1714699768396,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1714699768396,
      "end": 1714699768396,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1714699768396,
      "end": 1714699768396,
      "order": "normal"
    },
    {
      "name": "unplugin-auto-import",
      "start": 1714699768396,
      "end": 1714699768396,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1714699768396,
      "end": 1714699768396,
      "order": "post"
    },
    {
      "name": "vite:style-import",
      "start": 1714699768396,
      "end": 1714699768396,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1714699768396,
      "end": 1714699768396,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1714699768396,
      "end": 1714699768396,
      "order": "normal"
    }
  ]
}
