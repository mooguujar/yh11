{
  "resolvedId": "/Users/afeng/Desktop/work/gdpayh5-web/node_modules/.pnpm/vxe-table@4.5.21_vue@3.4.19_xe-utils@3.5.24/node_modules/vxe-table/es/table/src/body.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { createCommentVNode, defineComponent, h, ref, inject, nextTick, onBeforeUnmount, onMounted, onUnmounted } from 'vue';\nimport XEUtils from 'xe-utils';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport { VXETable } from '../../v-x-e-table';\nimport { mergeBodyMethod, getRowid, removeScrollListener, restoreScrollListener } from './util';\nimport { updateCellTitle, getPropClass } from '../../tools/dom';\nimport { isEnableConf } from '../../tools/utils';\nimport { getSlotVNs } from '../../tools/vn';\nvar renderType = 'body';\nvar lineOffsetSizes = {\n    mini: 3,\n    small: 2,\n    medium: 1\n};\nexport default defineComponent({\n    name: 'VxeTableBody',\n    props: {\n        tableData: Array,\n        tableColumn: Array,\n        fixedColumn: Array,\n        fixedType: { type: String, default: null }\n    },\n    setup: function (props) {\n        var $xetable = inject('$xetable', {});\n        var xesize = inject('xesize', null);\n        var xID = $xetable.xID, tableProps = $xetable.props, tableContext = $xetable.context, tableReactData = $xetable.reactData, tableInternalData = $xetable.internalData;\n        var _a = $xetable.getRefMaps(), refTableHeader = _a.refTableHeader, refTableBody = _a.refTableBody, refTableFooter = _a.refTableFooter, refTableLeftBody = _a.refTableLeftBody, refTableRightBody = _a.refTableRightBody, refValidTooltip = _a.refValidTooltip;\n        var _b = $xetable.getComputeMaps(), computeEditOpts = _b.computeEditOpts, computeMouseOpts = _b.computeMouseOpts, computeSYOpts = _b.computeSYOpts, computeEmptyOpts = _b.computeEmptyOpts, computeKeyboardOpts = _b.computeKeyboardOpts, computeTooltipOpts = _b.computeTooltipOpts, computeRadioOpts = _b.computeRadioOpts, computeExpandOpts = _b.computeExpandOpts, computeTreeOpts = _b.computeTreeOpts, computeCheckboxOpts = _b.computeCheckboxOpts, computeValidOpts = _b.computeValidOpts, computeRowOpts = _b.computeRowOpts, computeColumnOpts = _b.computeColumnOpts;\n        var refElem = ref();\n        var refBodyTable = ref();\n        var refBodyColgroup = ref();\n        var refBodyTBody = ref();\n        var refBodyXSpace = ref();\n        var refBodyYSpace = ref();\n        var refBodyEmptyBlock = ref();\n        var getOffsetSize = function () {\n            if (xesize) {\n                var vSize = xesize.value;\n                if (vSize) {\n                    return lineOffsetSizes[vSize] || 0;\n                }\n            }\n            return 0;\n        };\n        // 滚动、拖动过程中不需要触发\n        var isVMScrollProcess = function () {\n            var delayHover = tableProps.delayHover;\n            var lastScrollTime = tableReactData.lastScrollTime, _isResize = tableReactData._isResize;\n            return !!(_isResize || (lastScrollTime && Date.now() < lastScrollTime + delayHover));\n        };\n        var countTreeExpand = function (prevRow, params) {\n            var count = 1;\n            if (!prevRow) {\n                return count;\n            }\n            var treeOpts = computeTreeOpts.value;\n            var childrenField = treeOpts.children || treeOpts.childrenField;\n            var rowChildren = prevRow[childrenField];\n            if (rowChildren && $xetable.isTreeExpandByRow(prevRow)) {\n                for (var index = 0; index < rowChildren.length; index++) {\n                    count += countTreeExpand(rowChildren[index], params);\n                }\n            }\n            return count;\n        };\n        var calcTreeLine = function (params, items, rIndex) {\n            var expandSize = 1;\n            if (rIndex) {\n                expandSize = countTreeExpand(items[rIndex - 1], params);\n            }\n            return tableReactData.rowHeight * expandSize - (rIndex ? 1 : (12 - getOffsetSize()));\n        };\n        var renderLine = function (params) {\n            var row = params.row, column = params.column;\n            var treeConfig = tableProps.treeConfig;\n            var treeOpts = computeTreeOpts.value;\n            var slots = column.slots, treeNode = column.treeNode;\n            var fullAllDataRowIdData = tableInternalData.fullAllDataRowIdData;\n            var rowid = getRowid($xetable, row);\n            var rest = fullAllDataRowIdData[rowid];\n            var rLevel = 0;\n            var rIndex = 0;\n            var items = [];\n            if (rest) {\n                rLevel = rest.level;\n                rIndex = rest._index;\n                items = rest.items;\n            }\n            if (slots && slots.line) {\n                return $xetable.callSlot(slots.line, params);\n            }\n            if (treeConfig && treeNode && (treeOpts.showLine || treeOpts.line)) {\n                return [\n                    h('div', {\n                        class: 'vxe-tree--line-wrapper'\n                    }, [\n                        h('div', {\n                            class: 'vxe-tree--line',\n                            style: {\n                                height: \"\".concat(calcTreeLine(params, items, rIndex), \"px\"),\n                                left: \"\".concat((rLevel * treeOpts.indent) + (rLevel ? 2 - getOffsetSize() : 0) + 16, \"px\")\n                            }\n                        })\n                    ])\n                ];\n            }\n            return [];\n        };\n        /**\n         * 渲染列\n         */\n        var renderColumn = function (seq, rowid, fixedType, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, columns, items) {\n            var _a;\n            var columnKey = tableProps.columnKey, height = tableProps.height, allColumnOverflow = tableProps.showOverflow, allCellClassName = tableProps.cellClassName, cellStyle = tableProps.cellStyle, allAlign = tableProps.align, spanMethod = tableProps.spanMethod, mouseConfig = tableProps.mouseConfig, editConfig = tableProps.editConfig, editRules = tableProps.editRules, tooltipConfig = tableProps.tooltipConfig;\n            var tableData = tableReactData.tableData, overflowX = tableReactData.overflowX, scrollYLoad = tableReactData.scrollYLoad, currentColumn = tableReactData.currentColumn, mergeList = tableReactData.mergeList, editStore = tableReactData.editStore, isAllOverflow = tableReactData.isAllOverflow, validErrorMaps = tableReactData.validErrorMaps;\n            var afterFullData = tableInternalData.afterFullData;\n            var validOpts = computeValidOpts.value;\n            var checkboxOpts = computeCheckboxOpts.value;\n            var editOpts = computeEditOpts.value;\n            var tooltipOpts = computeTooltipOpts.value;\n            var rowOpts = computeRowOpts.value;\n            var sYOpts = computeSYOpts.value;\n            var columnOpts = computeColumnOpts.value;\n            var type = column.type, cellRender = column.cellRender, editRender = column.editRender, align = column.align, showOverflow = column.showOverflow, className = column.className, treeNode = column.treeNode, slots = column.slots;\n            var actived = editStore.actived;\n            var scrollYRHeight = sYOpts.rHeight;\n            var rowHeight = rowOpts.height;\n            var renderOpts = editRender || cellRender;\n            var compConf = renderOpts ? VXETable.renderer.get(renderOpts.name) : null;\n            var compCellClassName = compConf ? compConf.cellClassName : '';\n            var compCellStyle = compConf ? compConf.cellStyle : '';\n            var showAllTip = tooltipOpts.showAll;\n            var columnIndex = $xetable.getColumnIndex(column);\n            var _columnIndex = $xetable.getVTColumnIndex(column);\n            var isEdit = isEnableConf(editRender);\n            var fixedHiddenColumn = fixedType ? column.fixed !== fixedType : column.fixed && overflowX;\n            var cellOverflow = (XEUtils.isUndefined(showOverflow) || XEUtils.isNull(showOverflow)) ? allColumnOverflow : showOverflow;\n            var showEllipsis = cellOverflow === 'ellipsis';\n            var showTitle = cellOverflow === 'title';\n            var showTooltip = cellOverflow === true || cellOverflow === 'tooltip';\n            var hasEllipsis = showTitle || showTooltip || showEllipsis;\n            var isDirty;\n            var tdOns = {};\n            var cellAlign = align || allAlign;\n            var errorValidItem = validErrorMaps[\"\".concat(rowid, \":\").concat(column.id)];\n            var showValidTip = editRules && validOpts.showMessage && (validOpts.message === 'default' ? (height || tableData.length > 1) : validOpts.message === 'inline');\n            var attrs = { colid: column.id };\n            var params = { $table: $xetable, $grid: $xetable.xegrid, seq: seq, rowid: rowid, row: row, rowIndex: rowIndex, $rowIndex: $rowIndex, _rowIndex: _rowIndex, column: column, columnIndex: columnIndex, $columnIndex: $columnIndex, _columnIndex: _columnIndex, fixed: fixedType, type: renderType, isHidden: fixedHiddenColumn, level: rowLevel, visibleData: afterFullData, data: tableData, items: items };\n            // 虚拟滚动不支持动态高度\n            if (scrollYLoad && !hasEllipsis) {\n                showEllipsis = hasEllipsis = true;\n            }\n            // hover 进入事件\n            if (showTitle || showTooltip || showAllTip || tooltipConfig) {\n                tdOns.onMouseenter = function (evnt) {\n                    if (isVMScrollProcess()) {\n                        return;\n                    }\n                    if (showTitle) {\n                        updateCellTitle(evnt.currentTarget, column);\n                    }\n                    else if (showTooltip || showAllTip) {\n                        // 如果配置了显示 tooltip\n                        $xetable.triggerBodyTooltipEvent(evnt, params);\n                    }\n                    $xetable.dispatchEvent('cell-mouseenter', Object.assign({ cell: evnt.currentTarget }, params), evnt);\n                };\n            }\n            // hover 退出事件\n            if (showTooltip || showAllTip || tooltipConfig) {\n                tdOns.onMouseleave = function (evnt) {\n                    if (isVMScrollProcess()) {\n                        return;\n                    }\n                    if (showTooltip || showAllTip) {\n                        $xetable.handleTargetLeaveEvent(evnt);\n                    }\n                    $xetable.dispatchEvent('cell-mouseleave', Object.assign({ cell: evnt.currentTarget }, params), evnt);\n                };\n            }\n            // 按下事件处理\n            if (checkboxOpts.range || mouseConfig) {\n                tdOns.onMousedown = function (evnt) {\n                    $xetable.triggerCellMousedownEvent(evnt, params);\n                };\n            }\n            // 点击事件处理\n            tdOns.onClick = function (evnt) {\n                $xetable.triggerCellClickEvent(evnt, params);\n            };\n            // 双击事件处理\n            tdOns.onDblclick = function (evnt) {\n                $xetable.triggerCellDblclickEvent(evnt, params);\n            };\n            // 合并行或列\n            if (mergeList.length) {\n                var spanRest = mergeBodyMethod(mergeList, _rowIndex, _columnIndex);\n                if (spanRest) {\n                    var rowspan = spanRest.rowspan, colspan = spanRest.colspan;\n                    if (!rowspan || !colspan) {\n                        return null;\n                    }\n                    if (rowspan > 1) {\n                        attrs.rowspan = rowspan;\n                    }\n                    if (colspan > 1) {\n                        attrs.colspan = colspan;\n                    }\n                }\n            }\n            else if (spanMethod) {\n                // 自定义合并行或列的方法\n                var _b = spanMethod(params) || {}, _c = _b.rowspan, rowspan = _c === void 0 ? 1 : _c, _d = _b.colspan, colspan = _d === void 0 ? 1 : _d;\n                if (!rowspan || !colspan) {\n                    return null;\n                }\n                if (rowspan > 1) {\n                    attrs.rowspan = rowspan;\n                }\n                if (colspan > 1) {\n                    attrs.colspan = colspan;\n                }\n            }\n            // 如果被合并不可隐藏\n            if (fixedHiddenColumn && mergeList) {\n                if (attrs.colspan > 1 || attrs.rowspan > 1) {\n                    fixedHiddenColumn = false;\n                }\n            }\n            // 如果编辑列开启显示状态\n            if (!fixedHiddenColumn && editConfig && (editRender || cellRender) && (editOpts.showStatus || editOpts.showUpdateStatus)) {\n                isDirty = $xetable.isUpdateByRow(row, column.field);\n            }\n            var tdVNs = [];\n            if (fixedHiddenColumn && (allColumnOverflow ? isAllOverflow : allColumnOverflow)) {\n                tdVNs.push(h('div', {\n                    class: ['vxe-cell', {\n                            'c--title': showTitle,\n                            'c--tooltip': showTooltip,\n                            'c--ellipsis': showEllipsis\n                        }],\n                    style: {\n                        maxHeight: hasEllipsis && (scrollYRHeight || rowHeight) ? \"\".concat(scrollYRHeight || rowHeight, \"px\") : ''\n                    }\n                }));\n            }\n            else {\n                // 渲染单元格\n                tdVNs.push.apply(tdVNs, __spreadArray(__spreadArray([], renderLine(params), false), [h('div', {\n                        class: ['vxe-cell', {\n                                'c--title': showTitle,\n                                'c--tooltip': showTooltip,\n                                'c--ellipsis': showEllipsis\n                            }],\n                        style: {\n                            maxHeight: hasEllipsis && (scrollYRHeight || rowHeight) ? \"\".concat(scrollYRHeight || rowHeight, \"px\") : ''\n                        },\n                        title: showTitle ? $xetable.getCellLabel(row, column) : null\n                    }, column.renderCell(params))], false));\n                if (showValidTip && errorValidItem) {\n                    var errRule = errorValidItem.rule;\n                    var validSlot = slots ? slots.valid : null;\n                    var validParams = __assign(__assign({}, params), errorValidItem);\n                    tdVNs.push(h('div', {\n                        class: ['vxe-cell--valid-error-hint', getPropClass(validOpts.className, validParams)],\n                        style: errRule && errRule.maxWidth ? {\n                            width: \"\".concat(errRule.maxWidth, \"px\")\n                        } : null\n                    }, validSlot ? $xetable.callSlot(validSlot, validParams) : [\n                        h('span', {\n                            class: 'vxe-cell--valid-error-msg'\n                        }, errorValidItem.content)\n                    ]));\n                }\n            }\n            return h('td', __assign(__assign(__assign({ class: [\n                    'vxe-body--column',\n                    column.id,\n                    (_a = {},\n                        _a[\"col--\".concat(cellAlign)] = cellAlign,\n                        _a[\"col--\".concat(type)] = type,\n                        _a['col--last'] = $columnIndex === columns.length - 1,\n                        _a['col--tree-node'] = treeNode,\n                        _a['col--edit'] = isEdit,\n                        _a['col--ellipsis'] = hasEllipsis,\n                        _a['fixed--hidden'] = fixedHiddenColumn,\n                        _a['col--dirty'] = isDirty,\n                        _a['col--active'] = editConfig && isEdit && (actived.row === row && (actived.column === column || editOpts.mode === 'row')),\n                        _a['col--valid-error'] = !!errorValidItem,\n                        _a['col--current'] = currentColumn === column,\n                        _a),\n                    getPropClass(compCellClassName, params),\n                    getPropClass(className, params),\n                    getPropClass(allCellClassName, params)\n                ], key: columnKey || columnOpts.useKey ? column.id : $columnIndex }, attrs), { style: Object.assign({\n                    height: hasEllipsis && (scrollYRHeight || rowHeight) ? \"\".concat(scrollYRHeight || rowHeight, \"px\") : ''\n                }, XEUtils.isFunction(compCellStyle) ? compCellStyle(params) : compCellStyle, XEUtils.isFunction(cellStyle) ? cellStyle(params) : cellStyle) }), tdOns), tdVNs);\n        };\n        var renderRows = function (fixedType, tableData, tableColumn) {\n            var stripe = tableProps.stripe, rowKey = tableProps.rowKey, highlightHoverRow = tableProps.highlightHoverRow, rowClassName = tableProps.rowClassName, rowStyle = tableProps.rowStyle, allColumnOverflow = tableProps.showOverflow, editConfig = tableProps.editConfig, treeConfig = tableProps.treeConfig;\n            var hasFixedColumn = tableReactData.hasFixedColumn, treeExpandedMaps = tableReactData.treeExpandedMaps, scrollYLoad = tableReactData.scrollYLoad, rowExpandedMaps = tableReactData.rowExpandedMaps, expandColumn = tableReactData.expandColumn, selectRadioRow = tableReactData.selectRadioRow, pendingRowMaps = tableReactData.pendingRowMaps, pendingRowList = tableReactData.pendingRowList;\n            var fullAllDataRowIdData = tableInternalData.fullAllDataRowIdData;\n            var checkboxOpts = computeCheckboxOpts.value;\n            var radioOpts = computeRadioOpts.value;\n            var treeOpts = computeTreeOpts.value;\n            var editOpts = computeEditOpts.value;\n            var rowOpts = computeRowOpts.value;\n            var transform = treeOpts.transform;\n            var childrenField = treeOpts.children || treeOpts.childrenField;\n            var rows = [];\n            tableData.forEach(function (row, $rowIndex) {\n                var trOn = {};\n                var rowIndex = $rowIndex;\n                // 确保任何情况下 rowIndex 都精准指向真实 data 索引\n                rowIndex = $xetable.getRowIndex(row);\n                // 事件绑定\n                if (rowOpts.isHover || highlightHoverRow) {\n                    trOn.onMouseenter = function (evnt) {\n                        if (isVMScrollProcess()) {\n                            return;\n                        }\n                        $xetable.triggerHoverEvent(evnt, { row: row, rowIndex: rowIndex });\n                    };\n                    trOn.onMouseleave = function () {\n                        if (isVMScrollProcess()) {\n                            return;\n                        }\n                        $xetable.clearHoverRow();\n                    };\n                }\n                var rowid = getRowid($xetable, row);\n                var rest = fullAllDataRowIdData[rowid];\n                var rowLevel = 0;\n                var seq = -1;\n                var _rowIndex = 0;\n                if (rest) {\n                    rowLevel = rest.level;\n                    seq = rest.seq;\n                    _rowIndex = rest._index;\n                }\n                var params = { $table: $xetable, seq: seq, rowid: rowid, fixed: fixedType, type: renderType, level: rowLevel, row: row, rowIndex: rowIndex, $rowIndex: $rowIndex, _rowIndex: _rowIndex };\n                // 行是否被展开\n                var isExpandRow = expandColumn && !!rowExpandedMaps[rowid];\n                // 树节点是否被展开\n                var isExpandTree = false;\n                var rowChildren = [];\n                // 处理新增状态\n                var isNewRow = false;\n                if (editConfig) {\n                    isNewRow = $xetable.isInsertByRow(row);\n                }\n                if (treeConfig && !scrollYLoad && !transform) {\n                    rowChildren = row[childrenField];\n                    isExpandTree = rowChildren && rowChildren.length && !!treeExpandedMaps[rowid];\n                }\n                rows.push(h('tr', __assign({ class: [\n                        'vxe-body--row',\n                        treeConfig ? \"row--level-\".concat(rowLevel) : '',\n                        {\n                            'row--stripe': stripe && ($xetable.getVTRowIndex(row) + 1) % 2 === 0,\n                            'is--new': isNewRow,\n                            'is--expand-row': isExpandRow,\n                            'is--expand-tree': isExpandTree,\n                            'row--new': isNewRow && (editOpts.showStatus || editOpts.showInsertStatus),\n                            'row--radio': radioOpts.highlight && $xetable.eqRow(selectRadioRow, row),\n                            'row--checked': checkboxOpts.highlight && $xetable.isCheckedByCheckboxRow(row),\n                            'row--pending': pendingRowList.length && !!pendingRowMaps[rowid]\n                        },\n                        getPropClass(rowClassName, params)\n                    ], rowid: rowid, style: rowStyle ? (XEUtils.isFunction(rowStyle) ? rowStyle(params) : rowStyle) : null, key: (rowKey || rowOpts.useKey) || treeConfig ? rowid : $rowIndex }, trOn), tableColumn.map(function (column, $columnIndex) {\n                    return renderColumn(seq, rowid, fixedType, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, tableColumn, tableData);\n                })));\n                // 如果行被展开了\n                if (isExpandRow) {\n                    var expandOpts = computeExpandOpts.value;\n                    var expandHeight = expandOpts.height;\n                    var cellStyle = {};\n                    if (expandHeight) {\n                        cellStyle.height = \"\".concat(expandHeight, \"px\");\n                    }\n                    if (treeConfig) {\n                        cellStyle.paddingLeft = \"\".concat((rowLevel * treeOpts.indent) + 30, \"px\");\n                    }\n                    var showOverflow = expandColumn.showOverflow;\n                    var hasEllipsis = (XEUtils.isUndefined(showOverflow) || XEUtils.isNull(showOverflow)) ? allColumnOverflow : showOverflow;\n                    var expandParams = { $table: $xetable, seq: seq, column: expandColumn, fixed: fixedType, type: renderType, level: rowLevel, row: row, rowIndex: rowIndex, $rowIndex: $rowIndex, _rowIndex: _rowIndex };\n                    rows.push(h('tr', __assign({ class: 'vxe-body--expanded-row', key: \"expand_\".concat(rowid), style: rowStyle ? (XEUtils.isFunction(rowStyle) ? rowStyle(expandParams) : rowStyle) : null }, trOn), [\n                        h('td', {\n                            class: {\n                                'vxe-body--expanded-column': 1,\n                                'fixed--hidden': fixedType && !hasFixedColumn,\n                                'col--ellipsis': hasEllipsis\n                            },\n                            colspan: tableColumn.length\n                        }, [\n                            h('div', {\n                                class: {\n                                    'vxe-body--expanded-cell': 1,\n                                    'is--ellipsis': expandHeight\n                                },\n                                style: cellStyle\n                            }, [\n                                expandColumn.renderData(expandParams)\n                            ])\n                        ])\n                    ]));\n                }\n                // 如果是树形表格\n                if (isExpandTree) {\n                    rows.push.apply(rows, renderRows(fixedType, rowChildren, tableColumn));\n                }\n            });\n            return rows;\n        };\n        /**\n         * 同步滚动条\n         */\n        var scrollProcessTimeout;\n        var syncBodyScroll = function (fixedType, scrollTop, elem1, elem2) {\n            if (elem1 || elem2) {\n                if (elem1) {\n                    removeScrollListener(elem1);\n                    elem1.scrollTop = scrollTop;\n                }\n                if (elem2) {\n                    removeScrollListener(elem2);\n                    elem2.scrollTop = scrollTop;\n                }\n                clearTimeout(scrollProcessTimeout);\n                scrollProcessTimeout = setTimeout(function () {\n                    // const tableBody = refTableBody.value\n                    // const leftBody = refTableLeftBody.value\n                    // const rightBody = refTableRightBody.value\n                    // const bodyElem = tableBody.$el as XEBodyScrollElement\n                    // const leftElem = leftBody ? leftBody.$el as XEBodyScrollElement : null\n                    // const rightElem = rightBody ? rightBody.$el as XEBodyScrollElement : null\n                    restoreScrollListener(elem1);\n                    restoreScrollListener(elem2);\n                    // 检查滚动条是的同步\n                    // let targetTop = bodyElem.scrollTop\n                    // if (fixedType === 'left') {\n                    //   if (leftElem) {\n                    //     targetTop = leftElem.scrollTop\n                    //   }\n                    // } else if (fixedType === 'right') {\n                    //   if (rightElem) {\n                    //     targetTop = rightElem.scrollTop\n                    //   }\n                    // }\n                    // setScrollTop(bodyElem, targetTop)\n                    // setScrollTop(leftElem, targetTop)\n                    // setScrollTop(rightElem, targetTop)\n                    tableReactData.lastScrollTime = Date.now();\n                }, 300);\n            }\n        };\n        var scrollLoadingTime = null;\n        /**\n         * 滚动处理\n         * 如果存在列固定左侧，同步更新滚动状态\n         * 如果存在列固定右侧，同步更新滚动状态\n         */\n        var scrollEvent = function (evnt) {\n            var fixedType = props.fixedType;\n            var highlightHoverRow = tableProps.highlightHoverRow;\n            var scrollXLoad = tableReactData.scrollXLoad, scrollYLoad = tableReactData.scrollYLoad;\n            var elemStore = tableInternalData.elemStore, lastScrollTop = tableInternalData.lastScrollTop, lastScrollLeft = tableInternalData.lastScrollLeft;\n            var rowOpts = computeRowOpts.value;\n            var tableHeader = refTableHeader.value;\n            var tableBody = refTableBody.value;\n            var tableFooter = refTableFooter.value;\n            var leftBody = refTableLeftBody.value;\n            var rightBody = refTableRightBody.value;\n            var validTip = refValidTooltip.value;\n            var scrollBodyElem = refElem.value;\n            var headerElem = tableHeader ? tableHeader.$el : null;\n            var footerElem = tableFooter ? tableFooter.$el : null;\n            var bodyElem = tableBody.$el;\n            var leftElem = leftBody ? leftBody.$el : null;\n            var rightElem = rightBody ? rightBody.$el : null;\n            var bodyYRef = elemStore['main-body-ySpace'];\n            var bodyYElem = bodyYRef ? bodyYRef.value : null;\n            var bodyXRef = elemStore['main-body-xSpace'];\n            var bodyXElem = bodyXRef ? bodyXRef.value : null;\n            var bodyHeight = scrollYLoad && bodyYElem ? bodyYElem.clientHeight : bodyElem.clientHeight;\n            var bodyWidth = scrollXLoad && bodyXElem ? bodyXElem.clientWidth : bodyElem.clientWidth;\n            var scrollTop = scrollBodyElem.scrollTop;\n            var scrollLeft = bodyElem.scrollLeft;\n            var isRollX = scrollLeft !== lastScrollLeft;\n            var isRollY = scrollTop !== lastScrollTop;\n            tableInternalData.lastScrollTop = scrollTop;\n            tableInternalData.lastScrollLeft = scrollLeft;\n            tableReactData.lastScrollTime = Date.now();\n            if (rowOpts.isHover || highlightHoverRow) {\n                $xetable.clearHoverRow();\n            }\n            if (leftElem && fixedType === 'left') {\n                scrollTop = leftElem.scrollTop;\n                syncBodyScroll(fixedType, scrollTop, bodyElem, rightElem);\n            }\n            else if (rightElem && fixedType === 'right') {\n                scrollTop = rightElem.scrollTop;\n                syncBodyScroll(fixedType, scrollTop, bodyElem, leftElem);\n            }\n            else {\n                if (isRollX) {\n                    if (headerElem) {\n                        headerElem.scrollLeft = bodyElem.scrollLeft;\n                    }\n                    if (footerElem) {\n                        footerElem.scrollLeft = bodyElem.scrollLeft;\n                    }\n                }\n                if (leftElem || rightElem) {\n                    $xetable.checkScrolling();\n                    if (isRollY) {\n                        syncBodyScroll(fixedType, scrollTop, leftElem, rightElem);\n                    }\n                }\n            }\n            // let isLoadScroll = false\n            if (scrollXLoad && isRollX) {\n                // isLoadScroll = true\n                $xetable.triggerScrollXEvent(evnt);\n            }\n            if (scrollYLoad && isRollY) {\n                // isLoadScroll = true\n                $xetable.triggerScrollYEvent(evnt);\n            }\n            if (scrollLoadingTime !== null) {\n                clearTimeout(scrollLoadingTime);\n            }\n            // if (isLoadScroll) {\n            //   tableReactData.scrollVMLoading = true\n            //   scrollLoadingTime = setTimeout(() => {\n            //     scrollLoadingTime = null\n            //     tableReactData.scrollVMLoading = false\n            //   }, 20)\n            // } else {\n            //   tableReactData.scrollVMLoading = false\n            // }\n            if (isRollX && validTip && validTip.reactData.visible) {\n                validTip.updatePlacement();\n            }\n            $xetable.dispatchEvent('scroll', {\n                type: renderType,\n                fixed: fixedType,\n                scrollTop: scrollTop,\n                scrollLeft: scrollLeft,\n                scrollHeight: bodyElem.scrollHeight,\n                scrollWidth: bodyElem.scrollWidth,\n                bodyHeight: bodyHeight,\n                bodyWidth: bodyWidth,\n                isX: isRollX,\n                isY: isRollY\n            }, evnt);\n        };\n        var wheelTime;\n        var wheelYSize = 0;\n        var wheelYInterval = 0;\n        var wheelYTotal = 0;\n        var isPrevWheelTop = false;\n        var handleWheel = function (evnt, isTopWheel, deltaTop, isRollX, isRollY) {\n            var elemStore = tableInternalData.elemStore;\n            var scrollXLoad = tableReactData.scrollXLoad, scrollYLoad = tableReactData.scrollYLoad;\n            var tableBody = refTableBody.value;\n            var leftBody = refTableLeftBody.value;\n            var rightBody = refTableRightBody.value;\n            var leftElem = leftBody ? leftBody.$el : null;\n            var rightElem = rightBody ? rightBody.$el : null;\n            var bodyElem = tableBody.$el;\n            var bodyYRef = elemStore['main-body-ySpace'];\n            var bodyYElem = bodyYRef ? bodyYRef.value : null;\n            var bodyXRef = elemStore['main-body-xSpace'];\n            var bodyXElem = bodyXRef ? bodyXRef.value : null;\n            var bodyHeight = scrollYLoad && bodyYElem ? bodyYElem.clientHeight : bodyElem.clientHeight;\n            var bodyWidth = scrollXLoad && bodyXElem ? bodyXElem.clientWidth : bodyElem.clientWidth;\n            var remainSize = isPrevWheelTop === isTopWheel ? Math.max(0, wheelYSize - wheelYTotal) : 0;\n            isPrevWheelTop = isTopWheel;\n            wheelYSize = Math.abs(isTopWheel ? deltaTop - remainSize : deltaTop + remainSize);\n            wheelYInterval = 0;\n            wheelYTotal = 0;\n            clearTimeout(wheelTime);\n            var handleSmooth = function () {\n                if (wheelYTotal < wheelYSize) {\n                    var fixedType = props.fixedType;\n                    wheelYInterval = Math.max(5, Math.floor(wheelYInterval * 1.5));\n                    wheelYTotal = wheelYTotal + wheelYInterval;\n                    if (wheelYTotal > wheelYSize) {\n                        wheelYInterval = wheelYInterval - (wheelYTotal - wheelYSize);\n                    }\n                    var scrollTop = bodyElem.scrollTop, clientHeight = bodyElem.clientHeight, scrollHeight = bodyElem.scrollHeight;\n                    var targerTop = scrollTop + (wheelYInterval * (isTopWheel ? -1 : 1));\n                    bodyElem.scrollTop = targerTop;\n                    if (leftElem) {\n                        leftElem.scrollTop = targerTop;\n                    }\n                    if (rightElem) {\n                        rightElem.scrollTop = targerTop;\n                    }\n                    if (isTopWheel ? targerTop < scrollHeight - clientHeight : targerTop >= 0) {\n                        wheelTime = setTimeout(handleSmooth, 10);\n                    }\n                    $xetable.dispatchEvent('scroll', {\n                        type: renderType,\n                        fixed: fixedType,\n                        scrollTop: bodyElem.scrollTop,\n                        scrollLeft: bodyElem.scrollLeft,\n                        scrollHeight: bodyElem.scrollHeight,\n                        scrollWidth: bodyElem.scrollWidth,\n                        bodyHeight: bodyHeight,\n                        bodyWidth: bodyWidth,\n                        isX: isRollX,\n                        isY: isRollY\n                    }, evnt);\n                }\n            };\n            handleSmooth();\n        };\n        /**\n         * 滚轮处理\n         */\n        var wheelEvent = function (evnt) {\n            var deltaY = evnt.deltaY, deltaX = evnt.deltaX;\n            var highlightHoverRow = tableProps.highlightHoverRow;\n            var scrollYLoad = tableReactData.scrollYLoad;\n            var lastScrollTop = tableInternalData.lastScrollTop, lastScrollLeft = tableInternalData.lastScrollLeft;\n            var rowOpts = computeRowOpts.value;\n            var tableBody = refTableBody.value;\n            var scrollBodyElem = refElem.value;\n            var bodyElem = tableBody.$el;\n            var deltaTop = deltaY;\n            var deltaLeft = deltaX;\n            var isTopWheel = deltaTop < 0;\n            // 如果滚动位置已经是顶部或底部，则不需要触发\n            if (isTopWheel ? scrollBodyElem.scrollTop <= 0 : scrollBodyElem.scrollTop >= scrollBodyElem.scrollHeight - scrollBodyElem.clientHeight) {\n                return;\n            }\n            var scrollTop = scrollBodyElem.scrollTop + deltaTop;\n            var scrollLeft = bodyElem.scrollLeft + deltaLeft;\n            var isRollX = scrollLeft !== lastScrollLeft;\n            var isRollY = scrollTop !== lastScrollTop;\n            // 用于鼠标纵向滚轮处理\n            if (isRollY) {\n                evnt.preventDefault();\n                tableInternalData.lastScrollTop = scrollTop;\n                tableInternalData.lastScrollLeft = scrollLeft;\n                tableReactData.lastScrollTime = Date.now();\n                if (rowOpts.isHover || highlightHoverRow) {\n                    $xetable.clearHoverRow();\n                }\n                handleWheel(evnt, isTopWheel, deltaTop, isRollX, isRollY);\n                if (scrollYLoad) {\n                    $xetable.triggerScrollYEvent(evnt);\n                }\n            }\n        };\n        onMounted(function () {\n            nextTick(function () {\n                var fixedType = props.fixedType;\n                var elemStore = tableInternalData.elemStore;\n                var prefix = \"\".concat(fixedType || 'main', \"-body-\");\n                var el = refElem.value;\n                elemStore[\"\".concat(prefix, \"wrapper\")] = refElem;\n                elemStore[\"\".concat(prefix, \"table\")] = refBodyTable;\n                elemStore[\"\".concat(prefix, \"colgroup\")] = refBodyColgroup;\n                elemStore[\"\".concat(prefix, \"list\")] = refBodyTBody;\n                elemStore[\"\".concat(prefix, \"xSpace\")] = refBodyXSpace;\n                elemStore[\"\".concat(prefix, \"ySpace\")] = refBodyYSpace;\n                elemStore[\"\".concat(prefix, \"emptyBlock\")] = refBodyEmptyBlock;\n                if (el) {\n                    el.onscroll = scrollEvent;\n                    el._onscroll = scrollEvent;\n                }\n            });\n        });\n        onBeforeUnmount(function () {\n            var el = refElem.value;\n            clearTimeout(wheelTime);\n            if (el) {\n                el._onscroll = null;\n                el.onscroll = null;\n            }\n        });\n        onUnmounted(function () {\n            var fixedType = props.fixedType;\n            var elemStore = tableInternalData.elemStore;\n            var prefix = \"\".concat(fixedType || 'main', \"-body-\");\n            elemStore[\"\".concat(prefix, \"wrapper\")] = null;\n            elemStore[\"\".concat(prefix, \"table\")] = null;\n            elemStore[\"\".concat(prefix, \"colgroup\")] = null;\n            elemStore[\"\".concat(prefix, \"list\")] = null;\n            elemStore[\"\".concat(prefix, \"xSpace\")] = null;\n            elemStore[\"\".concat(prefix, \"ySpace\")] = null;\n            elemStore[\"\".concat(prefix, \"emptyBlock\")] = null;\n        });\n        var renderVN = function () {\n            var fixedColumn = props.fixedColumn, fixedType = props.fixedType, tableColumn = props.tableColumn;\n            var keyboardConfig = tableProps.keyboardConfig, allColumnOverflow = tableProps.showOverflow, spanMethod = tableProps.spanMethod, mouseConfig = tableProps.mouseConfig;\n            var tableData = tableReactData.tableData, mergeList = tableReactData.mergeList, scrollYLoad = tableReactData.scrollYLoad, isAllOverflow = tableReactData.isAllOverflow;\n            var visibleColumn = tableInternalData.visibleColumn;\n            var slots = tableContext.slots;\n            var sYOpts = computeSYOpts.value;\n            var emptyOpts = computeEmptyOpts.value;\n            var keyboardOpts = computeKeyboardOpts.value;\n            var mouseOpts = computeMouseOpts.value;\n            // const isMergeLeftFixedExceeded = computeIsMergeLeftFixedExceeded.value\n            // const isMergeRightFixedExceeded = computeIsMergeRightFixedExceeded.value\n            // 如果是使用优化模式\n            if (fixedType) {\n                // 如果存在展开行使用全量渲染\n                if (!tableReactData.expandColumn && (scrollYLoad || (allColumnOverflow ? isAllOverflow : allColumnOverflow))) {\n                    if (!mergeList.length && !spanMethod && !(keyboardConfig && keyboardOpts.isMerge)) {\n                        tableColumn = fixedColumn;\n                    }\n                    else {\n                        tableColumn = visibleColumn;\n                        // 检查固定列是否被合并，合并范围是否超出固定列\n                        // if (mergeList.length && !isMergeLeftFixedExceeded && fixedType === 'left') {\n                        //   tableColumn = fixedColumn\n                        // } else if (mergeList.length && !isMergeRightFixedExceeded && fixedType === 'right') {\n                        //   tableColumn = fixedColumn\n                        // } else {\n                        //   tableColumn = visibleColumn\n                        // }\n                    }\n                }\n                else {\n                    tableColumn = visibleColumn;\n                }\n            }\n            var emptyContent;\n            var emptySlot = slots ? slots.empty : null;\n            if (emptySlot) {\n                emptyContent = $xetable.callSlot(emptySlot, { $table: $xetable, $grid: $xetable.xegrid });\n            }\n            else {\n                var compConf = emptyOpts.name ? VXETable.renderer.get(emptyOpts.name) : null;\n                var renderEmpty = compConf ? compConf.renderEmpty : null;\n                if (renderEmpty) {\n                    emptyContent = getSlotVNs(renderEmpty(emptyOpts, { $table: $xetable }));\n                }\n                else {\n                    emptyContent = tableProps.emptyText || GlobalConfig.i18n('vxe.table.emptyText');\n                }\n            }\n            return h('div', __assign({ ref: refElem, class: ['vxe-table--body-wrapper', fixedType ? \"fixed-\".concat(fixedType, \"--wrapper\") : 'body--wrapper'], xid: xID }, (sYOpts.mode === 'wheel' ? { onWheel: wheelEvent } : {})), [\n                fixedType ? createCommentVNode() : h('div', {\n                    ref: refBodyXSpace,\n                    class: 'vxe-body--x-space'\n                }),\n                h('div', {\n                    ref: refBodyYSpace,\n                    class: 'vxe-body--y-space'\n                }),\n                h('table', {\n                    ref: refBodyTable,\n                    class: 'vxe-table--body',\n                    xid: xID,\n                    cellspacing: 0,\n                    cellpadding: 0,\n                    border: 0\n                }, [\n                    /**\n                     * 列宽\n                     */\n                    h('colgroup', {\n                        ref: refBodyColgroup\n                    }, tableColumn.map(function (column, $columnIndex) {\n                        return h('col', {\n                            name: column.id,\n                            key: $columnIndex\n                        });\n                    })),\n                    /**\n                     * 内容\n                     */\n                    h('tbody', {\n                        ref: refBodyTBody\n                    }, renderRows(fixedType, tableData, tableColumn))\n                ]),\n                h('div', {\n                    class: 'vxe-table--checkbox-range'\n                }),\n                mouseConfig && mouseOpts.area ? h('div', {\n                    class: 'vxe-table--cell-area'\n                }, [\n                    h('span', {\n                        class: 'vxe-table--cell-main-area'\n                    }, mouseOpts.extension ? [\n                        h('span', {\n                            class: 'vxe-table--cell-main-area-btn',\n                            onMousedown: function (evnt) {\n                                $xetable.triggerCellExtendMousedownEvent(evnt, { $table: $xetable, fixed: fixedType, type: renderType });\n                            }\n                        })\n                    ] : []),\n                    h('span', {\n                        class: 'vxe-table--cell-copy-area'\n                    }),\n                    h('span', {\n                        class: 'vxe-table--cell-extend-area'\n                    }),\n                    h('span', {\n                        class: 'vxe-table--cell-multi-area'\n                    }),\n                    h('span', {\n                        class: 'vxe-table--cell-active-area'\n                    })\n                ]) : null,\n                !fixedType ? h('div', {\n                    class: 'vxe-table--empty-block',\n                    ref: refBodyEmptyBlock\n                }, [\n                    h('div', {\n                        class: 'vxe-table--empty-content'\n                    }, emptyContent)\n                ]) : null\n            ]);\n        };\n        return renderVN;\n    }\n});\n",
      "start": 1714699769240,
      "end": 1714699769331,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1714699769331,
      "end": 1714699769331,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1714699769331,
      "end": 1714699769331,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1714699769331,
      "end": 1714699769331,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1714699769331,
      "end": 1714699769331,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1714699769331,
      "end": 1714699769331,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1714699769331,
      "end": 1714699769331,
      "order": "normal"
    },
    {
      "name": "vite-plugin-vconsole",
      "result": "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { createCommentVNode, defineComponent, h, ref, inject, nextTick, onBeforeUnmount, onMounted, onUnmounted } from 'vue';\nimport XEUtils from 'xe-utils';\nimport GlobalConfig from '../../v-x-e-table/src/conf';\nimport { VXETable } from '../../v-x-e-table';\nimport { mergeBodyMethod, getRowid, removeScrollListener, restoreScrollListener } from './util';\nimport { updateCellTitle, getPropClass } from '../../tools/dom';\nimport { isEnableConf } from '../../tools/utils';\nimport { getSlotVNs } from '../../tools/vn';\nvar renderType = 'body';\nvar lineOffsetSizes = {\n    mini: 3,\n    small: 2,\n    medium: 1\n};\nexport default defineComponent({\n    name: 'VxeTableBody',\n    props: {\n        tableData: Array,\n        tableColumn: Array,\n        fixedColumn: Array,\n        fixedType: { type: String, default: null }\n    },\n    setup: function (props) {\n        var $xetable = inject('$xetable', {});\n        var xesize = inject('xesize', null);\n        var xID = $xetable.xID, tableProps = $xetable.props, tableContext = $xetable.context, tableReactData = $xetable.reactData, tableInternalData = $xetable.internalData;\n        var _a = $xetable.getRefMaps(), refTableHeader = _a.refTableHeader, refTableBody = _a.refTableBody, refTableFooter = _a.refTableFooter, refTableLeftBody = _a.refTableLeftBody, refTableRightBody = _a.refTableRightBody, refValidTooltip = _a.refValidTooltip;\n        var _b = $xetable.getComputeMaps(), computeEditOpts = _b.computeEditOpts, computeMouseOpts = _b.computeMouseOpts, computeSYOpts = _b.computeSYOpts, computeEmptyOpts = _b.computeEmptyOpts, computeKeyboardOpts = _b.computeKeyboardOpts, computeTooltipOpts = _b.computeTooltipOpts, computeRadioOpts = _b.computeRadioOpts, computeExpandOpts = _b.computeExpandOpts, computeTreeOpts = _b.computeTreeOpts, computeCheckboxOpts = _b.computeCheckboxOpts, computeValidOpts = _b.computeValidOpts, computeRowOpts = _b.computeRowOpts, computeColumnOpts = _b.computeColumnOpts;\n        var refElem = ref();\n        var refBodyTable = ref();\n        var refBodyColgroup = ref();\n        var refBodyTBody = ref();\n        var refBodyXSpace = ref();\n        var refBodyYSpace = ref();\n        var refBodyEmptyBlock = ref();\n        var getOffsetSize = function () {\n            if (xesize) {\n                var vSize = xesize.value;\n                if (vSize) {\n                    return lineOffsetSizes[vSize] || 0;\n                }\n            }\n            return 0;\n        };\n        // 滚动、拖动过程中不需要触发\n        var isVMScrollProcess = function () {\n            var delayHover = tableProps.delayHover;\n            var lastScrollTime = tableReactData.lastScrollTime, _isResize = tableReactData._isResize;\n            return !!(_isResize || (lastScrollTime && Date.now() < lastScrollTime + delayHover));\n        };\n        var countTreeExpand = function (prevRow, params) {\n            var count = 1;\n            if (!prevRow) {\n                return count;\n            }\n            var treeOpts = computeTreeOpts.value;\n            var childrenField = treeOpts.children || treeOpts.childrenField;\n            var rowChildren = prevRow[childrenField];\n            if (rowChildren && $xetable.isTreeExpandByRow(prevRow)) {\n                for (var index = 0; index < rowChildren.length; index++) {\n                    count += countTreeExpand(rowChildren[index], params);\n                }\n            }\n            return count;\n        };\n        var calcTreeLine = function (params, items, rIndex) {\n            var expandSize = 1;\n            if (rIndex) {\n                expandSize = countTreeExpand(items[rIndex - 1], params);\n            }\n            return tableReactData.rowHeight * expandSize - (rIndex ? 1 : (12 - getOffsetSize()));\n        };\n        var renderLine = function (params) {\n            var row = params.row, column = params.column;\n            var treeConfig = tableProps.treeConfig;\n            var treeOpts = computeTreeOpts.value;\n            var slots = column.slots, treeNode = column.treeNode;\n            var fullAllDataRowIdData = tableInternalData.fullAllDataRowIdData;\n            var rowid = getRowid($xetable, row);\n            var rest = fullAllDataRowIdData[rowid];\n            var rLevel = 0;\n            var rIndex = 0;\n            var items = [];\n            if (rest) {\n                rLevel = rest.level;\n                rIndex = rest._index;\n                items = rest.items;\n            }\n            if (slots && slots.line) {\n                return $xetable.callSlot(slots.line, params);\n            }\n            if (treeConfig && treeNode && (treeOpts.showLine || treeOpts.line)) {\n                return [\n                    h('div', {\n                        class: 'vxe-tree--line-wrapper'\n                    }, [\n                        h('div', {\n                            class: 'vxe-tree--line',\n                            style: {\n                                height: \"\".concat(calcTreeLine(params, items, rIndex), \"px\"),\n                                left: \"\".concat((rLevel * treeOpts.indent) + (rLevel ? 2 - getOffsetSize() : 0) + 16, \"px\")\n                            }\n                        })\n                    ])\n                ];\n            }\n            return [];\n        };\n        /**\n         * 渲染列\n         */\n        var renderColumn = function (seq, rowid, fixedType, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, columns, items) {\n            var _a;\n            var columnKey = tableProps.columnKey, height = tableProps.height, allColumnOverflow = tableProps.showOverflow, allCellClassName = tableProps.cellClassName, cellStyle = tableProps.cellStyle, allAlign = tableProps.align, spanMethod = tableProps.spanMethod, mouseConfig = tableProps.mouseConfig, editConfig = tableProps.editConfig, editRules = tableProps.editRules, tooltipConfig = tableProps.tooltipConfig;\n            var tableData = tableReactData.tableData, overflowX = tableReactData.overflowX, scrollYLoad = tableReactData.scrollYLoad, currentColumn = tableReactData.currentColumn, mergeList = tableReactData.mergeList, editStore = tableReactData.editStore, isAllOverflow = tableReactData.isAllOverflow, validErrorMaps = tableReactData.validErrorMaps;\n            var afterFullData = tableInternalData.afterFullData;\n            var validOpts = computeValidOpts.value;\n            var checkboxOpts = computeCheckboxOpts.value;\n            var editOpts = computeEditOpts.value;\n            var tooltipOpts = computeTooltipOpts.value;\n            var rowOpts = computeRowOpts.value;\n            var sYOpts = computeSYOpts.value;\n            var columnOpts = computeColumnOpts.value;\n            var type = column.type, cellRender = column.cellRender, editRender = column.editRender, align = column.align, showOverflow = column.showOverflow, className = column.className, treeNode = column.treeNode, slots = column.slots;\n            var actived = editStore.actived;\n            var scrollYRHeight = sYOpts.rHeight;\n            var rowHeight = rowOpts.height;\n            var renderOpts = editRender || cellRender;\n            var compConf = renderOpts ? VXETable.renderer.get(renderOpts.name) : null;\n            var compCellClassName = compConf ? compConf.cellClassName : '';\n            var compCellStyle = compConf ? compConf.cellStyle : '';\n            var showAllTip = tooltipOpts.showAll;\n            var columnIndex = $xetable.getColumnIndex(column);\n            var _columnIndex = $xetable.getVTColumnIndex(column);\n            var isEdit = isEnableConf(editRender);\n            var fixedHiddenColumn = fixedType ? column.fixed !== fixedType : column.fixed && overflowX;\n            var cellOverflow = (XEUtils.isUndefined(showOverflow) || XEUtils.isNull(showOverflow)) ? allColumnOverflow : showOverflow;\n            var showEllipsis = cellOverflow === 'ellipsis';\n            var showTitle = cellOverflow === 'title';\n            var showTooltip = cellOverflow === true || cellOverflow === 'tooltip';\n            var hasEllipsis = showTitle || showTooltip || showEllipsis;\n            var isDirty;\n            var tdOns = {};\n            var cellAlign = align || allAlign;\n            var errorValidItem = validErrorMaps[\"\".concat(rowid, \":\").concat(column.id)];\n            var showValidTip = editRules && validOpts.showMessage && (validOpts.message === 'default' ? (height || tableData.length > 1) : validOpts.message === 'inline');\n            var attrs = { colid: column.id };\n            var params = { $table: $xetable, $grid: $xetable.xegrid, seq: seq, rowid: rowid, row: row, rowIndex: rowIndex, $rowIndex: $rowIndex, _rowIndex: _rowIndex, column: column, columnIndex: columnIndex, $columnIndex: $columnIndex, _columnIndex: _columnIndex, fixed: fixedType, type: renderType, isHidden: fixedHiddenColumn, level: rowLevel, visibleData: afterFullData, data: tableData, items: items };\n            // 虚拟滚动不支持动态高度\n            if (scrollYLoad && !hasEllipsis) {\n                showEllipsis = hasEllipsis = true;\n            }\n            // hover 进入事件\n            if (showTitle || showTooltip || showAllTip || tooltipConfig) {\n                tdOns.onMouseenter = function (evnt) {\n                    if (isVMScrollProcess()) {\n                        return;\n                    }\n                    if (showTitle) {\n                        updateCellTitle(evnt.currentTarget, column);\n                    }\n                    else if (showTooltip || showAllTip) {\n                        // 如果配置了显示 tooltip\n                        $xetable.triggerBodyTooltipEvent(evnt, params);\n                    }\n                    $xetable.dispatchEvent('cell-mouseenter', Object.assign({ cell: evnt.currentTarget }, params), evnt);\n                };\n            }\n            // hover 退出事件\n            if (showTooltip || showAllTip || tooltipConfig) {\n                tdOns.onMouseleave = function (evnt) {\n                    if (isVMScrollProcess()) {\n                        return;\n                    }\n                    if (showTooltip || showAllTip) {\n                        $xetable.handleTargetLeaveEvent(evnt);\n                    }\n                    $xetable.dispatchEvent('cell-mouseleave', Object.assign({ cell: evnt.currentTarget }, params), evnt);\n                };\n            }\n            // 按下事件处理\n            if (checkboxOpts.range || mouseConfig) {\n                tdOns.onMousedown = function (evnt) {\n                    $xetable.triggerCellMousedownEvent(evnt, params);\n                };\n            }\n            // 点击事件处理\n            tdOns.onClick = function (evnt) {\n                $xetable.triggerCellClickEvent(evnt, params);\n            };\n            // 双击事件处理\n            tdOns.onDblclick = function (evnt) {\n                $xetable.triggerCellDblclickEvent(evnt, params);\n            };\n            // 合并行或列\n            if (mergeList.length) {\n                var spanRest = mergeBodyMethod(mergeList, _rowIndex, _columnIndex);\n                if (spanRest) {\n                    var rowspan = spanRest.rowspan, colspan = spanRest.colspan;\n                    if (!rowspan || !colspan) {\n                        return null;\n                    }\n                    if (rowspan > 1) {\n                        attrs.rowspan = rowspan;\n                    }\n                    if (colspan > 1) {\n                        attrs.colspan = colspan;\n                    }\n                }\n            }\n            else if (spanMethod) {\n                // 自定义合并行或列的方法\n                var _b = spanMethod(params) || {}, _c = _b.rowspan, rowspan = _c === void 0 ? 1 : _c, _d = _b.colspan, colspan = _d === void 0 ? 1 : _d;\n                if (!rowspan || !colspan) {\n                    return null;\n                }\n                if (rowspan > 1) {\n                    attrs.rowspan = rowspan;\n                }\n                if (colspan > 1) {\n                    attrs.colspan = colspan;\n                }\n            }\n            // 如果被合并不可隐藏\n            if (fixedHiddenColumn && mergeList) {\n                if (attrs.colspan > 1 || attrs.rowspan > 1) {\n                    fixedHiddenColumn = false;\n                }\n            }\n            // 如果编辑列开启显示状态\n            if (!fixedHiddenColumn && editConfig && (editRender || cellRender) && (editOpts.showStatus || editOpts.showUpdateStatus)) {\n                isDirty = $xetable.isUpdateByRow(row, column.field);\n            }\n            var tdVNs = [];\n            if (fixedHiddenColumn && (allColumnOverflow ? isAllOverflow : allColumnOverflow)) {\n                tdVNs.push(h('div', {\n                    class: ['vxe-cell', {\n                            'c--title': showTitle,\n                            'c--tooltip': showTooltip,\n                            'c--ellipsis': showEllipsis\n                        }],\n                    style: {\n                        maxHeight: hasEllipsis && (scrollYRHeight || rowHeight) ? \"\".concat(scrollYRHeight || rowHeight, \"px\") : ''\n                    }\n                }));\n            }\n            else {\n                // 渲染单元格\n                tdVNs.push.apply(tdVNs, __spreadArray(__spreadArray([], renderLine(params), false), [h('div', {\n                        class: ['vxe-cell', {\n                                'c--title': showTitle,\n                                'c--tooltip': showTooltip,\n                                'c--ellipsis': showEllipsis\n                            }],\n                        style: {\n                            maxHeight: hasEllipsis && (scrollYRHeight || rowHeight) ? \"\".concat(scrollYRHeight || rowHeight, \"px\") : ''\n                        },\n                        title: showTitle ? $xetable.getCellLabel(row, column) : null\n                    }, column.renderCell(params))], false));\n                if (showValidTip && errorValidItem) {\n                    var errRule = errorValidItem.rule;\n                    var validSlot = slots ? slots.valid : null;\n                    var validParams = __assign(__assign({}, params), errorValidItem);\n                    tdVNs.push(h('div', {\n                        class: ['vxe-cell--valid-error-hint', getPropClass(validOpts.className, validParams)],\n                        style: errRule && errRule.maxWidth ? {\n                            width: \"\".concat(errRule.maxWidth, \"px\")\n                        } : null\n                    }, validSlot ? $xetable.callSlot(validSlot, validParams) : [\n                        h('span', {\n                            class: 'vxe-cell--valid-error-msg'\n                        }, errorValidItem.content)\n                    ]));\n                }\n            }\n            return h('td', __assign(__assign(__assign({ class: [\n                    'vxe-body--column',\n                    column.id,\n                    (_a = {},\n                        _a[\"col--\".concat(cellAlign)] = cellAlign,\n                        _a[\"col--\".concat(type)] = type,\n                        _a['col--last'] = $columnIndex === columns.length - 1,\n                        _a['col--tree-node'] = treeNode,\n                        _a['col--edit'] = isEdit,\n                        _a['col--ellipsis'] = hasEllipsis,\n                        _a['fixed--hidden'] = fixedHiddenColumn,\n                        _a['col--dirty'] = isDirty,\n                        _a['col--active'] = editConfig && isEdit && (actived.row === row && (actived.column === column || editOpts.mode === 'row')),\n                        _a['col--valid-error'] = !!errorValidItem,\n                        _a['col--current'] = currentColumn === column,\n                        _a),\n                    getPropClass(compCellClassName, params),\n                    getPropClass(className, params),\n                    getPropClass(allCellClassName, params)\n                ], key: columnKey || columnOpts.useKey ? column.id : $columnIndex }, attrs), { style: Object.assign({\n                    height: hasEllipsis && (scrollYRHeight || rowHeight) ? \"\".concat(scrollYRHeight || rowHeight, \"px\") : ''\n                }, XEUtils.isFunction(compCellStyle) ? compCellStyle(params) : compCellStyle, XEUtils.isFunction(cellStyle) ? cellStyle(params) : cellStyle) }), tdOns), tdVNs);\n        };\n        var renderRows = function (fixedType, tableData, tableColumn) {\n            var stripe = tableProps.stripe, rowKey = tableProps.rowKey, highlightHoverRow = tableProps.highlightHoverRow, rowClassName = tableProps.rowClassName, rowStyle = tableProps.rowStyle, allColumnOverflow = tableProps.showOverflow, editConfig = tableProps.editConfig, treeConfig = tableProps.treeConfig;\n            var hasFixedColumn = tableReactData.hasFixedColumn, treeExpandedMaps = tableReactData.treeExpandedMaps, scrollYLoad = tableReactData.scrollYLoad, rowExpandedMaps = tableReactData.rowExpandedMaps, expandColumn = tableReactData.expandColumn, selectRadioRow = tableReactData.selectRadioRow, pendingRowMaps = tableReactData.pendingRowMaps, pendingRowList = tableReactData.pendingRowList;\n            var fullAllDataRowIdData = tableInternalData.fullAllDataRowIdData;\n            var checkboxOpts = computeCheckboxOpts.value;\n            var radioOpts = computeRadioOpts.value;\n            var treeOpts = computeTreeOpts.value;\n            var editOpts = computeEditOpts.value;\n            var rowOpts = computeRowOpts.value;\n            var transform = treeOpts.transform;\n            var childrenField = treeOpts.children || treeOpts.childrenField;\n            var rows = [];\n            tableData.forEach(function (row, $rowIndex) {\n                var trOn = {};\n                var rowIndex = $rowIndex;\n                // 确保任何情况下 rowIndex 都精准指向真实 data 索引\n                rowIndex = $xetable.getRowIndex(row);\n                // 事件绑定\n                if (rowOpts.isHover || highlightHoverRow) {\n                    trOn.onMouseenter = function (evnt) {\n                        if (isVMScrollProcess()) {\n                            return;\n                        }\n                        $xetable.triggerHoverEvent(evnt, { row: row, rowIndex: rowIndex });\n                    };\n                    trOn.onMouseleave = function () {\n                        if (isVMScrollProcess()) {\n                            return;\n                        }\n                        $xetable.clearHoverRow();\n                    };\n                }\n                var rowid = getRowid($xetable, row);\n                var rest = fullAllDataRowIdData[rowid];\n                var rowLevel = 0;\n                var seq = -1;\n                var _rowIndex = 0;\n                if (rest) {\n                    rowLevel = rest.level;\n                    seq = rest.seq;\n                    _rowIndex = rest._index;\n                }\n                var params = { $table: $xetable, seq: seq, rowid: rowid, fixed: fixedType, type: renderType, level: rowLevel, row: row, rowIndex: rowIndex, $rowIndex: $rowIndex, _rowIndex: _rowIndex };\n                // 行是否被展开\n                var isExpandRow = expandColumn && !!rowExpandedMaps[rowid];\n                // 树节点是否被展开\n                var isExpandTree = false;\n                var rowChildren = [];\n                // 处理新增状态\n                var isNewRow = false;\n                if (editConfig) {\n                    isNewRow = $xetable.isInsertByRow(row);\n                }\n                if (treeConfig && !scrollYLoad && !transform) {\n                    rowChildren = row[childrenField];\n                    isExpandTree = rowChildren && rowChildren.length && !!treeExpandedMaps[rowid];\n                }\n                rows.push(h('tr', __assign({ class: [\n                        'vxe-body--row',\n                        treeConfig ? \"row--level-\".concat(rowLevel) : '',\n                        {\n                            'row--stripe': stripe && ($xetable.getVTRowIndex(row) + 1) % 2 === 0,\n                            'is--new': isNewRow,\n                            'is--expand-row': isExpandRow,\n                            'is--expand-tree': isExpandTree,\n                            'row--new': isNewRow && (editOpts.showStatus || editOpts.showInsertStatus),\n                            'row--radio': radioOpts.highlight && $xetable.eqRow(selectRadioRow, row),\n                            'row--checked': checkboxOpts.highlight && $xetable.isCheckedByCheckboxRow(row),\n                            'row--pending': pendingRowList.length && !!pendingRowMaps[rowid]\n                        },\n                        getPropClass(rowClassName, params)\n                    ], rowid: rowid, style: rowStyle ? (XEUtils.isFunction(rowStyle) ? rowStyle(params) : rowStyle) : null, key: (rowKey || rowOpts.useKey) || treeConfig ? rowid : $rowIndex }, trOn), tableColumn.map(function (column, $columnIndex) {\n                    return renderColumn(seq, rowid, fixedType, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, tableColumn, tableData);\n                })));\n                // 如果行被展开了\n                if (isExpandRow) {\n                    var expandOpts = computeExpandOpts.value;\n                    var expandHeight = expandOpts.height;\n                    var cellStyle = {};\n                    if (expandHeight) {\n                        cellStyle.height = \"\".concat(expandHeight, \"px\");\n                    }\n                    if (treeConfig) {\n                        cellStyle.paddingLeft = \"\".concat((rowLevel * treeOpts.indent) + 30, \"px\");\n                    }\n                    var showOverflow = expandColumn.showOverflow;\n                    var hasEllipsis = (XEUtils.isUndefined(showOverflow) || XEUtils.isNull(showOverflow)) ? allColumnOverflow : showOverflow;\n                    var expandParams = { $table: $xetable, seq: seq, column: expandColumn, fixed: fixedType, type: renderType, level: rowLevel, row: row, rowIndex: rowIndex, $rowIndex: $rowIndex, _rowIndex: _rowIndex };\n                    rows.push(h('tr', __assign({ class: 'vxe-body--expanded-row', key: \"expand_\".concat(rowid), style: rowStyle ? (XEUtils.isFunction(rowStyle) ? rowStyle(expandParams) : rowStyle) : null }, trOn), [\n                        h('td', {\n                            class: {\n                                'vxe-body--expanded-column': 1,\n                                'fixed--hidden': fixedType && !hasFixedColumn,\n                                'col--ellipsis': hasEllipsis\n                            },\n                            colspan: tableColumn.length\n                        }, [\n                            h('div', {\n                                class: {\n                                    'vxe-body--expanded-cell': 1,\n                                    'is--ellipsis': expandHeight\n                                },\n                                style: cellStyle\n                            }, [\n                                expandColumn.renderData(expandParams)\n                            ])\n                        ])\n                    ]));\n                }\n                // 如果是树形表格\n                if (isExpandTree) {\n                    rows.push.apply(rows, renderRows(fixedType, rowChildren, tableColumn));\n                }\n            });\n            return rows;\n        };\n        /**\n         * 同步滚动条\n         */\n        var scrollProcessTimeout;\n        var syncBodyScroll = function (fixedType, scrollTop, elem1, elem2) {\n            if (elem1 || elem2) {\n                if (elem1) {\n                    removeScrollListener(elem1);\n                    elem1.scrollTop = scrollTop;\n                }\n                if (elem2) {\n                    removeScrollListener(elem2);\n                    elem2.scrollTop = scrollTop;\n                }\n                clearTimeout(scrollProcessTimeout);\n                scrollProcessTimeout = setTimeout(function () {\n                    // const tableBody = refTableBody.value\n                    // const leftBody = refTableLeftBody.value\n                    // const rightBody = refTableRightBody.value\n                    // const bodyElem = tableBody.$el as XEBodyScrollElement\n                    // const leftElem = leftBody ? leftBody.$el as XEBodyScrollElement : null\n                    // const rightElem = rightBody ? rightBody.$el as XEBodyScrollElement : null\n                    restoreScrollListener(elem1);\n                    restoreScrollListener(elem2);\n                    // 检查滚动条是的同步\n                    // let targetTop = bodyElem.scrollTop\n                    // if (fixedType === 'left') {\n                    //   if (leftElem) {\n                    //     targetTop = leftElem.scrollTop\n                    //   }\n                    // } else if (fixedType === 'right') {\n                    //   if (rightElem) {\n                    //     targetTop = rightElem.scrollTop\n                    //   }\n                    // }\n                    // setScrollTop(bodyElem, targetTop)\n                    // setScrollTop(leftElem, targetTop)\n                    // setScrollTop(rightElem, targetTop)\n                    tableReactData.lastScrollTime = Date.now();\n                }, 300);\n            }\n        };\n        var scrollLoadingTime = null;\n        /**\n         * 滚动处理\n         * 如果存在列固定左侧，同步更新滚动状态\n         * 如果存在列固定右侧，同步更新滚动状态\n         */\n        var scrollEvent = function (evnt) {\n            var fixedType = props.fixedType;\n            var highlightHoverRow = tableProps.highlightHoverRow;\n            var scrollXLoad = tableReactData.scrollXLoad, scrollYLoad = tableReactData.scrollYLoad;\n            var elemStore = tableInternalData.elemStore, lastScrollTop = tableInternalData.lastScrollTop, lastScrollLeft = tableInternalData.lastScrollLeft;\n            var rowOpts = computeRowOpts.value;\n            var tableHeader = refTableHeader.value;\n            var tableBody = refTableBody.value;\n            var tableFooter = refTableFooter.value;\n            var leftBody = refTableLeftBody.value;\n            var rightBody = refTableRightBody.value;\n            var validTip = refValidTooltip.value;\n            var scrollBodyElem = refElem.value;\n            var headerElem = tableHeader ? tableHeader.$el : null;\n            var footerElem = tableFooter ? tableFooter.$el : null;\n            var bodyElem = tableBody.$el;\n            var leftElem = leftBody ? leftBody.$el : null;\n            var rightElem = rightBody ? rightBody.$el : null;\n            var bodyYRef = elemStore['main-body-ySpace'];\n            var bodyYElem = bodyYRef ? bodyYRef.value : null;\n            var bodyXRef = elemStore['main-body-xSpace'];\n            var bodyXElem = bodyXRef ? bodyXRef.value : null;\n            var bodyHeight = scrollYLoad && bodyYElem ? bodyYElem.clientHeight : bodyElem.clientHeight;\n            var bodyWidth = scrollXLoad && bodyXElem ? bodyXElem.clientWidth : bodyElem.clientWidth;\n            var scrollTop = scrollBodyElem.scrollTop;\n            var scrollLeft = bodyElem.scrollLeft;\n            var isRollX = scrollLeft !== lastScrollLeft;\n            var isRollY = scrollTop !== lastScrollTop;\n            tableInternalData.lastScrollTop = scrollTop;\n            tableInternalData.lastScrollLeft = scrollLeft;\n            tableReactData.lastScrollTime = Date.now();\n            if (rowOpts.isHover || highlightHoverRow) {\n                $xetable.clearHoverRow();\n            }\n            if (leftElem && fixedType === 'left') {\n                scrollTop = leftElem.scrollTop;\n                syncBodyScroll(fixedType, scrollTop, bodyElem, rightElem);\n            }\n            else if (rightElem && fixedType === 'right') {\n                scrollTop = rightElem.scrollTop;\n                syncBodyScroll(fixedType, scrollTop, bodyElem, leftElem);\n            }\n            else {\n                if (isRollX) {\n                    if (headerElem) {\n                        headerElem.scrollLeft = bodyElem.scrollLeft;\n                    }\n                    if (footerElem) {\n                        footerElem.scrollLeft = bodyElem.scrollLeft;\n                    }\n                }\n                if (leftElem || rightElem) {\n                    $xetable.checkScrolling();\n                    if (isRollY) {\n                        syncBodyScroll(fixedType, scrollTop, leftElem, rightElem);\n                    }\n                }\n            }\n            // let isLoadScroll = false\n            if (scrollXLoad && isRollX) {\n                // isLoadScroll = true\n                $xetable.triggerScrollXEvent(evnt);\n            }\n            if (scrollYLoad && isRollY) {\n                // isLoadScroll = true\n                $xetable.triggerScrollYEvent(evnt);\n            }\n            if (scrollLoadingTime !== null) {\n                clearTimeout(scrollLoadingTime);\n            }\n            // if (isLoadScroll) {\n            //   tableReactData.scrollVMLoading = true\n            //   scrollLoadingTime = setTimeout(() => {\n            //     scrollLoadingTime = null\n            //     tableReactData.scrollVMLoading = false\n            //   }, 20)\n            // } else {\n            //   tableReactData.scrollVMLoading = false\n            // }\n            if (isRollX && validTip && validTip.reactData.visible) {\n                validTip.updatePlacement();\n            }\n            $xetable.dispatchEvent('scroll', {\n                type: renderType,\n                fixed: fixedType,\n                scrollTop: scrollTop,\n                scrollLeft: scrollLeft,\n                scrollHeight: bodyElem.scrollHeight,\n                scrollWidth: bodyElem.scrollWidth,\n                bodyHeight: bodyHeight,\n                bodyWidth: bodyWidth,\n                isX: isRollX,\n                isY: isRollY\n            }, evnt);\n        };\n        var wheelTime;\n        var wheelYSize = 0;\n        var wheelYInterval = 0;\n        var wheelYTotal = 0;\n        var isPrevWheelTop = false;\n        var handleWheel = function (evnt, isTopWheel, deltaTop, isRollX, isRollY) {\n            var elemStore = tableInternalData.elemStore;\n            var scrollXLoad = tableReactData.scrollXLoad, scrollYLoad = tableReactData.scrollYLoad;\n            var tableBody = refTableBody.value;\n            var leftBody = refTableLeftBody.value;\n            var rightBody = refTableRightBody.value;\n            var leftElem = leftBody ? leftBody.$el : null;\n            var rightElem = rightBody ? rightBody.$el : null;\n            var bodyElem = tableBody.$el;\n            var bodyYRef = elemStore['main-body-ySpace'];\n            var bodyYElem = bodyYRef ? bodyYRef.value : null;\n            var bodyXRef = elemStore['main-body-xSpace'];\n            var bodyXElem = bodyXRef ? bodyXRef.value : null;\n            var bodyHeight = scrollYLoad && bodyYElem ? bodyYElem.clientHeight : bodyElem.clientHeight;\n            var bodyWidth = scrollXLoad && bodyXElem ? bodyXElem.clientWidth : bodyElem.clientWidth;\n            var remainSize = isPrevWheelTop === isTopWheel ? Math.max(0, wheelYSize - wheelYTotal) : 0;\n            isPrevWheelTop = isTopWheel;\n            wheelYSize = Math.abs(isTopWheel ? deltaTop - remainSize : deltaTop + remainSize);\n            wheelYInterval = 0;\n            wheelYTotal = 0;\n            clearTimeout(wheelTime);\n            var handleSmooth = function () {\n                if (wheelYTotal < wheelYSize) {\n                    var fixedType = props.fixedType;\n                    wheelYInterval = Math.max(5, Math.floor(wheelYInterval * 1.5));\n                    wheelYTotal = wheelYTotal + wheelYInterval;\n                    if (wheelYTotal > wheelYSize) {\n                        wheelYInterval = wheelYInterval - (wheelYTotal - wheelYSize);\n                    }\n                    var scrollTop = bodyElem.scrollTop, clientHeight = bodyElem.clientHeight, scrollHeight = bodyElem.scrollHeight;\n                    var targerTop = scrollTop + (wheelYInterval * (isTopWheel ? -1 : 1));\n                    bodyElem.scrollTop = targerTop;\n                    if (leftElem) {\n                        leftElem.scrollTop = targerTop;\n                    }\n                    if (rightElem) {\n                        rightElem.scrollTop = targerTop;\n                    }\n                    if (isTopWheel ? targerTop < scrollHeight - clientHeight : targerTop >= 0) {\n                        wheelTime = setTimeout(handleSmooth, 10);\n                    }\n                    $xetable.dispatchEvent('scroll', {\n                        type: renderType,\n                        fixed: fixedType,\n                        scrollTop: bodyElem.scrollTop,\n                        scrollLeft: bodyElem.scrollLeft,\n                        scrollHeight: bodyElem.scrollHeight,\n                        scrollWidth: bodyElem.scrollWidth,\n                        bodyHeight: bodyHeight,\n                        bodyWidth: bodyWidth,\n                        isX: isRollX,\n                        isY: isRollY\n                    }, evnt);\n                }\n            };\n            handleSmooth();\n        };\n        /**\n         * 滚轮处理\n         */\n        var wheelEvent = function (evnt) {\n            var deltaY = evnt.deltaY, deltaX = evnt.deltaX;\n            var highlightHoverRow = tableProps.highlightHoverRow;\n            var scrollYLoad = tableReactData.scrollYLoad;\n            var lastScrollTop = tableInternalData.lastScrollTop, lastScrollLeft = tableInternalData.lastScrollLeft;\n            var rowOpts = computeRowOpts.value;\n            var tableBody = refTableBody.value;\n            var scrollBodyElem = refElem.value;\n            var bodyElem = tableBody.$el;\n            var deltaTop = deltaY;\n            var deltaLeft = deltaX;\n            var isTopWheel = deltaTop < 0;\n            // 如果滚动位置已经是顶部或底部，则不需要触发\n            if (isTopWheel ? scrollBodyElem.scrollTop <= 0 : scrollBodyElem.scrollTop >= scrollBodyElem.scrollHeight - scrollBodyElem.clientHeight) {\n                return;\n            }\n            var scrollTop = scrollBodyElem.scrollTop + deltaTop;\n            var scrollLeft = bodyElem.scrollLeft + deltaLeft;\n            var isRollX = scrollLeft !== lastScrollLeft;\n            var isRollY = scrollTop !== lastScrollTop;\n            // 用于鼠标纵向滚轮处理\n            if (isRollY) {\n                evnt.preventDefault();\n                tableInternalData.lastScrollTop = scrollTop;\n                tableInternalData.lastScrollLeft = scrollLeft;\n                tableReactData.lastScrollTime = Date.now();\n                if (rowOpts.isHover || highlightHoverRow) {\n                    $xetable.clearHoverRow();\n                }\n                handleWheel(evnt, isTopWheel, deltaTop, isRollX, isRollY);\n                if (scrollYLoad) {\n                    $xetable.triggerScrollYEvent(evnt);\n                }\n            }\n        };\n        onMounted(function () {\n            nextTick(function () {\n                var fixedType = props.fixedType;\n                var elemStore = tableInternalData.elemStore;\n                var prefix = \"\".concat(fixedType || 'main', \"-body-\");\n                var el = refElem.value;\n                elemStore[\"\".concat(prefix, \"wrapper\")] = refElem;\n                elemStore[\"\".concat(prefix, \"table\")] = refBodyTable;\n                elemStore[\"\".concat(prefix, \"colgroup\")] = refBodyColgroup;\n                elemStore[\"\".concat(prefix, \"list\")] = refBodyTBody;\n                elemStore[\"\".concat(prefix, \"xSpace\")] = refBodyXSpace;\n                elemStore[\"\".concat(prefix, \"ySpace\")] = refBodyYSpace;\n                elemStore[\"\".concat(prefix, \"emptyBlock\")] = refBodyEmptyBlock;\n                if (el) {\n                    el.onscroll = scrollEvent;\n                    el._onscroll = scrollEvent;\n                }\n            });\n        });\n        onBeforeUnmount(function () {\n            var el = refElem.value;\n            clearTimeout(wheelTime);\n            if (el) {\n                el._onscroll = null;\n                el.onscroll = null;\n            }\n        });\n        onUnmounted(function () {\n            var fixedType = props.fixedType;\n            var elemStore = tableInternalData.elemStore;\n            var prefix = \"\".concat(fixedType || 'main', \"-body-\");\n            elemStore[\"\".concat(prefix, \"wrapper\")] = null;\n            elemStore[\"\".concat(prefix, \"table\")] = null;\n            elemStore[\"\".concat(prefix, \"colgroup\")] = null;\n            elemStore[\"\".concat(prefix, \"list\")] = null;\n            elemStore[\"\".concat(prefix, \"xSpace\")] = null;\n            elemStore[\"\".concat(prefix, \"ySpace\")] = null;\n            elemStore[\"\".concat(prefix, \"emptyBlock\")] = null;\n        });\n        var renderVN = function () {\n            var fixedColumn = props.fixedColumn, fixedType = props.fixedType, tableColumn = props.tableColumn;\n            var keyboardConfig = tableProps.keyboardConfig, allColumnOverflow = tableProps.showOverflow, spanMethod = tableProps.spanMethod, mouseConfig = tableProps.mouseConfig;\n            var tableData = tableReactData.tableData, mergeList = tableReactData.mergeList, scrollYLoad = tableReactData.scrollYLoad, isAllOverflow = tableReactData.isAllOverflow;\n            var visibleColumn = tableInternalData.visibleColumn;\n            var slots = tableContext.slots;\n            var sYOpts = computeSYOpts.value;\n            var emptyOpts = computeEmptyOpts.value;\n            var keyboardOpts = computeKeyboardOpts.value;\n            var mouseOpts = computeMouseOpts.value;\n            // const isMergeLeftFixedExceeded = computeIsMergeLeftFixedExceeded.value\n            // const isMergeRightFixedExceeded = computeIsMergeRightFixedExceeded.value\n            // 如果是使用优化模式\n            if (fixedType) {\n                // 如果存在展开行使用全量渲染\n                if (!tableReactData.expandColumn && (scrollYLoad || (allColumnOverflow ? isAllOverflow : allColumnOverflow))) {\n                    if (!mergeList.length && !spanMethod && !(keyboardConfig && keyboardOpts.isMerge)) {\n                        tableColumn = fixedColumn;\n                    }\n                    else {\n                        tableColumn = visibleColumn;\n                        // 检查固定列是否被合并，合并范围是否超出固定列\n                        // if (mergeList.length && !isMergeLeftFixedExceeded && fixedType === 'left') {\n                        //   tableColumn = fixedColumn\n                        // } else if (mergeList.length && !isMergeRightFixedExceeded && fixedType === 'right') {\n                        //   tableColumn = fixedColumn\n                        // } else {\n                        //   tableColumn = visibleColumn\n                        // }\n                    }\n                }\n                else {\n                    tableColumn = visibleColumn;\n                }\n            }\n            var emptyContent;\n            var emptySlot = slots ? slots.empty : null;\n            if (emptySlot) {\n                emptyContent = $xetable.callSlot(emptySlot, { $table: $xetable, $grid: $xetable.xegrid });\n            }\n            else {\n                var compConf = emptyOpts.name ? VXETable.renderer.get(emptyOpts.name) : null;\n                var renderEmpty = compConf ? compConf.renderEmpty : null;\n                if (renderEmpty) {\n                    emptyContent = getSlotVNs(renderEmpty(emptyOpts, { $table: $xetable }));\n                }\n                else {\n                    emptyContent = tableProps.emptyText || GlobalConfig.i18n('vxe.table.emptyText');\n                }\n            }\n            return h('div', __assign({ ref: refElem, class: ['vxe-table--body-wrapper', fixedType ? \"fixed-\".concat(fixedType, \"--wrapper\") : 'body--wrapper'], xid: xID }, (sYOpts.mode === 'wheel' ? { onWheel: wheelEvent } : {})), [\n                fixedType ? createCommentVNode() : h('div', {\n                    ref: refBodyXSpace,\n                    class: 'vxe-body--x-space'\n                }),\n                h('div', {\n                    ref: refBodyYSpace,\n                    class: 'vxe-body--y-space'\n                }),\n                h('table', {\n                    ref: refBodyTable,\n                    class: 'vxe-table--body',\n                    xid: xID,\n                    cellspacing: 0,\n                    cellpadding: 0,\n                    border: 0\n                }, [\n                    /**\n                     * 列宽\n                     */\n                    h('colgroup', {\n                        ref: refBodyColgroup\n                    }, tableColumn.map(function (column, $columnIndex) {\n                        return h('col', {\n                            name: column.id,\n                            key: $columnIndex\n                        });\n                    })),\n                    /**\n                     * 内容\n                     */\n                    h('tbody', {\n                        ref: refBodyTBody\n                    }, renderRows(fixedType, tableData, tableColumn))\n                ]),\n                h('div', {\n                    class: 'vxe-table--checkbox-range'\n                }),\n                mouseConfig && mouseOpts.area ? h('div', {\n                    class: 'vxe-table--cell-area'\n                }, [\n                    h('span', {\n                        class: 'vxe-table--cell-main-area'\n                    }, mouseOpts.extension ? [\n                        h('span', {\n                            class: 'vxe-table--cell-main-area-btn',\n                            onMousedown: function (evnt) {\n                                $xetable.triggerCellExtendMousedownEvent(evnt, { $table: $xetable, fixed: fixedType, type: renderType });\n                            }\n                        })\n                    ] : []),\n                    h('span', {\n                        class: 'vxe-table--cell-copy-area'\n                    }),\n                    h('span', {\n                        class: 'vxe-table--cell-extend-area'\n                    }),\n                    h('span', {\n                        class: 'vxe-table--cell-multi-area'\n                    }),\n                    h('span', {\n                        class: 'vxe-table--cell-active-area'\n                    })\n                ]) : null,\n                !fixedType ? h('div', {\n                    class: 'vxe-table--empty-block',\n                    ref: refBodyEmptyBlock\n                }, [\n                    h('div', {\n                        class: 'vxe-table--empty-content'\n                    }, emptyContent)\n                ]) : null\n            ]);\n        };\n        return renderVN;\n    }\n});\n",
      "start": 1714699769331,
      "end": 1714699769331,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "esbuild",
      "start": 1714699769331,
      "end": 1714699769331,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1714699769331,
      "end": 1714699769331,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1714699769331,
      "end": 1714699769331,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1714699769331,
      "end": 1714699769331,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1714699769331,
      "end": 1714699769331,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1714699769331,
      "end": 1714699769331,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1714699769331,
      "end": 1714699769333,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1714699769333,
      "end": 1714699769333,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1714699769333,
      "end": 1714699769333,
      "order": "normal"
    },
    {
      "name": "unplugin-auto-import",
      "start": 1714699769333,
      "end": 1714699769333,
      "order": "post"
    },
    {
      "name": "unplugin-vue-components",
      "start": 1714699769333,
      "end": 1714699769333,
      "order": "post"
    },
    {
      "name": "vite:style-import",
      "start": 1714699769333,
      "end": 1714699769333,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1714699769333,
      "end": 1714699769333,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1714699769333,
      "end": 1714699769333,
      "order": "normal"
    }
  ]
}
